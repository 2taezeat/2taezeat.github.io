<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Android View 기초 | 2taezeat, blog</title>
<meta name=keywords content="Android"><meta name=description content="Android View 기초"><meta name=author content="2taezeat"><link rel=canonical href=https://2taezeat.github.io/posts/android/android-view/><meta name=google-site-verification content="YaEERzgrvu-ZwPg7gswZdTzRMufkHw3uIH7i8hVal1c"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.9d319fd17dcb71a3a4f47e635bf2dac252103f703806e3ed7033472975765287.css integrity="sha256-nTGf0X3LcaOk9H5jW/LawlIQP3A4BuPtcDNHKXV2Uoc=" rel="preload stylesheet" as=style><link rel=icon href=https://2taezeat.github.io/icon/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://2taezeat.github.io/icon/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://2taezeat.github.io/icon/favicon-32x32.png><link rel=apple-touch-icon href=https://2taezeat.github.io/icon/apple-touch-icon.png><link rel=mask-icon href=https://2taezeat.github.io/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://2taezeat.github.io/posts/android/android-view/><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><meta property="og:title" content="Android View 기초"><meta property="og:description" content="Android View 기초"><meta property="og:type" content="article"><meta property="og:url" content="https://2taezeat.github.io/posts/android/android-view/"><meta property="og:image" content="https://2taezeat.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-11-09T11:30:03+00:00"><meta property="article:modified_time" content="2023-11-09T11:30:03+00:00"><meta property="og:site_name" content="2taezeat, blog"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://2taezeat.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="Android View 기초"><meta name=twitter:description content="Android View 기초"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://2taezeat.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Android View 기초","item":"https://2taezeat.github.io/posts/android/android-view/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Android View 기초","name":"Android View 기초","description":"Android View 기초","keywords":["Android"],"articleBody":"Android View View 생명주기의 핵심 단계 생성 (Construction): View 객체가 생성되는 단계입니다. 생성자를 통해 초기화 작업을 수행합니다. 주로 XML 레이아웃 파일에서 View가 inflate 되거나, Kotlin/Java 코드에서 View 객체를 생성할 때 호출됩니다. 부착 (Attachment): View가 윈도우(Window)에 부착되는 단계입니다. onAttachedToWindow() 메서드가 호출됩니다. 이 시점부터 View는 화면에 표시될 준비가 되었으며, 사용자 입력을 처리할 수 있습니다. 리소스 할당이나 이벤트 리스너 등록 등 초기화 작업을 수행하기에 적합한 시점입니다. 측정 (Measurement): View의 크기를 결정하는 단계입니다. onMeasure() 메서드가 호출됩니다. 부모 View로부터 전달받은 제약 조건과 View 자신의 특성을 고려하여 View의 크기를 계산합니다. 배치 (Layout): View의 위치를 결정하는 단계입니다. onLayout() 메서드가 호출됩니다. 부모 View로부터 전달받은 크기와 위치 정보를 기반으로 View의 위치를 설정합니다. 자식 View가 있다면, 자식 View들의 위치도 결정합니다. 그리기 (Drawing): View의 내용을 화면에 그리는 단계입니다. onDraw() 메서드가 호출됩니다. Canvas 객체를 사용하여 View의 배경, 텍스트, 이미지 등을 그립니다. 분리 (Detachment): View가 윈도우에서 분리되는 단계입니다. onDetachedFromWindow() 메서드가 호출됩니다. 이 시점부터 View는 더 이상 화면에 표시되지 않으며, 사용자 입력을 처리할 수 없습니다. 사용하지 않는 리소스를 해제하고 이벤트 리스너를 제거하는 등 정리 작업을 수행하기에 적합한 시점입니다. View 생명주기 활용 예시\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class CustomView(context: Context, attrs: AttributeSet?) : View(context, attrs) { override fun onAttachedToWindow() { super.onAttachedToWindow() // 리소스 초기화, 이벤트 리스너 등록 등 } override fun onMeasure(widthMeasureSpec: Int, heightMeasureSpec: Int) { // View의 크기 계산 } override fun onLayout(changed: Boolean, left: Int, top: Int, right: Int, bottom: Int) { // View의 위치 설정 } override fun onDraw(canvas: Canvas) { // View의 내용 그리기 } override fun onDetachedFromWindow() { super.onDetachedFromWindow() // 리소스 해제, 이벤트 리스너 제거 등 } } invalidate() vs. requestLayout(): 차이점 및 사용 시점 invalidate()\n역할: View의 외관(appearance)이 변경되었을 때 호출하여 해당 View만 다시 그리도록 요청합니다. 동작: invalidate() 메서드가 호출되면 View는 “dirty” 상태로 표시됩니다. 다음 UI 렌더링 주기에서 시스템은 “dirty” 상태인 View의 onDraw() 메서드를 호출하여 다시 그립니다. View의 크기나 위치는 변경되지 않습니다. 사용 시점: View의 내용(텍스트, 색상, 이미지 등)이 변경되었을 때 View의 일부 영역만 다시 그려야 할 때 (예: invalidate(Rect) 사용) 애니메이션 효과를 구현할 때 requestLayout()\n역할: View의 크기나 위치가 변경되었을 때 호출하여 View의 측정 및 배치 과정을 다시 실행하도록 요청합니다. 동작: requestLayout() 메서드가 호출되면 View는 “layout requested” 상태로 표시됩니다. 다음 UI 렌더링 주기에서 시스템은 “layout requested” 상태인 View와 해당 View의 모든 자식 View에 대해 측정 (onMeasure()) 및 배치 (onLayout()) 과정을 다시 실행합니다. View의 내용은 변경되지 않을 수도 있습니다. 사용 시점: View의 크기 (LayoutParams)가 변경되었을 때 View의 내용 변경으로 인해 View의 크기가 변경될 수 있을 때 화면 회전 등으로 인해 레이아웃이 변경되어야 할 때 주의 사항\ninvalidate()는 View의 외관만 변경하므로, 크기나 위치 변경에는 영향을 미치지 않습니다. requestLayout()는 View의 크기나 위치를 변경하므로, 해당 View와 모든 자식 View의 측정 및 배치 과정을 다시 실행하여 성능에 영향을 줄 수 있습니다. 불필요한 invalidate() 또는 requestLayout() 호출은 UI 성능 저하를 야기할 수 있으므로 주의해야 합니다. 예시\n1 2 3 4 5 6 7 8 9 // 텍스트 내용 변경 (invalidate() 사용) textView.text = \"새로운 텍스트\" textView.invalidate() // View의 크기 변경 (requestLayout() 사용) val params = textView.layoutParams params.width = ViewGroup.LayoutParams.WRAP_CONTENT textView.layoutParams = params textView.requestLayout() Android View 계층 구조 Android View는 트리 형태의 계층 구조를 이루며, 이를 View 계층 구조(View Hierarchy)라고 합니다.\n각 View는 트리의 부모-자식 관계로 연결되어 있으며, 최상위 View를 루트 View(Root View) 라고 합니다.\n전위 순회 (root-\u003e left -\u003e right)\nView와 ViewGroup View: 화면에 보이는 UI 요소의 기본 단위입니다. TextView, ImageView, Button 등이 View에 해당합니다. ViewGroup: 다른 View들을 담는 컨테이너 역할을 하는 View입니다. LinearLayout, RelativeLayout, ConstraintLayout 등이 ViewGroup에 해당합니다. ViewGroup은 View를 상속받기 때문에 View의 모든 속성과 기능을 가지면서, 추가로 자식 View들을 관리하는 기능을 제공합니다. View 계층 구조의 특징 트리 구조: View 계층 구조는 하나의 루트 View를 시작으로 여러 개의 자식 View들이 연결되어 트리 형태를 이룹니다. 부모-자식 관계: 각 View는 하나의 부모 View를 가지며, 여러 개의 자식 View를 가질 수 있습니다. 레이아웃 관리: ViewGroup은 자식 View들의 크기와 위치를 결정하여 화면에 배치하는 역할을 합니다. 이벤트 전달: 터치, 클릭 등 사용자 이벤트는 View 계층 구조를 따라 전달됩니다. View 계층 구조의 예시 DecorView (Root View) ㄴ LinearLayout ㄴ TextView ㄴ ImageView ㄴ Button 위 예시에서 DecorView는 루트 View이며, LinearLayout은 DecorView의 자식 View이자 ViewGroup입니다.\nTextView, ImageView, Button은 LinearLayout의 자식 View입니다.\nView 계층 구조의 활용 UI 구성: View 계층 구조를 통해 다양한 UI 요소를 조합하여 복잡한 화면을 구성할 수 있습니다. 레이아웃 관리: ViewGroup을 사용하여 자식 View들의 배치를 효율적으로 관리할 수 있습니다. 커스텀 View 생성: View 클래스를 상속받아 새로운 View를 만들거나 기존 View의 기능을 확장할 수 있습니다. 이벤트 처리: View 계층 구조를 통해 사용자 이벤트를 처리하고 적절한 동작을 수행할 수 있습니다. 추가 정보 View 계층 구조는 액티비티(Activity)가 시작될 때 setContentView() 메서드를 통해 설정됩니다. View 계층 구조는 findViewById() 메서드를 통해 특정 View를 찾을 수 있습니다. View 계층 구조는 getParent() 메서드를 통해 부모 View를, getChildCount() 및 getChildAt() 메서드를 통해 자식 View들을 확인할 수 있습니다. Android에서 ConstraintLayout을 사용하는 이유와 설명 ConstraintLayout은 Android UI 개발에서 복잡한 레이아웃을 효율적으로 구성하기 위해 설계된 강력한 ViewGroup입니다.\n기존의 RelativeLayout이나 LinearLayout 등의 레이아웃 방식보다 더욱 유연하고 성능이 뛰어나다는 장점을 가지고 있습니다.\nConstraintLayout 사용 이유\n복잡한 레이아웃 구현 용이: 제약 조건(constraints) 을 사용하여 View 간의 관계를 정의함으로써 복잡한 레이아웃을 간결하게 표현할 수 있습니다. 상대적인 위치, 정렬, 비율 등 다양한 제약 조건을 설정하여 View를 원하는 위치에 배치할 수 있습니다. Guideline, Barrier, Group 등의 기능을 활용하여 더욱 유연한 레이아웃 구성이 가능합니다. 중첩 레이아웃 감소: ConstraintLayout은 View 간의 관계를 직접적으로 정의하므로, 불필요한 중첩 레이아웃을 줄일 수 있습니다. 중첩 레이아웃은 UI 성능 저하의 주요 원인이 될 수 있으므로, ConstraintLayout을 사용하면 성능 향상을 기대할 수 있습니다. 성능 향상: ConstraintLayout은 내부적으로 효율적인 알고리즘을 사용하여 레이아웃을 계산합니다. 따라서 렌더링 속도가 빠르고, 특히 복잡한 레이아웃에서 성능 이점을 얻을 수 있습니다. 다양한 화면 크기 지원: ConstraintLayout은 다양한 화면 크기와 해상도에 대한 적응성이 뛰어납니다. 제약 조건을 사용하여 View의 크기와 위치를 상대적으로 설정하므로, 다양한 기기에서 일관된 UI를 유지할 수 있습니다. ConstraintLayout은 다음과 같은 주요 기능을 제공합니다.\n제약 조건 (Constraints): View의 위치, 크기, 정렬 등을 다른 View나 부모 레이아웃에 상대적으로 정의합니다. Guideline: View의 위치를 잡기 위한 보조선 역할을 합니다. 수직 또는 수평 Guideline을 생성하여 View를 정렬하거나 배치할 수 있습니다. Barrier: 여러 View의 위치를 기준으로 동적으로 생성되는 보이지 않는 장벽입니다. Barrier를 사용하여 특정 View들이 특정 위치를 넘어가지 않도록 제한할 수 있습니다. Group: 여러 View를 하나의 그룹으로 묶어서 관리합니다. 그룹 단위로 Visibility를 설정하거나 제약 조건을 적용할 수 있습니다. Chains: 여러 View를 연결하여 일렬로 배치하고 간격을 조절하는 기능입니다. Android Data Binding Android Data Binding은 UI 레이아웃과 데이터를 연결하여 UI 업데이트를 단순화하는 라이브러리입니다.\nData Binding의 핵심 기능:\n데이터 바인딩 표현식: 레이아웃 파일에서 데이터를 직접 참조하고 조작할 수 있습니다.\n예를 들어 @{user.name}과 같이 데이터 객체의 속성을 참조하여 TextView에 표시할 수 있습니다. 이벤트 핸들링: 버튼 클릭과 같은 이벤트 발생 시 데이터 객체의 메서드를 호출하거나 특정 로직을 실행할 수 있습니다.\nObservable 객체: 데이터가 변경될 때 UI를 자동으로 업데이트할 수 있도록 Observable 객체를 사용합니다. LiveData, ObservableField 등이 이에 해당합니다.\nBinding Adapter: Data Binding 표현식에서 사용할 수 있는 커스텀 속성을 정의하고, 속성 값에 따라 View의 속성을 변경하는 로직을 구현할 수 있습니다.\nData Binding 사용 이유:\nUI 코드 간소화: UI 업데이트를 위한 findViewById() 및 setText()와 같은 반복적인 코드 작성을 줄여줍니다. 가독성 향상: UI 로직이 레이아웃 파일에 명확하게 표현되어 코드의 가독성이 좋아집니다. 오류 감소: 데이터 바인딩 표현식의 유효성을 컴파일 타임에 검사하여 런타임 오류 발생 가능성을 줄여줍니다. 유지보수성 향상: UI 로직과 데이터 로직이 분리되어 유지보수가 용이해집니다. 프로그래매틱 방식이 아니라, 선언적 방식을 사용하여 UI 구성요소를 데이터에 결합할 수 있는 지원 라이브러리 뷰를 데이터 객체와 결합하는 데 필요한 클래스를 자동으로 생성 (view와 data를 바인딩) DataBinding으로 인해 ViewModel이 View를 알지 못해도, 다양한 인터랙션 처리 가능 Model에서 데이터가 변경되면, ViewModel에 전달 변경된 데이터가 ViewModel에서 View로 전달되도록 LiveData, RxJava, Kotlin Flow을 사용해 구현 옵저버 패턴 or Reactive(반응형) 프로그래밍 binding 클래스 자동 생성 Android Data Binding 라이브러리를 사용하면 레이아웃 파일(*.xml)에 대응하는 바인딩 클래스가 자동으로 생성됩니다.\n이 바인딩 클래스는 레이아웃 파일의 UI 요소와 데이터를 연결하는 데 사용됩니다.\n자동 생성 클래스 규칙\n클래스 이름: 레이아웃 파일 이름을 파스칼 표기법(PascalCase)으로 변환하고 “Binding” 접미사를 붙입니다. 예를 들어 activity_main.xml 레이아웃 파일은 ActivityMainBinding 클래스로 변환됩니다. 클래스 위치: build 디렉토리 안에 생성됩니다. (예: app/build/generated/data_binding_base_class_source_out/debug/out/com/example/databinding/) 클래스 구성: 레이아웃 파일의 각 View 요소에 대한 참조 변수 데이터 바인딩 표현식에 정의된 변수에 대한 getter/setter 메서드 inflate() 메서드: 레이아웃 파일을 inflate하고 바인딩 객체를 생성하는 정적 메서드 Android BindingAdapter DataBinding에서, 데이터 바인딩 표현식과 View의 속성을 연결하는 역할을 합니다.\n기본적으로 제공되는 BindingAdapter 외에도 개발자가 직접 정의하여 커스텀 속성과 View의 동작을 연결할 수 있습니다.\nBindingAdapter의 주요 기능:\n커스텀 속성: @BindingAdapter 어노테이션을 사용하여 View의 속성과 연결할 커스텀 속성을 정의할 수 있습니다. 예를 들어, ImageView에 이미지 URL을 바인딩하는 app:imageUrl 속성을 만들 수 있습니다. 속성 값 변환: BindingAdapter 메서드를 통해 데이터 모델의 값을 View의 속성 값으로 변환하는 로직을 구현할 수 있습니다. 예를 들어, app:imageUrl 속성에 전달된 URL 문자열을 Glide 라이브러리를 사용하여 이미지로 변환하여 ImageView에 표시할 수 있습니다. Android View Binding vs. Data Binding 비교 Android View Binding과 Data Binding은 모두 레이아웃 파일의 View에 쉽게 접근하고 UI 업데이트를 용이하게 하는 데 사용되는 라이브러리입니다.\nView Binding\n핵심 기능: 레이아웃 파일에 정의된 View에 대한 참조를 자동으로 생성합니다. findViewById() 메서드를 사용하지 않고 View에 직접 접근할 수 있습니다. Null 안정성을 보장합니다. (ID가 없는 View에 접근하려고 하면 컴파일 오류 발생) 장점: 빌드 시간에 바인딩 클래스를 생성하므로 런타임 성능에 영향을 주지 않습니다. Data Binding보다 가볍고 간결합니다. findViewById() 메서드 사용 시 발생할 수 있는 null 관련 오류를 방지합니다. 단점: 레이아웃 파일과 코드 간의 데이터 바인딩 기능은 제공하지 않습니다. 양방향 데이터 바인딩이나 복잡한 UI 로직을 구현하기 어렵습니다. Data Binding\n핵심 기능: 레이아웃 파일과 데이터를 직접 연결하여 UI 업데이트를 자동화합니다. 데이터 변경 시 UI를 자동으로 갱신합니다. 이벤트 리스너를 간편하게 설정할 수 있습니다. BindingAdapter를 사용하여 커스텀 속성을 정의하고 View의 동작을 제어할 수 있습니다. 장점: UI 로직을 레이아웃 파일에 명시하여 코드의 가독성을 높입니다. 데이터 변경에 따른 UI 업데이트를 자동화하여 생산성을 향상시킵니다. 양방향 데이터 바인딩과 복잡한 UI 로직 구현이 가능합니다. 단점: 빌드 시간이 다소 증가할 수 있습니다. View Binding보다 학습 곡선이 가파릅니다. 복잡한 표현식 사용 시 런타임 성능에 영향을 줄 수 있습니다. Android Custom View 설명 Android Custom View는 기본으로 제공되는 View 클래스들을 조합하거나 상속하여 개발자가 직접 정의하는 View입니다.\n기존 View로 표현하기 어려운 복잡한 UI나 특정 기능을 구현할 때 유용하게 사용됩니다.\nCustom View를 만드는 이유\n재사용성: 자주 사용되는 UI 요소를 Custom View로 만들어 여러 곳에서 재사용할 수 있습니다. 캡슐화: Custom View 내부의 로직을 캡슐화하여 코드의 복잡성을 줄이고 유지보수를 용이하게 합니다. 유연성: 기존 View의 기능을 확장하거나 새로운 기능을 추가하여 원하는 디자인과 동작을 구현할 수 있습니다. Custom View 종류\n기존 View 조합: 여러 개의 기존 View를 조합하여 새로운 UI 요소를 만듭니다. 예: 복합적인 레이아웃, 특정 디자인의 버튼 등 View 상속: View 클래스를 상속받아 새로운 View를 만듭니다. 예: 원형 ProgressBar, 특정 모양의 그래프 등 ViewGroup 상속: ViewGroup 클래스를 상속받아 여러 자식 View를 포함하는 Custom View를 만듭니다. 예: RecyclerView와 유사한 리스트 뷰 등 Custom View 생성 방법\n클래스 생성: View 또는 ViewGroup 클래스를 상속받아 새로운 클래스를 만듭니다. 생성자 정의: Context와 AttributeSet을 매개변수로 받는 생성자를 정의합니다. 속성 정의: attrs.xml 파일에 Custom View의 속성을 정의합니다. 메서드 오버라이딩: 필요에 따라 View의 생명주기 메서드 (onMeasure(), onLayout(), onDraw())를 오버라이딩하여 Custom View의 동작을 구현합니다. RecyclerView RecyclerView : 많은 수의 데이터 집합(Data Set)을 개별 아이템 단위로 구성하여 화면에 출력하는 뷰그룹(ViewGroup) 이며, 한 화면에 표시되기 힘든 많은 수의 데이터를 스크롤 가능한 리스트로 표시해주는 위젯입니다.\n리스트뷰(ListView)의 경우, 문제점 중의 하나는, 리스트 항목이 갱신될 때마다, 매번 아이템 뷰를 새로 구성해야 한다는 것이었습니다.\n리스트뷰의 단점을 참고하여, 리사이클러뷰는 아이템을 표시하기 위해 생성한 뷰를 재활용(recycle)합니다. 애니메이션 불가, 수직만 가능 Adapter : 리사이클러뷰에 표시될 ‘아이템 뷰’를 생성하는 역할은 어댑터가 담당합니다. 사용자 데이터 리스트로부터 ‘아이템 뷰’를 만드는 것, 그것이 바로 어댑터가 하는 역할이죠.\nlayoutManger : 레이아웃매니저는 리사이클러뷰가 아이템을 화면에 표시할 때, 아이템 뷰들이 리사이클러뷰 내부에서 배치되는 형태를 관리하는 요소입니다\nViewHolder : 뷰홀더(ViewHolder)는 화면에 표시될 아이템 뷰를 저장하는 객체입니다.\nRecyclerView.Adapter를 상속받아 새로운 어댑터를 만들 때, 오버라이드가 필요한 메서드는 아래와 같습니다.\nonCreateViewHolder() : ViewHolder를 새로 만들어야 할 때 호출되는 메서드이다. 이 메서드를 통해 각 아이템을 위한 XML 레이아웃을 이용한 뷰 객체를 생성하고 뷰 홀더에 담아 리턴한다. 이때는 뷰의 콘텐츠를 채우지 않는다. 왜냐하면 아직 ViewHolder가 특정 데이터에 바인딩된 상태가 아니기 때문이다.\nonBindViewHolder() : ViewHolder 를 ’어떠한 데이터와 연결할 때’ 호출되는 메소드로, 이를 통해 ’뷰 홀더 객체들의 레이아웃’을 채우게 된다. position 이라는 파라미터를 활용하여 데이터의 순서에 맞게 아이템 레이아웃을 바인딩해줄 수 있다.\nViewHolder 패턴은, 각 뷰의 객체를 ViewHolder 에 보관함으로써 뷰의 내용을 업데이트하기 위한 findViewById() 메소드 호출을 줄여 효과적으로 퍼포먼스 개선을 할 수 있는 패턴이다.\nViewHolder 패턴을 사용하면, 한 번 생성하여 저장했던 뷰는 다시 findViewById() 를 통해 뷰를 불러올 필요가 사라지게 된다.\n만약 데이터가 1번부터 10번까지 10개 있고, 이를 리스트 형태로 보여줄 때 스마트폰의 화면 크기 상 1번부터 5번까지 보여준다고 가정해보자. 그럼 사용자가 스크롤을 하게 되면, 최상단에 있던 1번 및 2번 아이템의 레이아웃은 눈에 보이지 않게 될 것이다. 그와 동시에 6번 및 7번 아이템이 화면에 새롭게 보여지지 않겠는가? 이 때, 6번 및 7번 아이템을 화면에 표시하기 위해 findViewById() 를 일일히 호출하여 레이아웃에 데이터를 바인딩하지 않고, 기존에 1번 및 2번 아이템을 그려줄 때 사용했던 View 를 재사용하여 이미 불러왔었던 레이아웃에 데이터만 채워주는 것이다. 재사용성을 높였을 뿐더러 불필요한 High-Cost 동작을 줄인 것이다. Android RecyclerView 구성 요소 Android RecyclerView는 복잡한 리스트를 효율적으로 표시하기 위한 강력한 도구입니다.\nViewHolder 패턴: 각 아이템을 나타내는 ViewHolder를 사용하여 뷰 재활용을 통해 성능을 향상시킵니다.\n1. RecyclerView:\n역할: 화면에 아이템 목록을 표시하는 뷰(View)입니다. 스크롤, 아이템 추가/삭제 등의 기능을 담당합니다. 특징: 유연한 레이아웃: 다양한 LayoutManager를 사용하여 리스트, 그리드, 폭포수 등 다양한 형태로 아이템을 배치할 수 있습니다. 효율적인 뷰 재활용: ViewHolder 패턴을 사용하여 화면 밖으로 사라진 아이템 뷰를 재활용하여 메모리 사용량을 줄이고 성능을 향상시킵니다. 2. Adapter:\n역할: 데이터와 RecyclerView를 연결하는 다리 역할을 합니다. 데이터를 ViewHolder에 바인딩하고, ViewHolder를 생성하여 RecyclerView에 제공합니다. 핵심 메서드: onCreateViewHolder(): ViewHolder 객체 생성, 이 메서드를 통해 각 아이템을 위한 XML 레이아웃을 이용한 뷰 객체를 생성하고 ViewHodler에 담아 리턴한다. 이때는 뷰의 콘텐츠를 채우지 않는다. 왜냐하면 아직 ViewHolder가 특정 데이터에 바인딩된 상태가 아니기 때문이다. onBindViewHolder(): ViewHolder에 데이터를 바인딩합니다. getItemCount(): 전체 아이템 개수를 반환합니다. 3. ViewHolder:\n역할: 말 그대로, 각 아이템의 View를 담고(Hold) 있는 객체입니다. 뷰 재활용을 위해 뷰를 참조하고 데이터를 바인딩하는 역할을 합니다. 특징: itemView 속성을 통해 아이템 뷰에 접근할 수 있습니다. adapter의onBindViewHolder() 에서 ViewHolder에서 우리가 작성한 bind 함수를 호출해 데이터를 바인딩합니다. 4. LayoutManager:\n역할: 아이템 뷰를 화면에 배치하는 방식을 결정합니다. 종류: LinearLayoutManager: 아이템을 수직 또는 수평으로 배치합니다. GridLayoutManager: 아이템을 격자 형태로 배치합니다. StaggeredGridLayoutManager: 아이템을 엇갈리게 배치합니다. (Custom LayoutManager): 개발자가 직접 정의한 레이아웃 방식을 사용할 수 있습니다. 5. ItemDecoration:\n역할: 아이템 뷰 사이에 구분선, 간격 등을 추가하여 시각적인 효과를 줍니다. 6. ItemAnimator:\n역할: 아이템 추가, 삭제, 이동 등의 변경 사항에 대한 애니메이션 효과를 제공합니다. RecyclerView 작동 방식:\n1. 초기화 단계:\nRecyclerView는 Adapter에게 화면에 표시될 아이템 개수(getItemCount())를 요청합니다. LayoutManager는 화면 크기와 아이템 크기를 기반으로 초기 화면에 표시할 아이템 개수를 계산합니다. RecyclerView는 Adapter에게 필요한 만큼의 ViewHolder를 요청합니다. Adapter는 onCreateViewHolder() 메서드를 호출하여 ViewHolder를 생성하고 각 아이템에 해당하는 레이아웃을 inflate 합니다. RecyclerView는 생성된 ViewHolder를 LayoutManager에게 전달합니다. LayoutManager는 ViewHolder를 화면에 배치하고, Adapter에게 각 ViewHolder의 데이터 바인딩을 요청합니다. Adapter는 onBindViewHolder() 메서드를 호출하여 ViewHolder에 데이터를 설정합니다. 2. 스크롤 및 뷰 재활용 단계:\n사용자가 RecyclerView를 스크롤하면 화면 밖으로 사라지는 아이템 뷰는 RecyclerView의 Recycler Pool로 이동합니다.\n화면에 새로운 아이템이 나타나면 RecyclerView는 Recycler Pool에서 재활용 가능한 ViewHolder를 찾습니다.\n재활용 가능한 ViewHolder가 있으면, Adapter는 onBindViewHolder() 메서드를 호출하여 새로운 데이터를 바인딩합니다.\n재활용 가능한 ViewHolder가 없으면, Adapter는 onCreateViewHolder() 메서드를 호출하여 새로운 ViewHolder를 생성합니다.\nLayoutManager는 새로운 또는 재활용된 ViewHolder를 화면에 배치합니다.\nRecyclerView 장점:\n유연성: 다양한 레이아웃과 아이템 유형을 지원하여 복잡한 UI를 쉽게 구현할 수 있습니다. 성능: ViewHolder 패턴과 뷰 재활용을 통해 대량의 데이터를 효율적으로 처리할 수 있습니다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 class PlaylistAdapter : ListAdapter\u003cPlaylistUiModel, PlaylistAdapter.PlaylistViewHolder\u003e(PlaylistItemDiffUtil) { override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): PlaylistViewHolder { return PlaylistViewHolder.from(parent) } override fun onBindViewHolder(holder: PlaylistViewHolder, position: Int) { holder.bind(currentList[position]) } class PlaylistViewHolder private constructor(private val binding: ItemPlaylistBinding) : RecyclerView.ViewHolder(binding.root) { private val moreMessage = itemView.context.getText(R.string.develop_in_future) init { binding.ibMore.setOnClickListener { Snackbar.make(itemView, moreMessage, Snackbar.LENGTH_LONG).show() } } fun bind(item: PlaylistUiModel) { binding.playlist = item } companion object { fun from(parent: ViewGroup) = PlaylistViewHolder( ItemPlaylistBinding.inflate( LayoutInflater.from(parent.context), parent, false ) ) } } object PlaylistItemDiffUtil : DiffUtil.ItemCallback\u003cPlaylistUiModel\u003e() { override fun areItemsTheSame(oldItem: PlaylistUiModel, newItem: PlaylistUiModel): Boolean { return oldItem.id == newItem.id // 아이템의 고유 ID 비교 } override fun areContentsTheSame(oldItem: PlaylistUiModel, newItem: PlaylistUiModel): Boolean { return oldItem == newItem // 아이템 내용 비교 } } } Android ListAdapter 설명 RecyclerView.Adapter를 상속받아 구현되었으며, DiffUtil을 내부적으로 사용하여 데이터 변경 시 효율적인 업데이트를 수행합니다.\nListAdapter의 주요 특징:\nDiffUtil 기반 업데이트: DiffUtil을 사용하여 이전 목록과 새 목록 간의 차이점을 계산하고, 변경된 부분만 업데이트합니다.\n이는 notifyDataSetChanged()처럼 전체 목록을 새로고침하는 것보다 성능이 훨씬 좋습니다. 백그라운드 스레드 활용: DiffUtil의 차이점 계산은 백그라운드 스레드에서 수행되므로 UI 스레드를 차단하지 않아 부드러운 UI를 유지할 수 있습니다.\n간편한 사용: submitList() 메서드를 통해 새 목록을 전달하면 ListAdapter가 알아서 차이점 계산 및 업데이트를 처리합니다.\n애니메이션 지원: DefaultItemAnimator와 함께 사용하면 변경된 아이템에 대한 애니메이션 효과를 자동으로 적용할 수 있습니다.\nListAdapter 사용 방법:\nListAdapter 상속: RecyclerView.Adapter 대신 ListAdapter를 상속받아 Adapter 클래스를 생성합니다. DiffUtil.ItemCallback 구현: 데이터 클래스의 어떤 속성을 기준으로 아이템의 동일성과 내용 변경을 판단할지 정의하는 DiffUtil.ItemCallback 객체를 생성합니다. submitList() 호출: 데이터 변경 시 submitList() 메서드를 호출하여 새 목록을 전달합니다. DiffUtil.ItemCallback 사용 방법:\nItemCallback 구현: DiffUtil.ItemCallback을 상속받아 추상 메서드인 areItemsTheSame()과 areContentsTheSame()를 구현합니다.\nDiffUtil.calculateDiff() 호출: DiffUtil.calculateDiff() 메서드에 구현한 ItemCallback 객체와 이전 목록, 새 목록을 전달하여 DiffResult 객체를 얻습니다.\n1 2 3 4 val diffCallback = MyDiffCallback() val diffResult = DiffUtil.calculateDiff(diffCallback) diffResult.dispatchUpdatesTo(myAdapter) Adapter 업데이트: DiffResult 객체의 dispatchUpdatesTo() 메서드를 호출하여 RecyclerView의 Adapter에 변경 사항을 알립니다.\nListAdapter 사용 시 주의 사항:\nDiffUtil.ItemCallback을 정확하게 구현해야 합니다. 아이템의 동일성과 내용 변경을 정확하게 판단하지 못하면 업데이트가 제대로 이루어지지 않을 수 있습니다.\nareItemsTheSame() 함수가 먼저 실행이 되고 해당 함수의 결과로 true 가 반환됐을 경우에만, areContentsTheSame() 이 호출됩니다.\n그렇기 때문에 areItemsTheSame() 에는 id 처럼 아이템을 식별할 수 있는 유니크한 값을 비교하고,\nareContentsTheSame() 에는 아이템의 내부 정보가 모두 동일한지 비교합니다.\nsubmitList() 메서드 호출 시 이전 목록과 새 목록을 비교하는 데 시간이 소요될 수 있습니다. 따라서 너무 자주 호출하지 않도록 주의해야 합니다.\nListAdapter는 RecyclerView.Adapter의 모든 기능을 지원하지 않을 수 있습니다. 필요한 기능이 있는지 확인하고, 필요하다면 직접 구현해야 합니다.\n","wordCount":"2868","inLanguage":"en","image":"https://2taezeat.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E","datePublished":"2023-11-09T11:30:03Z","dateModified":"2023-11-09T11:30:03Z","author":{"@type":"Person","name":"2taezeat"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://2taezeat.github.io/posts/android/android-view/"},"publisher":{"@type":"Organization","name":"2taezeat, blog","logo":{"@type":"ImageObject","url":"https://2taezeat.github.io/icon/favicon.ico"}}}</script></head><body id=top><header class=header><nav class=nav><div class=logo><a href=https://2taezeat.github.io/ accesskey=h title="2taezeat blog (Alt + H)"><img src=https://2taezeat.github.io/icon/apple-touch-icon.png alt aria-label=logo height=30>2taezeat blog</a><div class=logo-switches></div></div><ul id=menu><li><a href=https://2taezeat.github.io/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://2taezeat.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://2taezeat.github.io/searchs/ title=Search><span>Search</span></a></li><li><a href=https://github.com/2taezeat title=Github><span>Github</span>&nbsp;<svg fill="none" shape-rendering="geometricPrecision" stroke="currentcolor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2.5" viewBox="0 0 24 24" height="12" width="12"><path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"/><path d="M15 3h6v6"/><path d="M10 14 21 3"/></svg></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://2taezeat.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://2taezeat.github.io/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">Android View 기초</h1><div class=post-description>Android View 기초</div><div class=post-meta><span title='2023-11-09 11:30:03 +0000 +0000'>2023-11-09</span>&nbsp;·&nbsp;14 min&nbsp;·&nbsp;2868 words&nbsp;·&nbsp;2taezeat</div></header><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#android-view>Android View</a><ul><li><a href=#view-생명주기의-핵심-단계>View 생명주기의 핵심 단계</a></li><li><a href=#invalidate-vs-requestlayout-차이점-및-사용-시점><code>invalidate()</code> vs. <code>requestLayout()</code>: 차이점 및 사용 시점</a></li><li><a href=#android-view-계층-구조>Android View 계층 구조</a><ul><li><a href=#view와-viewgroup>View와 ViewGroup</a></li><li><a href=#view-계층-구조의-특징>View 계층 구조의 특징</a></li><li><a href=#view-계층-구조의-예시>View 계층 구조의 예시</a></li><li><a href=#view-계층-구조의-활용>View 계층 구조의 활용</a></li><li><a href=#추가-정보>추가 정보</a></li></ul></li></ul></li><li><a href=#android에서-constraintlayout을-사용하는-이유와-설명>Android에서 ConstraintLayout을 사용하는 이유와 설명</a></li><li><a href=#android-data-binding>Android Data Binding</a><ul><li><a href=#binding-클래스-자동-생성>binding 클래스 자동 생성</a></li><li><a href=#android-bindingadapter>Android BindingAdapter</a></li><li><a href=#android-view-binding-vs-data-binding-비교>Android View Binding vs. Data Binding 비교</a></li></ul></li><li><a href=#android-custom-view-설명>Android Custom View 설명</a></li><li><a href=#recyclerview>RecyclerView</a><ul><li><a href=#android-recyclerview-구성-요소>Android RecyclerView 구성 요소</a></li><li><a href=#android-listadapter-설명>Android ListAdapter 설명</a></li></ul></li></ul></nav></div></details></div><div class=post-content><h1 id=android-view>Android View<a hidden class=anchor aria-hidden=true href=#android-view>#</a></h1><h2 id=view-생명주기의-핵심-단계>View 생명주기의 핵심 단계<a hidden class=anchor aria-hidden=true href=#view-생명주기의-핵심-단계>#</a></h2><p><img loading=lazy src=/images/before/image-20240520061145855.png alt=image-20240520061145855.png width=680 height=auto></p><ol><li><strong>생성 (Construction):</strong><ul><li>View 객체가 생성되는 단계입니다.</li><li>생성자를 통해 초기화 작업을 수행합니다.</li><li><strong>주로 XML 레이아웃 파일에서 View가 inflate 되거나, Kotlin/Java 코드에서 View 객체를 생성할 때 호출됩니다.</strong></li></ul></li><li><strong>부착 (Attachment):</strong><ul><li>View가 윈도우(Window)에 부착되는 단계입니다.</li><li><code>onAttachedToWindow()</code> 메서드가 호출됩니다.</li><li>이 시점부터 View는 화면에 표시될 준비가 되었으며, 사용자 입력을 처리할 수 있습니다.</li><li>리소스 할당이나 이벤트 리스너 등록 등 초기화 작업을 수행하기에 적합한 시점입니다.</li></ul></li><li><strong>측정 (Measurement):</strong><ul><li>View의 크기를 결정하는 단계입니다.</li><li><code>onMeasure()</code> 메서드가 호출됩니다.</li><li><strong>부모 View로부터 전달받은 제약 조건과 View 자신의 특성을 고려하여 View의 크기를 계산합니다.</strong></li></ul></li><li><strong>배치 (Layout):</strong><ul><li>View의 위치를 결정하는 단계입니다.</li><li><code>onLayout()</code> 메서드가 호출됩니다.</li><li><strong>부모 View로부터 전달받은 크기와 위치 정보를 기반으로 View의 위치를 설정합니다.</strong></li><li>자식 View가 있다면, 자식 View들의 위치도 결정합니다.</li></ul></li><li><strong>그리기 (Drawing):</strong><ul><li>View의 내용을 화면에 그리는 단계입니다.</li><li><code>onDraw()</code> 메서드가 호출됩니다.</li><li>Canvas 객체를 사용하여 View의 배경, 텍스트, 이미지 등을 그립니다.</li></ul></li><li><strong>분리 (Detachment):</strong><ul><li>View가 윈도우에서 분리되는 단계입니다.</li><li><code>onDetachedFromWindow()</code> 메서드가 호출됩니다.</li><li>이 시점부터 View는 더 이상 화면에 표시되지 않으며, 사용자 입력을 처리할 수 없습니다.</li><li>사용하지 않는 리소스를 해제하고 이벤트 리스너를 제거하는 등 정리 작업을 수행하기에 적합한 시점입니다.</li></ul></li></ol><p><strong>View 생명주기 활용 예시</strong></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-kotlin data-lang=kotlin><span class=line><span class=cl><span class=k>class</span> <span class=nc>CustomView</span><span class=p>(</span><span class=n>context</span><span class=p>:</span> <span class=n>Context</span><span class=p>,</span> <span class=n>attrs</span><span class=p>:</span> <span class=n>AttributeSet</span><span class=p>?)</span> <span class=p>:</span> <span class=n>View</span><span class=p>(</span><span class=n>context</span><span class=p>,</span> <span class=n>attrs</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>override</span> <span class=k>fun</span> <span class=nf>onAttachedToWindow</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>super</span><span class=p>.</span><span class=n>onAttachedToWindow</span><span class=p>()</span>
</span></span><span class=line><span class=cl>        <span class=c1>// 리소스 초기화, 이벤트 리스너 등록 등
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>override</span> <span class=k>fun</span> <span class=nf>onMeasure</span><span class=p>(</span><span class=n>widthMeasureSpec</span><span class=p>:</span> <span class=n>Int</span><span class=p>,</span> <span class=n>heightMeasureSpec</span><span class=p>:</span> <span class=n>Int</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=c1>// View의 크기 계산
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>override</span> <span class=k>fun</span> <span class=nf>onLayout</span><span class=p>(</span><span class=n>changed</span><span class=p>:</span> <span class=n>Boolean</span><span class=p>,</span> <span class=n>left</span><span class=p>:</span> <span class=n>Int</span><span class=p>,</span> <span class=n>top</span><span class=p>:</span> <span class=n>Int</span><span class=p>,</span> <span class=n>right</span><span class=p>:</span> <span class=n>Int</span><span class=p>,</span> <span class=n>bottom</span><span class=p>:</span> <span class=n>Int</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=c1>// View의 위치 설정
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>override</span> <span class=k>fun</span> <span class=nf>onDraw</span><span class=p>(</span><span class=n>canvas</span><span class=p>:</span> <span class=n>Canvas</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=c1>// View의 내용 그리기
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>override</span> <span class=k>fun</span> <span class=nf>onDetachedFromWindow</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>super</span><span class=p>.</span><span class=n>onDetachedFromWindow</span><span class=p>()</span>
</span></span><span class=line><span class=cl>        <span class=c1>// 리소스 해제, 이벤트 리스너 제거 등
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><h2 id=invalidate-vs-requestlayout-차이점-및-사용-시점><code>invalidate()</code> vs. <code>requestLayout()</code>: 차이점 및 사용 시점<a hidden class=anchor aria-hidden=true href=#invalidate-vs-requestlayout-차이점-및-사용-시점>#</a></h2><p><strong>invalidate()</strong></p><ul><li><strong>역할:</strong> View의 <strong>외관(appearance)이 변경</strong>되었을 때 호출하여 <strong>해당 View만 다시 그리도록 요청</strong>합니다.</li><li>동작:<ol><li><code>invalidate()</code> 메서드가 호출되면 View는 &ldquo;dirty&rdquo; 상태로 표시됩니다.</li><li>다음 UI 렌더링 주기에서 시스템은 &ldquo;dirty&rdquo; 상태인 View의 <code>onDraw()</code> 메서드를 호출하여 다시 그립니다.</li><li>View의 <strong>크기나 위치</strong>는 변경되지 않습니다.</li></ol></li><li>사용 시점:<ul><li>View의 내용(텍스트, 색상, 이미지 등)이 변경되었을 때</li><li>View의 일부 영역만 다시 그려야 할 때 (예: <code>invalidate(Rect)</code> 사용)</li><li>애니메이션 효과를 구현할 때</li></ul></li></ul><p><strong>requestLayout()</strong></p><ul><li><strong>역할:</strong> View의 <strong>크기나 위치</strong>가 변경되었을 때 호출하여 <strong>View의 측정 및 배치 과정을 다시 실행</strong>하도록 요청합니다.</li><li>동작:<ol><li><code>requestLayout()</code> 메서드가 호출되면 View는 &ldquo;layout requested&rdquo; 상태로 표시됩니다.</li><li>다음 UI 렌더링 주기에서 시스템은 &ldquo;layout requested&rdquo; 상태인 View와 해당 View의 모든 자식 View에 대해 측정 (<code>onMeasure()</code>) 및 배치 (<code>onLayout()</code>) 과정을 다시 실행합니다.</li><li>View의 내용은 변경되지 않을 수도 있습니다.</li></ol></li><li>사용 시점:<ul><li>View의 크기 (<code>LayoutParams</code>)가 변경되었을 때</li><li>View의 내용 변경으로 인해 View의 크기가 변경될 수 있을 때</li><li><strong>화면 회전 등으로 인해 레이아웃이 변경</strong>되어야 할 때</li></ul></li></ul><p><strong>주의 사항</strong></p><ul><li><code>invalidate()</code>는 View의 외관만 변경하므로, 크기나 위치 변경에는 영향을 미치지 않습니다.</li><li><code>requestLayout()</code>는 View의 크기나 위치를 변경하므로, 해당 View와 모든 자식 View의 측정 및 배치 과정을 다시 실행하여 성능에 영향을 줄 수 있습니다.</li><li>불필요한 <code>invalidate()</code> 또는 <code>requestLayout()</code> 호출은 UI 성능 저하를 야기할 수 있으므로 주의해야 합니다.</li></ul><p><strong>예시</strong></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span><span class=lnt>9
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-kotlin data-lang=kotlin><span class=line><span class=cl><span class=c1>// 텍스트 내용 변경 (invalidate() 사용)
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>textView</span><span class=p>.</span><span class=n>text</span> <span class=p>=</span> <span class=s2>&#34;새로운 텍스트&#34;</span>
</span></span><span class=line><span class=cl><span class=n>textView</span><span class=p>.</span><span class=n>invalidate</span><span class=p>()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// View의 크기 변경 (requestLayout() 사용)
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>val</span> <span class=py>params</span> <span class=p>=</span> <span class=n>textView</span><span class=p>.</span><span class=n>layoutParams</span>
</span></span><span class=line><span class=cl><span class=n>params</span><span class=p>.</span><span class=n>width</span> <span class=p>=</span> <span class=nc>ViewGroup</span><span class=p>.</span><span class=nc>LayoutParams</span><span class=p>.</span><span class=n>WRAP_CONTENT</span>
</span></span><span class=line><span class=cl><span class=n>textView</span><span class=p>.</span><span class=n>layoutParams</span> <span class=p>=</span> <span class=n>params</span>
</span></span><span class=line><span class=cl><span class=n>textView</span><span class=p>.</span><span class=n>requestLayout</span><span class=p>()</span>
</span></span></code></pre></td></tr></table></div></div><h2 id=android-view-계층-구조>Android View 계층 구조<a hidden class=anchor aria-hidden=true href=#android-view-계층-구조>#</a></h2><p>Android View는 트리 형태의 계층 구조를 이루며, 이를 View 계층 구조(View Hierarchy)라고 합니다.</p><p>각 View는 <strong>트리의 부모-자식 관계로 연결되어 있으며, 최상위 View를 루트 View(Root View)</strong> 라고 합니다.</p><p><strong>전위 순회 (root-> left -> right)</strong></p><h3 id=view와-viewgroup>View와 ViewGroup<a hidden class=anchor aria-hidden=true href=#view와-viewgroup>#</a></h3><ul><li><strong>View:</strong> 화면에 보이는 UI 요소의 기본 단위입니다. TextView, ImageView, Button 등이 View에 해당합니다.</li><li><strong>ViewGroup:</strong> 다른 View들을 담는 컨테이너 역할을 하는 View입니다.<ul><li>LinearLayout, RelativeLayout, ConstraintLayout 등이 ViewGroup에 해당합니다.</li><li>ViewGroup은 View를 상속받기 때문에 View의 모든 속성과 기능을 가지면서, <strong>추가로 자식 View들을 관리하는 기능을 제공</strong>합니다.</li></ul></li></ul><h3 id=view-계층-구조의-특징>View 계층 구조의 특징<a hidden class=anchor aria-hidden=true href=#view-계층-구조의-특징>#</a></h3><ul><li><strong>트리 구조:</strong> View 계층 구조는 하나의 루트 View를 시작으로 여러 개의 자식 View들이 연결되어 트리 형태를 이룹니다.</li><li><strong>부모-자식 관계:</strong> 각 View는 하나의 부모 View를 가지며, 여러 개의 자식 View를 가질 수 있습니다.</li><li><strong>레이아웃 관리:</strong> ViewGroup은 자식 View들의 크기와 위치를 결정하여 화면에 배치하는 역할을 합니다.</li><li><strong>이벤트 전달:</strong> 터치, 클릭 등 사용자 이벤트는 View 계층 구조를 따라 전달됩니다.</li></ul><h3 id=view-계층-구조의-예시>View 계층 구조의 예시<a hidden class=anchor aria-hidden=true href=#view-계층-구조의-예시>#</a></h3><pre tabindex=0><code>DecorView (Root View)
ㄴ LinearLayout
    ㄴ TextView
    ㄴ ImageView
    ㄴ Button
</code></pre><p>위 예시에서 DecorView는 루트 View이며, LinearLayout은 DecorView의 자식 View이자 ViewGroup입니다.</p><p>TextView, ImageView, Button은 LinearLayout의 자식 View입니다.</p><h3 id=view-계층-구조의-활용>View 계층 구조의 활용<a hidden class=anchor aria-hidden=true href=#view-계층-구조의-활용>#</a></h3><ul><li><strong>UI 구성:</strong> View 계층 구조를 통해 다양한 UI 요소를 조합하여 복잡한 화면을 구성할 수 있습니다.</li><li><strong>레이아웃 관리:</strong> ViewGroup을 사용하여 자식 View들의 배치를 효율적으로 관리할 수 있습니다.</li><li><strong>커스텀 View 생성:</strong> View 클래스를 상속받아 새로운 View를 만들거나 기존 View의 기능을 확장할 수 있습니다.</li><li><strong>이벤트 처리:</strong> View 계층 구조를 통해 사용자 이벤트를 처리하고 적절한 동작을 수행할 수 있습니다.</li></ul><h3 id=추가-정보>추가 정보<a hidden class=anchor aria-hidden=true href=#추가-정보>#</a></h3><ul><li>View 계층 구조는 액티비티(Activity)가 시작될 때 <code>setContentView()</code> 메서드를 통해 설정됩니다.</li><li>View 계층 구조는 <code>findViewById()</code> 메서드를 통해 특정 View를 찾을 수 있습니다.</li><li>View 계층 구조는 <code>getParent()</code> 메서드를 통해 부모 View를, <code>getChildCount()</code> 및 <code>getChildAt()</code> 메서드를 통해 자식 View들을 확인할 수 있습니다.</li></ul><h1 id=android에서-constraintlayout을-사용하는-이유와-설명>Android에서 ConstraintLayout을 사용하는 이유와 설명<a hidden class=anchor aria-hidden=true href=#android에서-constraintlayout을-사용하는-이유와-설명>#</a></h1><p>ConstraintLayout은 Android UI 개발에서 복잡한 레이아웃을 효율적으로 구성하기 위해 설계된 강력한 ViewGroup입니다.</p><p>기존의 RelativeLayout이나 LinearLayout 등의 레이아웃 방식보다 더욱 <strong>유연</strong>하고 <strong>성능이 뛰어나다는 장점</strong>을 가지고 있습니다.</p><p><strong>ConstraintLayout 사용 이유</strong></p><ol><li><strong>복잡한 레이아웃 구현 용이:</strong><ul><li><strong>제약 조건(constraints)</strong> 을 사용하여 View 간의 관계를 정의함으로써 복잡한 레이아웃을 <strong>간결하게 표현</strong>할 수 있습니다.</li><li>상대적인 위치, 정렬, 비율 등 다양한 제약 조건을 설정하여 View를 원하는 위치에 배치할 수 있습니다.</li><li>Guideline, Barrier, Group 등의 기능을 활용하여 더욱 유연한 레이아웃 구성이 가능합니다.</li></ul></li><li><strong>중첩 레이아웃 감소:</strong><ul><li>ConstraintLayout은 View 간의 관계를 직접적으로 정의하므로, <strong>불필요한 중첩 레이아웃을 줄일 수 있습니다.</strong></li><li><strong>중첩 레이아웃은 UI 성능 저하의 주요 원인</strong>이 될 수 있으므로, ConstraintLayout을 사용하면 <strong>성능 향상</strong>을 기대할 수 있습니다.</li></ul></li><li><strong>성능 향상:</strong><ul><li>ConstraintLayout은 내부적으로 효율적인 알고리즘을 사용하여 레이아웃을 계산합니다.</li><li>따라서 렌더링 속도가 빠르고, 특히 복잡한 레이아웃에서 성능 이점을 얻을 수 있습니다.</li></ul></li><li><strong>다양한 화면 크기 지원:</strong><ul><li>ConstraintLayout은 <strong>다양한 화면 크기와 해상도에 대한 적응성이 뛰어</strong>납니다.</li><li>제약 조건을 사용하여 View의 크기와 위치를 <strong>상대적으로 설정</strong>하므로, <strong>다양한 기기에서 일관된 UI를 유지</strong>할 수 있습니다.</li></ul></li></ol><p><strong>ConstraintLayout은 다음과 같은 주요 기능을 제공합니다.</strong></p><ul><li><strong>제약 조건 (Constraints):</strong> View의 위치, 크기, 정렬 등을 다른 View나 부모 레이아웃에 <strong>상대적으로 정의</strong>합니다.</li><li><strong>Guideline:</strong> View의 위치를 잡기 위한 <strong>보조선 역할</strong>을 합니다. 수직 또는 수평 Guideline을 생성하여 View를 정렬하거나 배치할 수 있습니다.</li><li><strong>Barrier:</strong> 여러 View의 위치를 기준으로 <strong>동적으로 생성되는 보이지 않는 장벽</strong>입니다. Barrier를 사용하여 특정 View들이 특정 위치를 넘어가지 않도록 제한할 수 있습니다.</li><li><strong>Group:</strong> 여러 View를 하나의 그룹으로 묶어서 관리합니다. 그룹 단위로 Visibility를 설정하거나 제약 조건을 적용할 수 있습니다.</li><li><strong>Chains:</strong> 여러 View를 연결하여 <strong>일렬로 배치하고 간격을 조절</strong>하는 기능입니다.</li></ul><h1 id=android-data-binding>Android Data Binding<a hidden class=anchor aria-hidden=true href=#android-data-binding>#</a></h1><p>Android Data Binding은 UI 레이아웃과 데이터를 연결하여 UI 업데이트를 단순화하는 라이브러리입니다.</p><p><strong>Data Binding의 핵심 기능:</strong></p><ul><li><p><strong>데이터 바인딩 표현식:</strong> <strong>레이아웃 파일</strong>에서 데이터를 <strong>직접 참조하고 조작</strong>할 수 있습니다.</p><ul><li>예를 들어 <code>@{user.name}</code>과 같이 데이터 객체의 속성을 참조하여 TextView에 표시할 수 있습니다.</li></ul></li><li><p><strong>이벤트 핸들링:</strong> 버튼 클릭과 같은 이벤트 발생 시 데이터 객체의 메서드를 호출하거나 특정 로직을 실행할 수 있습니다.</p></li><li><p><strong>Observable 객체:</strong> 데이터가 변경될 때 UI를 자동으로 업데이트할 수 있도록 <strong>Observable 객체</strong>를 사용합니다. LiveData, ObservableField 등이 이에 해당합니다.</p></li><li><p><strong>Binding Adapter:</strong> Data Binding 표현식에서 사용할 수 있는 <strong>커스텀 속성을 정의</strong>하고, 속성 값에 따라 View의 속성을 변경하는 로직을 구현할 수 있습니다.</p></li></ul><p><strong>Data Binding 사용 이유:</strong></p><ol><li><strong>UI 코드 간소화:</strong> UI 업데이트를 위한 findViewById() 및 setText()와 같은 반복적인 코드 작성을 줄여줍니다.</li><li><strong>가독성 향상:</strong> UI 로직이 레이아웃 파일에 명확하게 표현되어 코드의 가독성이 좋아집니다.</li><li><strong>오류 감소:</strong> 데이터 바인딩 표현식의 유효성을 컴파일 타임에 검사하여 런타임 오류 발생 가능성을 줄여줍니다.</li><li><strong>유지보수성 향상:</strong> UI 로직과 데이터 로직이 분리되어 유지보수가 용이해집니다.</li></ol><ul><li><strong>프로그래매틱 방식이 아니라,</strong> <strong>선언적 방식</strong>을 사용하여 UI 구성요소를 데이터에 결합할 수 있는 지원 라이브러리<ul><li>뷰를 데이터 객체와 결합하는 데 <strong>필요한 클래스를 자동</strong>으로 생성 (view와 data를 바인딩)</li></ul></li><li>DataBinding으로 인해 ViewModel이 View를 알지 못해도, 다양한 인터랙션 처리 가능<ul><li>Model에서 데이터가 변경되면, ViewModel에 전달</li><li>변경된 데이터가 ViewModel에서 View로 전달되도록 LiveData, RxJava, Kotlin Flow을 사용해 구현<ul><li>옵저버 패턴 or Reactive(반응형) 프로그래밍</li></ul></li></ul></li></ul><h2 id=binding-클래스-자동-생성>binding 클래스 자동 생성<a hidden class=anchor aria-hidden=true href=#binding-클래스-자동-생성>#</a></h2><p>Android Data Binding 라이브러리를 사용하면 레이아웃 파일(*.xml)에 대응하는 바인딩 클래스가 자동으로 생성됩니다.</p><p>이 바인딩 클래스는 레이아웃 파일의 UI 요소와 데이터를 연결하는 데 사용됩니다.</p><p><strong>자동 생성 클래스 규칙</strong></p><ul><li><strong>클래스 이름:</strong> 레이아웃 파일 이름을 파스칼 표기법(PascalCase)으로 변환하고 &ldquo;Binding&rdquo; 접미사를 붙입니다. 예를 들어 <code>activity_main.xml</code> 레이아웃 파일은 <code>ActivityMainBinding</code> 클래스로 변환됩니다.</li><li><strong>클래스 위치:</strong> <code>build</code> 디렉토리 안에 생성됩니다. (예: <code>app/build/generated/data_binding_base_class_source_out/debug/out/com/example/databinding/</code>)</li><li>클래스 구성:<ul><li>레이아웃 파일의 각 View 요소에 대한 참조 변수</li><li>데이터 바인딩 표현식에 정의된 변수에 대한 getter/setter 메서드</li><li><code>inflate()</code> 메서드: 레이아웃 파일을 inflate하고 바인딩 객체를 생성하는 정적 메서드</li></ul></li></ul><h2 id=android-bindingadapter>Android BindingAdapter<a hidden class=anchor aria-hidden=true href=#android-bindingadapter>#</a></h2><p>DataBinding에서, <strong>데이터 바인딩 표현식과 View의 속성을 연결</strong>하는 역할을 합니다.</p><p>기본적으로 제공되는 BindingAdapter 외에도 개발자가 직접 정의하여 커스텀 속성과 View의 동작을 연결할 수 있습니다.</p><p><strong>BindingAdapter의 주요 기능:</strong></p><ol><li><strong>커스텀 속성:</strong> <code>@BindingAdapter</code> 어노테이션을 사용하여 View의 속성과 연결할 커스텀 속성을 정의할 수 있습니다. 예를 들어, ImageView에 이미지 URL을 바인딩하는 <code>app:imageUrl</code> 속성을 만들 수 있습니다.</li><li><strong>속성 값 변환:</strong> BindingAdapter 메서드를 통해 데이터 모델의 값을 <strong>View의 속성 값</strong>으로 변환하는 로직을 구현할 수 있습니다. 예를 들어, <code>app:imageUrl</code> 속성에 전달된 URL 문자열을 Glide 라이브러리를 사용하여 이미지로 변환하여 ImageView에 표시할 수 있습니다.</li></ol><h2 id=android-view-binding-vs-data-binding-비교>Android View Binding vs. Data Binding 비교<a hidden class=anchor aria-hidden=true href=#android-view-binding-vs-data-binding-비교>#</a></h2><p>Android View Binding과 Data Binding은 모두 레이아웃 파일의 View에 쉽게 접근하고 UI 업데이트를 용이하게 하는 데 사용되는 라이브러리입니다.</p><p><strong>View Binding</strong></p><ul><li>핵심 기능:<ul><li>레이아웃 파일에 정의된 View에 대한 참조를 자동으로 생성합니다.</li><li><code>findViewById()</code> 메서드를 사용하지 않고 View에 직접 접근할 수 있습니다.</li><li>Null 안정성을 보장합니다. (ID가 없는 View에 접근하려고 하면 컴파일 오류 발생)</li></ul></li><li>장점:<ul><li><strong>빌드 시간에 바인딩 클래스를 생성</strong>하므로 런타임 성능에 영향을 주지 않습니다.</li><li>Data Binding보다 가볍고 간결합니다.</li><li>findViewById() 메서드 사용 시 발생할 수 있는 null 관련 오류를 방지합니다.</li></ul></li><li>단점:<ul><li>레이아웃 파일과 코드 간의 데이터 바인딩 기능은 제공하지 않습니다.</li><li>양방향 데이터 바인딩이나 복잡한 UI 로직을 구현하기 어렵습니다.</li></ul></li></ul><p><strong>Data Binding</strong></p><ul><li>핵심 기능:<ul><li>레이아웃 파일과 데이터를 직접 연결하여 UI 업데이트를 자동화합니다.</li><li>데이터 변경 시 UI를 자동으로 갱신합니다.</li><li>이벤트 리스너를 간편하게 설정할 수 있습니다.</li><li>BindingAdapter를 사용하여 커스텀 속성을 정의하고 View의 동작을 제어할 수 있습니다.</li></ul></li><li>장점:<ul><li>UI 로직을 레이아웃 파일에 명시하여 코드의 가독성을 높입니다.</li><li>데이터 변경에 따른 UI 업데이트를 자동화하여 생산성을 향상시킵니다.</li><li>양방향 데이터 바인딩과 복잡한 UI 로직 구현이 가능합니다.</li></ul></li><li>단점:<ul><li><strong>빌드 시간이 다소 증가</strong>할 수 있습니다.</li><li>View Binding보다 학습 곡선이 가파릅니다.</li><li>복잡한 표현식 사용 시 런타임 성능에 영향을 줄 수 있습니다.</li></ul></li></ul><h1 id=android-custom-view-설명>Android Custom View 설명<a hidden class=anchor aria-hidden=true href=#android-custom-view-설명>#</a></h1><p>Android Custom View는 기본으로 제공되는 <strong>View 클래스들을 조합하거나 상속</strong>하여 개발자가 직접 정의하는 View입니다.</p><p>기존 View로 표현하기 어려운 복잡한 UI나 특정 기능을 구현할 때 유용하게 사용됩니다.</p><p><strong>Custom View를 만드는 이유</strong></p><ul><li><strong>재사용성:</strong> 자주 사용되는 UI 요소를 Custom View로 만들어 여러 곳에서 재사용할 수 있습니다.</li><li><strong>캡슐화:</strong> Custom View <strong>내부의 로직을 캡슐화하여 코드의 복잡성을 줄이고 유지보수를 용이</strong>하게 합니다.</li><li><strong>유연성:</strong> 기존 View의 기능을 확장하거나 새로운 기능을 추가하여 원하는 디자인과 동작을 구현할 수 있습니다.</li></ul><p><strong>Custom View 종류</strong></p><ul><li><strong>기존 View 조합:</strong> 여러 개의 기존 View를 조합하여 새로운 UI 요소를 만듭니다. 예: 복합적인 레이아웃, 특정 디자인의 버튼 등</li><li><strong>View 상속:</strong> View 클래스를 상속받아 새로운 View를 만듭니다. 예: 원형 ProgressBar, 특정 모양의 그래프 등</li><li><strong>ViewGroup 상속:</strong> ViewGroup 클래스를 상속받아 여러 자식 View를 포함하는 Custom View를 만듭니다. 예: RecyclerView와 유사한 리스트 뷰 등</li></ul><p><strong>Custom View 생성 방법</strong></p><ol><li><strong>클래스 생성:</strong> View 또는 ViewGroup 클래스를 상속받아 새로운 클래스를 만듭니다.</li><li><strong>생성자 정의:</strong> <code>Context</code>와 <code>AttributeSet</code>을 매개변수로 받는 생성자를 정의합니다.</li><li><strong>속성 정의:</strong> <code>attrs.xml</code> 파일에 Custom View의 속성을 정의합니다.</li><li><strong>메서드 오버라이딩:</strong> 필요에 따라 <strong>View의 생명주기 메서드</strong> (<code>onMeasure()</code>, <code>onLayout()</code>, <code>onDraw()</code>)를 오버라이딩하여 Custom View의 동작을 구현합니다.</li></ol><h1 id=recyclerview>RecyclerView<a hidden class=anchor aria-hidden=true href=#recyclerview>#</a></h1><ol><li><p>RecyclerView : 많은 수의 데이터 집합(Data Set)을 <strong>개별 아이템 단위로 구성하여 화면에 출력</strong>하는 뷰그룹(<strong>ViewGroup)</strong> 이며, 한 화면에 표시되기 힘든 많은 수의 <strong>데이터를 스크롤 가능한 리스트로 표시해주는 위젯</strong>입니다.</p></li><li><p><code>리스트뷰(ListView)</code>의 경우, 문제점 중의 하나는, 리스트 항목이 갱신될 때마다, 매번 아이템 뷰를 새로 구성해야 한다는 것이었습니다.</p><ul><li>리스트뷰의 단점을 참고하여, 리사이클러뷰는 아이템을 표시하기 위해 생성한 뷰를 재활용(recycle)합니다. 애니메이션 불가, 수직만 가능</li></ul></li><li><p><strong>Adapter</strong> : 리사이클러뷰에 표시될 ‘아이템 뷰’를 생성하는 역할은 어댑터가 담당합니다. 사용자 데이터 리스트로부터 ‘아이템 뷰’를 만드는 것, 그것이 바로 어댑터가 하는 역할이죠.</p></li><li><p><strong>layoutManger</strong> : 레이아웃매니저는 리사이클러뷰가 아이템을 화면에 표시할 때, 아이템 뷰들이 리사이클러뷰 내부에서 배치되는 형태를 관리하는 요소입니다</p></li><li><p><strong>ViewHolder</strong> : 뷰홀더(ViewHolder)는 화면에 표시될 아이템 뷰를 저장하는 객체입니다.</p></li><li><p><code>RecyclerView.Adapter</code>를 상속받아 새로운 어댑터를 만들 때, 오버라이드가 필요한 메서드는 아래와 같습니다.</p><ul><li><p><strong>onCreateViewHolder</strong>() : ViewHolder를 새로 만들어야 할 때 호출되는 메서드이다. 이 메서드를 통해 각 아이템을 위한 XML 레이아웃을 이용한 뷰 객체를 생성하고 뷰 홀더에 담아 리턴한다. 이때는 뷰의 콘텐츠를 채우지 않는다. 왜냐하면 아직 ViewHolder가 특정 데이터에 바인딩된 상태가 아니기 때문이다.</p></li><li><p><strong>onBindViewHolder</strong>() : ViewHolder 를 ’<strong>어떠한 데이터와 연결할 때’ 호출되는 메소드</strong>로, 이를 통해 ’<strong>뷰 홀더 객체들의 레이아웃’을 채우게</strong> 된다. <code>position</code> 이라는 파라미터를 활용하여 <strong>데이터의 순서에 맞게 아이템 레이아웃을 바인딩</strong>해줄 수 있다.</p></li></ul></li><li><p><strong>ViewHolder 패턴</strong>은, 각 <strong>뷰의 객체</strong>를 ViewHolder 에 보관함으로써 <strong>뷰의 내용을 업데이트하기 위한</strong> <code>findViewById()</code> 메소드 호출을 줄여 효과적으로 퍼포먼스 개선을 할 수 있는 패턴이다.</p></li><li><p>ViewHolder 패턴을 사용하면, 한 번 생성하여 저장했던 뷰는 다시 <code>findViewById()</code> 를 통해 뷰를 불러올 필요가 사라지게 된다.</p><ol><li>만약 데이터가 1번부터 10번까지 10개 있고, 이를 리스트 형태로 보여줄 때 스마트폰의 화면 크기 상 1번부터 5번까지 보여준다고 가정해보자. 그럼 사용자가 스크롤을 하게 되면, 최상단에 있던 1번 및 2번 아이템의 레이아웃은 눈에 보이지 않게 될 것이다. 그와 동시에 6번 및 7번 아이템이 화면에 새롭게 보여지지 않겠는가?</li><li>이 때, 6번 및 7번 아이템을 화면에 표시하기 위해 <strong><code>findViewById()</code> 를 일일히 호출하여 레이아웃에 데이터를 바인딩하지 않고</strong>,</li><li>기존에 1번 및 2번 아이템을 그려줄 때 <strong>사용했던 View 를 재사용하여</strong> <strong>이미 불러왔었던 레이아웃에 데이터</strong>만 채워주는 것이다.</li><li><strong>재사용성을 높였을 뿐더러 불필요한 High-Cost 동작을 줄인 것</strong>이다.</li></ol></li></ol><h2 id=android-recyclerview-구성-요소>Android RecyclerView 구성 요소<a hidden class=anchor aria-hidden=true href=#android-recyclerview-구성-요소>#</a></h2><p>Android RecyclerView는 복잡한 리스트를 효율적으로 표시하기 위한 강력한 도구입니다.</p><p><strong>ViewHolder 패턴:</strong> 각 아이템을 나타내는 ViewHolder를 사용하여 <strong>뷰 재활용</strong>을 통해 성능을 향상시킵니다.</p><p><strong>1. RecyclerView:</strong></p><ul><li><strong>역할:</strong> 화면에 아이템 목록을 표시하는 뷰(View)입니다. 스크롤, 아이템 추가/삭제 등의 기능을 담당합니다.</li><li>특징:<ul><li><strong>유연한 레이아웃:</strong> 다양한 LayoutManager를 사용하여 리스트, 그리드, 폭포수 등 다양한 형태로 아이템을 배치할 수 있습니다.</li><li><strong>효율적인 뷰 재활용:</strong> ViewHolder 패턴을 사용하여 화면 밖으로 사라진 아이템 뷰를 재활용하여 메모리 사용량을 줄이고 성능을 향상시킵니다.</li></ul></li></ul><p><strong>2. Adapter:</strong></p><ul><li><strong>역할:</strong> 데이터와 RecyclerView를 <strong>연결하는 다리 역할</strong>을 합니다. 데이터를 ViewHolder에 바인딩하고, ViewHolder를 생성하여 RecyclerView에 제공합니다.</li><li>핵심 메서드:<ul><li><code>onCreateViewHolder()</code>: ViewHolder 객체 생성, 이 메서드를 통해 각 아이템을 위한 XML 레이아웃을 이용한 뷰 객체를 생성하고 ViewHodler에 담아 리턴한다. 이때는 뷰의 콘텐츠를 채우지 않는다. 왜냐하면 아직 ViewHolder가 특정 데이터에 바인딩된 상태가 아니기 때문이다.</li><li><code>onBindViewHolder()</code>: ViewHolder에 데이터를 바인딩합니다.</li><li><code>getItemCount()</code>: 전체 아이템 개수를 반환합니다.</li></ul></li></ul><p><strong>3. ViewHolder:</strong></p><ul><li><strong>역할:</strong> 말 그대로, <strong>각 아이템의 View를 담고(Hold) 있는 객체</strong>입니다. <strong>뷰 재활용</strong>을 위해 <strong>뷰를 참조하고 데이터를 바인딩</strong>하는 역할을 합니다.</li><li>특징:<ul><li><code>itemView</code> 속성을 통해 아이템 뷰에 접근할 수 있습니다.</li><li>adapter의<code>onBindViewHolder()</code> 에서 ViewHolder에서 우리가 작성한 <code>bind 함수</code>를 호출해 데이터를 바인딩합니다.</li></ul></li></ul><p><strong>4. LayoutManager:</strong></p><ul><li><strong>역할:</strong> 아이템 뷰를 화면에 <strong>배치하는 방식을 결정</strong>합니다.</li><li>종류:<ul><li><code>LinearLayoutManager</code>: 아이템을 수직 또는 수평으로 배치합니다.</li><li><code>GridLayoutManager</code>: 아이템을 격자 형태로 배치합니다.</li><li><code>StaggeredGridLayoutManager</code>: 아이템을 엇갈리게 배치합니다.</li><li>(Custom LayoutManager): 개발자가 직접 정의한 레이아웃 방식을 사용할 수 있습니다.</li></ul></li></ul><p><strong>5. ItemDecoration:</strong></p><ul><li><strong>역할:</strong> 아이템 뷰 사이에 구분선, 간격 등을 추가하여 시각적인 효과를 줍니다.</li></ul><p><strong>6. ItemAnimator:</strong></p><ul><li><strong>역할:</strong> 아이템 추가, 삭제, 이동 등의 변경 사항에 대한 애니메이션 효과를 제공합니다.</li></ul><p><strong>RecyclerView 작동 방식:</strong></p><p><strong>1. 초기화 단계:</strong></p><ul><li>RecyclerView는 Adapter에게 화면에 표시될 아이템 개수(<code>getItemCount()</code>)를 요청합니다.</li><li>LayoutManager는 화면 크기와 아이템 크기를 기반으로 초기 화면에 표시할 아이템 개수를 계산합니다.</li><li>RecyclerView는 Adapter에게 필요한 만큼의 ViewHolder를 요청합니다.</li><li>Adapter는 <code>onCreateViewHolder()</code> 메서드를 호출하여 <strong>ViewHolder를 생성</strong>하고 <strong>각 아이템에 해당하는 레이아웃을 inflate</strong> 합니다.</li><li>RecyclerView는 생성된 ViewHolder를 LayoutManager에게 전달합니다.</li><li>LayoutManager는 ViewHolder를 화면에 배치하고, Adapter에게 각 ViewHolder의 데이터 바인딩을 요청합니다.</li><li>Adapter는 <code>onBindViewHolder()</code> 메서드를 호출하여 ViewHolder에 데이터를 설정합니다.</li></ul><p><strong>2. 스크롤 및 뷰 재활용 단계:</strong></p><ul><li><p>사용자가 RecyclerView를 스크롤하면 화면 밖으로 사라지는 아이템 뷰는 <strong>RecyclerView의 Recycler Pool</strong>로 이동합니다.</p></li><li><p>화면에 새로운 아이템이 나타나면 RecyclerView는 <strong>Recycler Pool에서 재활용 가능한 ViewHolder를 찾습니다.</strong></p></li><li><p>재활용 가능한 ViewHolder가 있으면, Adapter는 <code>onBindViewHolder()</code> 메서드를 호출하여 새로운 데이터를 바인딩합니다.</p></li><li><p>재활용 가능한 ViewHolder가 없으면, Adapter는 <code>onCreateViewHolder()</code> 메서드를 호출하여 새로운 ViewHolder를 생성합니다.</p></li><li><p>LayoutManager는 새로운 또는 재활용된 ViewHolder를 화면에 배치합니다.</p></li></ul><p><strong>RecyclerView 장점:</strong></p><ul><li><strong>유연성:</strong> 다양한 레이아웃과 아이템 유형을 지원하여 복잡한 UI를 쉽게 구현할 수 있습니다.</li><li><strong>성능:</strong> ViewHolder 패턴과 뷰 재활용을 통해 대량의 데이터를 효율적으로 처리할 수 있습니다.</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=lnt>38
</span><span class=lnt>39
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-kotlin data-lang=kotlin><span class=line><span class=cl><span class=k>class</span> <span class=nc>PlaylistAdapter</span> <span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=n>ListAdapter</span><span class=p>&lt;</span><span class=n>PlaylistUiModel</span><span class=p>,</span> <span class=nc>PlaylistAdapter</span><span class=p>.</span><span class=n>PlaylistViewHolder</span><span class=p>&gt;(</span><span class=n>PlaylistItemDiffUtil</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>override</span> <span class=k>fun</span> <span class=nf>onCreateViewHolder</span><span class=p>(</span><span class=n>parent</span><span class=p>:</span> <span class=n>ViewGroup</span><span class=p>,</span> <span class=n>viewType</span><span class=p>:</span> <span class=n>Int</span><span class=p>):</span> <span class=n>PlaylistViewHolder</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=nc>PlaylistViewHolder</span><span class=p>.</span><span class=n>from</span><span class=p>(</span><span class=n>parent</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>override</span> <span class=k>fun</span> <span class=nf>onBindViewHolder</span><span class=p>(</span><span class=n>holder</span><span class=p>:</span> <span class=n>PlaylistViewHolder</span><span class=p>,</span> <span class=n>position</span><span class=p>:</span> <span class=n>Int</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>holder</span><span class=p>.</span><span class=n>bind</span><span class=p>(</span><span class=n>currentList</span><span class=p>[</span><span class=n>position</span><span class=p>])</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>class</span> <span class=nc>PlaylistViewHolder</span> <span class=k>private</span> <span class=k>constructor</span><span class=p>(</span><span class=k>private</span> <span class=k>val</span> <span class=py>binding</span><span class=p>:</span> <span class=n>ItemPlaylistBinding</span><span class=p>)</span> <span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=nc>RecyclerView</span><span class=p>.</span><span class=n>ViewHolder</span><span class=p>(</span><span class=n>binding</span><span class=p>.</span><span class=n>root</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>private</span> <span class=k>val</span> <span class=py>moreMessage</span> <span class=p>=</span> <span class=n>itemView</span><span class=p>.</span><span class=n>context</span><span class=p>.</span><span class=n>getText</span><span class=p>(</span><span class=nc>R</span><span class=p>.</span><span class=n>string</span><span class=p>.</span><span class=n>develop_in_future</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=k>init</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=n>binding</span><span class=p>.</span><span class=n>ibMore</span><span class=p>.</span><span class=n>setOnClickListener</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=nc>Snackbar</span><span class=p>.</span><span class=n>make</span><span class=p>(</span><span class=n>itemView</span><span class=p>,</span> <span class=n>moreMessage</span><span class=p>,</span> <span class=nc>Snackbar</span><span class=p>.</span><span class=n>LENGTH_LONG</span><span class=p>).</span><span class=n>show</span><span class=p>()</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=k>fun</span> <span class=nf>bind</span><span class=p>(</span><span class=n>item</span><span class=p>:</span> <span class=n>PlaylistUiModel</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=n>binding</span><span class=p>.</span><span class=n>playlist</span> <span class=p>=</span> <span class=n>item</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=k>companion</span> <span class=k>object</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=k>fun</span> <span class=nf>from</span><span class=p>(</span><span class=n>parent</span><span class=p>:</span> <span class=n>ViewGroup</span><span class=p>)</span> <span class=p>=</span> <span class=n>PlaylistViewHolder</span><span class=p>(</span>
</span></span><span class=line><span class=cl>                <span class=nc>ItemPlaylistBinding</span><span class=p>.</span><span class=n>inflate</span><span class=p>(</span> <span class=nc>LayoutInflater</span><span class=p>.</span><span class=n>from</span><span class=p>(</span><span class=n>parent</span><span class=p>.</span><span class=n>context</span><span class=p>),</span> <span class=n>parent</span><span class=p>,</span> <span class=k>false</span> <span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>object</span> <span class=nc>PlaylistItemDiffUtil</span> <span class=p>:</span> <span class=nc>DiffUtil</span><span class=p>.</span><span class=n>ItemCallback</span><span class=p>&lt;</span><span class=n>PlaylistUiModel</span><span class=p>&gt;()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>override</span> <span class=k>fun</span> <span class=nf>areItemsTheSame</span><span class=p>(</span><span class=n>oldItem</span><span class=p>:</span> <span class=n>PlaylistUiModel</span><span class=p>,</span> <span class=n>newItem</span><span class=p>:</span> <span class=n>PlaylistUiModel</span><span class=p>):</span> <span class=n>Boolean</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=n>oldItem</span><span class=p>.</span><span class=n>id</span> <span class=o>==</span> <span class=n>newItem</span><span class=p>.</span><span class=n>id</span>             <span class=c1>// 아이템의 고유 ID 비교
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=k>override</span> <span class=k>fun</span> <span class=nf>areContentsTheSame</span><span class=p>(</span><span class=n>oldItem</span><span class=p>:</span> <span class=n>PlaylistUiModel</span><span class=p>,</span> <span class=n>newItem</span><span class=p>:</span> <span class=n>PlaylistUiModel</span><span class=p>):</span> <span class=n>Boolean</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=n>oldItem</span> <span class=o>==</span> <span class=n>newItem</span>             <span class=c1>// 아이템 내용 비교
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><h2 id=android-listadapter-설명>Android ListAdapter 설명<a hidden class=anchor aria-hidden=true href=#android-listadapter-설명>#</a></h2><p>RecyclerView.Adapter를 상속받아 구현되었으며, <strong>DiffUtil을 내부적으로 사용하여</strong> 데이터 변경 시 효율적인 업데이트를 수행합니다.</p><p><strong>ListAdapter의 주요 특징:</strong></p><ul><li><p><strong>DiffUtil 기반 업데이트:</strong> DiffUtil을 사용하여 이전 목록과 새 목록 간의 <strong>차이점을 계산</strong>하고, <strong>변경된 부분만 업데이트</strong>합니다.</p><ul><li>이는 <code>notifyDataSetChanged()</code>처럼 전체 목록을 새로고침하는 것보다 성능이 훨씬 좋습니다.</li></ul></li><li><p><strong>백그라운드 스레드 활용:</strong> DiffUtil의 차이점 계산은 <strong>백그라운드 스레드에서 수행</strong>되므로 <strong>UI 스레드를 차단하지 않아 부드러운 UI</strong>를 유지할 수 있습니다.</p></li><li><p><strong>간편한 사용:</strong> <code>submitList()</code> 메서드를 통해 새 목록을 전달하면 ListAdapter가 <strong>알아서 차이점 계산 및 업데이트를 처리</strong>합니다.</p></li><li><p><strong>애니메이션 지원:</strong> <code>DefaultItemAnimator</code>와 함께 사용하면 변경된 아이템에 대한 애니메이션 효과를 자동으로 적용할 수 있습니다.</p></li></ul><p><strong>ListAdapter 사용 방법:</strong></p><ol><li><strong>ListAdapter 상속:</strong> <code>RecyclerView.Adapter</code> 대신 <code>ListAdapter</code>를 상속받아 Adapter 클래스를 생성합니다.</li><li><strong>DiffUtil.ItemCallback 구현:</strong> 데이터 클래스의 어떤 속성을 기준으로 아이템의 동일성과 내용 변경을 판단할지 정의하는 <strong>DiffUtil.ItemCallback 객체를 생성</strong>합니다.</li><li><strong>submitList() 호출:</strong> 데이터 변경 시 <code>submitList()</code> 메서드를 호출하여 새 목록을 전달합니다.</li></ol><p><strong>DiffUtil.ItemCallback 사용 방법:</strong></p><ol><li><p><strong>ItemCallback 구현:</strong> <code>DiffUtil.ItemCallback</code>을 상속받아 추상 메서드인 <code>areItemsTheSame()</code>과 <code>areContentsTheSame()</code>를 구현합니다.</p></li><li><p><strong>DiffUtil.calculateDiff() 호출:</strong> <code>DiffUtil.calculateDiff()</code> 메서드에 구현한 <code>ItemCallback</code> 객체와 이전 목록, 새 목록을 전달하여 <code>DiffResult</code> 객체를 얻습니다.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-kotlin data-lang=kotlin><span class=line><span class=cl><span class=k>val</span> <span class=py>diffCallback</span> <span class=p>=</span> <span class=n>MyDiffCallback</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=k>val</span> <span class=py>diffResult</span> <span class=p>=</span> <span class=nc>DiffUtil</span><span class=p>.</span><span class=n>calculateDiff</span><span class=p>(</span><span class=n>diffCallback</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>diffResult</span><span class=p>.</span><span class=n>dispatchUpdatesTo</span><span class=p>(</span><span class=n>myAdapter</span><span class=p>)</span>
</span></span></code></pre></td></tr></table></div></div></li><li><p><strong>Adapter 업데이트:</strong> <code>DiffResult</code> 객체의 <code>dispatchUpdatesTo()</code> 메서드를 호출하여 RecyclerView의 Adapter에 변경 사항을 알립니다.</p></li></ol><p><strong>ListAdapter 사용 시 주의 사항:</strong></p><ul><li><p>DiffUtil.ItemCallback을 정확하게 구현해야 합니다. 아이템의 동일성과 내용 변경을 정확하게 판단하지 못하면 업데이트가 제대로 이루어지지 않을 수 있습니다.</p><ul><li><p><code>areItemsTheSame()</code> 함수가 먼저 실행이 되고 해당 함수의 결과로 true 가 반환됐을 경우에만, <code>areContentsTheSame()</code> 이 호출됩니다.</p></li><li><p>그렇기 때문에 <code>areItemsTheSame()</code> 에는 <strong>id 처럼 아이템을 식별할 수 있는 유니크한 값을 비교</strong>하고,</p></li><li><p><code>areContentsTheSame()</code> 에는 <strong>아이템의 내부 정보가 모두 동일</strong>한지 비교합니다.</p></li></ul></li><li><p><code>submitList()</code> 메서드 호출 시 이전 목록과 새 목록을 비교하는 데 시간이 소요될 수 있습니다. 따라서 너무 자주 호출하지 않도록 주의해야 합니다.</p></li><li><p>ListAdapter는 RecyclerView.Adapter의 모든 기능을 지원하지 않을 수 있습니다. 필요한 기능이 있는지 확인하고, 필요하다면 직접 구현해야 합니다.</p></li></ul></div><footer class=post-footer><ul class=post-tags><li><a href=https://2taezeat.github.io/tags/android/>Android</a></li></ul><nav class=paginav><a class=prev href=https://2taezeat.github.io/posts/android/jetpack-navigation/><span class=title>« Prev</span><br><span>Jetpack Navigation 기초</span>
</a><a class=next href=https://2taezeat.github.io/posts/android/android-testing-%EC%A0%95%EB%A6%AC/><span class=title>Next »</span><br><span>Android Testing 기초</span></a></nav><ul class=share-buttons><li><a target=_blank rel="noopener noreferrer" aria-label="share Android View 기초 on x" href="https://x.com/intent/tweet/?text=Android%20View%20%ea%b8%b0%ec%b4%88&amp;url=https%3a%2f%2f2taezeat.github.io%2fposts%2fandroid%2fandroid-view%2f&amp;hashtags=Android"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446C483.971.0 512 28.03 512 62.554zM269.951 190.75 182.567 75.216H56L207.216 272.95 63.9 436.783h61.366L235.9 310.383l96.667 126.4H456L298.367 228.367l134-153.151H371.033zM127.633 110h36.468l219.38 290.065H349.5z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Android View 기초 on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2f2taezeat.github.io%2fposts%2fandroid%2fandroid-view%2f&amp;title=Android%20View%20%ea%b8%b0%ec%b4%88&amp;summary=Android%20View%20%ea%b8%b0%ec%b4%88&amp;source=https%3a%2f%2f2taezeat.github.io%2fposts%2fandroid%2fandroid-view%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Android View 기초 on reddit" href="https://reddit.com/submit?url=https%3a%2f%2f2taezeat.github.io%2fposts%2fandroid%2fandroid-view%2f&title=Android%20View%20%ea%b8%b0%ec%b4%88"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Android View 기초 on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2f2taezeat.github.io%2fposts%2fandroid%2fandroid-view%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Android View 기초 on whatsapp" href="https://api.whatsapp.com/send?text=Android%20View%20%ea%b8%b0%ec%b4%88%20-%20https%3a%2f%2f2taezeat.github.io%2fposts%2fandroid%2fandroid-view%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Android View 기초 on telegram" href="https://telegram.me/share/url?text=Android%20View%20%ea%b8%b0%ec%b4%88&amp;url=https%3a%2f%2f2taezeat.github.io%2fposts%2fandroid%2fandroid-view%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentcolor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Android View 기초 on ycombinator" href="https://news.ycombinator.com/submitlink?t=Android%20View%20%ea%b8%b0%ec%b4%88&u=https%3a%2f%2f2taezeat.github.io%2fposts%2fandroid%2fandroid-view%2f"><svg width="30" height="30" viewBox="0 0 512 512" fill="currentcolor" xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"><path d="M449.446.0C483.971.0 512 28.03 512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446zM183.8767 87.9921h-62.034L230.6673 292.4508V424.0079h50.6655V292.4508L390.1575 87.9921H328.1233L256 238.2489z"/></svg></a></li></ul></footer><script src=https://utteranc.es/client.js repo=2taezeat/blog_comment issue-term=pathname label=comment theme=github-light crossorigin=anonymous async></script></article></main><footer class=footer><span>&copy; 2024 <a href=https://2taezeat.github.io/>2taezeat, blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>