<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>[컴퓨터구조 + 운영체제] ch11. CPU 스케쥴링 | 2taezeat, blog</title>
<meta name=keywords content="OS,CS"><meta name=description content="'혼자 공부하는 컴퓨터구조+운영체제', ch11. CPU 스케쥴링"><meta name=author content="2taezeat"><link rel=canonical href=https://2taezeat.github.io/posts/os/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0-+-%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C-ch11.-cpu-%EC%8A%A4%EC%BC%80%EC%A5%B4%EB%A7%81/><meta name=google-site-verification content="YaEERzgrvu-ZwPg7gswZdTzRMufkHw3uIH7i8hVal1c"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.9d319fd17dcb71a3a4f47e635bf2dac252103f703806e3ed7033472975765287.css integrity="sha256-nTGf0X3LcaOk9H5jW/LawlIQP3A4BuPtcDNHKXV2Uoc=" rel="preload stylesheet" as=style><link rel=icon href=https://2taezeat.github.io/icon/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://2taezeat.github.io/icon/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://2taezeat.github.io/icon/favicon-32x32.png><link rel=apple-touch-icon href=https://2taezeat.github.io/icon/apple-touch-icon.png><link rel=mask-icon href=https://2taezeat.github.io/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://2taezeat.github.io/posts/os/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0-+-%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C-ch11.-cpu-%EC%8A%A4%EC%BC%80%EC%A5%B4%EB%A7%81/><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><meta property="og:title" content="[컴퓨터구조 + 운영체제] ch11. CPU 스케쥴링"><meta property="og:description" content="'혼자 공부하는 컴퓨터구조+운영체제', ch11. CPU 스케쥴링"><meta property="og:type" content="article"><meta property="og:url" content="https://2taezeat.github.io/posts/os/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0-+-%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C-ch11.-cpu-%EC%8A%A4%EC%BC%80%EC%A5%B4%EB%A7%81/"><meta property="og:image" content="https://2taezeat.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-04-03T11:30:03+00:00"><meta property="article:modified_time" content="2024-04-03T11:30:03+00:00"><meta property="og:site_name" content="2taezeat, blog"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://2taezeat.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="[컴퓨터구조 + 운영체제] ch11. CPU 스케쥴링"><meta name=twitter:description content="'혼자 공부하는 컴퓨터구조+운영체제', ch11. CPU 스케쥴링"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://2taezeat.github.io/posts/"},{"@type":"ListItem","position":2,"name":"[컴퓨터구조 + 운영체제] ch11. CPU 스케쥴링","item":"https://2taezeat.github.io/posts/os/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0-+-%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C-ch11.-cpu-%EC%8A%A4%EC%BC%80%EC%A5%B4%EB%A7%81/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"[컴퓨터구조 + 운영체제] ch11. CPU 스케쥴링","name":"[컴퓨터구조 \u002b 운영체제] ch11. CPU 스케쥴링","description":"'혼자 공부하는 컴퓨터구조+운영체제', ch11. CPU 스케쥴링","keywords":["OS","CS"],"articleBody":"11.1 CPU 스케쥴링 개요 CPU 스케쥴링: 운영체제가 프로세스들에게 공정하고 합리적으로 CPU 자원을 배분 하는 것 11.1.1 프로세스 우선순위 프로세스들에게 공정하게 CPU를 배분하려면 어떻게 해야 할까?\n프로세스마다 우선순위가 다 다르다.\n우선순위가 높은 프로세스: 빨리 처리해야 하는 프로세스\n우선순위가 높은 프로세스에는 대표적은 I/O가 많은 프로세스\n대부분의 프로세스는 CPU와 입출력장치를 모두 사용하며 실행\nrunning(실행) 상태와 대기(waiting) 상태를 반복하며 실행 프로세스 종류마다 입출력장치를 이용하는 시간과 CPU를 이용하는 시간의 양에는 차이가 존재\nI/O bound process 입출력 집중 프로세스\n비디오 재생이나 디스크 백업 작업을 담당하는 프로세스와 같이 입출력 작업이 많은 프로세스 실행 상태보다는 입출력을 위한 대기 상태에 더 많이 머무르게 됩니다. I/O burst가 많은 프로세스 I/O burst: 입출력장치를 기다리는 작업 CPU bound process CPU 집중 프로세스\n복잡한 수학 연산, 컴파일, 그래픽 처리 작업을 담당하는 프로세스와 같이 CPU 작업이 많은 프로세스 반대로 CPU 집중 프로세스는 대기 상태보다는 실행 상태에 더 많이 머무름 CPU burst가 많은 프로레스 CPU burst: CPU를 이용하는 작업을 CPU 집중 프로세스와 입출력 집중 프로세스가 모두 동일한 빈도로 CPU를 사용하는 것은 비합리적\nCPU 집중 프로세스와 입출력 집중 프로세스가 동시에 CPU 자원을 요구했다고 가정\n입출력 집중 프로세스를 가능한 한 빨리 실행시켜 입출력장치를 끊임없이 작동시키고 그 다음 CPU 집중 프로세스에 집중적으로 CPU를 할당하는 것이 더 효율적 입출력장치가 입출력 작업을 완료하기 전까지는, 입출력 집중 프로세스는 어차피 대기 상태가 될 예정이기 때문에 입출력 집중 프로세스를 얼른 먼저 처리해 버리면 다른 프로세스가 CPU를 사용할 수 있기 때문입니다. I/O bound process의 대기 시간을 줄이자 모든 프로세스가 CPU를 차례대로 돌아가며 사용하는 것보다, 각각의 상황에 맞게 CPU를 배분하는 것이 더 효율적\n상황에 맞게, 중요도에 맞게 CPU를 이용할 수 있도록 하기 위해 운영체제는 프로세스마다 우선순위 priority를 부여\n운영체제는 각 프로세스의 PCB에 우선순위를 명시, PCB에 적힌 우선순위를 기준으로 먼저 처리할 프로세스를 결정\n우선순위가 높은 프로세스는 더 빨리, 더 자주 실행 11.1.2 스케쥴링 큐 운영체제가 매번 일일이 모든 PCB를 검사하여, 먼저 자원을 이용할 프로세스를 결정하는일은 매우 비효율적\n그래서 운영체제는 프로세스들에 ‘줄을 서서 기다릴 것‘을 요구\nCPU를 사용하고 싶은 프로세스들 메모리에 적재되고 싶은 프로세스들 특정 입출력장치를 사용하고 싶은 프로세스들 이 프로세스들을 모두 줄세움 운영체제는 이 줄을 스케줄링 큐; scheduing queue로 구현하고 관리, 큐에 삽입하여 줄을 세움\n큐는 선입선출(First In First Out) 자료 구조이지만, 스케줄링에서 이야기하는 큐는 반드시 선입선출 방식일 필요는 없다.\n운영체제가 관리하는 대부분의 자원은 이렇듯 큐로 관리\n운영체제가 관리하는 줄(큐)에는 다양한 종류가 존재 준비 큐; ready queue는 CPU를 이용하고 싶은 프로세스들이 서는 줄을 의미\n대기 큐; wating queue는 입출력장치를 이용하기 위해 대기 상태에 접어든 프로세스들이 서는 줄을 의미\n운영체제는 PCB들이 큐에 삽입된 순서대로 프로세스를 하나씩 실행하되, 그중 우선순위가 높은 프로세스를 먼저 실행\n우선순위가 낮은 프로세스들이 먼저 큐에 삽입되어도, 우선순위가 높은 프로세스는 그들보다 먼저 처리될 수 있다.\n이런 점에서 봤을 때 높은 우선순위를 가진 프로세스는 마치 VIP와도 같다. 입출력이 완료되어, 완료 인터럽트가 발생하면 운영체제는 대기 큐에서 작업이 완료된 PCB를 찾고\n이 PCB를 준비 상태로 변경한 뒤 대기 큐에서 제거합니다. 당연히 해당 PCB는 준비 큐로 이동합니다.\n11.1.3 선점형과 비선점형 스케쥴링 선점형 preemptive 스케쥴링\n프로세스가 CPU를 비롯한 자원을 사용하고 있더라도, 운영체제가 프로세스로부터 자원을 강제로 빼앗아 다른 프로세스에 할당할 수 있는 스케줄링 방식\n어느 하나의 프로세스가 자원 사용을 ‘독점할 수 없는’ 스케줄링 방식\n프로세스마다 정해진 시간만큼 CPU를 사용하고, 정해진 시간을 모두 소비하여 타이머 인터럽트가 발생하면,\n운영체제가 해당 프로세스로부터 CPU 자원을 빼앗아 다음 프로세스에 할당하는 방식\n현재 대부분의 운영체제가 사용\n장점: 더 급한 프로세스가 언제든 끼어들어 사용할 수 있는 방식이므로 자원 독점을 막고 프로세스들에 골고루 자원을 배분 가능\n단점: 문맥 교환 과정에서 오버헤드가 발생\n비선점형 non-prremptive 스케쥴링\n하나의 프로세스가 자원을 사용하고 있다면 그 프로세스가 종료되거나 스스로 대기 상태에 접어들기 전까진, 다른 프로세스가 끼어들 수 없는 스케줄링 방식 하나의 프로세스가 자원 사용을 독점할 수 있는 스케줄링 방식 만약 비선점형 스케줄링 방식으로 자원을 이용하는 프로세스가 있다면 다른 프로세스들은 그 프로세스의 사용이 모두 끝날 때까지 기다려야 한다. 장점: 문맥 교환의 횟수가 선점형 스케줄링보다 적기 때문에 문맥 교환에서 발생 하는 오버헤드가 적다 단점: 하나의 프로세스가 자원을 사용 중이라면 당장 자원을 사용해야 하는 상황에서도 무작정 기다려야만 한다. (기아 현상) 모든 프로세스가 골고루 자원을 사용할 수 없다 11.2 CPU 스케쥴링 알고리즘 11.2.1 스케쥴링 알고리즘의 종류 FCFS 스케쥴링\nFCFS; First Come First Served Scheduling, 선입 선처리 준비 큐에 삽입된 순서대로 프로세스들을 처리하는 비선점형 스케쥴링 프로세스들이 기다리는 시간이 매우 길어질 수 있다 호위 효과 convoy effect 발생 앞선 프로세스가 실행시간이 길다면 실행시간이 짧은 프로세스들이 실행되지 못해 마치 부하처럼 뒤따라서 기다리고 있다는 것을 가리키는 효과이다. SJF 스케쥴링\nShortest Job First, 최단 작업 우선 호위 효과 방지 준비 큐에 삽입된 프로세스들 중 CPU 이용 시간의 길이(CPU burst) 가 가장 짧은 프로세스부터 실행 비선점형 스케쥴링으로 분류 되지만, 선점형으로 구현될 수 도 있다. 선점형 SJF가 ‘최소 잔여 시간 우선 스케쥴링(SRT)’ 이다. SJF가 가장 효율적인 CPU 스케줄링 방법 같지만, 비현실적이다. 왜냐하면 프로세스의 CPU 점유 시간(Burst time) 을 알 수 없다. 한 프로세스가 실행 중에는 많은 변수가 존재하기에, CPU 점유 시간을 알려면 실제로 수행하여 측정하는 수밖에 없다. 실제 측정한 시간으로 예측하여 SJF를 사용할 수도 있지만, 이는 오버헤드가 매우 큰 작업으로 잘 사용되지 않는다. ​\nRound Robin 스케쥴링\nFCFS에 타임 슬라이스(Time Quantum, Time Slice) 라는 개념이 더해진 방식 타임 슬라이스란 각 프로세스가 CPU를 사용할 수 있는 정해진 시간을 의미 정해진 타임 슬라이스만큼의 시간 동안 돌아가며 CPU를 이용하는 선점형 스케줄링 타임 슬라이스 크기가 매우 중요 타임 슬라이스가 크면 사실상 선입 선처리 스케줄링과 다를 바 없어 호위 효과가 생길 여지가 있고, 타임 슬라이스가 작으면 문맥 교환에 발생하는 비용이 커 CPU는 프로세스를 처리하는 일보다 프로세스를 전환하는 데에 온 힘을 다 쓸 여지가 있기 때문 시분할 시스템의 성질을 활용한 방법 SRT 스케쥴링\n최소 잔여 시간 우선 스케쥴링\n프로세스들은 정해진 타임 슬라이스만큼 CPU를 사용하되, 다음 프로세스로는 남아있는 작업 시간이 가장 적은 프로세스가 선택됨.\nSJF, Round Robin 을 합친 방식 우선순위 스케쥴링\n프로세스들에 우선순위를 부여하고, 가장 높은 우선순위를 가진 프로세스부터 실행 SJF, SRT 모두 우선순위 스케쥴링의 일종으로 볼 수 있다. 기아 현상, 근본적인 문제 우선순위가 높은 프로세스들에 의해 실행이 계속되어 연기됨 이를 방지하기 위한 대표적인 기법으로 에이징; aging이 있다. 오랫동안 대기한 프로세스의 우선순위를 점차 높이는 방식입니다. 말하자면 대기 중인 프로세스의 우선순위를 마치 나이 먹듯 점차 증가시키는 방법 Multi-level Queue 스케쥴링\n다단계 큐 스케쥴링 우선순위별로 준비 큐를 여러 개 사용하는 스케쥴링 프로세스들이 큐 사이를 이동할 수 없다. 기아 현상이 발생 할 수 있다. 이렇게 큐를 여러 개 두면 프로세스 유형별로 우선순위를 구분하여 실행하는 것이 편리해집니다. 가령 어떤 큐에는 우선순위가 비교적 높아야 하는 I/O bound 프로세스가 삽입될 수 있고, 어떤 큐에는 우선순위가 비교적 낮아도 상관없는 CPU bound 프로세스가 삽입될 수 있다. 또 어떤 큐에는 (우선순위가 비교적 높아야 하는) 백그라운드 프로세스들을 삽입할 수 있고, 어떤 큐에는 (우선순위가 비교적 낮아도 무방한) 사용자와의 상호작용이 잦은 프로세스들을 삽입할 수 있다. 큐별로 타임 슬라이스를 여러 개 지정할 수도 있고, 큐마다 다른 스케줄링 알고리즘을 사용할수도 있다. Multilevel Feedback Queue 스케쥴링\n다단계 피드백 큐 스케줄링 다단계 큐 스케쥴링의 발전된 형태 구현 복잡하지만, 가장 일반적인 CPU 스케쥴링 알고리즘 동작 방식 다단계 피드백 큐 스케줄링에서 새로 준비 상태가 된 프로세스가 있다면 우선순위가 가장 높은 우선순위 큐에 삽입되고 타임 슬라이스 동안 실행 만약 새로운 프로세스가 해당 큐에서 실행이 끝나지 않는다면 다음 우선순위 큐에 삽입되어 실행 그리고 또 해당 큐에서 실행이 끝나지 않는다면 프로세스는 또 다음 우선순위 큐에 삽입되고, 결국 CPU를 오래 사용해야 하는 프로세스는 점차 우선순위가 낮아짐 프로세스들이 큐 사이를 이동할 수 있다 낮은 우선순위 큐에서 너무 오래 기다리고 있는 프로세스가 있다면 에이징 기법을 적용하여 기아 현상을 예방 ​\tReference 혼자 공부하는 컴퓨터구조+운영체제 (강민철, 한빛미디어) https://product.kyobobook.co.kr/detail/S000061584886 ","wordCount":"1142","inLanguage":"en","image":"https://2taezeat.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E","datePublished":"2024-04-03T11:30:03Z","dateModified":"2024-04-03T11:30:03Z","author":{"@type":"Person","name":"2taezeat"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://2taezeat.github.io/posts/os/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0-+-%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C-ch11.-cpu-%EC%8A%A4%EC%BC%80%EC%A5%B4%EB%A7%81/"},"publisher":{"@type":"Organization","name":"2taezeat, blog","logo":{"@type":"ImageObject","url":"https://2taezeat.github.io/icon/favicon.ico"}}}</script></head><body id=top><header class=header><nav class=nav><div class=logo><a href=https://2taezeat.github.io/ accesskey=h title="2taezeat blog (Alt + H)"><img src=https://2taezeat.github.io/icon/apple-touch-icon.png alt aria-label=logo height=30>2taezeat blog</a><div class=logo-switches></div></div><ul id=menu><li><a href=https://2taezeat.github.io/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://2taezeat.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://2taezeat.github.io/searchs/ title=Search><span>Search</span></a></li><li><a href=https://github.com/2taezeat title=Github><span>Github</span>&nbsp;<svg fill="none" shape-rendering="geometricPrecision" stroke="currentcolor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2.5" viewBox="0 0 24 24" height="12" width="12"><path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"/><path d="M15 3h6v6"/><path d="M10 14 21 3"/></svg></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://2taezeat.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://2taezeat.github.io/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">[컴퓨터구조 + 운영체제] ch11. CPU 스케쥴링</h1><div class=post-description>'혼자 공부하는 컴퓨터구조+운영체제', ch11. CPU 스케쥴링</div><div class=post-meta><span title='2024-04-03 11:30:03 +0000 +0000'>2024-04-03</span>&nbsp;·&nbsp;6 min&nbsp;·&nbsp;1142 words&nbsp;·&nbsp;2taezeat</div></header><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#111-cpu-스케쥴링-개요>11.1 CPU 스케쥴링 개요</a><ul><li><a href=#1111-프로세스-우선순위>11.1.1 프로세스 우선순위</a></li><li><a href=#1112-스케쥴링-큐>11.1.2 스케쥴링 큐</a></li><li><a href=#1113-선점형과-비선점형-스케쥴링>11.1.3 선점형과 비선점형 스케쥴링</a></li></ul></li><li><a href=#112-cpu-스케쥴링-알고리즘>11.2 CPU 스케쥴링 알고리즘</a><ul><li><a href=#1121-스케쥴링-알고리즘의-종류>11.2.1 스케쥴링 알고리즘의 종류</a></li></ul></li><li><a href=#reference>Reference</a></li></ul></nav></div></details></div><div class=post-content><h1 id=111-cpu-스케쥴링-개요>11.1 CPU 스케쥴링 개요<a hidden class=anchor aria-hidden=true href=#111-cpu-스케쥴링-개요>#</a></h1><ul><li><strong>CPU 스케쥴링</strong>: 운영체제가 프로세스들에게 공정하고 합리적으로 <strong>CPU 자원을 배분</strong> 하는 것</li></ul><h2 id=1111-프로세스-우선순위>11.1.1 프로세스 우선순위<a hidden class=anchor aria-hidden=true href=#1111-프로세스-우선순위>#</a></h2><ul><li><p>프로세스들에게 공정하게 CPU를 배분하려면 어떻게 해야 할까?</p></li><li><p>프로세스마다 우선순위가 다 다르다.</p></li><li><p>우선순위가 높은 프로세스: 빨리 처리해야 하는 프로세스</p></li><li><p>우선순위가 높은 프로세스에는 대표적은 I/O가 많은 프로세스</p></li><li><p>대부분의 프로세스는 CPU와 입출력장치를 모두 사용하며 실행</p><ul><li><strong>running(실행) 상태와 대기(waiting) 상태</strong>를 반복하며 실행</li></ul></li></ul><p><img loading=lazy src=/images/before/image-20240430231608352.png alt=image-20240430231608352.png width=680 height=auto></p><ul><li><p>프로세스 종류마다 입출력장치를 이용하는 시간과 CPU를 이용하는 시간의 양에는 차이가 존재</p></li><li><p><strong>I/O bound process 입출력 집중 프로세스</strong></p><ul><li>비디오 재생이나 디스크 백업 작업을 담당하는 프로세스와 같이 입출력 작업이 많은 프로세스</li><li>실행 상태보다는 입출력을 위한 <strong>대기 상태</strong>에 더 많이 머무르게 됩니다.</li><li>I/O burst가 많은 프로세스<ul><li><strong>I/O burst</strong>: 입출력장치를 기다리는 작업</li></ul></li></ul></li><li><p><strong>CPU bound process CPU 집중 프로세스</strong></p><ul><li>복잡한 수학 연산, 컴파일, 그래픽 처리 작업을 담당하는 프로세스와 같이 CPU 작업이 많은 프로세스</li><li>반대로 CPU 집중 프로세스는 대기 상태보다는 <strong>실행 상태</strong>에 더 많이 머무름</li><li>CPU burst가 많은 프로레스<ul><li><strong>CPU burst:</strong> CPU를 이용하는 작업을</li></ul></li></ul></li><li><p>CPU 집중 프로세스와 입출력 집중 프로세스가 <strong>모두 동일한 빈도로 CPU를 사용하는 것은 비합리적</strong></p></li><li><p>CPU 집중 프로세스와 입출력 집중 프로세스가 동시에 CPU 자원을 요구했다고 가정</p><ul><li>입출력 집중 프로세스를 <strong>가능한 한 빨리 실행시켜 입출력장치를 끊임없이 작동시키고</strong></li><li>그 다음 CPU 집중 프로세스에 집중적으로 CPU를 할당하는 것이 더 효율적</li><li>입출력장치가 입출력 작업을 완료하기 전까지는, <strong>입출력 집중 프로세스</strong>는 어차피 <strong>대기 상태</strong>가 될 예정이기 때문에</li><li>입출력 집중 프로세스를 <strong>얼른 먼저 처리해 버리면 다른 프로세스가 CPU를 사용</strong>할 수 있기 때문입니다.</li><li><strong>I/O bound process</strong>의 <strong>대기 시간</strong>을 줄이자</li></ul></li><li><p>모든 프로세스가 CPU를 차례대로 돌아가며 사용하는 것보다, <strong>각각의 상황에 맞게 CPU를 배분하는 것이 더 효율적</strong></p></li><li><p>상황에 맞게, 중요도에 맞게 CPU를 이용할 수 있도록 하기 위해 운영체제는 프로세스마다 <strong>우선순위 priority</strong>를 부여</p></li><li><p>운영체제는 각 프로세스의 <strong>PCB에 우선순위를 명시</strong>, PCB에 적힌 <strong>우선순위를 기준으로 먼저 처리할 프로세스를 결정</strong></p><ul><li>우선순위가 높은 프로세스는 더 빨리, 더 자주 실행</li></ul></li></ul><p><img loading=lazy src=/images/before/image-20240430232940909.png alt=image-20240430232940909.png width=680 height=auto></p><h2 id=1112-스케쥴링-큐>11.1.2 스케쥴링 큐<a hidden class=anchor aria-hidden=true href=#1112-스케쥴링-큐>#</a></h2><ul><li><p>운영체제가 매번 일일이 모든 PCB를 검사하여, 먼저 자원을 이용할 프로세스를 결정하는일은 매우 비효율적</p></li><li><p>그래서 운영체제는 프로세스들에 &lsquo;<strong>줄을 서서 기다릴 것</strong>&lsquo;을 요구</p><ul><li><strong>CPU</strong>를 사용하고 싶은 프로세스들</li><li><strong>메모리</strong>에 적재되고 싶은 프로세스들</li><li>특정 <strong>입출력장치</strong>를 사용하고 싶은 프로세스들</li><li>이 프로세스들을 모두 줄세움</li></ul></li><li><p>운영체제는 이 줄을 <strong>스케줄링 큐; scheduing queue</strong>로 구현하고 관리, 큐에 삽입하여 줄을 세움</p></li></ul><blockquote><p>큐는 선입선출(First In First Out) 자료 구조이지만, <strong>스케줄링에서 이야기하는 큐</strong>는 반드시 선입선출 방식일 필요는 없다.</p></blockquote><p><img loading=lazy src=/images/before/image-20240430233540998.png alt=image-20240430233540998.png width=680 height=auto></p><ul><li><p>운영체제가 관리하는 대부분의 자원은 이렇듯 큐로 관리</p><ul><li>운영체제가 관리하는 줄(큐)에는 다양한 종류가 존재</li></ul></li><li><p><strong>준비 큐; ready queue</strong>는 <strong>CPU</strong>를 이용하고 싶은 프로세스들이 서는 줄을 의미</p></li><li><p><strong>대기 큐; wating queue</strong>는 <strong>입출력장치</strong>를 이용하기 위해 <strong>대기 상태</strong>에 접어든 프로세스들이 서는 줄을 의미</p></li></ul><p><img loading=lazy src=/images/before/SCR-20240430-uiso.png alt=SCR-20240430-uiso.png width=680 height=auto></p><ul><li><p>운영체제는 PCB들이 큐에 삽입된 순서대로 프로세스를 하나씩 실행하되, 그중 우선순위가 높은 프로세스를 먼저 실행</p></li><li><p>우선순위가 낮은 프로세스들이 먼저 큐에 삽입되어도, 우선순위가 높은 프로세스는 그들보다 먼저 처리될 수 있다.</p><ul><li>이런 점에서 봤을 때 높은 우선순위를 가진 프로세스는 마치 VIP와도 같다.</li></ul></li><li><p>입출력이 완료되어, 완료 인터럽트가 발생하면 운영체제는 <strong>대기 큐</strong>에서 작업이 완료된 PCB를 찾고</p></li><li><p>이 PCB를 <strong>준비 상태</strong>로 변경한 뒤 <strong>대기 큐에서 제거</strong>합니다. 당연히 해당 PCB는 <strong>준비 큐</strong>로 이동합니다.</p></li></ul><p><img loading=lazy src=/images/before/image-20240430234233711.png alt=image-20240430234233711.png width=680 height=auto></p><p><img loading=lazy src=/images/before/image-20240430234254462.png alt=image-20240430234254462.png width=680 height=auto></p><h2 id=1113-선점형과-비선점형-스케쥴링>11.1.3 선점형과 비선점형 스케쥴링<a hidden class=anchor aria-hidden=true href=#1113-선점형과-비선점형-스케쥴링>#</a></h2><ul><li><p><strong>선점형 preemptive 스케쥴링</strong></p><ul><li><p>프로세스가 CPU를 비롯한 자원을 사용하고 있더라도, <strong>운영체제가 프로세스로부터 자원을 강제로 빼앗아</strong> 다른 프로세스에 할당할 수 있는 스케줄링 방식</p></li><li><p>어느 하나의 프로세스가 자원 사용을 <strong>&lsquo;독점할 수 없는&rsquo;</strong> 스케줄링 방식</p></li><li><p>프로세스마다 정해진 시간만큼 CPU를 사용하고, 정해진 시간을 모두 소비하여 <strong>타이머 인터럽트</strong>가 발생하면,</p></li><li><p>운영체제가 해당 프로세스로부터 CPU 자원을 빼앗아 다음 프로세스에 할당하는 방식</p></li><li><p>현재 대부분의 운영체제가 사용</p></li><li><p><strong>장점</strong>: 더 급한 프로세스가 언제든 끼어들어 사용할 수 있는 방식이므로 <strong>자원 독점을 막고 프로세스들에 골고루 자원을 배분 가능</strong></p></li><li><p><strong>단점</strong>: 문맥 교환 과정에서 오버헤드가 발생</p></li></ul></li><li><p><strong>비선점형 non-prremptive 스케쥴링</strong></p><ul><li>하나의 프로세스가 자원을 사용하고 있다면 그 프로세스가 종료되거나 <strong>스스로 대기 상태</strong>에 접어들기 전까진, <strong>다른 프로세스가 끼어들 수 없는 스케줄링 방식</strong></li><li>하나의 프로세스가 자원 사용을 <strong>독점할 수 있는</strong> 스케줄링 방식</li><li>만약 비선점형 스케줄링 방식으로 자원을 이용하는 프로세스가 있다면 다른 프로세스들은 그 프로세스의 사용이 모두 끝날 때까지 기다려야 한다.</li><li><strong>장점</strong>: 문맥 교환의 횟수가 선점형 스케줄링보다 적기 때문에 <strong>문맥 교환에서 발생 하는 오버헤드가 적다</strong></li><li><strong>단점:</strong> 하나의 프로세스가 자원을 사용 중이라면 당장 자원을 사용해야 하는 상황에서도 무작정 기다려야만 한다. (기아 현상)<ul><li>모든 프로세스가 골고루 자원을 사용할 수 없다</li></ul></li></ul></li></ul><h1 id=112-cpu-스케쥴링-알고리즘>11.2 CPU 스케쥴링 알고리즘<a hidden class=anchor aria-hidden=true href=#112-cpu-스케쥴링-알고리즘>#</a></h1><h2 id=1121-스케쥴링-알고리즘의-종류>11.2.1 스케쥴링 알고리즘의 종류<a hidden class=anchor aria-hidden=true href=#1121-스케쥴링-알고리즘의-종류>#</a></h2><ul><li><p><strong>FCFS 스케쥴링</strong></p><p><img loading=lazy src=/images/before/image-20240430235442963.png alt=image-20240430235442963.png width=680 height=auto></p><ul><li><strong>FCFS; First Come First Served Scheduling, 선입 선처리</strong></li><li>준비 큐에 삽입된 순서대로 프로세스들을 처리하는 <strong>비선점형 스케쥴링</strong></li><li>프로세스들이 기다리는 시간이 매우 길어질 수 있다</li><li><strong>호위 효과 convoy effect</strong> 발생<ul><li>앞선 프로세스가 실행시간이 길다면 실행시간이 짧은 프로세스들이 실행되지 못해 <strong>마치 부하처럼 뒤따라서 기다리고</strong> 있다는 것을 가리키는 효과이다.</li></ul></li></ul></li><li><p><strong>SJF 스케쥴링</strong></p><p><img loading=lazy src=/images/before/image-20240430235831179.png alt=image-20240430235831179.png width=680 height=auto></p><ul><li><strong>Shortest Job First</strong>, <strong>최단 작업 우선</strong></li><li><strong>호위 효과</strong> 방지</li><li>준비 큐에 삽입된 프로세스들 중 <strong>CPU 이용 시간의 길이(CPU burst)</strong> 가 가장 짧은 프로세스부터 실행</li><li><strong>비선점형 스케쥴링</strong>으로 분류 되지만, <strong>선점형</strong>으로 구현될 수 도 있다.<ul><li>선점형 SJF가 <strong>&lsquo;최소 잔여 시간 우선 스케쥴링(SRT)&rsquo;</strong> 이다.</li></ul></li><li>SJF가 가장 효율적인 CPU 스케줄링 방법 같지만, <strong>비현실적</strong>이다.<ul><li>왜냐하면 프로세스의 <strong>CPU 점유 시간(Burst time)</strong> 을 <strong>알 수 없다.</strong></li><li>한 프로세스가 실행 중에는 많은 변수가 존재하기에, <strong>CPU 점유 시간</strong>을 알려면 <strong>실제로 수행하여 측정</strong>하는 수밖에 없다.</li><li>실제 측정한 시간으로 예측하여 SJF를 사용할 수도 있지만, 이는 <strong>오버헤드가 매우 큰 작업</strong>으로 잘 사용되지 않는다.</li></ul></li></ul></li></ul><p>​</p><ul><li><p><strong>Round Robin 스케쥴링</strong></p><p><img loading=lazy src=/images/before/image-20240501000732727.png alt=image-20240501000732727.png width=680 height=auto></p><ul><li><strong>FCFS</strong>에 <strong>타임 슬라이스(Time Quantum, Time Slice)</strong> 라는 개념이 더해진 방식</li><li>타임 슬라이스란 각 프로세스가 CPU를 사용할 수 있는 정해진 시간을 의미</li><li>정해진 타임 슬라이스만큼의 시간 동안 돌아가며 CPU를 이용하는 <strong>선점형 스케줄링</strong></li><li>타임 슬라이스 크기가 매우 중요<ul><li>타임 슬라이스가 크면 사실상 <strong>선입 선처리 스케줄링</strong>과 다를 바 없어 <strong>호위 효과</strong>가 생길 여지가 있고,</li><li>타임 슬라이스가 작으면 <strong>문맥 교환에 발생하는 비용이 커</strong> CPU는 프로세스를 처리하는 일보다 프로세스를 전환하는 데에 온 힘을 다 쓸 여지가 있기 때문</li></ul></li><li>시분할 시스템의 성질을 활용한 방법</li></ul></li><li><p><strong>SRT 스케쥴링</strong></p><ul><li><p><strong>최소 잔여 시간 우선 스케쥴링</strong></p></li><li><p>프로세스들은 정해진 타임 슬라이스만큼 CPU를 사용하되, 다음 프로세스로는 남아있는 작업 시간이 가장 적은 프로세스가 선택됨.</p><ul><li><strong>SJF</strong>, <strong>Round Robin</strong> 을 합친 방식</li></ul></li></ul></li><li><p><strong>우선순위 스케쥴링</strong></p><p><img loading=lazy src=/images/before/image-20240501001658797.png alt=image-20240501001658797.png width=680 height=auto></p><ul><li>프로세스들에 우선순위를 부여하고, 가장 높은 우선순위를 가진 프로세스부터 실행</li><li>SJF, SRT 모두 우선순위 스케쥴링의 일종으로 볼 수 있다.</li><li><strong>기아 현상</strong>, 근본적인 문제<ul><li>우선순위가 높은 프로세스들에 의해 실행이 계속되어 연기됨</li></ul></li><li>이를 방지하기 위한 대표적인 기법으로 <strong>에이징; aging</strong>이 있다.<ul><li>오랫동안 대기한 프로세스의 우선순위를 점차 높이는 방식입니다.</li><li>말하자면 대기 중인 프로세스의 우선순위를 마치 나이 먹듯 점차 증가시키는 방법</li></ul></li></ul></li><li><p><strong>Multi-level Queue 스케쥴링</strong></p><p><img loading=lazy src=/images/before/image-20240501001808177.png alt=image-20240501001808177.png width=680 height=auto></p><ul><li><strong>다단계 큐 스케쥴링</strong></li><li><strong>우선순위별로 준비 큐</strong>를 여러 개 사용하는 스케쥴링</li><li>프로세스들이 큐 사이를 이동할 수 <strong>없다.</strong><ul><li>기아 현상이 발생 할 수 있다.</li></ul></li><li>이렇게 큐를 여러 개 두면 프로세스 유형별로 우선순위를 구분하여 실행하는 것이 편리해집니다.<ul><li>가령 어떤 큐에는 우선순위가 비교적 <strong>높아야</strong> 하는 <strong>I/O bound</strong> 프로세스가 삽입될 수 있고,</li><li>어떤 큐에는 우선순위가 비교적 <strong>낮아도</strong> 상관없는 <strong>CPU bound</strong> 프로세스가 삽입될 수 있다.</li><li>또 어떤 큐에는 <strong>(우선순위가 비교적 높아야 하는)</strong> <strong>백그라운드 프로세스</strong>들을 삽입할 수 있고,</li><li>어떤 큐에는 <strong>(우선순위가 비교적 낮아도 무방한</strong>) <strong>사용자와의 상호작용이 잦은 프로세스</strong>들을 삽입할 수 있다.</li><li>큐별로 타임 슬라이스를 여러 개 지정할 수도 있고, 큐마다 다른 스케줄링 알고리즘을 사용할수도 있다.</li></ul></li></ul></li><li><p><strong>Multilevel Feedback Queue 스케쥴링</strong></p><p><img loading=lazy src=/images/before/image-20240501003014161.png alt=image-20240501003014161.png width=680 height=auto></p><p><img loading=lazy src=/images/before/SCR-20240501-bjhd-2.png alt=SCR-20240501-bjhd-2.png width=680 height=auto></p><ul><li><strong>다단계 피드백 큐 스케줄링</strong></li><li><strong>다단계 큐 스케쥴링</strong>의 발전된 형태</li><li>구현 복잡하지만, 가장 일반적인 CPU 스케쥴링 알고리즘</li><li>동작 방식<ul><li>다단계 피드백 큐 스케줄링에서 새로 준비 상태가 된 프로세스가 있다면 우선순위가 가장 높은 우선순위 큐에 삽입되고 타임 슬라이스 동안 실행</li><li>만약 새로운 프로세스가 해당 큐에서 실행이 끝나지 않는다면 다음 우선순위 큐에 삽입되어 실행</li><li>그리고 또 해당 큐에서 실행이 끝나지 않는다면 프로세스는 또 다음 우선순위 큐에 삽입되고, 결국 CPU를 오래 사용해야 하는 프로세스는 점차 우선순위가 낮아짐</li></ul></li><li>프로세스들이 큐 사이를 이동할 수 있다<ul><li>낮은 우선순위 큐에서 너무 오래 기다리고 있는 프로세스가 있다면 <strong>에이징 기법</strong>을 적용하여 <strong>기아 현상을 예방</strong></li></ul></li></ul></li></ul><p>​ <img loading=lazy src=/images/before/SCR-20240501-bjmw-2.png alt=SCR-20240501-bjmw-2.png width=680 height=auto></p><h1 id=reference>Reference<a hidden class=anchor aria-hidden=true href=#reference>#</a></h1><ul><li>혼자 공부하는 컴퓨터구조+운영체제 (강민철, 한빛미디어) <a href=https://product.kyobobook.co.kr/detail/S000061584886>https://product.kyobobook.co.kr/detail/S000061584886</a></li></ul></div><footer class=post-footer><ul class=post-tags><li><a href=https://2taezeat.github.io/tags/os/>OS</a></li><li><a href=https://2taezeat.github.io/tags/cs/>CS</a></li></ul><nav class=paginav><a class=prev href=https://2taezeat.github.io/posts/os/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0-+-%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C-ch12.-%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4-%EB%8F%99%EA%B8%B0%ED%99%94/><span class=title>« Prev</span><br><span>[컴퓨터구조 + 운영체제] ch12. 프로세스 동기화</span>
</a><a class=next href=https://2taezeat.github.io/posts/os/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0-+-%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C-ch10.-%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4%EC%99%80-%EC%8A%A4%EB%A0%88%EB%93%9C/><span class=title>Next »</span><br><span>[컴퓨터구조 + 운영체제] ch10. 프로세스와 스레드</span></a></nav><ul class=share-buttons><li><a target=_blank rel="noopener noreferrer" aria-label="share [컴퓨터구조 + 운영체제] ch11. CPU 스케쥴링 on x" href="https://x.com/intent/tweet/?text=%5b%ec%bb%b4%ed%93%a8%ed%84%b0%ea%b5%ac%ec%a1%b0%20%2b%20%ec%9a%b4%ec%98%81%ec%b2%b4%ec%a0%9c%5d%20ch11.%20CPU%20%ec%8a%a4%ec%bc%80%ec%a5%b4%eb%a7%81&amp;url=https%3a%2f%2f2taezeat.github.io%2fposts%2fos%2f%25EC%25BB%25B4%25ED%2593%25A8%25ED%2584%25B0%25EA%25B5%25AC%25EC%25A1%25B0-%2b-%25EC%259A%25B4%25EC%2598%2581%25EC%25B2%25B4%25EC%25A0%259C-ch11.-cpu-%25EC%258A%25A4%25EC%25BC%2580%25EC%25A5%25B4%25EB%25A7%2581%2f&amp;hashtags=OS%2cCS"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446C483.971.0 512 28.03 512 62.554zM269.951 190.75 182.567 75.216H56L207.216 272.95 63.9 436.783h61.366L235.9 310.383l96.667 126.4H456L298.367 228.367l134-153.151H371.033zM127.633 110h36.468l219.38 290.065H349.5z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share [컴퓨터구조 + 운영체제] ch11. CPU 스케쥴링 on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2f2taezeat.github.io%2fposts%2fos%2f%25EC%25BB%25B4%25ED%2593%25A8%25ED%2584%25B0%25EA%25B5%25AC%25EC%25A1%25B0-%2b-%25EC%259A%25B4%25EC%2598%2581%25EC%25B2%25B4%25EC%25A0%259C-ch11.-cpu-%25EC%258A%25A4%25EC%25BC%2580%25EC%25A5%25B4%25EB%25A7%2581%2f&amp;title=%5b%ec%bb%b4%ed%93%a8%ed%84%b0%ea%b5%ac%ec%a1%b0%20%2b%20%ec%9a%b4%ec%98%81%ec%b2%b4%ec%a0%9c%5d%20ch11.%20CPU%20%ec%8a%a4%ec%bc%80%ec%a5%b4%eb%a7%81&amp;summary=%5b%ec%bb%b4%ed%93%a8%ed%84%b0%ea%b5%ac%ec%a1%b0%20%2b%20%ec%9a%b4%ec%98%81%ec%b2%b4%ec%a0%9c%5d%20ch11.%20CPU%20%ec%8a%a4%ec%bc%80%ec%a5%b4%eb%a7%81&amp;source=https%3a%2f%2f2taezeat.github.io%2fposts%2fos%2f%25EC%25BB%25B4%25ED%2593%25A8%25ED%2584%25B0%25EA%25B5%25AC%25EC%25A1%25B0-%2b-%25EC%259A%25B4%25EC%2598%2581%25EC%25B2%25B4%25EC%25A0%259C-ch11.-cpu-%25EC%258A%25A4%25EC%25BC%2580%25EC%25A5%25B4%25EB%25A7%2581%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share [컴퓨터구조 + 운영체제] ch11. CPU 스케쥴링 on reddit" href="https://reddit.com/submit?url=https%3a%2f%2f2taezeat.github.io%2fposts%2fos%2f%25EC%25BB%25B4%25ED%2593%25A8%25ED%2584%25B0%25EA%25B5%25AC%25EC%25A1%25B0-%2b-%25EC%259A%25B4%25EC%2598%2581%25EC%25B2%25B4%25EC%25A0%259C-ch11.-cpu-%25EC%258A%25A4%25EC%25BC%2580%25EC%25A5%25B4%25EB%25A7%2581%2f&title=%5b%ec%bb%b4%ed%93%a8%ed%84%b0%ea%b5%ac%ec%a1%b0%20%2b%20%ec%9a%b4%ec%98%81%ec%b2%b4%ec%a0%9c%5d%20ch11.%20CPU%20%ec%8a%a4%ec%bc%80%ec%a5%b4%eb%a7%81"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share [컴퓨터구조 + 운영체제] ch11. CPU 스케쥴링 on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2f2taezeat.github.io%2fposts%2fos%2f%25EC%25BB%25B4%25ED%2593%25A8%25ED%2584%25B0%25EA%25B5%25AC%25EC%25A1%25B0-%2b-%25EC%259A%25B4%25EC%2598%2581%25EC%25B2%25B4%25EC%25A0%259C-ch11.-cpu-%25EC%258A%25A4%25EC%25BC%2580%25EC%25A5%25B4%25EB%25A7%2581%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share [컴퓨터구조 + 운영체제] ch11. CPU 스케쥴링 on whatsapp" href="https://api.whatsapp.com/send?text=%5b%ec%bb%b4%ed%93%a8%ed%84%b0%ea%b5%ac%ec%a1%b0%20%2b%20%ec%9a%b4%ec%98%81%ec%b2%b4%ec%a0%9c%5d%20ch11.%20CPU%20%ec%8a%a4%ec%bc%80%ec%a5%b4%eb%a7%81%20-%20https%3a%2f%2f2taezeat.github.io%2fposts%2fos%2f%25EC%25BB%25B4%25ED%2593%25A8%25ED%2584%25B0%25EA%25B5%25AC%25EC%25A1%25B0-%2b-%25EC%259A%25B4%25EC%2598%2581%25EC%25B2%25B4%25EC%25A0%259C-ch11.-cpu-%25EC%258A%25A4%25EC%25BC%2580%25EC%25A5%25B4%25EB%25A7%2581%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share [컴퓨터구조 + 운영체제] ch11. CPU 스케쥴링 on telegram" href="https://telegram.me/share/url?text=%5b%ec%bb%b4%ed%93%a8%ed%84%b0%ea%b5%ac%ec%a1%b0%20%2b%20%ec%9a%b4%ec%98%81%ec%b2%b4%ec%a0%9c%5d%20ch11.%20CPU%20%ec%8a%a4%ec%bc%80%ec%a5%b4%eb%a7%81&amp;url=https%3a%2f%2f2taezeat.github.io%2fposts%2fos%2f%25EC%25BB%25B4%25ED%2593%25A8%25ED%2584%25B0%25EA%25B5%25AC%25EC%25A1%25B0-%2b-%25EC%259A%25B4%25EC%2598%2581%25EC%25B2%25B4%25EC%25A0%259C-ch11.-cpu-%25EC%258A%25A4%25EC%25BC%2580%25EC%25A5%25B4%25EB%25A7%2581%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentcolor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share [컴퓨터구조 + 운영체제] ch11. CPU 스케쥴링 on ycombinator" href="https://news.ycombinator.com/submitlink?t=%5b%ec%bb%b4%ed%93%a8%ed%84%b0%ea%b5%ac%ec%a1%b0%20%2b%20%ec%9a%b4%ec%98%81%ec%b2%b4%ec%a0%9c%5d%20ch11.%20CPU%20%ec%8a%a4%ec%bc%80%ec%a5%b4%eb%a7%81&u=https%3a%2f%2f2taezeat.github.io%2fposts%2fos%2f%25EC%25BB%25B4%25ED%2593%25A8%25ED%2584%25B0%25EA%25B5%25AC%25EC%25A1%25B0-%2b-%25EC%259A%25B4%25EC%2598%2581%25EC%25B2%25B4%25EC%25A0%259C-ch11.-cpu-%25EC%258A%25A4%25EC%25BC%2580%25EC%25A5%25B4%25EB%25A7%2581%2f"><svg width="30" height="30" viewBox="0 0 512 512" fill="currentcolor" xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"><path d="M449.446.0C483.971.0 512 28.03 512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446zM183.8767 87.9921h-62.034L230.6673 292.4508V424.0079h50.6655V292.4508L390.1575 87.9921H328.1233L256 238.2489z"/></svg></a></li></ul></footer><script src=https://utteranc.es/client.js repo=2taezeat/blog_comment issue-term=pathname label=comment theme=github-light crossorigin=anonymous async></script></article></main><footer class=footer><span>&copy; 2024 <a href=https://2taezeat.github.io/>2taezeat, blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>