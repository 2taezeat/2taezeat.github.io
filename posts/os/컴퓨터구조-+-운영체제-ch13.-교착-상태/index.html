<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>[컴퓨터구조 + 운영체제] ch13. 교착 상태 | 2taezeat, blog</title>
<meta name=keywords content="OS,CS"><meta name=description content="'혼자 공부하는 컴퓨터구조+운영체제', ch13. 교착 상태"><meta name=author content="2taezeat"><link rel=canonical href=https://2taezeat.github.io/posts/os/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0-+-%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C-ch13.-%EA%B5%90%EC%B0%A9-%EC%83%81%ED%83%9C/><meta name=google-site-verification content="YaEERzgrvu-ZwPg7gswZdTzRMufkHw3uIH7i8hVal1c"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.fcb4dca47a3205209ed5ad677bea9ef840216e00cc778e31a6e3943bf8f843e1.css integrity="sha256-/LTcpHoyBSCe1a1ne+qe+EAhbgDMd44xpuOUO/j4Q+E=" rel="preload stylesheet" as=style><link rel=icon href=https://2taezeat.github.io/icon/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://2taezeat.github.io/icon/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://2taezeat.github.io/icon/favicon-32x32.png><link rel=apple-touch-icon href=https://2taezeat.github.io/icon/apple-touch-icon.png><link rel=mask-icon href=https://2taezeat.github.io/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://2taezeat.github.io/posts/os/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0-+-%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C-ch13.-%EA%B5%90%EC%B0%A9-%EC%83%81%ED%83%9C/><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><meta property="og:title" content="[컴퓨터구조 + 운영체제] ch13. 교착 상태"><meta property="og:description" content="'혼자 공부하는 컴퓨터구조+운영체제', ch13. 교착 상태"><meta property="og:type" content="article"><meta property="og:url" content="https://2taezeat.github.io/posts/os/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0-+-%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C-ch13.-%EA%B5%90%EC%B0%A9-%EC%83%81%ED%83%9C/"><meta property="og:image" content="https://2taezeat.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-04-05T11:30:03+00:00"><meta property="article:modified_time" content="2024-04-05T11:30:03+00:00"><meta property="og:site_name" content="2taezeat, blog"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://2taezeat.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="[컴퓨터구조 + 운영체제] ch13. 교착 상태"><meta name=twitter:description content="'혼자 공부하는 컴퓨터구조+운영체제', ch13. 교착 상태"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://2taezeat.github.io/posts/"},{"@type":"ListItem","position":2,"name":"[컴퓨터구조 + 운영체제] ch13. 교착 상태","item":"https://2taezeat.github.io/posts/os/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0-+-%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C-ch13.-%EA%B5%90%EC%B0%A9-%EC%83%81%ED%83%9C/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"[컴퓨터구조 + 운영체제] ch13. 교착 상태","name":"[컴퓨터구조 \u002b 운영체제] ch13. 교착 상태","description":"'혼자 공부하는 컴퓨터구조+운영체제', ch13. 교착 상태","keywords":["OS","CS"],"articleBody":"13.1 교착 상태란 13.1.1 식사하는 철학자 문제 식사하는 철학자 문제; dining philosophers problem 는 교착 상태(dead lock) 상황을 설명하기 위한 고전적인 문제 상황 모든 철학자가 동시에 포크를 집어 식사를 하면 어떤 철학자도 식사를 할 수 없고 영원히 생각만 하는 상황이 발생 모든 철학자가 왼쪽 포크를 집어들면 모두가 오른쪽 포크를 집어들 수 없기 때문 다시 말해 모든 철학자는 다른 철학자가 포크를 내려놓을 때까지 기다림 포크-임계 구역 or 자원 철학자-프로세스 or 스레드 생각하는 행위-자원을 기다리는 것 교착 상태; deadlock: 영원히 일어나지 않을 사건을 기다리며, 진행이 멈춰 버리는 현상 프로세스A는 임계 구역 진입 전 lock1을 잠그고 (lock1 = true), 프로세스B는 임계 구역 진입 전 lock2를 잠갔다고 (lock2 = true) 가정 만일 프로세스 A는 lock2가 false가 되길 기다리고, 프로세스 B는 lock1이 false가 되길 기다린다면 교착 상태가 발생 13.1.2 자원 할당 그래프 교착 상태는 자원 할당 그래프 resource-allocation graph 를 통해 단순하게 표현 가능 교착 상태가 발생한 상황은 자원 할당 그래프가 원의 형태를 띈다 13.1.3 교착 상태 발생 조건 아래 조건 중 하나라도 만족하지 않는다면 교착 상태 발생 X\n아래 조건이 모두 만족될 때 교착 상태 발생 O\n13.1.3.1 상호 배제, mutual exclusion 식사하는 철학자 문제에서 하나의 포크를 여러 명이 동시에 사용할 수 있었다면 교착 상태는 발생하지 않음 프로세스도 한 프로세스가 사용하는 자원을 다른 프로세스가 사용할 수 없을 때, 즉, 상호 배제 mutual exclusion 상황에서 교착 상태가 발생 가능 13.1.3.2 점유와 대기, hold and wait 어떠한 자원을 할당받은 상태에서 다른 자원을 할당받기를 기다린다면 교착 상태가 발생할 수 있습니다. 이렇게 ‘자원을 할당받은 상태에서 다른 자원을 할당받기를 기다리는 상태‘를 점유와 대기라 한다. 13.1.3.3 비선점, nonpreemptive 만일 철학자들 중 누군가가 다른 철학자의 포크를 강제로 빼앗을 수 있었다면 교착 상태는 발생하지 않음\n프로세스가 자원을 비선점 nonpreemptive 하고 있었기 때문.\n비선점 자원은 그 자원을 이용하는 프로세스의 작업이 끝나야만 비로소 이용할 수 있다.\n즉, 어떤 프로세스도 다른 프로세스의 자원을 강제로 빼앗지 못했기 때문에 교착 상태가 발생\n13.1.3.4 원형 대기, circular wait 프로세스들과 프로세스가 요청 및 할당받은 자원이 원의 형태를 이루었기 때문입니다. 프로세스들이 원의 형태로 자원을 대기하는 것을 원형 대기 circular wait 라고 합니다. 자원 할당 그래프가 원의 형태로 그려지면 교착 상태가 발생할 ‘수’ 있다고 표현한 이유가 있다. 자원 할당 그래프가 원의 형태를 띄지 않는다면 교착 상태는 발생하지 않으나, 원의 형태를 띈다고 해서 반드시 교착 상태가 발생하는 것은 아닙니다. 13.2 교착 상태 해결 방법 운영체제는 애초에 교착 상태가 일어나지 않도록 교착 상태 발생 조건에 부합하지 않게 자원을 분배하여 교착 상태를 예방 가능\n교착 상태가 발생하지 않을 정도로 조금씩 자원을 할당하다가 교착 상태의 위험이 있다면 자원을 할당하지 않는 방식으로 교착 상태를 회피 가능\n자원을 제약 없이 할당하다가 교착 상태가 검출되면 교착 상태를 회복 가능\n13.2.1 교착 상태 예방 프로세스들에 자원을 할당할 때 상호 배제, 점유와 대기, 비선점, 원형 대기 중 하나의 조건이라도 만족시키지 않게 할당\n상호 배제 없애기\n모든 자원을 공유 가능하게 만든다는 말 교착 상태는 없앨 수 있지만, 모든 자원의 상호 배제를 없애기는 현실적으로 어려움 점유와 대기 없애기\n철학자들로 하여금 한 손에 포크를 들고 다른 포크를 기다리지 못하게 금지하는 것과 같다. 포크를 두 개 동시에 들게 하거나, 아니면 아예 들지 못하게 하는 것 점유와 대기를 없애면 운영체제는 특정 프로세스에 자원을 모두 할당하거나, 아예 할당하지않는 방식으로 배분 이론적으로는 교착 상태를 해결할 수 있지만, 단점도 존재 자원의 활용률이 낮아질 우려 존재 점유와 대기를 금지하면 한 프로세스에 필요한 자원들을 몰아주고, 그 다음에 다른 프로세스에 필요한 자원들을 몰아줘야 함 이는 당장 자원이 필요해도 기다릴 수밖에 없는 프로세스와 사용되지 않으면서 오랫동안 할당되는 자원을 다수 양산하기 때문에 자원의 활용률이 낮아짐 많은 자원을 사용하는 프로세스가 불리 자원을 많이 사용하는 프로세스는 적게 사용하는 프로세스에 비해 동시에 자원을 사용할 타이밍을 확보하기 어렵기 때문 결국 많은 자원을 필요로 하는 프로세스가 무한정 기다리게 되는 기아 현상을 야기할 우려 비선점 조건 없애기\n비선점 조건을 없애면 자원을 이용 중인 프로세스로부터 해당 자원을 빼앗을 수 있음 이 방식은 선점하여 사용할 수 있는 일부 자원에 대해서는 효과적 가령 CPU는 프로세스들이 선점할 수 있는 대표적인 자원 한 프로세스가 CPU를 이용하다가 일정 시간이 지나면 아직 작업이 모두 끝나지 않았다고 할지라도 다른 프로세스가 CPU를 할당받아 사용할 수 있기 때문 하지만 모든 자원이 이렇게 선점 가능한 것은 아님 한 프로세스의 작업이 끝날 때까지 다른 프로세스가 기다려야 하는 자원도 얼마든지 존재 예를 들어 한 번에 하나의 프로세스만 이용 가능한 프린터 자원 한 프로세스가 이 프린터를 이용하는 도중에, 다른 프로세스가 프린터 자원을 빼앗아 사용하기 어려움 그렇기에 비선점 조건을 없애 모든 자원을 빼앗을 수 있도록 하는 것은 다소 범용성이 떨어지는 방안 원형 대기 조건 없애기\n모든 자원에 번호를 붙이고, 오름차순으로 자원을 할당하면 원형 대기는 발생하지 않음 예를 들어, 식사하는 철학자 문제에서 모든 포크에 1번부터 5번까지 번호를 붙이고, 철학자들로 하여금 번호가 낮은 포크에서 높은 포크 순으로 집어들게 한다면 원형 대기는 발생하지 않음 5번 포크를 집어들고 1번 포크를 집어들 수 없기 때문 원형 대기를 없앰으로써 교착 상태를 예방하는 방식은 비교적 현실적이고 실용적인 방식이지만, 역시 단점 존재 모든 컴퓨터 시스템 내에 존재하는 수많은 자원에 번호를 붙이는 일은 간단한 작업이 아니거니와 각 자원에 어떤 번호를 붙이는지에 따라 특정 자원의 활용률이 떨어질 수 있음 이렇듯 발생 조건을 원천적으로 제거하여 교착 상태를 사전에 방지하는 예방 방식은 교착 상태가 발생하지 않음을 보장할 수는 있지만 여러 부작용이 존재\n13.2.2 교착 상태 회피 교착 상태 회피는 교착 상태가 발생하지 않을 정도로만 조심 조심 자원을 할당하는 방식\n항시 ‘안전 상태’를 유지하도록 자원을 할당하는 방식 교착 상태 회피 방식에서는 교착 상태를 한정된 자원의 무분별한 할당으로 인해 발생하는 문제로 간주\n포크가 100개, 1,000개 있는 상태에서 철학자들이 한두 개 의 포크를 요구하면 교착 상태는 발생 X 반면 포크의 양이 충분하지 않은 상태에서 모두 자신이 요구할 수 있는 최대의 포크 (두 개)를 요구하면 교착 상태가 발생 안전 상태; safe state: 교착 상태가 발생하지 않고, 모든 프로세스가 정상적으로 자원을 할당받고 종료될 수 있는 상태\n안전 순서열이 있어서 교착 상태가 발생하지 않는 상태를 안전 상태 라 한다. 불안전 상태; unsafe state: 교착 상태가 발생할 수도 있는 상황\n안전 순서열이 없는 상태, 교착 상태가 발생할 위험이 있음 안전 순서열; safe sequence: 교착 상태 없이 안전하게 프로세스들에 자원을 할당할 수 있는 순서\n예를 들어 웹 브라우저, 메모장, 게임 프로세스가 동시에 운영체제에 자원을 요청한 상황에서 웹 브라우저-메모장-게임 프로세스 순서대로 자원을 할당하면 교착 상태가 발생하지 않는다고 가정 이 경우 웹 브라우저 -\u003e 메모장 \u003e 게임이 안전 순서열이 됩니다. 프로세스와 스레드는 자원을 사용하기 위해\n우선 자원을 운영체제에게 요청 운영체제로부터 자원을 할당받아 사용 자원의 사용이 끝났다면 자원을 반환 안전 상태 예시 ​\t​\t불안전 상태 예시\n​\t13.2.3 교착 상태 검출 후 회복 교착 상태 예방과 회피는 교착 상태 발생을 막기 위한 노력이었다면, 교착 상태 검출 후 회복은 교착 상태 발생을 인정하고 사후에 조치하는 방식 검출 후 회복 방식에서 운영체제는 프로세스들이 자원을 요구할 때마다 그때그때 모두 할당 교착 상태 발생 여부를 주기적으로 검사하고, 검출되면 그때 회복 13.2.3.1 선점(독점 불가)을 통한 회복 교착 상태가 해결될 때까지 한 프로세스씩 자원을 몰아주는 방식 교착 상태가 해결될 때까지 다른 프로세스로부터 자원을 강제로 빼앗고 한 프로세스에 할당하는 방식 13.2.3.2 프로세스 강제 종료를 통한 회복 프로세스 강제 종료를 통한 회복은 가장 단순하면서 확실한 방식\n운영체제는 교착 상태에 놓인 프로세스를 모두 강제 종료할 수도 있고,\n가장 확실한 방식이지만 그만큼 많은 프로세스들이 작업 내역을 잃게 될 가능성이 존재 교착 상태가 없어질 때까지 한 프로세스씩 강제 종료할 수도 있다.\n작업 내역을 잃는 프로세스는 최대한 줄일수 있지만 교착 상태가 없어졌는지 여부를 확인 오버헤드를 야기 실은 교착 상태를 아예 무시하는 방법도 존재\n타조(ostrich) 알고리즘: 드물게 발생하는 잠재적 문제를 무시로 대처하는 방식 완벽을 추구하는 과학자나 수학자 입장에서는 납득할 수 없는 방식일지 모르나 문제 발생의 빈도나 심각성에 따라 최대 효율을 추구하는 엔지니어 입장에서는 때때로 이 방식이 적합할 때도 있다. Reference 혼자 공부하는 컴퓨터구조+운영체제 (강민철, 한빛미디어) https://product.kyobobook.co.kr/detail/S000061584886 ","wordCount":"1177","inLanguage":"en","image":"https://2taezeat.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E","datePublished":"2024-04-05T11:30:03Z","dateModified":"2024-04-05T11:30:03Z","author":{"@type":"Person","name":"2taezeat"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://2taezeat.github.io/posts/os/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0-+-%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C-ch13.-%EA%B5%90%EC%B0%A9-%EC%83%81%ED%83%9C/"},"publisher":{"@type":"Organization","name":"2taezeat, blog","logo":{"@type":"ImageObject","url":"https://2taezeat.github.io/icon/favicon.ico"}}}</script></head><body id=top><header class=header><nav class=nav><div class=logo><a href=https://2taezeat.github.io/ accesskey=h title="2taezeat blog (Alt + H)"><img src=https://2taezeat.github.io/icon/apple-touch-icon.png alt aria-label=logo height=30>2taezeat blog</a><div class=logo-switches></div></div><ul id=menu><li><a href=https://2taezeat.github.io/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://2taezeat.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://2taezeat.github.io/searchs/ title=Search><span>Search</span></a></li><li><a href=https://github.com/2taezeat title=Github><span>Github</span>&nbsp;<svg fill="none" shape-rendering="geometricPrecision" stroke="currentcolor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2.5" viewBox="0 0 24 24" height="12" width="12"><path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"/><path d="M15 3h6v6"/><path d="M10 14 21 3"/></svg></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://2taezeat.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://2taezeat.github.io/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">[컴퓨터구조 + 운영체제] ch13. 교착 상태</h1><div class=post-description>'혼자 공부하는 컴퓨터구조+운영체제', ch13. 교착 상태</div><div class=post-meta><span title='2024-04-05 11:30:03 +0000 +0000'>2024-04-05</span>&nbsp;·&nbsp;6 min&nbsp;·&nbsp;1177 words&nbsp;·&nbsp;2taezeat</div></header><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#131-교착-상태란>13.1 교착 상태란</a><ul><li><a href=#1311-식사하는-철학자-문제>13.1.1 식사하는 철학자 문제</a></li><li><a href=#1312-자원-할당-그래프>13.1.2 자원 할당 그래프</a></li><li><a href=#1313-교착-상태-발생-조건>13.1.3 교착 상태 발생 조건</a><ul><li><a href=#13131-상호-배제-mutual-exclusion>13.1.3.1 상호 배제, mutual exclusion</a></li><li><a href=#13132-점유와-대기-hold-and-wait>13.1.3.2 점유와 대기, hold and wait</a></li><li><a href=#13133-비선점-nonpreemptive>13.1.3.3 비선점, nonpreemptive</a></li><li><a href=#13134-원형-대기-circular-wait>13.1.3.4 원형 대기, circular wait</a></li></ul></li></ul></li><li><a href=#132-교착-상태-해결-방법>13.2 교착 상태 해결 방법</a><ul><li><a href=#1321-교착-상태-예방>13.2.1 교착 상태 예방</a></li><li><a href=#1322-교착-상태-회피>13.2.2 교착 상태 회피</a></li><li><a href=#1323-교착-상태-검출-후-회복>13.2.3 교착 상태 검출 후 회복</a><ul><li><a href=#13231-선점독점-불가을-통한-회복>13.2.3.1 선점(독점 불가)을 통한 회복</a></li><li><a href=#13232-프로세스-강제-종료를-통한-회복>13.2.3.2 프로세스 강제 종료를 통한 회복</a></li></ul></li></ul></li><li><a href=#reference>Reference</a></li></ul></nav></div></details></div><div class=post-content><h1 id=131-교착-상태란>13.1 교착 상태란<a hidden class=anchor aria-hidden=true href=#131-교착-상태란>#</a></h1><h2 id=1311-식사하는-철학자-문제>13.1.1 식사하는 철학자 문제<a hidden class=anchor aria-hidden=true href=#1311-식사하는-철학자-문제>#</a></h2><ul><li><strong>식사하는 철학자 문제; dining philosophers problem</strong> 는 교착 상태(dead lock) 상황을 설명하기 위한 고전적인 문제 상황<ul><li>모든 철학자가 동시에 포크를 집어 식사를 하면 어떤 철학자도 식사를 할 수 없고 영원히 생각만 하는 상황이 발생</li><li>모든 철학자가 왼쪽 포크를 집어들면 모두가 오른쪽 포크를 집어들 수 없기 때문</li><li>다시 말해 모든 철학자는 다른 철학자가 포크를 내려놓을 때까지 기다림</li><li>포크-임계 구역 or 자원</li><li>철학자-프로세스 or 스레드</li><li>생각하는 행위-자원을 기다리는 것</li></ul></li><li><strong>교착 상태; deadlock</strong>: 영원히 일어나지 않을 사건을 기다리며, 진행이 멈춰 버리는 현상</li></ul><ul><li>프로세스A는 임계 구역 진입 전 lock1을 잠그고 (lock1 = true), 프로세스B는 임계 구역 진입 전 lock2를 잠갔다고 (lock2 = true) 가정</li><li>만일 프로세스 A는 lock2가 false가 되길 기다리고, 프로세스 B는 lock1이 false가 되길 기다린다면 교착 상태가 발생</li></ul><p><img loading=lazy src=/Users/taezeat/IdeaProjects/myBlog/assets/img/blog/2024/image-20240501145100292.png alt=image-20240501145100292></p><h2 id=1312-자원-할당-그래프>13.1.2 자원 할당 그래프<a hidden class=anchor aria-hidden=true href=#1312-자원-할당-그래프>#</a></h2><ul><li>교착 상태는 <strong>자원 할당 그래프 resource-allocation graph</strong> 를 통해 단순하게 표현 가능</li></ul><ol><li></li><li></li><li></li><li></li></ol><ul><li>교착 상태가 발생한 상황은 <strong>자원 할당 그래프</strong>가 <strong>원의 형태</strong>를 띈다</li></ul><h2 id=1313-교착-상태-발생-조건>13.1.3 교착 상태 발생 조건<a hidden class=anchor aria-hidden=true href=#1313-교착-상태-발생-조건>#</a></h2><ul><li><p>아래 조건 중 하나라도 만족하지 않는다면 교착 상태 발생 X</p></li><li><p>아래 조건이 모두 만족될 때 교착 상태 발생 O</p></li></ul><h3 id=13131-상호-배제-mutual-exclusion>13.1.3.1 상호 배제, mutual exclusion<a hidden class=anchor aria-hidden=true href=#13131-상호-배제-mutual-exclusion>#</a></h3><ul><li>식사하는 철학자 문제에서 하나의 포크를 여러 명이 동시에 사용할 수 있었다면 교착 상태는 발생하지 않음</li><li>프로세스도 한 프로세스가 사용하는 자원을 다른 프로세스가 사용할 수 없을 때,</li><li>즉, <strong>상호 배제 mutual exclusion</strong> 상황에서 교착 상태가 발생 가능</li></ul><h3 id=13132-점유와-대기-hold-and-wait>13.1.3.2 점유와 대기, hold and wait<a hidden class=anchor aria-hidden=true href=#13132-점유와-대기-hold-and-wait>#</a></h3><ul><li>어떠한 자원을 할당받은 상태에서 다른 자원을 할당받기를 기다린다면 교착 상태가 발생할 수 있습니다.</li><li>이렇게 &lsquo;<strong>자원을 할당받은 상태에서 다른 자원을 할당받기를 기다리는 상태</strong>&lsquo;를 <strong>점유와 대기</strong>라 한다.</li></ul><h3 id=13133-비선점-nonpreemptive>13.1.3.3 비선점, nonpreemptive<a hidden class=anchor aria-hidden=true href=#13133-비선점-nonpreemptive>#</a></h3><ul><li><p>만일 철학자들 중 누군가가 다른 철학자의 포크를 <strong>강제로 빼앗을 수 있었다면</strong> 교착 상태는 발생하지 않음</p></li><li><p>프로세스가 자원을 <strong>비선점 nonpreemptive</strong> 하고 있었기 때문.</p></li><li><p>비선점 자원은 그 자원을 이용하는 프로세스의 작업이 끝나야만 비로소 이용할 수 있다.</p></li><li><p>즉, 어떤 프로세스도 다른 프로세스의 자원을 강제로 빼앗지 못했기 때문에 교착 상태가 발생</p></li></ul><h3 id=13134-원형-대기-circular-wait>13.1.3.4 원형 대기, circular wait<a hidden class=anchor aria-hidden=true href=#13134-원형-대기-circular-wait>#</a></h3><ul><li><strong>프로세스</strong>들과 프로세스가 요청 및 할당받은 <strong>자원이 원의 형태</strong>를 이루었기 때문입니다.</li><li>프로세스들이 원의 형태로 자원을 대기하는 것을 <strong>원형 대기 circular wait</strong> 라고 합니다.</li></ul><blockquote><ul><li>자원 할당 그래프가 원의 형태로 그려지면 교착 상태가 발생할 &lsquo;<strong>수</strong>&rsquo; 있다고 표현한 이유가 있다.<ul><li>자원 할당 그래프가 원의 형태를 띄지 않는다면 교착 상태는 발생하지 않으나,</li><li><strong>원의 형태를 띈다고 해서 반드시 교착 상태가 발생하는 것은 아닙니다.</strong></li></ul></li></ul></blockquote><h1 id=132-교착-상태-해결-방법>13.2 교착 상태 해결 방법<a hidden class=anchor aria-hidden=true href=#132-교착-상태-해결-방법>#</a></h1><ul><li><p>운영체제는 애초에 교착 상태가 일어나지 않도록 <strong>교착 상태 발생 조건에 부합하지 않게 자원을 분배</strong>하여 교착 상태를 <strong>예방</strong> 가능</p></li><li><p>교착 상태가 발생하지 않을 정도로 조금씩 자원을 할당하다가 <strong>교착 상태의 위험이 있다면 자원을 할당하지 않는 방식</strong>으로 교착 상태를 <strong>회피</strong> 가능</p></li><li><p>자원을 제약 없이 할당하다가 교착 상태가 검출되면 교착 상태를 <strong>회복</strong> 가능</p></li></ul><h2 id=1321-교착-상태-예방>13.2.1 교착 상태 예방<a hidden class=anchor aria-hidden=true href=#1321-교착-상태-예방>#</a></h2><ul><li><p>프로세스들에 자원을 할당할 때 <strong>상호 배제, 점유와 대기, 비선점, 원형 대기</strong> 중 <strong>하나의 조건이라도 만족시키지 않게</strong> 할당</p></li><li><p><strong>상호 배제 없애기</strong></p><ul><li><strong>모든 자원을 공유 가능</strong>하게 만든다는 말</li><li>교착 상태는 없앨 수 있지만, 모든 자원의 상호 배제를 없애기는 현실적으로 어려움</li></ul></li><li><p><strong>점유와 대기 없애기</strong></p><ul><li>철학자들로 하여금 한 손에 포크를 들고 다른 포크를 기다리지 못하게 금지하는 것과 같다.<ul><li><strong>포크를 두 개 동시에 들게 하거나, 아니면 아예 들지 못하게 하는 것</strong></li></ul></li><li>점유와 대기를 없애면 운영체제는 <strong>특정 프로세스에 자원을 모두 할당하거나, 아예 할당하지않는 방식</strong>으로 배분</li><li>이론적으로는 교착 상태를 해결할 수 있지만, 단점도 존재<ul><li>자원의 활용률이 낮아질 우려 존재<ul><li><strong>점유와 대기를 금지</strong>하면 한 프로세스에 필요한 자원들을 몰아주고, 그 다음에 다른 프로세스에 필요한 자원들을 몰아줘야 함</li><li>이는 당장 <strong>자원이 필요해도 기다릴 수밖에 없는 프로세스</strong>와 <strong>사용되지 않으면서 오랫동안 할당되는 자원</strong>을 다수 양산하기 때문에 자원의 활용률이 낮아짐</li></ul></li><li>많은 자원을 사용하는 프로세스가 불리<ul><li>자원을 많이 사용하는 프로세스는 적게 사용하는 프로세스에 비해 동시에 자원을 사용할 타이밍을 확보하기 어렵기 때문</li><li>결국 많은 자원을 필요로 하는 프로세스가 무한정 기다리게 되는 <strong>기아 현상</strong>을 야기할 우려</li></ul></li></ul></li></ul></li><li><p><strong>비선점 조건 없애기</strong></p><ul><li>비선점 조건을 없애면 자원을 이용 중인 프로세스로부터 해당 자원을 빼앗을 수 있음</li><li>이 방식은 선점하여 사용할 수 있는 일부 자원에 대해서는 효과적<ul><li>가령 CPU는 프로세스들이 선점할 수 있는 대표적인 자원</li><li>한 프로세스가 CPU를 이용하다가 일정 시간이 지나면 아직 작업이 모두 끝나지 않았다고 할지라도 다른 프로세스가 CPU를 할당받아 사용할 수 있기 때문</li></ul></li><li>하지만 모든 자원이 이렇게 <strong>선점 가능</strong>한 것은 아님<ul><li>한 프로세스의 작업이 끝날 때까지 다른 프로세스가 기다려야 하는 자원도 얼마든지 존재<ul><li>예를 들어 한 번에 하나의 프로세스만 이용 가능한 프린터 자원</li><li>한 프로세스가 이 프린터를 이용하는 도중에, 다른 프로세스가 프린터 자원을 빼앗아 사용하기 어려움</li><li>그렇기에 비선점 조건을 없애 모든 자원을 빼앗을 수 있도록 하는 것은 다소 범용성이 떨어지는 방안</li></ul></li></ul></li></ul></li><li><p><strong>원형 대기 조건 없애기</strong></p><ul><li>모든 자원에 번호를 붙이고, <strong>오름차순으로 자원을 할당</strong>하면 원형 대기는 발생하지 않음<ul><li>예를 들어, 식사하는 철학자 문제에서 모든 포크에 1번부터 5번까지 번호를 붙이고,</li><li>철학자들로 하여금 번호가 낮은 포크에서 높은 포크 순으로 집어들게 한다면 원형 대기는 발생하지 않음</li><li>5번 포크를 집어들고 1번 포크를 집어들 수 없기 때문</li></ul></li><li>원형 대기를 없앰으로써 교착 상태를 예방하는 방식은 비교적 현실적이고 실용적인 방식이지만, 역시 단점 존재<ul><li>모든 컴퓨터 시스템 내에 존재하는 수많은 자원에 번호를 붙이는 일은 간단한 작업이 아니거니와</li><li>각 자원에 어떤 번호를 붙이는지에 따라 특정 자원의 활용률이 떨어질 수 있음</li></ul></li></ul></li><li><p>이렇듯 발생 조건을 원천적으로 제거하여 교착 상태를 사전에 방지하는 예방 방식은 교착 상태가 발생하지 않음을 보장할 수는 있지만 <strong>여러 부작용이 존재</strong></p></li></ul><h2 id=1322-교착-상태-회피>13.2.2 교착 상태 회피<a hidden class=anchor aria-hidden=true href=#1322-교착-상태-회피>#</a></h2><ul><li><p>교착 상태 회피는 교착 상태가 발생하지 않을 정도로만 조심 조심 자원을 할당하는 방식</p><ul><li><strong>항시 &lsquo;안전 상태&rsquo;를 유지하도록 자원을 할당하는 방식</strong></li></ul></li><li><p>교착 상태 회피 방식에서는 교착 상태를 한정된 자원의 무분별한 할당으로 인해 발생하는 문제로 간주</p><ul><li>포크가 100개, 1,000개 있는 상태에서 철학자들이 한두 개 의 포크를 요구하면 교착 상태는 발생 X</li><li>반면 포크의 양이 충분하지 않은 상태에서 모두 자신이 요구할 수 있는 최대의 포크 (두 개)를 요구하면 교착 상태가 발생</li></ul></li><li><p><strong>안전 상태; safe state</strong>: 교착 상태가 발생하지 않고, 모든 프로세스가 정상적으로 자원을 할당받고 종료될 수 있는 상태</p><ul><li><strong>안전 순서열</strong>이 있어서 교착 상태가 발생하지 않는 상태를 <strong>안전 상태</strong> 라 한다.</li></ul></li><li><p><strong>불안전 상태; unsafe state</strong>: 교착 상태가 발생할 수도 있는 상황</p><ul><li><strong>안전 순서열</strong>이 없는 상태, 교착 상태가 발생할 위험이 있음</li></ul></li><li><p><strong>안전 순서열; safe sequence</strong>: 교착 상태 없이 안전하게 프로세스들에 자원을 할당할 수 있는 순서</p><ul><li>예를 들어 웹 브라우저, 메모장, 게임 프로세스가 동시에 운영체제에 자원을 요청한 상황에서</li><li><code>웹 브라우저-메모장-게임</code> 프로세스 순서대로 자원을 할당하면 교착 상태가 발생하지 않는다고 가정</li><li>이 경우 <code>웹 브라우저 -> 메모장 > 게임</code>이 <strong>안전 순서열</strong>이 됩니다.</li></ul></li></ul><blockquote><p>프로세스와 스레드는 자원을 사용하기 위해</p><ol><li>우선 자원을 운영체제에게 요청</li><li>운영체제로부터 자원을 할당받아 사용</li><li>자원의 사용이 끝났다면 자원을 반환</li></ol></blockquote><ul><li>안전 상태 예시</li></ul><p>​</p><p>​</p><ul><li><p>불안전 상태 예시</p></li></ul><p>​</p><h2 id=1323-교착-상태-검출-후-회복>13.2.3 교착 상태 검출 후 회복<a hidden class=anchor aria-hidden=true href=#1323-교착-상태-검출-후-회복>#</a></h2><ul><li>교착 상태 예방과 회피는 교착 상태 발생을 막기 위한 노력이었다면,</li><li>교착 상태 검출 후 회복은 교착 상태 발생을 인정하고 사후에 조치하는 방식<ul><li>검출 후 회복 방식에서 운영체제는 프로세스들이 자원을 요구할 때마다 그때그때 모두 할당</li><li>교착 상태 발생 여부를 주기적으로 검사하고, 검출되면 그때 회복</li></ul></li></ul><h3 id=13231-선점독점-불가을-통한-회복>13.2.3.1 선점(독점 불가)을 통한 회복<a hidden class=anchor aria-hidden=true href=#13231-선점독점-불가을-통한-회복>#</a></h3><ul><li>교착 상태가 해결될 때까지 <strong>한 프로세스씩 자원을 몰아주는 방식</strong></li><li>교착 상태가 해결될 때까지 <strong>다른 프로세스로부터 자원을 강제로 빼앗고 한 프로세스에 할당하는 방식</strong></li></ul><h3 id=13232-프로세스-강제-종료를-통한-회복>13.2.3.2 프로세스 강제 종료를 통한 회복<a hidden class=anchor aria-hidden=true href=#13232-프로세스-강제-종료를-통한-회복>#</a></h3><ul><li><p>프로세스 <strong>강제 종료</strong>를 통한 회복은 가장 단순하면서 확실한 방식</p></li><li><p>운영체제는 교착 상태에 놓인 프로세스를 <strong>모두 강제 종료</strong>할 수도 있고,</p><ul><li>가장 확실한 방식이지만 그만큼 많은 프로세스들이 작업 내역을 잃게 될 가능성이 존재</li></ul></li><li><p>교착 상태가 없어질 때까지 <strong>한 프로세스씩 강제 종료</strong>할 수도 있다.</p><ul><li>작업 내역을 잃는 프로세스는 최대한 줄일수 있지만 교착 상태가 없어졌는지 여부를 확인 오버헤드를 야기</li></ul></li><li><p>실은 교착 상태를 <strong>아예 무시하는 방법</strong>도 존재</p><ul><li><strong>타조(ostrich) 알고리즘</strong>: 드물게 발생하는 <strong>잠재적 문제를 무시로 대처하는 방식</strong></li><li>완벽을 추구하는 과학자나 수학자 입장에서는 납득할 수 없는 방식일지 모르나</li><li>문제 발생의 <strong>빈도</strong>나 <strong>심각성</strong>에 따라 <strong>최대 효율을 추구하는 엔지니어 입장</strong>에서는 때때로 이 방식이 적합할 때도 있다.</li></ul></li></ul><h1 id=reference>Reference<a hidden class=anchor aria-hidden=true href=#reference>#</a></h1><ul><li>혼자 공부하는 컴퓨터구조+운영체제 (강민철, 한빛미디어) <a href=https://product.kyobobook.co.kr/detail/S000061584886>https://product.kyobobook.co.kr/detail/S000061584886</a></li></ul></div><footer class=post-footer><ul class=post-tags><li><a href=https://2taezeat.github.io/tags/os/>OS</a></li><li><a href=https://2taezeat.github.io/tags/cs/>CS</a></li></ul><nav class=paginav><a class=prev href=https://2taezeat.github.io/posts/os/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0-+-%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C-ch14.-%EA%B0%80%EC%83%81-%EB%A9%94%EB%AA%A8%EB%A6%AC/><span class=title>« Prev</span><br><span>[컴퓨터구조 + 운영체제] ch14. 가상 메모리</span>
</a><a class=next href=https://2taezeat.github.io/posts/os/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0-+-%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C-ch12.-%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4-%EB%8F%99%EA%B8%B0%ED%99%94/><span class=title>Next »</span><br><span>[컴퓨터구조 + 운영체제] ch12. 프로세스 동기화</span></a></nav><ul class=share-buttons><li><a target=_blank rel="noopener noreferrer" aria-label="share [컴퓨터구조 + 운영체제] ch13. 교착 상태 on x" href="https://x.com/intent/tweet/?text=%5b%ec%bb%b4%ed%93%a8%ed%84%b0%ea%b5%ac%ec%a1%b0%20%2b%20%ec%9a%b4%ec%98%81%ec%b2%b4%ec%a0%9c%5d%20ch13.%20%ea%b5%90%ec%b0%a9%20%ec%83%81%ed%83%9c&amp;url=https%3a%2f%2f2taezeat.github.io%2fposts%2fos%2f%25EC%25BB%25B4%25ED%2593%25A8%25ED%2584%25B0%25EA%25B5%25AC%25EC%25A1%25B0-%2b-%25EC%259A%25B4%25EC%2598%2581%25EC%25B2%25B4%25EC%25A0%259C-ch13.-%25EA%25B5%2590%25EC%25B0%25A9-%25EC%2583%2581%25ED%2583%259C%2f&amp;hashtags=OS%2cCS"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446C483.971.0 512 28.03 512 62.554zM269.951 190.75 182.567 75.216H56L207.216 272.95 63.9 436.783h61.366L235.9 310.383l96.667 126.4H456L298.367 228.367l134-153.151H371.033zM127.633 110h36.468l219.38 290.065H349.5z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share [컴퓨터구조 + 운영체제] ch13. 교착 상태 on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2f2taezeat.github.io%2fposts%2fos%2f%25EC%25BB%25B4%25ED%2593%25A8%25ED%2584%25B0%25EA%25B5%25AC%25EC%25A1%25B0-%2b-%25EC%259A%25B4%25EC%2598%2581%25EC%25B2%25B4%25EC%25A0%259C-ch13.-%25EA%25B5%2590%25EC%25B0%25A9-%25EC%2583%2581%25ED%2583%259C%2f&amp;title=%5b%ec%bb%b4%ed%93%a8%ed%84%b0%ea%b5%ac%ec%a1%b0%20%2b%20%ec%9a%b4%ec%98%81%ec%b2%b4%ec%a0%9c%5d%20ch13.%20%ea%b5%90%ec%b0%a9%20%ec%83%81%ed%83%9c&amp;summary=%5b%ec%bb%b4%ed%93%a8%ed%84%b0%ea%b5%ac%ec%a1%b0%20%2b%20%ec%9a%b4%ec%98%81%ec%b2%b4%ec%a0%9c%5d%20ch13.%20%ea%b5%90%ec%b0%a9%20%ec%83%81%ed%83%9c&amp;source=https%3a%2f%2f2taezeat.github.io%2fposts%2fos%2f%25EC%25BB%25B4%25ED%2593%25A8%25ED%2584%25B0%25EA%25B5%25AC%25EC%25A1%25B0-%2b-%25EC%259A%25B4%25EC%2598%2581%25EC%25B2%25B4%25EC%25A0%259C-ch13.-%25EA%25B5%2590%25EC%25B0%25A9-%25EC%2583%2581%25ED%2583%259C%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share [컴퓨터구조 + 운영체제] ch13. 교착 상태 on reddit" href="https://reddit.com/submit?url=https%3a%2f%2f2taezeat.github.io%2fposts%2fos%2f%25EC%25BB%25B4%25ED%2593%25A8%25ED%2584%25B0%25EA%25B5%25AC%25EC%25A1%25B0-%2b-%25EC%259A%25B4%25EC%2598%2581%25EC%25B2%25B4%25EC%25A0%259C-ch13.-%25EA%25B5%2590%25EC%25B0%25A9-%25EC%2583%2581%25ED%2583%259C%2f&title=%5b%ec%bb%b4%ed%93%a8%ed%84%b0%ea%b5%ac%ec%a1%b0%20%2b%20%ec%9a%b4%ec%98%81%ec%b2%b4%ec%a0%9c%5d%20ch13.%20%ea%b5%90%ec%b0%a9%20%ec%83%81%ed%83%9c"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share [컴퓨터구조 + 운영체제] ch13. 교착 상태 on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2f2taezeat.github.io%2fposts%2fos%2f%25EC%25BB%25B4%25ED%2593%25A8%25ED%2584%25B0%25EA%25B5%25AC%25EC%25A1%25B0-%2b-%25EC%259A%25B4%25EC%2598%2581%25EC%25B2%25B4%25EC%25A0%259C-ch13.-%25EA%25B5%2590%25EC%25B0%25A9-%25EC%2583%2581%25ED%2583%259C%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share [컴퓨터구조 + 운영체제] ch13. 교착 상태 on whatsapp" href="https://api.whatsapp.com/send?text=%5b%ec%bb%b4%ed%93%a8%ed%84%b0%ea%b5%ac%ec%a1%b0%20%2b%20%ec%9a%b4%ec%98%81%ec%b2%b4%ec%a0%9c%5d%20ch13.%20%ea%b5%90%ec%b0%a9%20%ec%83%81%ed%83%9c%20-%20https%3a%2f%2f2taezeat.github.io%2fposts%2fos%2f%25EC%25BB%25B4%25ED%2593%25A8%25ED%2584%25B0%25EA%25B5%25AC%25EC%25A1%25B0-%2b-%25EC%259A%25B4%25EC%2598%2581%25EC%25B2%25B4%25EC%25A0%259C-ch13.-%25EA%25B5%2590%25EC%25B0%25A9-%25EC%2583%2581%25ED%2583%259C%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share [컴퓨터구조 + 운영체제] ch13. 교착 상태 on telegram" href="https://telegram.me/share/url?text=%5b%ec%bb%b4%ed%93%a8%ed%84%b0%ea%b5%ac%ec%a1%b0%20%2b%20%ec%9a%b4%ec%98%81%ec%b2%b4%ec%a0%9c%5d%20ch13.%20%ea%b5%90%ec%b0%a9%20%ec%83%81%ed%83%9c&amp;url=https%3a%2f%2f2taezeat.github.io%2fposts%2fos%2f%25EC%25BB%25B4%25ED%2593%25A8%25ED%2584%25B0%25EA%25B5%25AC%25EC%25A1%25B0-%2b-%25EC%259A%25B4%25EC%2598%2581%25EC%25B2%25B4%25EC%25A0%259C-ch13.-%25EA%25B5%2590%25EC%25B0%25A9-%25EC%2583%2581%25ED%2583%259C%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentcolor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share [컴퓨터구조 + 운영체제] ch13. 교착 상태 on ycombinator" href="https://news.ycombinator.com/submitlink?t=%5b%ec%bb%b4%ed%93%a8%ed%84%b0%ea%b5%ac%ec%a1%b0%20%2b%20%ec%9a%b4%ec%98%81%ec%b2%b4%ec%a0%9c%5d%20ch13.%20%ea%b5%90%ec%b0%a9%20%ec%83%81%ed%83%9c&u=https%3a%2f%2f2taezeat.github.io%2fposts%2fos%2f%25EC%25BB%25B4%25ED%2593%25A8%25ED%2584%25B0%25EA%25B5%25AC%25EC%25A1%25B0-%2b-%25EC%259A%25B4%25EC%2598%2581%25EC%25B2%25B4%25EC%25A0%259C-ch13.-%25EA%25B5%2590%25EC%25B0%25A9-%25EC%2583%2581%25ED%2583%259C%2f"><svg width="30" height="30" viewBox="0 0 512 512" fill="currentcolor" xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"><path d="M449.446.0C483.971.0 512 28.03 512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446zM183.8767 87.9921h-62.034L230.6673 292.4508V424.0079h50.6655V292.4508L390.1575 87.9921H328.1233L256 238.2489z"/></svg></a></li></ul></footer><script src=https://utteranc.es/client.js repo=2taezeat/blog_comment issue-term=pathname label=comment theme=github-light crossorigin=anonymous async></script></article></main><footer class=footer><span>&copy; 2024 <a href=https://2taezeat.github.io/>2taezeat, blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>