<!doctype html><html lang=en dir=auto><head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>컴퓨터구조 + 운영체제, 프로세스 동기화 (ch12) | 2taezeat, blog</title>
<meta name=keywords content><meta name=description content="&lsquo;혼자 공부하는 컴퓨터구조+운영체제&rsquo;, ch12. 프로세스 동기화 을 읽고, 정리한다."><meta name=author content="2taezeat"><link rel=canonical href=http://localhost:1313/posts/os/2024-04-04-%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0-+-%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C-%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4-%EB%8F%99%EA%B8%B0%ED%99%94-ch12/><meta name=google-site-verification content="YaEERzgrvu-ZwPg7gswZdTzRMufkHw3uIH7i8hVal1c"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.9bc633d66da2093ac93d30e5b21470b6655a1e928ddc297458ca9dfb4f00c07d.css integrity="sha256-m8Yz1m2iCTrJPTDlshRwtmVaHpKN3Cl0WMqd+08AwH0=" rel="preload stylesheet" as=style><link rel=icon href=http://localhost:1313/icon/favicon.ico><link rel=icon type=image/png sizes=16x16 href=http://localhost:1313/icon/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=http://localhost:1313/icon/favicon-32x32.png><link rel=apple-touch-icon href=http://localhost:1313/icon/apple-touch-icon.png><link rel=mask-icon href=http://localhost:1313/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=http://localhost:1313/posts/os/2024-04-04-%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0-+-%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C-%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4-%EB%8F%99%EA%B8%B0%ED%99%94-ch12/><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><meta property="og:title" content="컴퓨터구조 + 운영체제, 프로세스 동기화 (ch12)"><meta property="og:description" content="&lsquo;혼자 공부하는 컴퓨터구조+운영체제&rsquo;, ch12. 프로세스 동기화 을 읽고, 정리한다."><meta property="og:type" content="article"><meta property="og:url" content="http://localhost:1313/posts/os/2024-04-04-%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0-+-%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C-%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4-%EB%8F%99%EA%B8%B0%ED%99%94-ch12/"><meta property="og:image" content="http://localhost:1313/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-04-04T01:01:46+09:00"><meta property="article:modified_time" content="2024-04-04T01:01:46+09:00"><meta property="og:site_name" content="2taezeat, blog"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="http://localhost:1313/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="컴퓨터구조 + 운영체제, 프로세스 동기화 (ch12)"><meta name=twitter:description content="&lsquo;혼자 공부하는 컴퓨터구조+운영체제&rsquo;, ch12. 프로세스 동기화 을 읽고, 정리한다."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"http://localhost:1313/posts/"},{"@type":"ListItem","position":2,"name":"컴퓨터구조 + 운영체제, 프로세스 동기화 (ch12)","item":"http://localhost:1313/posts/os/2024-04-04-%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0-+-%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C-%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4-%EB%8F%99%EA%B8%B0%ED%99%94-ch12/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"컴퓨터구조 + 운영체제, 프로세스 동기화 (ch12)","name":"컴퓨터구조 \u002b 운영체제, 프로세스 동기화 (ch12)","description":"\u0026lsquo;혼자 공부하는 컴퓨터구조+운영체제\u0026rsquo;, ch12. 프로세스 동기화 을 읽고, 정리한다.\n","keywords":[],"articleBody":"‘혼자 공부하는 컴퓨터구조+운영체제’, ch12. 프로세스 동기화 을 읽고, 정리한다.\n12.1 동기화란 협력하여 실행되는 프로세스들은 실행 순서와 자원의 일관성을 보장하기 위해 동기화(synchronization) 되어야 한다 12.1.1 동기화의 의미 프로세스 동기화: 프로세스들 사이의 수행 시기를 맞추는 것 실행 순서 제어: 프로세스를 올바른 순서대로 실행하기 상호 배제(mutual exclusion): 동시에 접근해서는 안 되는 자원에 하나의 프로세스만 접근하게 하기 프로세스뿐만 아니라 스레드도 동기화 대상 정확히 말하면 실행의 흐름을 갖는 모든 것은 동기화의 대상 다만 이 책에서는 대부분의 전공서 표현에 따라 ‘프로세스 동기화’라고 칭함 실행 순서 제어를 위한 동기화\nReader 프로세스는 Writer 프로세스 실행이 끝나야 비로소 실행할 수 있어야 한다 Writer 가 Book.txt에 값을 저장하기도 전에 Reader 가 Book.txt를 읽는 것은 올바른 실행 순서가 아니다. Reader 는 ‘Book.txt 안에 값이 존재한다’는 특정 조건이 만족되어야만 실행을 이어나갈수 있다 프로세스를 올바른 순서대로 실행하는 것 상호 배제(mutual exclusion)를 위한 동기화\n동시에 접근해서는 안 되는 자원에 동시에 접근하지 못하게 하는 것\n두 개 이상의 프로세스가 임계 구역에 동시에 접근하지 못하도록 관리하는 것\n프로세스 A와 B가 동시에 실행되었다고 가정\n17만원이 계좌에 남을 거라고 유저는 기대\nA와 B는 ‘잔액’이라는 데이터를 동시에 사용하는데, A가 끝나기도 전에 B가 잔액을 읽어 버렸기 때문에 엉뚱한 결과가 나옴\nA와 B를 올바르게 실행하기 위해서는 한 프로세스가 잔액에 접근했을 때 다른 프로세스는 기다려야 한다\n​\t​\n​\n​\t12.1.2 생산자와 소비자 문제 상호 배제를 위한 동기화에 관련된 고전적이고 유명한 문제로 생산자와 소비자 문제가 있다.\n물건을 계속해서 생산하는 프로세스인 생산자\n물건을 계속해서 소비하는 프로세스인 소비자\n생산자와 소비자는 동시에 실행되는 스레드가 될 수도 있다.\n생산자를 100,000번, 소비자를 100,000번 동시에 실행\n유저는 총합 변수가 계속 10개로 머물러 있을 것으로 기대\n하지만 결과는 다름: 생산자 프로세스와 소비자 프로세스가 제대로 동기화되지 않았기 때문에 발생한 문제\n생산자와 소비자는 ‘총합’이라는 데이터를 동시에 사용하는데, 생산자가 소비자의 작업이 끝나기도 전에 총합을 수정해서때문에 엉뚱한 결과가 발생\n한 마디로 동시에 접근해서는 안 되는 자원에 동시에 접근했기에 발생한 문제\n12.1.3 공유 자원과 임계 구역 계좌 잔액 문제와 생산자 소비자 문제의 동시에 실행되는 프로세스들은 전역 변수 ‘잔액’, ‘총합’이라는 공동의 자원을 두고 작업을 했습니다.\n이러한 자원을 공유 자원; shared resource 이라 한다.\n공유 자원은 전역 변수, 파일, 입출력장치, 보조기억장치가 될 수도 있다.\n임계 구역; critical section: 동시에 실행하면 문제가 발생하는 자원에 접근하는 코드 영역\n임계 구역은 두 개 이상의 프로세스가 동시에 실행되면 안 되는 영역 두 개이 상의 프로세스가 임계 구역에 진입하고자 하면 둘 중 한는 대기해야 한다. 경쟁 상태; Race condition: 여러 프로세스가 동시 다발적으로 ‘‘임계 구역’‘의 코드를 실행하여 문제가 발생하는 경우\n데이터 일관성이 깨지는 문제 발생 컴퓨터는 고급 언어가 아닌 저급 언어를 실행하기 때문에 여러 줄의 저급 언어로 변환된 고급 언어한 줄을 실행하는 과정에서 문맥 교환이 일어남. 저급 언어를 실행하는 과정에서 문맥교환이 일어난다면 아래와 같은 문제가 발생 **‘상호 배제를 위한 동기화’**를 위해서는 세 가지 원칙이 반드시 지켜져야만 한다.\n상호 배제; mutual exclusion: 한 프로세스가 임계 구역에 진입했다면, 다른 프로세스는 임계 구역에 들어올 수 없다. 진행; progress: 임계 구역에 어떤 프로세스도 진입하지 않았다면, 임계 구역에 진입하고자 하는 프로세스는 들어갈 수 있어야 한다. 유한 대기; bounded waiting: 한 프로세스가 임계 구역에 진입하고 싶다면 그 프로세스는 언젠가는 임계 구역에 들어올 수 있어야 한다 (임계 구역에 들어오기 위해 무한정 대기해서는 안 된다). 12.2 동기화 기법 12.2.1 뮤텍스 락 옷 가게의 탈의실을 이용하는 것에 비유\n손님-프로세스, 탈의실-임계 구역\n자물쇠가 걸려 있지 않다면 탈의실을 이용하면 된다, 걸려 있다면 대기\n뮤텍스 락; MUTual EXclusion Lock: 이 자물쇠 기능을 코드로 구현한 것\n상호 배제를 위한 동기화 도구\n임계 구역에 진입하는 프로세스는 ‘내가 지금 임계 구역에 있음’을 알리기 위해 뮤텍스 락을 이용해 임계 구역에 자물쇠를 걸어둘 수 있고\n다른 프로세스는 임계 구역이 잠겨 있다면 기다리고, 잠겨 있지 않다면 임계 구역에 진입할 수 있다.\n뮤텍스 락의 단순한 형태는 하나의 전역 변수와 두 개의 함수로 구현 가능\n자물쇠 역할: 프로세스들이 공유하는 전역 변수 lock 임계 구역을 잠그는 역할: acquire 함수 임계 구역의 잠금을 해제하는 역할: release 함수 acquire 함수는 프로세스가 임계 구역에 진입하기 전에 호출하는 함수\n만일 임계 구역이 잠겨 있다면 임계 구역이 열릴 때까지 (lock이 false가 될 때까지) 임계 구역을 반복적으로 확인하고, 마치 탈의실 문이 잠겨 있는지 쉴 새 없이 반복하며 확인해 보는 것과 같다. 이런 대기 방식을 바쁜 대기; busy wait 이라 한다. 임계 구역이 열려 있다면 임계 구역을 잠그는 (lock을 true로 바꾸는) 함수 release 함수는 임계 구역에서의 작업이 끝나고 호출하는 함수\n현재 잠긴 임계 구역을 열어주는 (lock을 false로 바꾸는) 함수 이렇게 되면 프로세스는\n락을 획득할 수 없다면 (임계 구역에 진입할 수 없다면) 무작정 기다리고, 락을 획득할 수 있다면 (임계 구역에 진입할 수 있다면) 임계 구역을 잠근 뒤 임계 구역에서의 작업을 진행하고, 임계 구역에서 빠져나올 때엔 다시 임계 구역의 잠금을 해제함으로써 임계 구역을 보호할 수 있다. 12.2.2 세마포 세마포; semaphore는 뮤텍스 락과 비슷하지만, 조금 더 일반화된 방식의 동기화 도구\n엄밀히 말하면 세마포의 종류에도 이진 세마포(binary)와 카운팅 세마포(counting)가 존재 이진 세마포는 뮤텍스 락과 비슷한 개념이므로 여기서는 여러 공유 자원을 다룰 수 있는 카운팅 세마포를 다룬다 탈의실이 여러 개 있는 상황처럼 공유 자원이 여러 개 있을 경우 (각 공유 자원에는 하나의 프로세스만 진입이 가능할지라도) 여러 개의 프로세스가 각각 공유 자원에 접근이 가능해야 한다.\n한 번에 하나의 프로세스만 이용할 수 있는 프린터 세 대가 있는 상황에서 하나의 프린터를 사용할 수 있는 프로세스는 하나이지만, 총 세 개의 프로세스가 **공유 자원 (세 대의 프린터)**을 이용할 수 있다. 세마포는 공유 자원이 여러 개 있는 상황에서도 적용이 가능한 동기화 도구\n세마포는 뮤텍스 락과 비슷하게 하나의 변수와 두 개의 함수로 단순하게 구현할 수 있다.\n전역변수 S: 임계 구역에 진입할 수 있는 프로세스의 개수(사용 가능한 공유 자원의 개수) wait 함수: 임계 구역에 들어가도 좋은지, 기다려야 할지를 알려주는 함수 signal 함수: 임계 구역 앞에서 기다리는 프로세스에 ‘이제 가도 좋다’고 신호를 주는 함수 여기에서 세마포 변수와 함수 이름을 각각 S, wait, signal로 나타내지만, 변수, 함수 이름은 전공서마다 다를 수 있다. 일부에서는 세마포를 처음 개발한 다익스트라에 근거해 wait와 signal 함수를 P, V로 명명 일부에서는 철도 신호기에 근거해 down, up으로 명명 다만 변수와 함수를 어떻게 지칭하든지 원리와 작동 방식은 모두 동일 wait 함수\n만일 임계 구역에 진입할 수 있는 프로세스 개수가 0 이하라면 사용할 수 있는 자원이 있는지 반복적으로 확인하고, 임계 구역에 진입할 수 있는 프로세스 개수가 하나 이상이면 S를 1 감소시키고 임계 구역 진입한다. signal 함수\n임계 구역에서의 작업을 마친 뒤 S를 1 증가 여기서 한 가지 문제가 있습니다.\n이는 뮤텍스 락에도 해당되는 문제 사용할 수 있는 공유 자원이 없는 경우 프로세스는 무작정 무한히 반복하며 전역 변수 S를 확인해야 합니다. 이렇게 **바쁜 대기(busy wait)**를 반복하며 확인할 시간에 CPU는 더 생산성 있는 작업을 할 수 있을 텐데, CPU 주기를 낭비한다는 점에서 손해 그래서 실제로 세마포는 다른 더 좋은 방법을 사용\nwait 는 만일 사용할 수 있는 자원이 없을 경우 해당 프로세스 상태를 대기 상태로 만들고, 그 프로세스의 PCB를 세마포를 위한 대기 큐에 집어 넣음 다른 프로세스가 임계 구역에서의 작업이 끝나고 signal 를 호출하면 signal 는 대기 중인 프로세스를 대기 큐에서 제거하고, 프로세스 상태를 준비 상태로 변경한 뒤 준비 큐로 옮겨줌. 지금까지는 상호 배제를 위한 동기화 기법 아래는, 세마포를 이용해 실행 순서 제어를 위한 동기화(프로세스의 순서를 제어하는 방법) 에 대해 설명 세마포를 이용하면 동시에 실행되는 프로세스의 실행 순서도 원하는 대로 제어할 수 있다. 세마포의 변수 S를 0으로 두고 먼저 실행할 프로세스 뒤에 signal 함수, 다음에 실행할 프로세스 앞에 wait 함수를 붙이면 됩니다. P1이 먼저 실행되면 P1이 임계 구역에 먼저 진입하는 것은 자명 P2가 먼저 실행 되더라도 P2는 wait 함수를 만나므로 P1이 임계 구역에 진입 그리고 P1이 임계 구역의 실행을 끝내고 signal을 호출하면 그제서야 P2가 임계 구역에 진입 즉, P1이 먼저 실행되든 P2가 먼저 실행되든 반드시 P1 =\u003e P2 순서대로 실행된다. 12.2.3 모니터 세마포는 그 자체로 매우 훌륭한 프로세스 동기화 도구이지만, 사용하기가 조금 불편한 면이 있다. 매번 임계 구역에 앞뒤로 일일이 wait와 signal 함수를 명시하는 것은 번거로운 일 더군다나 자칫 아래처럼 잘못된 코드로 인해 예기치 못한 결과를 얻을 수도 있다. 최근에 등장한 동기화 도구가 모니터; montor 모니터는 공유 자원과 공유 자원에 접근하기 위한 인터페이스(통로)를 묶어 관리 프로세스는 반드시 인터페이스를 통해서만 공유 자원에 접근 모니터를 통해 공유 자원에 접근하고자 하는 프로세스를 큐에 삽입하고,\n큐에 삽입된 순서대로 하나씩 공유 자원을 이용하도록 합니다.\n즉, 모니터는 공유 자원을 다루는 **인터페이스에 접근하기 위한 큐(모니터에 진입하기 위한 큐)**를 만들고,\n모니터 안에 항상 하나의 프로세스만 들어오도록하여 상호 배제를 위한 동기화를 제공\n모니터는 세마포와 마찬가지로 실행 순서 제어를 위한 동기화도 제공합니다.\n특정 조건을 바탕으로 프로세스를 실행, 일시 중단하기 위해 조건 변수; condition variable를 사용하는데, 조건 변수는 프로세스나 스레드의 실행 순서를 제어하기 위해 사용하는 특별한 변수입니다. 모니터가 조건 변수를 사용한다고는 하지만 조건 변수와 모니터는 별개의 개념 조건 변수로는 wait와 signal 연산을 수행할 수 있다.\nwait는 호출한 프로세스의 상태를 대기 상태로 전환하고 일시적으로 조건 변수에 대한 대기 큐에 삽입하는 연산\n여기서 헷갈리면 안 되는 점\n**모니터에 진입하기 위해 삽입되는 큐(상호 배제를 위한 큐)**와 모니터에 한 번에 하나의 프로세스만 진입하도록 하기 위해 만들어진 큐 wait가 호출되어 실행이 중단된 프로세스들이 삽입되는 큐**(조건 변수에 대한 큐)**는 다르다 모니터에 이미 진입한 프로세스의 실행 조건이 만족될 때까지 잠시 실행이 중단되어 기다리기 위해 만들어진 큐 모니터에 진입한 어떤 프로세스가 x.wait() 를 통해 조건 변수 x에 대한 wait를 호출했다고 가정 그 프로세스는 다음 그림처럼 조건 변수 x에 대한 큐에 삽입되므로 모니터는 다시 비게됩니다. 그렇기에 다른 프로세스가 모니터 안에 들어올 수 있다. wait 연산으로 일시 중지된 프로세스는, 다른 프로세스의 signal 연산을 통해 실행이 재개\n즉, signal은 wait를 호출하여 큐에 삽입된 프로세스의 실행을 재개하는 연산입니다.\n가령 어떤 프로세스가 x.signal을 통해 조건 변수 x에 대한 signal을 호출했다고 가정\n이를 통해 조건 변수 x에 대해 대기 상태에 있던 프로세스가 깨어나 모니터 안으로 다시 들어옴\n모니터 안에는 하나의 프로세스만이 있다. 따라서 wait를 호출했던 프로세스는 signal을 호출한 프로세스가 모니터를 떠난 뒤에 실행되거나, signal을 호출한 프로세스의 실행을 일시 중단하고, 자신이 실행된 뒤 다시 signal을 호출한 프로세스의 수행을 재개 중요한 점은 모니터는 조건 변수를 이용하여 프로세스 실행 순서 제어를 위한 동기화를 제공 특정 프로세스가 아직 실행될 조건이 되지 않았을 때에는, wait를 통해 실행을 중단 특정 프로세스가 실행될 조건이 충족되었을 때에는, signal을 통해 실행을 재개 Reference 혼자 공부하는 컴퓨터구조+운영체제 (강민철, 한빛미디어) ","wordCount":"1544","inLanguage":"en","image":"http://localhost:1313/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E","datePublished":"2024-04-04T01:01:46+09:00","dateModified":"2024-04-04T01:01:46+09:00","author":{"@type":"Person","name":"2taezeat"},"mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:1313/posts/os/2024-04-04-%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0-+-%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C-%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4-%EB%8F%99%EA%B8%B0%ED%99%94-ch12/"},"publisher":{"@type":"Organization","name":"2taezeat, blog","logo":{"@type":"ImageObject","url":"http://localhost:1313/icon/favicon.ico"}}}</script></head><body id=top><header class=header><nav class=nav><div class=logo><a href=http://localhost:1313/ accesskey=h title="2taezeat blog (Alt + H)"><img src=http://localhost:1313/icon/apple-touch-icon.png alt aria-label=logo height=30>2taezeat blog</a><div class=logo-switches></div></div><ul id=menu><li><a href=http://localhost:1313/tags/ title=Tags><span>Tags</span></a></li><li><a href=http://localhost:1313/archives/ title=Archives><span>Archives</span></a></li><li><a href=http://localhost:1313/searchs/ title=Search><span>Search</span></a></li><li><a href=https://github.com/2taezeat title=Github><span>Github</span>&nbsp;<svg fill="none" shape-rendering="geometricPrecision" stroke="currentcolor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2.5" viewBox="0 0 24 24" height="12" width="12"><path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"/><path d="M15 3h6v6"/><path d="M10 14 21 3"/></svg></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=http://localhost:1313/>Home</a>&nbsp;»&nbsp;<a href=http://localhost:1313/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">컴퓨터구조 + 운영체제, 프로세스 동기화 (ch12)</h1><div class=post-meta><span title='2024-04-04 01:01:46 +0900 KST'>2024-04-04</span>&nbsp;·&nbsp;8 min&nbsp;·&nbsp;1544 words&nbsp;·&nbsp;2taezeat</div></header><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#121-동기화란>12.1 동기화란</a><ul><li><a href=#1211-동기화의-의미>12.1.1 동기화의 의미</a></li><li><a href=#1212-생산자와-소비자-문제>12.1.2 생산자와 소비자 문제</a></li><li><a href=#1213-공유-자원과-임계-구역>12.1.3 공유 자원과 임계 구역</a></li></ul></li><li><a href=#122-동기화-기법>12.2 동기화 기법</a><ul><li><a href=#1221-뮤텍스-락>12.2.1 뮤텍스 락</a></li><li><a href=#1222-세마포>12.2.2 세마포</a></li><li><a href=#1223-모니터>12.2.3 모니터</a></li></ul></li><li><a href=#reference>Reference</a></li></ul></nav></div></details></div><div class=post-content><p><strong>&lsquo;혼자 공부하는 컴퓨터구조+운영체제&rsquo;, ch12. 프로세스 동기화 을 읽고, 정리한다.</strong></p><hr><h1 id=121-동기화란>12.1 동기화란<a hidden class=anchor aria-hidden=true href=#121-동기화란>#</a></h1><ul><li>협력하여 실행되는 프로세스들은 <strong>실행 순서</strong>와 <strong>자원의 일관성</strong>을 보장하기 위해 <strong>동기화(synchronization)</strong> 되어야 한다</li></ul><h2 id=1211-동기화의-의미>12.1.1 동기화의 의미<a hidden class=anchor aria-hidden=true href=#1211-동기화의-의미>#</a></h2><ul><li><strong>프로세스 동기화</strong>: 프로세스들 사이의 수행 시기를 맞추는 것<ul><li><strong>실행 순서 제어</strong>: 프로세스를 <strong>올바른 순서대로 실행</strong>하기</li><li><strong>상호 배제(mutual exclusion)</strong>: 동시에 접근해서는 안 되는 자원에 하나의 프로세스만 접근하게 하기</li></ul></li></ul><blockquote><ul><li>프로세스뿐만 아니라 <strong>스레드</strong>도 동기화 대상</li><li>정확히 말하면 실행의 흐름을 갖는 모든 것은 동기화의 대상</li><li>다만 이 책에서는 대부분의 전공서 표현에 따라 &lsquo;프로세스 동기화&rsquo;라고 칭함</li></ul></blockquote><ul><li><p><strong>실행 순서 제어를 위한 동기화</strong></p><ul><li>Reader 프로세스는 Writer 프로세스 실행이 끝나야 비로소 실행할 수 있어야 한다</li><li>Writer 가 Book.txt에 값을 저장하기도 전에 Reader 가 Book.txt를 읽는 것은 올바른 실행 순서가 아니다.</li><li>Reader 는 &lsquo;Book.txt 안에 값이 존재한다&rsquo;는 <strong>특정 조건이 만족되어야만 실행을 이어나갈수 있다</strong></li><li><strong>프로세스를 올바른 순서대로 실행하는 것</strong></li></ul></li><li><p><strong>상호 배제(mutual exclusion)를 위한 동기화</strong></p><ul><li><p><strong>동시에 접근해서는 안 되는 자원에 동시에 접근하지 못하게 하는 것</strong></p></li><li><p>두 개 이상의 프로세스가 <strong>임계 구역</strong>에 <strong>동시에 접근하지 못하도록 관리</strong>하는 것</p></li><li></li></ul></li></ul><pre><code>&lt;img src=&quot;/Users/taezeat/IdeaProjects/myBlog/assets/img/blog/2024/image-20240501130315938.png&quot; alt=&quot;image-20240501130315938&quot; style=&quot;zoom:50%;&quot; /&gt;
</code></pre><ul><li><p>프로세스 A와 B가 동시에 실행되었다고 가정</p></li><li><p>17만원이 계좌에 남을 거라고 유저는 기대</p></li><li><p>A와 B는 &lsquo;잔액&rsquo;이라는 데이터를 동시에 사용하는데, A가 끝나기도 전에 B가 잔액을 읽어 버렸기 때문에 엉뚱한 결과가 나옴</p></li><li><p>A와 B를 올바르게 실행하기 위해서는 한 프로세스가 잔액에 접근했을 때 다른 프로세스는 기다려야 한다</p></li></ul><p>​</p><p>​</p><p>​</p><p>​</p><h2 id=1212-생산자와-소비자-문제>12.1.2 생산자와 소비자 문제<a hidden class=anchor aria-hidden=true href=#1212-생산자와-소비자-문제>#</a></h2><ul><li><p><strong>상호 배제</strong>를 위한 동기화에 관련된 고전적이고 유명한 문제로 <strong>생산자와 소비자 문제</strong>가 있다.</p><ul><li><p>물건을 계속해서 생산하는 프로세스인 생산자</p></li><li><p>물건을 계속해서 소비하는 프로세스인 소비자</p></li><li><p>생산자와 소비자는 동시에 실행되는 <strong>스레드</strong>가 될 수도 있다.</p></li></ul></li></ul><ul><li><p>생산자를 100,000번, 소비자를 100,000번 <strong>동시에</strong> 실행</p><ul><li><p>유저는 총합 변수가 계속 10개로 머물러 있을 것으로 기대</p></li><li><p>하지만 결과는 다름: 생산자 프로세스와 소비자 프로세스가 제대로 <strong>동기화되지 않았기 때문에</strong> 발생한 문제</p></li><li><p>생산자와 소비자는 <strong>&lsquo;총합&rsquo;이라는 데이터를 동시에 사용</strong>하는데, 생산자가 소비자의 작업이 끝나기도 전에 총합을 수정해서때문에 엉뚱한 결과가 발생</p></li><li><p>한 마디로 동시에 접근해서는 안 되는 자원에 동시에 접근했기에 발생한 문제</p></li></ul></li></ul><h2 id=1213-공유-자원과-임계-구역>12.1.3 공유 자원과 임계 구역<a hidden class=anchor aria-hidden=true href=#1213-공유-자원과-임계-구역>#</a></h2><ul><li><p>계좌 잔액 문제와 생산자 소비자 문제의 <strong>동시에 실행되는 프로세스</strong>들은 <strong>전역 변수 &lsquo;잔액&rsquo;, &lsquo;총합&rsquo;이라는 공동의 자원</strong>을 두고 작업을 했습니다.</p><ul><li><p>이러한 자원을 <strong>공유 자원; shared resource</strong> 이라 한다.</p></li><li><p>공유 자원은 <strong>전역 변수, 파일, 입출력장치, 보조기억장치</strong>가 될 수도 있다.</p></li></ul></li><li><p><strong>임계 구역; critical section</strong>: <strong>동시에 실행하면 문제가 발생하는 자원에 접근하는 코드 영역</strong></p><ul><li>임계 구역은 두 개 이상의 프로세스가 동시에 실행되면 안 되는 영역</li><li>두 개이 상의 프로세스가 임계 구역에 진입하고자 하면 둘 중 한는 <strong>대기</strong>해야 한다.</li></ul></li><li><p><strong>경쟁 상태; Race condition</strong>: 여러 프로세스가 <strong>동시 다발적으로 &lsquo;&lsquo;임계 구역&rsquo;&lsquo;의 코드를 실행</strong>하여 문제가 발생하는 경우</p><ul><li>데이터 일관성이 깨지는 문제 발생</li><li></li><li>컴퓨터는 고급 언어가 아닌 저급 언어를 실행하기 때문에 여러 줄의 저급 언어로 변환된 고급 언어한 줄을 실행하는 과정에서 문맥 교환이 일어남.</li><li>저급 언어를 실행하는 과정에서 문맥교환이 일어난다면 아래와 같은 문제가 발생</li><li></li></ul></li><li><p>**&lsquo;상호 배제를 위한 동기화&rsquo;**를 위해서는 세 가지 원칙이 반드시 지켜져야만 한다.</p><ol><li><strong>상호 배제; mutual exclusion</strong>: 한 프로세스가 임계 구역에 진입했다면, <strong>다른 프로세스는 임계 구역에 들어올 수 없다.</strong></li><li><strong>진행; progress</strong>: 임계 구역에 <strong>어떤 프로세스도 진입하지 않았다면</strong>, 임계 구역에 진입하고자 하는 프로세스는 들어갈 수 있어야 한다.</li><li><strong>유한 대기; bounded waiting</strong>: 한 프로세스가 임계 구역에 진입하고 싶다면 그 프로세스는 <strong>언젠가는</strong> 임계 구역에 들어올 수 있어야 한다 (임계 구역에 들어오기 위해 <strong>무한정 대기해서는 안 된다</strong>).</li></ol></li></ul><h1 id=122-동기화-기법>12.2 동기화 기법<a hidden class=anchor aria-hidden=true href=#122-동기화-기법>#</a></h1><h2 id=1221-뮤텍스-락>12.2.1 뮤텍스 락<a hidden class=anchor aria-hidden=true href=#1221-뮤텍스-락>#</a></h2><ul><li><p>옷 가게의 탈의실을 이용하는 것에 비유</p></li><li><p>손님-프로세스, 탈의실-임계 구역</p></li><li><p>자물쇠가 걸려 있지 않다면 탈의실을 이용하면 된다, 걸려 있다면 대기</p></li><li><p><strong>뮤텍스 락; MUTual EXclusion Lock</strong>: 이 자물쇠 기능을 코드로 구현한 것</p><ul><li><p>상호 배제를 위한 동기화 도구</p></li><li><p>임계 구역에 진입하는 프로세스는 &lsquo;내가 지금 임계 구역에 있음&rsquo;을 알리기 위해 뮤텍스 락을 이용해 임계 구역에 자물쇠를 걸어둘 수 있고</p></li><li><p>다른 프로세스는 임계 구역이 잠겨 있다면 기다리고, 잠겨 있지 않다면 임계 구역에 진입할 수 있다.</p></li></ul></li><li><p>뮤텍스 락의 단순한 형태는 하나의 전역 변수와 두 개의 함수로 구현 가능</p><ul><li>자물쇠 역할: 프로세스들이 <strong>공유</strong>하는 <strong>전역 변수 lock</strong></li><li>임계 구역을 잠그는 역할: <strong>acquire 함수</strong></li><li>임계 구역의 잠금을 해제하는 역할: <strong>release 함수</strong></li></ul></li></ul><ul><li><p><strong>acquire 함수</strong>는 프로세스가 임계 구역에 진입하기 전에 호출하는 함수</p><ul><li>만일 <strong>임계 구역</strong>이 잠겨 있다면 임계 구역이 열릴 때까지 (lock이 false가 될 때까지) 임계 구역을 반복적으로 확인하고,<ul><li>마치 탈의실 문이 잠겨 있는지 <strong>쉴 새 없이 반복하며 확인</strong>해 보는 것과 같다.</li><li>이런 대기 방식을 <strong>바쁜 대기; busy wait</strong> 이라 한다.</li></ul></li><li>임계 구역이 열려 있다면 임계 구역을 잠그는 (lock을 true로 바꾸는) 함수</li></ul></li><li><p><strong>release 함수</strong>는 임계 구역에서의 작업이 끝나고 호출하는 함수</p><ul><li>현재 잠긴 임계 구역을 열어주는 (lock을 false로 바꾸는) 함수</li></ul></li><li><p>이렇게 되면 프로세스는</p><ul><li>락을 획득할 수 없다면 (임계 구역에 진입할 수 없다면) 무작정 기다리고,</li><li>락을 획득할 수 있다면 (임계 구역에 진입할 수 있다면) 임계 구역을 잠근 뒤 임계 구역에서의 작업을 진행하고,</li><li>임계 구역에서 빠져나올 때엔 다시 임계 구역의 잠금을 해제함으로써 임계 구역을 보호할 수 있다.</li></ul></li></ul><h2 id=1222-세마포>12.2.2 세마포<a hidden class=anchor aria-hidden=true href=#1222-세마포>#</a></h2><ul><li><p><strong>세마포; semaphore</strong>는 <strong>뮤텍스 락과 비슷하지만, 조금 더 일반화된 방식</strong>의 동기화 도구</p><ul><li>엄밀히 말하면 세마포의 종류에도 이진 세마포(binary)와 카운팅 세마포(counting)가 존재</li><li>이진 세마포는 <strong>뮤텍스 락</strong>과 비슷한 개념이므로 여기서는 여러 공유 자원을 다룰 수 있는 <strong>카운팅 세마포</strong>를 다룬다</li></ul></li><li><p>탈의실이 여러 개 있는 상황처럼 공유 자원이 여러 개 있을 경우 (각 공유 자원에는 하나의 프로세스만 진입이 가능할지라도) 여러 개의 프로세스가 각각 공유 자원에 접근이 가능해야 한다.</p><ul><li>한 번에 하나의 프로세스만 이용할 수 있는 프린터 세 대가 있는 상황에서</li><li>하나의 프린터를 사용할 수 있는 프로세스는 하나이지만, <strong>총 세 개의 프로세스</strong>가 **공유 자원 (세 대의 프린터)**을 이용할 수 있다.</li></ul></li><li><p>세마포는 <strong>공유 자원이 여러 개 있는 상황</strong>에서도 적용이 가능한 동기화 도구</p></li><li><p>세마포는 뮤텍스 락과 비슷하게 하나의 변수와 두 개의 함수로 단순하게 구현할 수 있다.</p><ul><li><strong>전역변수 S</strong>: 임계 구역에 진입할 수 있는 <strong>프로세스의 개수(사용 가능한 공유 자원의 개수)</strong></li><li><strong>wait 함수</strong>: 임계 구역에 들어가도 좋은지, <strong>기다려야 할지를 알려주는 함수</strong></li><li><strong>signal 함수</strong>: 임계 구역 앞에서 기다리는 프로세스에 <strong>&lsquo;이제 가도 좋다&rsquo;고 신호</strong>를 주는 함수</li></ul></li></ul><blockquote><ul><li>여기에서 세마포 변수와 함수 이름을 각각 S, wait, signal로 나타내지만, 변수, 함수 이름은 전공서마다 다를 수 있다.</li><li>일부에서는 세마포를 처음 개발한 다익스트라에 근거해 wait와 signal 함수를 P, V로 명명</li><li>일부에서는 철도 신호기에 근거해 down, up으로 명명</li><li>다만 변수와 함수를 어떻게 지칭하든지 원리와 작동 방식은 모두 동일</li></ul></blockquote><ul><li><p><strong>wait 함수</strong></p><ul><li></li><li>만일 임계 구역에 진입할 수 있는 프로세스 개수가 0 이하라면</li><li>사용할 수 있는 자원이 있는지 <strong>반복적으로 확인</strong>하고,</li><li>임계 구역에 진입할 수 있는 프로세스 개수가 하나 이상이면 S<strong>를 1 감소시키고 임계 구역 진입</strong>한다.</li></ul></li><li><p><strong>signal 함수</strong></p><ul><li></li><li>임계 구역에서의 작업을 마친 뒤 S를 1 증가</li></ul></li></ul><ul><li><p>여기서 한 가지 문제가 있습니다.</p><ul><li>이는 <strong>뮤텍스 락에</strong>도 해당되는 문제</li><li>사용할 수 있는 공유 자원이 없는 경우 프로세스는 <strong>무작정 무한히 반복하며 전역 변수 S를 확인</strong>해야 합니다.</li><li>이렇게 **바쁜 대기(busy wait)**를 반복하며 확인할 시간에 CPU는 더 생산성 있는 작업을 할 수 있을 텐데, CPU 주기를 낭비한다는 점에서 손해</li></ul></li><li><p>그래서 실제로 <strong>세마포는 다른 더 좋은 방법</strong>을 사용</p><ul><li><strong>wait</strong> 는 만일 사용할 수 있는 자원이 없을 경우 <strong>해당 프로세스 상태</strong>를 <strong>대기 상태</strong>로 만들고,</li><li>그 프로세스의 PCB를 세마포를 위한 <strong>대기 큐</strong>에 <strong>집어 넣음</strong></li><li>다른 프로세스가 임계 구역에서의 작업이 끝나고 signal 를 호출하면 signal 는 대기 중인 프로세스를 <strong>대기 큐에서 제거</strong>하고,</li><li>프로세스 상태를 준비 상태로 변경한 뒤 <strong>준비 큐</strong>로 옮겨줌.</li></ul></li></ul><ul><li>지금까지는 <strong>상호 배제</strong>를 위한 동기화 기법</li><li>아래는, 세마포를 이용해 <strong>실행 순서 제어</strong>를 위한 동기화(프로세스의 순서를 제어하는 방법) 에 대해 설명</li><li><strong>세마포</strong>를 이용하면 동시에 실행되는 <strong>프로세스의 실행 순서도 원하는 대로 제어</strong>할 수 있다.<ul><li>세마포의 변수 S를 0으로 두고 <strong>먼저 실행할 프로세스 뒤에 signal 함수</strong>, <strong>다음에 실행할 프로세스 앞에 wait 함수</strong>를 붙이면 됩니다.</li><li></li><li>P1이 먼저 실행되면 P1이 임계 구역에 먼저 진입하는 것은 자명</li><li>P2가 먼저 실행 되더라도 P2는 wait 함수를 만나므로 P1이 임계 구역에 진입</li><li>그리고 P1이 임계 구역의 실행을 끝내고 signal을 호출하면 그제서야 P2가 임계 구역에 진입</li><li>즉, P1이 먼저 실행되든 P2가 먼저 실행되든 반드시 P1 => P2 순서대로 실행된다.</li></ul></li></ul><h2 id=1223-모니터>12.2.3 모니터<a hidden class=anchor aria-hidden=true href=#1223-모니터>#</a></h2><ul><li>세마포는 그 자체로 매우 훌륭한 프로세스 동기화 도구이지만, 사용하기가 조금 불편한 면이 있다.<ul><li>매번 임계 구역에 앞뒤로 일일이 wait와 signal 함수를 명시하는 것은 번거로운 일</li><li>더군다나 자칫 아래처럼 잘못된 코드로 인해 예기치 못한 결과를 얻을 수도 있다.</li></ul></li></ul><ul><li>최근에 등장한 동기화 도구가 <strong>모니터; montor</strong></li><li>모니터는 공유 자원과 공유 자원에 접근하기 위한 인터페이스(통로)를 묶어 관리</li><li>프로세스는 반드시 인터페이스를 통해서만 공유 자원에 접근</li></ul><ul><li><p>모니터를 통해 공유 자원에 접근하고자 하는 프로세스를 큐에 삽입하고,</p></li><li><p>큐에 삽입된 순서대로 하나씩 공유 자원을 이용하도록 합니다.</p></li><li><p>즉, 모니터는 공유 자원을 다루는 **인터페이스에 접근하기 위한 큐(모니터에 진입하기 위한 큐)**를 만들고,</p></li><li><p>모니터 안에 항상 하나의 프로세스만 들어오도록하여 <strong>상호 배제를 위한 동기화</strong>를 제공</p></li><li><p>모니터는 세마포와 마찬가지로 <strong>실행 순서 제어를 위한 동기화</strong>도 제공합니다.</p><ul><li>특정 조건을 바탕으로 프로세스를 실행, 일시 중단하기 위해 <strong>조건 변수; condition variable</strong>를 사용하는데,</li><li>조건 변수는 프로세스나 스레드의 실행 순서를 제어하기 위해 사용하는 특별한 변수입니다.</li><li>모니터가 조건 변수를 사용한다고는 하지만 <strong>조건 변수와 모니터는 별개의 개념</strong></li></ul></li><li><p><strong>조건 변수</strong>로는 wait와 signal 연산을 수행할 수 있다.</p></li><li><p><strong>wait</strong>는 호출한 프로세스의 상태를 <strong>대기 상태로 전환하고 일시적으로 조건 변수에 대한 대기 큐에 삽입</strong>하는 연산</p></li><li><p>여기서 헷갈리면 안 되는 점</p><ul><li>**모니터에 진입하기 위해 삽입되는 큐(상호 배제를 위한 큐)**와<ul><li>모니터에 한 번에 하나의 프로세스만 진입하도록 하기 위해 만들어진 큐</li></ul></li><li>wait가 호출되어 실행이 중단된 프로세스들이 삽입되는 큐**(조건 변수에 대한 큐)**는 다르다<ul><li>모니터에 이미 진입한 프로세스의 실행 조건이 만족될 때까지 잠시 실행이 중단되어 기다리기 위해 만들어진 큐</li></ul></li></ul></li></ul><ul><li>모니터에 진입한 어떤 프로세스가 x.wait() 를 통해 조건 변수 x에 대한 wait를 호출했다고 가정<ul><li>그 프로세스는 다음 그림처럼 조건 변수 x에 대한 큐에 삽입되므로 모니터는 다시 비게됩니다.</li><li>그렇기에 다른 프로세스가 모니터 안에 들어올 수 있다.</li></ul></li></ul><ul><li><p>wait 연산으로 일시 중지된 프로세스는, <strong>다른 프로세스의 signal 연산</strong>을 통해 실행이 재개</p><ul><li><p>즉, signal은 wait를 호출하여 큐에 삽입된 프로세스의 실행을 재개하는 연산입니다.</p></li><li><p>가령 어떤 프로세스가 x.signal을 통해 <strong>조건 변수 x</strong>에 대한 signal을 호출했다고 가정</p></li><li><p>이를 통해 조건 변수 x에 대해 대기 상태에 있던 프로세스가 깨어나 모니터 안으로 다시 들어옴</p></li></ul></li></ul><ul><li>모니터 안에는 하나의 프로세스만이 있다.<ul><li>따라서 wait를 호출했던 프로세스는 signal을 호출한 프로세스가 모니터를 떠난 뒤에 실행되거나,</li><li>signal을 호출한 프로세스의 실행을 일시 중단하고, 자신이 실행된 뒤 다시 signal을 호출한 프로세스의 수행을 재개</li><li>중요한 점은 모니터는 <strong>조건 변수</strong>를 이용하여 프로세스 <strong>실행 순서 제어를 위한 동기화</strong>를 제공<ul><li>특정 프로세스가 아직 실행될 조건이 되지 않았을 때에는, wait를 통해 실행을 중단</li><li>특정 프로세스가 실행될 조건이 충족되었을 때에는, signal을 통해 실행을 재개</li></ul></li></ul></li></ul><h1 id=reference>Reference<a hidden class=anchor aria-hidden=true href=#reference>#</a></h1><ul><li>혼자 공부하는 컴퓨터구조+운영체제 (강민철, 한빛미디어)</li></ul></div><footer class=post-footer><ul class=post-tags></ul><nav class=paginav><a class=prev href=http://localhost:1313/posts/os/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0-+-%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C-ch13.-%EA%B5%90%EC%B0%A9-%EC%83%81%ED%83%9C/><span class=title>« Prev</span><br><span>컴퓨터구조 + 운영체제, 교착 상태 (ch13)</span>
</a><a class=next href=http://localhost:1313/posts/os/2024-04-03-%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0-+-%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C-cpu-%EC%8A%A4%EC%BC%80%EC%A5%B4%EB%A7%81-ch11/><span class=title>Next »</span><br><span>컴퓨터구조 + 운영체제, CPU 스케쥴링 (ch11)</span></a></nav><ul class=share-buttons><li><a target=_blank rel="noopener noreferrer" aria-label="share 컴퓨터구조 + 운영체제, 프로세스 동기화 (ch12) on x" href="https://x.com/intent/tweet/?text=%ec%bb%b4%ed%93%a8%ed%84%b0%ea%b5%ac%ec%a1%b0%20%2b%20%ec%9a%b4%ec%98%81%ec%b2%b4%ec%a0%9c%2c%20%ed%94%84%eb%a1%9c%ec%84%b8%ec%8a%a4%20%eb%8f%99%ea%b8%b0%ed%99%94%20%28ch12%29&amp;url=http%3a%2f%2flocalhost%3a1313%2fposts%2fos%2f2024-04-04-%25EC%25BB%25B4%25ED%2593%25A8%25ED%2584%25B0%25EA%25B5%25AC%25EC%25A1%25B0-%2b-%25EC%259A%25B4%25EC%2598%2581%25EC%25B2%25B4%25EC%25A0%259C-%25ED%2594%2584%25EB%25A1%259C%25EC%2584%25B8%25EC%258A%25A4-%25EB%258F%2599%25EA%25B8%25B0%25ED%2599%2594-ch12%2f&amp;hashtags="><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446C483.971.0 512 28.03 512 62.554zM269.951 190.75 182.567 75.216H56L207.216 272.95 63.9 436.783h61.366L235.9 310.383l96.667 126.4H456L298.367 228.367l134-153.151H371.033zM127.633 110h36.468l219.38 290.065H349.5z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share 컴퓨터구조 + 운영체제, 프로세스 동기화 (ch12) on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=http%3a%2f%2flocalhost%3a1313%2fposts%2fos%2f2024-04-04-%25EC%25BB%25B4%25ED%2593%25A8%25ED%2584%25B0%25EA%25B5%25AC%25EC%25A1%25B0-%2b-%25EC%259A%25B4%25EC%2598%2581%25EC%25B2%25B4%25EC%25A0%259C-%25ED%2594%2584%25EB%25A1%259C%25EC%2584%25B8%25EC%258A%25A4-%25EB%258F%2599%25EA%25B8%25B0%25ED%2599%2594-ch12%2f&amp;title=%ec%bb%b4%ed%93%a8%ed%84%b0%ea%b5%ac%ec%a1%b0%20%2b%20%ec%9a%b4%ec%98%81%ec%b2%b4%ec%a0%9c%2c%20%ed%94%84%eb%a1%9c%ec%84%b8%ec%8a%a4%20%eb%8f%99%ea%b8%b0%ed%99%94%20%28ch12%29&amp;summary=%ec%bb%b4%ed%93%a8%ed%84%b0%ea%b5%ac%ec%a1%b0%20%2b%20%ec%9a%b4%ec%98%81%ec%b2%b4%ec%a0%9c%2c%20%ed%94%84%eb%a1%9c%ec%84%b8%ec%8a%a4%20%eb%8f%99%ea%b8%b0%ed%99%94%20%28ch12%29&amp;source=http%3a%2f%2flocalhost%3a1313%2fposts%2fos%2f2024-04-04-%25EC%25BB%25B4%25ED%2593%25A8%25ED%2584%25B0%25EA%25B5%25AC%25EC%25A1%25B0-%2b-%25EC%259A%25B4%25EC%2598%2581%25EC%25B2%25B4%25EC%25A0%259C-%25ED%2594%2584%25EB%25A1%259C%25EC%2584%25B8%25EC%258A%25A4-%25EB%258F%2599%25EA%25B8%25B0%25ED%2599%2594-ch12%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share 컴퓨터구조 + 운영체제, 프로세스 동기화 (ch12) on reddit" href="https://reddit.com/submit?url=http%3a%2f%2flocalhost%3a1313%2fposts%2fos%2f2024-04-04-%25EC%25BB%25B4%25ED%2593%25A8%25ED%2584%25B0%25EA%25B5%25AC%25EC%25A1%25B0-%2b-%25EC%259A%25B4%25EC%2598%2581%25EC%25B2%25B4%25EC%25A0%259C-%25ED%2594%2584%25EB%25A1%259C%25EC%2584%25B8%25EC%258A%25A4-%25EB%258F%2599%25EA%25B8%25B0%25ED%2599%2594-ch12%2f&title=%ec%bb%b4%ed%93%a8%ed%84%b0%ea%b5%ac%ec%a1%b0%20%2b%20%ec%9a%b4%ec%98%81%ec%b2%b4%ec%a0%9c%2c%20%ed%94%84%eb%a1%9c%ec%84%b8%ec%8a%a4%20%eb%8f%99%ea%b8%b0%ed%99%94%20%28ch12%29"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share 컴퓨터구조 + 운영체제, 프로세스 동기화 (ch12) on facebook" href="https://facebook.com/sharer/sharer.php?u=http%3a%2f%2flocalhost%3a1313%2fposts%2fos%2f2024-04-04-%25EC%25BB%25B4%25ED%2593%25A8%25ED%2584%25B0%25EA%25B5%25AC%25EC%25A1%25B0-%2b-%25EC%259A%25B4%25EC%2598%2581%25EC%25B2%25B4%25EC%25A0%259C-%25ED%2594%2584%25EB%25A1%259C%25EC%2584%25B8%25EC%258A%25A4-%25EB%258F%2599%25EA%25B8%25B0%25ED%2599%2594-ch12%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share 컴퓨터구조 + 운영체제, 프로세스 동기화 (ch12) on whatsapp" href="https://api.whatsapp.com/send?text=%ec%bb%b4%ed%93%a8%ed%84%b0%ea%b5%ac%ec%a1%b0%20%2b%20%ec%9a%b4%ec%98%81%ec%b2%b4%ec%a0%9c%2c%20%ed%94%84%eb%a1%9c%ec%84%b8%ec%8a%a4%20%eb%8f%99%ea%b8%b0%ed%99%94%20%28ch12%29%20-%20http%3a%2f%2flocalhost%3a1313%2fposts%2fos%2f2024-04-04-%25EC%25BB%25B4%25ED%2593%25A8%25ED%2584%25B0%25EA%25B5%25AC%25EC%25A1%25B0-%2b-%25EC%259A%25B4%25EC%2598%2581%25EC%25B2%25B4%25EC%25A0%259C-%25ED%2594%2584%25EB%25A1%259C%25EC%2584%25B8%25EC%258A%25A4-%25EB%258F%2599%25EA%25B8%25B0%25ED%2599%2594-ch12%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share 컴퓨터구조 + 운영체제, 프로세스 동기화 (ch12) on telegram" href="https://telegram.me/share/url?text=%ec%bb%b4%ed%93%a8%ed%84%b0%ea%b5%ac%ec%a1%b0%20%2b%20%ec%9a%b4%ec%98%81%ec%b2%b4%ec%a0%9c%2c%20%ed%94%84%eb%a1%9c%ec%84%b8%ec%8a%a4%20%eb%8f%99%ea%b8%b0%ed%99%94%20%28ch12%29&amp;url=http%3a%2f%2flocalhost%3a1313%2fposts%2fos%2f2024-04-04-%25EC%25BB%25B4%25ED%2593%25A8%25ED%2584%25B0%25EA%25B5%25AC%25EC%25A1%25B0-%2b-%25EC%259A%25B4%25EC%2598%2581%25EC%25B2%25B4%25EC%25A0%259C-%25ED%2594%2584%25EB%25A1%259C%25EC%2584%25B8%25EC%258A%25A4-%25EB%258F%2599%25EA%25B8%25B0%25ED%2599%2594-ch12%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentcolor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share 컴퓨터구조 + 운영체제, 프로세스 동기화 (ch12) on ycombinator" href="https://news.ycombinator.com/submitlink?t=%ec%bb%b4%ed%93%a8%ed%84%b0%ea%b5%ac%ec%a1%b0%20%2b%20%ec%9a%b4%ec%98%81%ec%b2%b4%ec%a0%9c%2c%20%ed%94%84%eb%a1%9c%ec%84%b8%ec%8a%a4%20%eb%8f%99%ea%b8%b0%ed%99%94%20%28ch12%29&u=http%3a%2f%2flocalhost%3a1313%2fposts%2fos%2f2024-04-04-%25EC%25BB%25B4%25ED%2593%25A8%25ED%2584%25B0%25EA%25B5%25AC%25EC%25A1%25B0-%2b-%25EC%259A%25B4%25EC%2598%2581%25EC%25B2%25B4%25EC%25A0%259C-%25ED%2594%2584%25EB%25A1%259C%25EC%2584%25B8%25EC%258A%25A4-%25EB%258F%2599%25EA%25B8%25B0%25ED%2599%2594-ch12%2f"><svg width="30" height="30" viewBox="0 0 512 512" fill="currentcolor" xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"><path d="M449.446.0C483.971.0 512 28.03 512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446zM183.8767 87.9921h-62.034L230.6673 292.4508V424.0079h50.6655V292.4508L390.1575 87.9921H328.1233L256 238.2489z"/></svg></a></li></ul></footer><script src=https://utteranc.es/client.js repo=2taezeat/blog_comment issue-term=pathname label=comment theme=github-light crossorigin=anonymous async></script></article></main><footer class=footer><span>&copy; 2024 <a href=http://localhost:1313/>2taezeat, blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>