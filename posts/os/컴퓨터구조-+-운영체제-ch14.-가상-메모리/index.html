<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>[컴퓨터구조 + 운영체제] ch14. 가상 메모리 | 2taezeat, blog</title>
<meta name=keywords content="OS,CS"><meta name=description content="'혼자 공부하는 컴퓨터구조+운영체제', ch14. 가상 메모리"><meta name=author content="2taezeat"><link rel=canonical href=https://2taezeat.github.io/posts/os/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0-+-%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C-ch14.-%EA%B0%80%EC%83%81-%EB%A9%94%EB%AA%A8%EB%A6%AC/><meta name=google-site-verification content="YaEERzgrvu-ZwPg7gswZdTzRMufkHw3uIH7i8hVal1c"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.ea60659c93fb4b6c01b6d070d5c41d96e09523812e590b1978e305c09ca02c83.css integrity="sha256-6mBlnJP7S2wBttBw1cQdluCVI4EuWQsZeOMFwJygLIM=" rel="preload stylesheet" as=style><link rel=icon href=https://2taezeat.github.io/icon/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://2taezeat.github.io/icon/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://2taezeat.github.io/icon/favicon-32x32.png><link rel=apple-touch-icon href=https://2taezeat.github.io/icon/apple-touch-icon.png><link rel=mask-icon href=https://2taezeat.github.io/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://2taezeat.github.io/posts/os/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0-+-%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C-ch14.-%EA%B0%80%EC%83%81-%EB%A9%94%EB%AA%A8%EB%A6%AC/><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><meta property="og:title" content="[컴퓨터구조 + 운영체제] ch14. 가상 메모리"><meta property="og:description" content="'혼자 공부하는 컴퓨터구조+운영체제', ch14. 가상 메모리"><meta property="og:type" content="article"><meta property="og:url" content="https://2taezeat.github.io/posts/os/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0-+-%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C-ch14.-%EA%B0%80%EC%83%81-%EB%A9%94%EB%AA%A8%EB%A6%AC/"><meta property="og:image" content="https://2taezeat.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-04-06T11:30:03+00:00"><meta property="article:modified_time" content="2024-04-06T11:30:03+00:00"><meta property="og:site_name" content="2taezeat, blog"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://2taezeat.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="[컴퓨터구조 + 운영체제] ch14. 가상 메모리"><meta name=twitter:description content="'혼자 공부하는 컴퓨터구조+운영체제', ch14. 가상 메모리"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://2taezeat.github.io/posts/"},{"@type":"ListItem","position":2,"name":"[컴퓨터구조 + 운영체제] ch14. 가상 메모리","item":"https://2taezeat.github.io/posts/os/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0-+-%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C-ch14.-%EA%B0%80%EC%83%81-%EB%A9%94%EB%AA%A8%EB%A6%AC/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"[컴퓨터구조 + 운영체제] ch14. 가상 메모리","name":"[컴퓨터구조 \u002b 운영체제] ch14. 가상 메모리","description":"'혼자 공부하는 컴퓨터구조+운영체제', ch14. 가상 메모리","keywords":["OS","CS"],"articleBody":"14.1 연속 메모리 할당 연속 메모리 할당 방식: 프로세스에 연속적인 메모리 공간을 할당하는 방식 14.1.1 스와핑 메모리에 적재된 프로세스들 중에는 현재 실행되지 않는 프로세스가 존재 입출력 작업의 요구로 대기 상태가 된 프로세스 오랫동안 사용되지 않은 프로세스 스와핑; swapping: 이러한 프로세스들을 임시로 보조기억장치 일부 영역으로 쫓아내고, 그렇게 해서 생긴 메 모리상의 빈 공간에 또 다른 프로세스를 적재하여 실행하는 방식 스왑 영역; swap space: 프로세스들이 쫓겨나는 보조기억장치의 일부 영역 스왑 아웃; swap-out: 현재 실행되지 않는 프로세스가 메모리에서 스왑 영역으로 옮겨지는 것 스왑 인; swap-in: 반대로스왑 영역에 있던 프로세스가 다시 메모리로 옮겨오는 것 스왑 아웃되었던 프로세스가 다시 스왑 인될 때는 스왑 아웃되기 전의 물리 주소와는 다른 주소에 적재될 수 있다 스와핑을 이용하면 프로세스들이 요구하는 메모리 주소 공간의 크기가 실제 메모리 크기보다 큰 경우에도 프로세스들을 동시 실행 가능 프로세스 A, B, C, D의 크기를 합하면 메모리의 크기보다 크지만, 스와핑을 통해 네 개의 프로세스를 동시에 실행 가능 14.1.2 메모리 할당 프로세스는 메모리 내의 빈 공간에 적재되어야 한다.\n여기에는 세 가지 방식이 존재 14.1.2.1 최초 적합, first fit 최초 적합은 운영체제가 메모리 내의 빈 공간을 순서대로 검색하다가 적재할 수 있는 공간을 발견하면 그 공간에 바로 프로세스를 배치하는 방식\n최초 적합 방식은 프로세스가 적재될 수 있는 공간을 발견하는 즉시 메모리를 할당하는 방식이므로 검색을 최소화 및 빠른 할당이 가능\n14.1.2.2 최적 적합, best fit 최적 적합 운영체제가 빈 공간을 모두 검색해 본 후, 프로세스가 적재될 수 있는 공간 중 가장 작은 공간에 프로세스를 배치하는 방식 최적 적합 방식으로 메모리를 할당하면 프로세스는 빈공간 C에 할당됩니다. 14.1.2.3 최악 접합, worst fit 최악 적합은 운영체제가 빈 공간을 모두 검색해 본 후, 프로세스가 적재될 수 있는 공간 중 가장 큰 공간에 프로세스를 배치하는 방식 최악 적합 방식으로 메모리를 할당하면 프로세스는 빈공간 B에 할당됩니다. 14.1.3 외부 단편화 연속 메모리 할당은 언뜻 들으면 당연하게 느껴질 수 있지만, 사실 이는 메모리를 효율적으로 사용하는 방법이 아니다.\n왜냐하면 외부단편화; external fragmentation 라는 문제를 내포하고 있기 때문\n프로세스들이 메모리에 연속적으로 할당되는 환경에서는 실행되고 종료되기를 반복하며 메모리 사이 사이에 빈 공간들이 생긴다.\n프로세스 바깥에 생기는 이러한 빈 공간들은 분명 빈 공간이지만 그 공간보다 큰 프로세스를 적재하기 어려운 상황을 초래하고, 결국 메모리 낭비로 이어짐\n이러한 현상을 외부단편화; external fragmentation 라 한다.\n외부 단편화: 프로세스를 할당하기 어려울 만큼 작은 메모리 공간들로 인해 메모리가 낭비되는 현상\n외부 단편화를 해결할 수 있는 대표적인 방안으로 메모리를 압축; compaction(메모리 조각 모음) 하는 방법이 존재\n흩어져 있는 빈 공간들을 하나로 모으는 방식으로 프로세스를 재배치시켜 흩어져 있는 작은 빈 공간들을 하나의 큰 빈 공간으로 만드는 방법 압축 방식은 여러 단점 존재\n작은 빈 공간들을 하나로 모으는 동안 시스템은 하던 일을 중지해야 하고,\n메모리에 있는 내용을 옮기는 작업은 많은 오버헤드를 야기하며,\n어떤 프로세스를 어떻게 움직여야 오버헤드를 최소화하며 압축할 수 있는지에 대한 명확한 방법을 결정하기 어려움\n이에 외부 단편화를 없앨 수 있는 또 다른 해결 방안 - 오늘날까지도 사용되는 가상 메모리 기법, 그 중에서도 페이징 기법\n14.2 페이징을 통한 가상 메모리 관리 프로세스를 메모리에 연속적으로 할당하는 방식은 두 가지 문제를 내포\n외부 단편화\n물리 메모리보다 큰 프로세스를 실행할 수 없다는 점\n가상 메모리 virtual memory는 실행하고자 하는 프로그램을 일부만 메모리에 적재하여 실제 물리 메모리 크기보다 더 큰 프로세스를 실행할 수 있게 하는 기술\n가상 메모리 관리 기법에는 크게 페이징과 세그멘테이션이 존재 페이징 기법을 이용하면 물리 메모리보다 큰 프로세스를 실행할 수 있을 뿐만아니라, 앞선 절에서 배운 외부 단편화 문제도 해결할 수 있다. 현대 대부분의 운영체제가 사용 14.2.1 페이징이란 외부 단편화가 생긴 근본적인 이유는 각기 다른 크기의 프로세스가 메모리에 연속적으로 할당되었기 때문 페이징은 메모리의 물리 주소 공간을 프레임; frame 단위로 자르고, 프로세스의 논리 주소 공간을 페이지; page 단위로 자른 뒤, 각 페이지(page, 논리) 를 프레임(frame, 물리) 에 할당하는 가상 메모리 관리 기법 페이징에서도 스와핑을 사용할 수 있다. 페이징을 사용하는 시스템에서는 프로세스 전체가 스왑 아웃/스왑 인되는 것이 아닌, 페이지 단위로 스왑 아웃/스왑 인 된다. 즉, 메모리에 적재될 필요가 없는 페이지들은 보조기억장치로 스왑 아웃(페이지 아웃) 되고, 실행에 필요한 페이지들은 메모리로 스왑 인(페이지 인) 되는 것 한 프로세스를 실행하기 위해 프로세스 전체가 메모리에 적재될 필요가 없다는 말과 같다. 프로세스를 이루는 페이지 중 실행에 필요한 일부 페이지만을 메모리에 적재하고, 당장 실행에 필요하지 않은 페이지들은 보조기억장치에 남겨둘 수 있다. 이와 같은 방식을 통해 물리 메모리보다 더 큰 프로세스를 실행할 수 있다 14.2.1.1 페이징의 이점 - 쓰기 시 복사 운영체제에서 fork 시스템 호출을 하면 부모 프로세스의 복사본이 자식 프로세서로서 만들어짐.\n복사 작업은 프로세스 생성 시간을 늦출 뿐만 아니라 불필요한 메모리 낭비를 야기\n부모 프로세스 혹은 자식 프로세스 둘 중 하나가 페이지에 쓰기 작업을 하면, 그 순간 해당 페이지가 별도의 공간으로 복제\n각 프로세스는 자신의 고유한 페이지가 할당된 프레임을 가리키킴, 이것이 쓰기 시 복사; copy on write 이다. 프로세스 생성 시간을 줄이는 것은 물론 메모리 공간 절약도 가능 14.2.1.2 계층적 페이징 페이지 테이블의 크기는 작지 않다. 프로세스를 이루는 모든 페이지 테이블 엔트리를 메모리에 두는 것은 큰 메모리 낭비 이에 프로세스를 이루는 모든 페이지 테이블 엔트리를 항상 메모리에 유지하지 않을 수 있는 방법이 등장 계층적 페이징; hierarchical Paging 계층적 페이징은 페이지 테이블을 페이징하여 여러 단계의 페이지를 두는 방식 여러 단계의 페이지를 둔다는 점에서 다단계 페이지 테이블; multilevel page table 기법으로 불린다. 페이지 테이블을 여러 개의 페이지로 자르고, 바깥쪽에 페이지 테이블을 하나 더 두어 잘린 페이지 테이블의 페이지들을 가리키게 하는 방식 페이지 테이블을 이렇게 계층적으로 구성하면 모든 페이지 테이블을 항상 메모리에 유지할 필요가 없다. 페이지 테이블들 중 몇 개는 보조기억장치에 있어도 무방하며, 추후 해당 페이지 테이블을 참조해야 할 때가 있으면 그때 메모리에 적재 다만 CPU와 가장 가까이 위치한 페이지 테이블(Outer 페이지 테이블)은 항상 메모리에 유지해야 한다. 계층적 페이징을 이용하는 환경에서의 논리 주소는 아래와 같은 형태로 만들어짐. 바깥 페이지 번호에 해당하는 항목은 CPU와 근접한 곳에 위치한 (바깥에 위치한) 페이지 테이블 엔트리를 가리키고 안쪽 페이지 번호는 첫 번째 페이지 테이블 바깥에 위치한 두 번째 페이지 테이블, 즉 페이지 테이블의 페이지 번호를 가리킴 논리 주소를 토대로 주소 변환은 다음과 같이 이루어짐 바깥 페이지 번호를 통해, 페이지 테이블의 페이지를 찾기 페이지 테이블의 페이지를 통해 프레임 번호를 찾고 변위를 더함으로서 물리 주소 얻기 페이지 테이블의 계층이 늘어날수록 페이지 폴트가 발생했을 경우 메모리 참조 횟수가 많아짐. 계층이 많다고 해서 반드시 좋다고 볼 수는 없다. 14.2.2 페이지 테이블 여기서 문제가 있다. 프로세스가 메모리에 불연속적으로 배치되어 있다면 CPU 입장에서 이를 순차적으로 실행할 수가 없다. 프로세스를 이루는 페이지가 어느 프레임에 적재되어 있는지 CPU가 모두 알고 있기란 어렵기 때문입 즉, 프로세스가 메모리에 불연속적으로 배치되면 CPU 입장에서 ‘다음에 실행할 명령어 위치’ 를 찾기가 어려움 이를 해결하기 위해 페이징 시스템은 프로세스가 비록 (실제 메모리 내의 주소인) 물리 주소에 불연속적으로 배치되더라도 (CPU가 바라보는 주소인) 논리 주소에는 연속적으로 배치되도록 페이지 테이블; page table을 이용 페이지 테이블은 페이지 번호와 프레임 번호를 짝지어 줌 (매핑) CPU로 하여금 페이지 번호만 보고 해당 페이지가 적재된 프레임을 찾을 수 있게 한다. 페이지 테이블은 현재 어떤 페이지가 어떤 프레임에 할당되었는지를 알려줌. 프로세스마다 각자의 페이지 테이블을 가지고 있고 각 프로세스의 페이지 테이블들은 메모리에 적재되어 있다. CPU 내의 Page Table Base Register; PTBR는 각 프로세스의 페이지 테이블이 적재된 주소를 가리킴 이러한 각 프로세스들의 페이지 테이블 정보들은 각 프로세스의 PCB에 기록\n프로세스의 문맥 교환이 일어날 때 다른 레지스터와 마찬가지로 함께 변경\n페이지 테이블을 메모리에 두면 문제가 발생 - 두 번의 메모리 접근이 필요하게 됨 메모리에 있는 페이지 테이블을 보기 위해 한 번 그렇게 알게 된 프레임에 접근하기위해 한 번 이 문제를 해결하기 위해, CPU 곁에 (MMU 내에) TLB; Translation Lookaside Buffer라는 페이지 테이블의 캐시 메모리를 둔다. CPU 곁에는 TLB가 있다. TLB는 페이지 테이블의 캐시이기 때문에 페이지 테이블의 일부 내용을 저장 참조 지역성에 근거해 주로 최근에 사용된 페이지 위주로 가져와 저장 CPU가 발생한 논리 주소에 대한 페이지 번호가 TLB에 있을 경우 이를 TLB hit 라 한다.\n페이지가 적재된 프레임을 알기 위해 메모리에 접근할 필요가 없다. 그렇기에 메모리 접근을 한 번만 하면 됩니다. 페이지 번호가 TLB에 없을 경우, 어쩔 수 없이 페이지가 적재된 프레임을 알기 위해 메모리 내의 페이지 테이블에 접근하는 수 밖에 없다. - TLB miss\n14.2.3 내부 단편화 페이징은 외부 단편화 문제를 해결할 수 있지만, 내부 단편화(internal fragmentation) 문제를 야기할 수 있다.\n페이징은 프로세스의 논리 주소 공간을 페이지라는 일정한 크기 단위로 자름 그런데 모든 프로세스가 페이지 크기에 딱 맞게 잘리는 것은 아니다, 모든 프로세스 크기가 페이지의 배수는 아니다. 가령 페이지 크기가 10 KB인데, 프로세스의 크기가 108 KB 인 경우, 마지막 페이지는 2(=110-108) KB 만큼의 크기가 남음 이러한 메모리 낭비를 내부 단편화라고 합니다.\n내부 단편화는 하나의 페이지 크기보다 작은 크기로 발생\n하나의 페이지 크기가 작다면 발생하는 내부 단편화의 크기는 작아질 것으로 기대할 수 있다.\n하지만 하나의 페이지 크기를 너무 작게 설정하면, 그만큼 페이지 테이블의 크기도 커지기 때문에 페이지 테이블이 차지하는 공간이 낭비\n그렇기에 내부 단편화를 적당히 방지하면서 너무 크지 않은 페이지 테이블이 만들어지도록 페이지의 크기를 조정하는 것이 중요\n일부 운영체제에서는 기본적으로 설정된 페이지 크기보다 더 큰 크기의 페이지; 대형 페이지(huge page) 도 일부 허용하며 메모리에 유지하는 경우도 있다. 14.2.4 페이징에서의 주소 변환 하나의 페이지 혹은 프레임은 여러 주소를 포괄, 그렇기에 특정 주소에 접근하려면 아래와 같은 두 가지 정보가 필요\n어떤 페이지 혹은 프레임에 접근하고 싶은지 (페이지 번호) 접근하려는 주소가 그 페이지 혹은 프레임으로부터 얼마나 떨어져 있는지(offset) 그렇기에 페이징 시스템에서는 모든 논리 주소 페이지 번호 page number와 변위; offset로 이루어져 있습니다. 가령 CPU가 32비트 주소를 내보냈다면, 이 중 N비트는 페이지 번호, 32-N 비트는 변위 페이지 번호: 말 그대로 접근하고자 하는 페이지 번호 페이지 테이블에서 해당 페이지 번호를 찾으면 페이지가 어떤 프레임에 할당되었는지를 알 수 있음 변위는 접근하려는 주소가 프레임의 시작 번지로부터 얼만큼 떨어져 있는지를 알기 위한 정보 즉, 논리 주소 [페이지 번호, 변위] 는 페이지 테이블을 통해 물리 주소 [프레임 번호, 변위] 로 변환 14.2.5 페이지 테이블 엔트리 페이지 테이블 엔트리PTE; Page Table Enty: 페이지 테이블의 각각의 행들 14.2.5.1 유효 비트; valid bit 유효 비트 현재 해당 페이지에 접근 가능한지 여부를 알려줌 (중요한 정보)\n일반적으로 프로세스를 이루는 모든 페이지가 메모리에 있지 않는다. (스와핑 때문)\n일부 페이지는 보조기억장치(스왑 영역) 에 있는 경우가 많다. 유효 비트는 현재 페이지가 메모리에 적재되어 있는지(=1) 아니면 보조기억장치에 있는지를 알려주는 비트(=0)\n만일 CPU가 유효 비트가 0인 메모리에 적재되어 있지 않은 페이지로 접근하려고 하면, 페이지 폴트; Page fault 라는 예외(Exception)가 발생\nCPU가 페이지 폴트를 처리하는 과정은 하드웨어 인터럽트를 처리하는 과정과 유사\nCPU는 기존의 작업 내역을 백업 페이지 폴트 처리 루틴을 실행 페이지 처리 루틴은 원하는 페이지를 메모리로 가져온 뒤 유효 비트를 1로 변경해 준다. 페이지 폴트를 처리했다면, CPU는 해당 페이지에 접근 가능 14.2.5.2 보호 비트; protection bit 보호 비트는 페이지 보호 기능을 위해 존재하는 비트입니다. 보호 비트를 통해 해당 페이지가 읽고 쓰기가 모두 가능한 페이지인지, 혹은 읽기만 가능한 페이지인지를 나타낼 수 있다. 보호 비트는 읽기(Read, r), 쓰기(Write, w), 실행(eXecute, x)의 조합으로 읽기, 쓰기, 실행하기 권한의 나타낸다. 보호 비트가 100인 페이지의 경우 1은 1, w와 x는 0이므로 이 페이지는 읽기만 가능 보호 비트가 110인 페이지의 경우 이 페이지는 읽고 쓰기만 가능하고 실행은 불가능 보호 비트가 111인페이지는 읽기, 쓰기, 실행이 모두 가능 14.2.5.3 참조 비트; reference bit 참조 비트 CPU가 이 페이지에 접근한 적이 있는지 여부를 나타냄. 적재 이후 CPU가 읽거나 쓴 페이지는 참조 비트가 1로 세팅되고, 적재 이후 읽거나 쓴 적이 없는 페이지는 0으로 유지 14.2.5.4 수정 비트; modified bit, dirty bit 수정 비트는 해당 페이지에 데이터를 쓴 적(write) 이 있는지 없는지 수정 여부를 알려줌.\n이 비트가 1이면 변경된 적이 있는 페이지, 0이면 변경된 적이 없는 페이지(한 번도 접근한 적 없거나, read만 했던 페이지)임을 나타냄.\n수정 비트는 페이지가 메모리에서 사라질 때, 보조기억장치에 쓰기 작업을 해야 하는지, 할 필요가 없는지를 판단하기 위해 존재\n이렇게 수정된 적이 있는 페이지가 스왑 아웃될 경우 변경된 값을 보조기억장치에 기록하는 작업이 추가되어야 함. 페이지 테이블 엔트리에 수정 비트를 통해 이 작업 필요성을 판단 14.3 페이지 교체와 프레임 할당 14.3.1 요구 페이징 요구 페이징; demand paging: 프로세스를 메모리에 적재할 때 처음부터 모든 페이지를 적재하지 않고 필요한 페이지만을 메모리에 적재하는 기법 요구 페이징의 기본적인 양상 CPU가 특정 페이지에 접근하는 명령어를 실행한다. 해당 페이지가 현재 메모리에 있을 경우 (유효 비트가 1일 경우) CPU는 페이지가 적재된 프레임에 접근한다. 해당 페이지가 현재 메모리에 없을 경우 (유효 비트가 0일 경우) 페이지 폴트가 발생한다. 페이지 폴트 처리 루틴은 해당 페이지를 메모리로 적재하고 유효 비트를 1로 설정한다. 다시 1번을 수행한다. 14.3.2 페이지 교체 알고리즘 요구 페이징 기법으로 페이지들을 적재하다 보면 언젠가 메모리가 가득 참\n이때는 당장 실행에 필요한 페이지를 적재하기 위해 메모리에 적재된 페이지를 보조기억장치로 내보내야 한다. 페이지 교체 알고리즘: 메모리에 적재된 많고 많은 페이지 중 어떤 페이지를 내보내는 것이 최선인지 결정하는 방법\n쫓아낼 페이지를 결정하는 방법 좋은 페이지 교체 알고리즘\n일반적으로 페이지 폴트를 가장 적게 일으키는 알고리즘 어떤 알고리즘을 통해 고른 페이지를 스왑 아웃시켜도 페이지 폴트가 자주 발생하지 않는다면 이는 성능 저하를 방지하는 좋은 알고리즘 페이지 폴트가 일어나면 보조기억장치로부터 페이지를 가져와야 하기에 메모리에 적재된 페이지를 가져오는 것보다 느려지기 때문 한 알고리즘을 통해 고른 페이지를 스왑 아웃시켰을 때 페이지 폴트가 자주 발생하면 이는 좋은 알고리즘이 아님.\n내보내면 안 되는 페이지를 보조기억장치로 내보냈기 때문 페이지 교체 알고리즘을 이해하려면 페이지 폴트 횟수를 알 아야 한다.\n페이지 폴트 횟수는 페이지 참조열; page reference sting을 통해 알 수 있다. 페이지 참조열; page reference sting: CPU가 참조하는 페이지들 중 연속된 페이지를 생략한 페이지열\n연속된 페이지를 생략하는 이유는 중복된 페이지를 참조하는 행위는 페이지 폴트를 발생시키지 않기 때문 14.3.2.1 FIFO, 페이지 교체 알고리즘 First-in First-Out 이름 그대로 메모리에 가장 먼저 올라온 페이지부터 내쫓는 방식 ““오래 머물렀다면 나가라\"는 알고리즘 장점: 아이디어와 구현이 간단 단점: 실행 초기에 적재된 페이지 속에는 프로그램 실행 내내 사용될 내용을 포함하고 있을 수도 있다. 이런 페이지는메모리에 먼저 적재되었다고 해서 내쫓아내는 것은 비효율 14.3.2.1 Optimal(최적), 페이지 교체 알고리즘 앞으로의 사용 빈도가 가장 낮은 페이지를 교체하는 알고리즘\nCPU에 의해 참조되는 횟수를 고려\n잘 생각해 보면 메모리에 오랫동안 남아야 할 페이지는 자주 사용될 페이지 보조기억장치로 내보내야 할 페이지는 앞으로 사용 빈도가 가장 낮은 페이지 장점: 타 페이지 교체 알고리즘에 비해 페이지 폴트 발생 빈도가 가장 낮다.\n단점: 최적 페이지 교체 알고리즘은 실제 구현이 어려움: ‘앞으로 오랫동안 사용되지 않을 페이지’를 예측하기란 어렵다.\n프로세스가 앞으로 메모리 어느 부분을 어떻게 참조할지 미리 알아야 하는데, 이는 현실적으로 불가능 다른 페이지 교체 알고리즘의 이론상 성능을 평가하기 위한 목적으로 사용\n최적 페이지 교체 알고리즘(하한선)에 비해 얼만큼 페이지 폴트 횟수가 발생하느냐를 통해 페이지 교체 알고리즘을 평가하기 위해 사용 14.3.2.1 LRU, 페이지 교체 알고리즘 가장 오랫동안 사용되지 ‘않은’ 페이지를 교체하는 알고리즘은 구현이 가능, Least Recenty Used ‘최근에 사용되지 않은 페이지는 앞으로도 사용되지 않을 것’이라는 아이디어를 토대로 만들어짐 페이지마다 마지막으로 사용한 시간을 토대로 최근에 가장 사용이 적었던 페이지를 교체 14.3.3 스래싱과 프레임 할당 페이지 폴트가 자주 발생하는 이유에 나쁜 페이지 교체 알고리즘만 있는 건 아니다. 프로세스가 사용할 수 있는 프레임 수가 적어도 페이지 폴트는 자주 발생 사실 이것이 더 근본적인 이유라고 볼 수 있다. 이처럼 프레임이 부족하면 CPU는 페이지 폴트가 자주 발생할 수밖에 없다. 실행의 맥이 탁 탁끊기고, 결과적으로 CPU의 이용률도 떨어짐 페이지 교체에 너무 많은 시간을 쏟으면 당연히 성능에도 큰 악영향 프로세스가 실제 실행되는 시간보다 페이징에 더 많은 시간을 소요하여 성능이 저해되는 것을 스래싱; thrashling 이라 한다. 가로축인 멀티프로그래밍의 정도를 통해 메모리에 올라와 있는 프로세스의 수를 알 수 있다.\n멀티프로그래밍의 정도: 메모리에서 동시 실행되는 프로세스의 수 멀티프로그래밍의 정도가 높다면 현재 메모리에는 많은 프로세스가 동시에 실행 중이라는 이야기 동시에 실행되는 프로세스의 수 (멀티프로그래밍의 정도)를 늘린다고 해서 CPU 이용률이 비례해서 증가하는 것이 아님\n필요 이상으로 늘리면 각 프로세스들이 사용할 수 있는 프레임 수가 적어지기 때문에 페이지 폴트가 지나치게 빈번히 발생\n스래싱이 발생하는 근본적인 원인은 각 프로세스가 필요로 하는 최소한의 프레임 수가 보장되지 않았기 때문\n균등 할당; equal allocation: 모든 프로세스에 균등하게 프레임을 제공하는 방식\n실행되는 프로세스들의 크기는각기 다른데, 천편일률적으로 동일한 프레임 개수를 할당하는 것은 비합리적 가장 단순한 형태의 프레임 할당 방식 비례 할당; proportional allocation: 프로세스의 크기가 크면 프레임을 많이 할당하고 크기가 작으면 프레임을 적게 나눠주는 방식\n프로세스의 크기와 프레임이 필요한 경우의 수는 비례하지 않을 수 있다. 한계점: 프로세스가 실제로 얼마나 많은 프레임이 필요할지는 결국 실행해 봐야 아는 경우가 많다. 균등 할당과 비례 할당 방식은 프로세스의 실행 과정을 고려하지 않고 단순히 프로세스의 크기와 물리 메모리의 크기만을 고려한 방식이라는 점에서 정적 할당 방식 이라 한다.\n프로세스를 실행하는 과정에서 배분할 프레임을 결정하는 방식 (동적 할당 방식) 작업 집합 모델; working set model 을 사용하는 방식 페이지 폴트 빈도 PPF; Page-Fault Frequency를 사용하는 방식 이 두 개 방식은 프로세스의 실행을 보고 할당할 프레임 수를 결정한다는 점에서 동적 할당 방식 이라 한다. 작업 집합; working set: 실행 중인 프로세스가 일정 시간 동안 참조한 페이지의 집합 작업 집합 모델 기반 프레임 할당 방식은 ‘프로세스가 일정 기간 동안 참조한 페이지 집합’을 기억하여 빈번한 페이지 교체를 방지 CPU가 메모리를 참조할 때에는 참조 지역성의 원리에 의거해 주로 비슷한 구역을 집중적으로 참조 만약 CPU가 어떤 프로세스를 실행하는 동안 3초에 20개의 페이지를 집중적으로 참조했다면 운영체제는 그 프로세스를 위해 그 순간만큼은 최소 20개의 프레임을 할당하면 된다. 페이지 폴트 기반, 두 개의 가정에서 생겨난 아이디어\n페이지 폴트율이 너무 높으면 그 프로세스는 너무 적은 프레임을 갖고 있다. 페이지 폴트율이 너무 낮으면 그 프로세스가 너무 많은 프레임을 갖고 있다. 만일 페이지 폴트율이 상한선보다 더 높아지면 그 프로세스는 너무 적은 프레임을 갖고 있다고 볼 수있다.\n이 경우 프레임을 더 할당해 주면 됩니다. 반대로 페이지 폴트율이 하한선보다 더 낮아지면 그 프로세스는 너무 많은 프레임을 갖고 있다고 볼 수 있다.\n이 경우 다른 프로세스에 할당하기 위해 프레임을 회수합니다. 페이지 폴트 빈도 기반 프레임 할당 방식은 페이지 폴트율 에 상한선과 하한선을 정하고, 이 범위 안에서만 프레임을 할당\nReference 혼자 공부하는 컴퓨터구조+운영체제 (강민철, 한빛미디어) https://product.kyobobook.co.kr/detail/S000061584886 ","wordCount":"2681","inLanguage":"en","image":"https://2taezeat.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E","datePublished":"2024-04-06T11:30:03Z","dateModified":"2024-04-06T11:30:03Z","author":{"@type":"Person","name":"2taezeat"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://2taezeat.github.io/posts/os/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0-+-%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C-ch14.-%EA%B0%80%EC%83%81-%EB%A9%94%EB%AA%A8%EB%A6%AC/"},"publisher":{"@type":"Organization","name":"2taezeat, blog","logo":{"@type":"ImageObject","url":"https://2taezeat.github.io/icon/favicon.ico"}}}</script></head><body id=top><header class=header><nav class=nav><div class=logo><a href=https://2taezeat.github.io/ accesskey=h title="2taezeat blog (Alt + H)"><img src=https://2taezeat.github.io/icon/apple-touch-icon.png alt aria-label=logo height=30>2taezeat blog</a><div class=logo-switches></div></div><ul id=menu><li><a href=https://2taezeat.github.io/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://2taezeat.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://2taezeat.github.io/searchs/ title=Search><span>Search</span></a></li><li><a href=https://github.com/2taezeat title=Github><span>Github</span>&nbsp;<svg fill="none" shape-rendering="geometricPrecision" stroke="currentcolor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2.5" viewBox="0 0 24 24" height="12" width="12"><path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"/><path d="M15 3h6v6"/><path d="M10 14 21 3"/></svg></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://2taezeat.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://2taezeat.github.io/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">[컴퓨터구조 + 운영체제] ch14. 가상 메모리</h1><div class=post-description>'혼자 공부하는 컴퓨터구조+운영체제', ch14. 가상 메모리</div><div class=post-meta><span title='2024-04-06 11:30:03 +0000 +0000'>2024-04-06</span>&nbsp;·&nbsp;13 min&nbsp;·&nbsp;2681 words&nbsp;·&nbsp;2taezeat</div></header><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#141-연속-메모리-할당>14.1 연속 메모리 할당</a><ul><li><a href=#1411-스와핑>14.1.1 스와핑</a></li><li><a href=#1412-메모리-할당>14.1.2 메모리 할당</a><ul><li><a href=#14121-최초-적합-first-fit>14.1.2.1 최초 적합, first fit</a></li><li><a href=#14122-최적-적합-best-fit>14.1.2.2 최적 적합, best fit</a></li><li><a href=#14123-최악-접합-worst-fit>14.1.2.3 최악 접합, worst fit</a></li></ul></li><li><a href=#1413-외부-단편화>14.1.3 외부 단편화</a></li></ul></li><li><a href=#142-페이징을-통한-가상-메모리-관리>14.2 페이징을 통한 가상 메모리 관리</a><ul><li><a href=#1421-페이징이란>14.2.1 페이징이란</a><ul><li><a href=#14211-페이징의-이점---쓰기-시-복사>14.2.1.1 페이징의 이점 - 쓰기 시 복사</a></li><li><a href=#14212-계층적-페이징>14.2.1.2 계층적 페이징</a></li></ul></li><li><a href=#1422-페이지-테이블>14.2.2 페이지 테이블</a></li><li><a href=#1423-내부-단편화>14.2.3 내부 단편화</a></li><li><a href=#1424-페이징에서의-주소-변환>14.2.4 페이징에서의 주소 변환</a></li><li><a href=#1425-페이지-테이블-엔트리>14.2.5 페이지 테이블 엔트리</a><ul><li><a href=#14251-유효-비트-valid-bit>14.2.5.1 유효 비트; valid bit</a></li><li><a href=#14252-보호-비트-protection-bit>14.2.5.2 보호 비트; protection bit</a></li><li><a href=#14253-참조-비트-reference-bit>14.2.5.3 참조 비트; reference bit</a></li><li><a href=#14254-수정-비트-modified-bit-dirty-bit>14.2.5.4 수정 비트; modified bit, dirty bit</a></li></ul></li></ul></li><li><a href=#143-페이지-교체와-프레임-할당>14.3 페이지 교체와 프레임 할당</a><ul><li><a href=#1431-요구-페이징>14.3.1 요구 페이징</a></li><li><a href=#1432-페이지-교체-알고리즘>14.3.2 페이지 교체 알고리즘</a><ul><li><a href=#14321-fifo-페이지-교체-알고리즘>14.3.2.1 FIFO, 페이지 교체 알고리즘</a></li><li><a href=#14321-optimal최적-페이지-교체-알고리즘>14.3.2.1 Optimal(최적), 페이지 교체 알고리즘</a></li><li><a href=#14321-lru-페이지-교체-알고리즘>14.3.2.1 LRU, 페이지 교체 알고리즘</a></li></ul></li><li><a href=#1433-스래싱과-프레임-할당>14.3.3 스래싱과 프레임 할당</a></li></ul></li><li><a href=#reference>Reference</a></li></ul></nav></div></details></div><div class=post-content><h1 id=141-연속-메모리-할당>14.1 연속 메모리 할당<a hidden class=anchor aria-hidden=true href=#141-연속-메모리-할당>#</a></h1><ul><li>연속 메모리 할당 방식: 프로세스에 연속적인 메모리 공간을 할당하는 방식</li></ul><p><img loading=lazy src=/images/before/image-20240502221545717.png alt=image-20240502221545717.png width=680 height=auto></p><h2 id=1411-스와핑>14.1.1 스와핑<a hidden class=anchor aria-hidden=true href=#1411-스와핑>#</a></h2><p><img loading=lazy src=/images/before/image-20240502221936392.png alt=image-20240502221936392.png width=680 height=auto></p><ul><li>메모리에 적재된 프로세스들 중에는 현재 실행되지 않는 프로세스가 존재<ul><li>입출력 작업의 요구로 대기 상태가 된 프로세스</li><li>오랫동안 사용되지 않은 프로세스</li></ul></li><li><strong>스와핑; swapping</strong>: 이러한 프로세스들을 임시로 보조기억장치 일부 영역으로 쫓아내고, 그렇게 해서 생긴 메 모리상의 빈 공간에 또 다른 프로세스를 적재하여 실행하는 방식</li><li><strong>스왑 영역; swap space</strong>: 프로세스들이 쫓겨나는 <strong>보조기억장치의 일부 영역</strong></li><li><strong>스왑 아웃; swap-out</strong>: 현재 실행되지 않는 프로세스가 메모리에서 스왑 영역으로 옮겨지는 것</li><li><strong>스왑 인; swap-in</strong>: 반대로스왑 영역에 있던 프로세스가 다시 메모리로 옮겨오는 것</li><li>스왑 아웃되었던 프로세스가 다시 스왑 인될 때는 스왑 아웃되기 전의 물리 주소와는 다른 주소에 적재될 수 있다</li></ul><p><img loading=lazy src=/images/before/image-20240502221956087.png alt=image-20240502221956087.png width=680 height=auto></p><ul><li>스와핑을 이용하면 프로세스들이 요구하는 메모리 주소 공간의 크기가 <strong>실제 메모리 크기보다 큰 경우</strong>에도 프로세스들을 동시 실행 가능</li><li>프로세스 A, B, C, D의 크기를 합하면 메모리의 크기보다 크지만, 스와핑을 통해 네 개의 프로세스를 동시에 실행 가능</li></ul><h2 id=1412-메모리-할당>14.1.2 메모리 할당<a hidden class=anchor aria-hidden=true href=#1412-메모리-할당>#</a></h2><p><img loading=lazy src=/images/before/image-20240502222105379.png alt=image-20240502222105379.png width=680 height=auto></p><ul><li><p>프로세스는 메모리 내의 빈 공간에 적재되어야 한다.</p><ul><li>여기에는 세 가지 방식이 존재</li></ul></li></ul><h3 id=14121-최초-적합-first-fit>14.1.2.1 최초 적합, first fit<a hidden class=anchor aria-hidden=true href=#14121-최초-적합-first-fit>#</a></h3><p><img loading=lazy src=/images/before/image-20240502222404731.png alt=image-20240502222404731.png width=680 height=auto></p><ul><li><p>최초 적합은 운영체제가 메모리 내의 빈 공간을 순서대로 검색하다가 <strong>적재할 수 있는 공간을 발견</strong>하면 그 공간에 바로 프로세스를 배치하는 방식</p></li><li><p>최초 적합 방식은 프로세스가 적재될 수 있는 공간을 발견하는 즉시 메모리를 할당하는 방식이므로 <strong>검색을 최소화</strong> 및 <strong>빠른 할당</strong>이 가능</p></li></ul><h3 id=14122-최적-적합-best-fit>14.1.2.2 최적 적합, best fit<a hidden class=anchor aria-hidden=true href=#14122-최적-적합-best-fit>#</a></h3><p><img loading=lazy src=/images/before/image-20240502222519144.png alt=image-20240502222519144.png width=680 height=auto></p><ul><li>최적 적합 운영체제가 빈 공간을 <strong>모두 검색</strong>해 본 후, 프로세스가 적재될 수 있는 공간 중 <strong>가장 작은 공간에 프로세스를 배치</strong>하는 방식</li><li>최적 적합 방식으로 메모리를 할당하면 프로세스는 빈공간 C에 할당됩니다.</li></ul><h3 id=14123-최악-접합-worst-fit>14.1.2.3 최악 접합, worst fit<a hidden class=anchor aria-hidden=true href=#14123-최악-접합-worst-fit>#</a></h3><p><img loading=lazy src=/images/before/image-20240502222606592.png alt=image-20240502222606592.png width=680 height=auto></p><ul><li>최악 적합은 운영체제가 빈 공간을 <strong>모두 검색</strong>해 본 후, 프로세스가 적재될 수 있는 공간 중 <strong>가장 큰 공간에 프로세스를 배치</strong>하는 방식</li><li>최악 적합 방식으로 메모리를 할당하면 프로세스는 빈공간 B에 할당됩니다.</li></ul><h2 id=1413-외부-단편화>14.1.3 외부 단편화<a hidden class=anchor aria-hidden=true href=#1413-외부-단편화>#</a></h2><ul><li><p><strong>연속 메모리 할당</strong>은 언뜻 들으면 당연하게 느껴질 수 있지만, 사실 이는 메모리를 효율적으로 사용하는 방법이 아니다.</p></li><li><p>왜냐하면 <strong>외부단편화; external fragmentation</strong> 라는 문제를 내포하고 있기 때문</p></li><li><p>프로세스들이 메모리에 연속적으로 할당되는 환경에서는 실행되고 종료되기를 반복하며 <strong>메모리 사이 사이에 빈 공간</strong>들이 생긴다.</p></li><li><p>프로세스 바깥에 생기는 이러한 빈 공간들은 분명 빈 공간이지만 그 공간보다 큰 프로세스를 적재하기 어려운 상황을 초래하고, 결국 메모리 낭비로 이어짐</p></li><li><p>이러한 현상을 <strong>외부단편화; external fragmentation</strong> 라 한다.</p></li><li><p><strong>외부 단편화</strong>: 프로세스를 할당하기 어려울 만큼 작은 메모리 공간들로 인해 메모리가 낭비되는 현상</p></li></ul><p><img loading=lazy src=/images/before/image-20240502223101200.png alt=image-20240502223101200.png width=680 height=auto></p><p><img loading=lazy src=/images/before/image-20240502223112408.png alt=image-20240502223112408.png width=680 height=auto></p><p><img loading=lazy src=/images/before/image-20240502223205239.png alt=image-20240502223205239.png width=680 height=auto></p><ul><li><p>외부 단편화를 해결할 수 있는 대표적인 방안으로 메모리를 <strong>압축; compaction(메모리 조각 모음)</strong> 하는 방법이 존재</p><ul><li>흩어져 있는 빈 공간들을 하나로 모으는 방식으로 프로세스를 재배치시켜 흩어져 있는 작은 빈 공간들을 하나의 큰 빈 공간으로 만드는 방법</li></ul></li><li><p><strong>압축 방식</strong>은 여러 단점 존재</p><ul><li><p>작은 빈 공간들을 하나로 모으는 동안 시스템은 하던 일을 중지해야 하고,</p></li><li><p>메모리에 있는 내용을 옮기는 작업은 많은 오버헤드를 야기하며,</p></li><li><p>어떤 프로세스를 어떻게 움직여야 오버헤드를 최소화하며 압축할 수 있는지에 대한 명확한 방법을 결정하기 어려움</p></li></ul></li><li><p>이에 외부 단편화를 없앨 수 있는 또 다른 해결 방안 - 오늘날까지도 사용되는 가상 메모리 기법, 그 중에서도 <strong>페이징 기법</strong></p></li></ul><h1 id=142-페이징을-통한-가상-메모리-관리>14.2 페이징을 통한 가상 메모리 관리<a hidden class=anchor aria-hidden=true href=#142-페이징을-통한-가상-메모리-관리>#</a></h1><ul><li><p>프로세스를 메모리에 <strong>연속적으로 할당</strong>하는 방식은 두 가지 문제를 내포</p><ol><li><p>외부 단편화</p></li><li><p>물리 메모리보다 큰 프로세스를 실행할 수 없다는 점</p></li></ol></li><li><p><strong>가상 메모리 virtual memory</strong>는 실행하고자 하는 프로그램을 일부만 메모리에 적재하여 실제 물리 메모리 크기보다 더 큰 프로세스를 실행할 수 있게 하는 기술</p><ul><li>가상 메모리 관리 기법에는 크게 <strong>페이징</strong>과 <strong>세그멘테이션</strong>이 존재</li><li><strong>페이징 기법</strong>을 이용하면 물리 메모리보다 큰 프로세스를 실행할 수 있을 뿐만아니라, 앞선 절에서 배운 <strong>외부 단편화 문제</strong>도 해결할 수 있다.<ul><li>현대 대부분의 운영체제가 사용</li></ul></li></ul></li></ul><h2 id=1421-페이징이란>14.2.1 페이징이란<a hidden class=anchor aria-hidden=true href=#1421-페이징이란>#</a></h2><ul><li><strong>외부 단편화</strong>가 생긴 근본적인 이유는 <strong>각기 다른 크기의 프로세스가 메모리에 연속적으로 할당</strong>되었기 때문</li></ul><p><img loading=lazy src=/images/before/image-20240502224906697.png alt=image-20240502224906697.png width=680 height=auto></p><p><img loading=lazy src=/images/before/image-20240502224915366.png alt=image-20240502224915366.png width=680 height=auto></p><ul><li>페이징은 메모리의 <strong>물리 주소 공간을 프레임; frame 단위</strong>로 자르고,</li><li>프로세스의 <strong>논리 주소 공간</strong>을 <strong>페이지; page 단위</strong>로 자른 뒤, 각 <strong>페이지(page, 논리)</strong> 를 <strong>프레임(frame, 물리)</strong> 에 할당하는 <strong>가상 메모리 관리 기법</strong></li></ul><p><img loading=lazy src=/images/before/image-20240502224938407.png alt=image-20240502224938407.png width=680 height=auto></p><ul><li>페이징에서도 스와핑을 사용할 수 있다.<ul><li>페이징을 사용하는 시스템에서는 프로세스 전체가 스왑 아웃/스왑 인되는 것이 아닌, <strong>페이지 단위</strong>로 스왑 아웃/스왑 인 된다.</li></ul></li><li>즉, 메모리에 적재될 필요가 없는 페이지들은 보조기억장치로 <strong>스왑 아웃(페이지 아웃)</strong> 되고,</li><li>실행에 필요한 페이지들은 메모리로 <strong>스왑 인(페이지 인)</strong> 되는 것</li></ul><p><img loading=lazy src=/images/before/image-20240502225244570.png alt=image-20240502225244570.png width=680 height=auto></p><ul><li>한 프로세스를 실행하기 위해 프로세스 전체가 메모리에 적재될 필요가 없다는 말과 같다.<ul><li>프로세스를 이루는 페이지 중 <strong>실행에 필요한</strong> <strong>일부 페이지만을 메모리에 적재</strong>하고,</li><li>당장 실행에 필요하지 않은 페이지들은 보조기억장치에 남겨둘 수 있다.</li><li>이와 같은 방식을 통해 <strong>물리 메모리보다 더 큰 프로세스를 실행할 수 있다</strong></li></ul></li></ul><h3 id=14211-페이징의-이점---쓰기-시-복사>14.2.1.1 페이징의 이점 - 쓰기 시 복사<a hidden class=anchor aria-hidden=true href=#14211-페이징의-이점---쓰기-시-복사>#</a></h3><ul><li><p>운영체제에서 fork 시스템 호출을 하면 부모 프로세스의 복사본이 자식 프로세서로서 만들어짐.</p><ul><li><p>복사 작업은 프로세스 생성 시간을 늦출 뿐만 아니라 불필요한 메모리 낭비를 야기</p><p><img loading=lazy src=/images/before/image-20240503100200689.png alt=image-20240503100200689.png width=680 height=auto></p></li></ul></li><li><p>부모 프로세스 혹은 자식 프로세스 둘 중 하나가 페이지에 쓰기 작업을 하면, 그 순간 해당 페이지가 별도의 공간으로 복제</p><ul><li>각 프로세스는 자신의 고유한 페이지가 할당된 프레임을 가리키킴, 이것이 <strong>쓰기 시 복사; copy on write</strong> 이다.</li><li>프로세스 생성 시간을 줄이는 것은 물론 메모리 공간 절약도 가능</li></ul></li></ul><p><img loading=lazy src=/images/before/image-20240503100315621.png alt=image-20240503100315621.png width=680 height=auto></p><p><img loading=lazy src=/images/before/image-20240503100326449.png alt=image-20240503100326449.png width=680 height=auto></p><h3 id=14212-계층적-페이징>14.2.1.2 계층적 페이징<a hidden class=anchor aria-hidden=true href=#14212-계층적-페이징>#</a></h3><ul><li>페이지 테이블의 크기는 작지 않다.<ul><li>프로세스를 이루는 모든 페이지 테이블 엔트리를 메모리에 두는 것은 큰 메모리 낭비</li></ul></li><li>이에 프로세스를 이루는 모든 페이지 테이블 엔트리를 항상 메모리에 유지하지 않을 수 있는 방법이 등장<ul><li><strong>계층적 페이징; hierarchical Paging</strong></li></ul></li></ul><p><img loading=lazy src=/images/before/image-20240503100626659.png alt=image-20240503100626659.png width=680 height=auto></p><ul><li>계층적 페이징은 페이지 테이블을 페이징하여 여러 단계의 페이지를 두는 방식<ul><li>여러 단계의 페이지를 둔다는 점에서 <strong>다단계 페이지 테이블; multilevel page table</strong> 기법으로 불린다.</li></ul></li><li>페이지 테이블을 여러 개의 페이지로 자르고, 바깥쪽에 페이지 테이블을 하나 더 두어 잘린 페이지 테이블의 페이지들을 가리키게 하는 방식</li><li>페이지 테이블을 이렇게 계층적으로 구성하면 모든 페이지 테이블을 항상 메모리에 유지할 필요가 없다.</li><li>페이지 테이블들 중 몇 개는 <strong>보조기억장치</strong>에 있어도 무방하며, 추후 해당 페이지 테이블을 참조해야 할 때가 있으면 그때 메모리에 적재<ul><li>다만 CPU와 가장 가까이 위치한 페이지 테이블(Outer 페이지 테이블)은 항상 메모리에 유지해야 한다.</li></ul></li></ul><p><img loading=lazy src=/images/before/image-20240503101134552.png alt=image-20240503101134552.png width=680 height=auto></p><ul><li>계층적 페이징을 이용하는 환경에서의 논리 주소는 아래와 같은 형태로 만들어짐.<ul><li>바깥 페이지 번호에 해당하는 항목은 CPU와 근접한 곳에 위치한 (바깥에 위치한) 페이지 테이블 엔트리를 가리키고</li><li>안쪽 페이지 번호는 첫 번째 페이지 테이블 바깥에 위치한 두 번째 페이지 테이블, 즉 페이지 테이블의 페이지 번호를 가리킴</li></ul></li></ul><p><img loading=lazy src=/images/before/image-20240503101134552.png alt=image-20240503101134552.png width=680 height=auto></p><ul><li>논리 주소를 토대로 주소 변환은 다음과 같이 이루어짐<ol><li>바깥 페이지 번호를 통해, <strong>페이지 테이블의 페이지를 찾기</strong></li><li>페이지 테이블의 페이지를 통해 프레임 번호를 찾고 <strong>변위를 더함</strong>으로서 물리 주소 얻기</li></ol></li></ul><p><img loading=lazy src=/images/before/image-20240503101415726.png alt=image-20240503101415726.png width=680 height=auto></p><ul><li>페이지 테이블의 계층이 늘어날수록 <strong>페이지 폴트</strong>가 발생했을 경우 <strong>메모리 참조 횟수</strong>가 많아짐.<ul><li>계층이 많다고 해서 반드시 좋다고 볼 수는 없다.</li></ul></li></ul><h2 id=1422-페이지-테이블>14.2.2 페이지 테이블<a hidden class=anchor aria-hidden=true href=#1422-페이지-테이블>#</a></h2><p><img loading=lazy src=/images/before/image-20240502225322511.png alt=image-20240502225322511.png width=680 height=auto></p><p><img loading=lazy src=/images/before/image-20240502225328172.png alt=image-20240502225328172.png width=680 height=auto></p><ul><li>여기서 문제가 있다. 프로세스가 메모리에 <strong>불연속적으로 배치되어 있다면 CPU 입장에서 이를 순차적으로 실행할 수가 없다.</strong><ul><li>프로세스를 이루는 페이지가 어느 프레임에 적재되어 있는지 CPU가 모두 알고 있기란 어렵기 때문입</li><li>즉, 프로세스가 메모리에 불연속적으로 배치되면 CPU 입장에서 <strong>&lsquo;다음에 실행할 명령어 위치&rsquo;</strong> 를 <strong>찾기가 어려움</strong></li></ul></li><li>이를 해결하기 위해 페이징 시스템은 프로세스가 비록 (실제 메모리 내의 주소인) <strong>물리 주소에 불연속적</strong>으로 배치되더라도</li><li>(CPU가 바라보는 주소인) <strong>논리 주소에는 연속적</strong>으로 배치되도록 <strong>페이지 테이블; page table</strong>을 이용</li><li><strong>페이지 테이블</strong>은 <strong>페이지 번호</strong>와 <strong>프레임 번호</strong>를 짝지어 줌 <strong>(매핑)</strong><ul><li>CPU로 하여금 <strong>페이지 번호</strong>만 보고 해당 <strong>페이지가 적재된 프레임을 찾을</strong> 수 있게 한다.</li><li>페이지 테이블은 현재 어떤 페이지가 어떤 프레임에 할당되었는지를 알려줌.</li></ul></li></ul><p><img loading=lazy src=/images/before/image-20240502225930430.png alt=image-20240502225930430.png width=680 height=auto></p><ul><li>프로세스마다 각자의 페이지 테이블을 가지고 있고 각 프로세스의 페이지 테이블들은 메모리에 적재되어 있다.</li><li>CPU 내의 <strong>Page Table Base Register; PTBR</strong>는 각 프로세스의 페이지 테이블이 적재된 주소를 가리킴</li></ul><blockquote><ul><li><p>이러한 각 프로세스들의 <strong>페이지 테이블 정보</strong>들은 각 프로세스의 <strong>PCB</strong>에 기록</p></li><li><p>프로세스의 <strong>문맥 교환</strong>이 일어날 때 다른 레지스터와 마찬가지로 함께 변경</p></li></ul></blockquote><p><img loading=lazy src=/images/before/image-20240502230225455.png alt=image-20240502230225455.png width=680 height=auto></p><ul><li>페이지 테이블을 메모리에 두면 문제가 발생 - 두 번의 메모리 접근이 필요하게 됨<ul><li>메모리에 있는 페이지 테이블을 보기 위해 한 번</li><li>그렇게 알게 된 프레임에 접근하기위해 한 번</li></ul></li></ul><p><img loading=lazy src=/images/before/image-20240502230410637.png alt=image-20240502230410637.png width=680 height=auto></p><ul><li>이 문제를 해결하기 위해, CPU 곁에 (MMU 내에) <strong>TLB; Translation Lookaside Buffer</strong>라는 <strong>페이지 테이블의 캐시 메모리</strong>를 둔다.<ul><li>CPU 곁에는 TLB가 있다.</li><li>TLB는 <strong>페이지 테이블의 캐시</strong>이기 때문에 페이지 테이블의 일부 내용을 저장</li><li><strong>참조 지역성</strong>에 근거해 주로 최근에 사용된 페이지 위주로 가져와 저장</li></ul></li></ul><p><img loading=lazy src=/images/before/image-20240502230431026.png alt=image-20240502230431026.png width=680 height=auto></p><ul><li><p>CPU가 발생한 논리 주소에 대한 <strong>페이지 번호</strong>가 TLB에 있을 경우 이를 <strong>TLB hit</strong> 라 한다.</p><ul><li>페이지가 적재된 프레임을 알기 위해 메모리에 접근할 필요가 없다. 그렇기에 메모리 접근을 <strong>한 번만</strong> 하면 됩니다.</li></ul></li><li><p>페이지 번호가 TLB에 없을 경우, 어쩔 수 없이 <strong>페이지가 적재된 프레임</strong>을 알기 위해 <strong>메모리 내의 페이지 테이블에 접근</strong>하는 수 밖에 없다. - <strong>TLB miss</strong></p></li></ul><h2 id=1423-내부-단편화>14.2.3 내부 단편화<a hidden class=anchor aria-hidden=true href=#1423-내부-단편화>#</a></h2><p><img loading=lazy src=/images/before/image-20240502231853712.png alt=image-20240502231853712.png width=680 height=auto></p><ul><li><p>페이징은 <strong>외부 단편화</strong> 문제를 해결할 수 있지만, <strong>내부 단편화(internal fragmentation)</strong> 문제를 야기할 수 있다.</p><ul><li>페이징은 프로세스의 논리 주소 공간을 페이지라는 일정한 크기 단위로 자름</li><li>그런데 모든 프로세스가 페이지 크기에 딱 맞게 잘리는 것은 아니다, 모든 프로세스 크기가 페이지의 배수는 아니다.</li><li>가령 페이지 크기가 10 KB인데, 프로세스의 크기가 108 KB 인 경우, 마지막 페이지는 <code>2(=110-108)</code> KB 만큼의 크기가 남음</li></ul></li><li><p>이러한 메모리 낭비를 <strong>내부 단편화</strong>라고 합니다.</p></li><li><p>내부 단편화는 하나의 페이지 크기보다 작은 크기로 발생</p></li><li><p>하나의 페이지 크기가 작다면 발생하는 내부 단편화의 크기는 작아질 것으로 기대할 수 있다.</p></li><li><p>하지만 하나의 페이지 크기를 너무 작게 설정하면, 그만큼 <strong>페이지 테이블의 크기도 커지기</strong> 때문에 <strong>페이지 테이블이 차지하는 공간이 낭비</strong></p></li><li><p>그렇기에 내부 단편화를 <strong>적당히 방지</strong>하면서 <strong>너무 크지 않은 페이지 테이블</strong>이 만들어지도록 페이지의 크기를 조정하는 것이 중요</p><ul><li>일부 운영체제에서는 <strong>기본적으로 설정된 페이지 크기</strong>보다 <strong>더 큰 크기의 페이지;</strong> <strong>대형 페이지(huge page)</strong> 도 일부 허용하며 메모리에 유지하는 경우도 있다.</li></ul></li></ul><h2 id=1424-페이징에서의-주소-변환>14.2.4 페이징에서의 주소 변환<a hidden class=anchor aria-hidden=true href=#1424-페이징에서의-주소-변환>#</a></h2><p><img loading=lazy src=/images/before/image-20240502232534552.png alt=image-20240502232534552.png width=680 height=auto></p><ul><li><p>하나의 페이지 혹은 프레임은 여러 주소를 포괄, 그렇기에 특정 주소에 접근하려면 아래와 같은 두 가지 정보가 필요</p><ol><li>어떤 페이지 혹은 프레임에 접근하고 싶은지 (<strong>페이지 번호</strong>)</li><li>접근하려는 <strong>주소</strong>가 그 페이지 혹은 프레임으로부터 <strong>얼마나 떨어져 있는지(offset)</strong></li></ol></li></ul><p><img loading=lazy src=/images/before/image-20240502232752971.png alt=image-20240502232752971.png width=680 height=auto></p><ul><li>그렇기에 페이징 시스템에서는 모든 <strong>논리 주소</strong> <strong>페이지 번호 page number</strong>와 <strong>변위; offset</strong>로 이루어져 있습니다.<ul><li>가령 CPU가 32비트 주소를 내보냈다면, 이 중 <code>N</code>비트는 페이지 번호, <code>32-N</code> 비트는 변위</li></ul></li><li>페이지 번호: 말 그대로 접근하고자 하는 페이지 번호<ul><li>페이지 테이블에서 해당 페이지 번호를 찾으면 <strong>페이지가 어떤 프레임에 할당</strong>되었는지를 알 수 있음</li></ul></li><li>변위는 접근하려는 주소가 프레임의 <strong>시작 번지로부터 얼만큼 떨어져 있는지</strong>를 알기 위한 정보<ul><li>즉, <strong>논리 주소 [페이지 번호, 변위]</strong> 는 <strong>페이지 테이블</strong>을 통해 <strong>물리 주소 [프레임 번호, 변위]</strong> 로 변환</li></ul></li></ul><p><img loading=lazy src=/images/before/SCR-20240502-ugpz.png alt=SCR-20240502-ugpz.png width=680 height=auto></p><h2 id=1425-페이지-테이블-엔트리>14.2.5 페이지 테이블 엔트리<a hidden class=anchor aria-hidden=true href=#1425-페이지-테이블-엔트리>#</a></h2><p><img loading=lazy src=/images/before/image-20240502233538307.png alt=image-20240502233538307.png width=680 height=auto></p><ul><li><strong>페이지 테이블 엔트리PTE; Page Table Enty</strong>: 페이지 테이블의 각각의 행들</li></ul><h3 id=14251-유효-비트-valid-bit>14.2.5.1 유효 비트; valid bit<a hidden class=anchor aria-hidden=true href=#14251-유효-비트-valid-bit>#</a></h3><p><img loading=lazy src=/images/before/image-20240502233447404.png alt=image-20240502233447404.png width=680 height=auto></p><ul><li><p>유효 비트 현재 해당 페이지에 접근 가능한지 여부를 알려줌 (중요한 정보)</p></li><li><p>일반적으로 프로세스를 이루는 모든 페이지가 메모리에 있지 않는다. (스와핑 때문)</p><ul><li>일부 페이지는 <strong>보조기억장치(스왑 영역)</strong> 에 있는 경우가 많다.</li></ul></li><li><p>유효 비트는 현재 페이지가 메모리에 적재되어 있는지(=1) 아니면 보조기억장치에 있는지를 알려주는 비트(=0)</p></li><li><p>만일 CPU가 유효 비트가 0인 메모리에 적재되어 있지 않은 페이지로 접근하려고 하면, <strong>페이지 폴트; Page fault</strong> 라는 예외(Exception)가 발생</p></li><li><p>CPU가 페이지 폴트를 처리하는 과정은 <strong>하드웨어 인터럽트</strong>를 처리하는 과정과 유사</p><ol><li>CPU는 기존의 작업 내역을 <strong>백업</strong></li><li><strong>페이지 폴트 처리 루틴</strong>을 실행</li><li>페이지 처리 루틴은 원하는 페이지를 메모리로 가져온 뒤 <strong>유효 비트를 1로 변경</strong>해 준다.</li><li>페이지 폴트를 처리했다면, CPU는 해당 페이지에 접근 가능</li></ol></li></ul><h3 id=14252-보호-비트-protection-bit>14.2.5.2 보호 비트; protection bit<a hidden class=anchor aria-hidden=true href=#14252-보호-비트-protection-bit>#</a></h3><p><img loading=lazy src=/images/before/image-20240502234738463.png alt=image-20240502234738463.png width=680 height=auto></p><ul><li>보호 비트는 페이지 보호 기능을 위해 존재하는 비트입니다.</li><li>보호 비트를 통해 해당 페이지가 <strong>읽고 쓰기가 모두 가능</strong>한 페이지인지, 혹은 <strong>읽기만 가능</strong>한 페이지인지를 나타낼 수 있다.</li><li>보호 비트는 읽기(Read, r), 쓰기(Write, w), 실행(eXecute, x)의 조합으로 읽기, 쓰기, 실행하기 권한의 나타낸다.<ul><li>보호 비트가 <code>100</code>인 페이지의 경우 1은 1, w와 x는 0이므로 이 페이지는 읽기만 가능</li><li>보호 비트가 <code>110</code>인 페이지의 경우 이 페이지는 읽고 쓰기만 가능하고 실행은 불가능</li><li>보호 비트가 <code>111</code>인페이지는 읽기, 쓰기, 실행이 모두 가능</li></ul></li></ul><h3 id=14253-참조-비트-reference-bit>14.2.5.3 참조 비트; reference bit<a hidden class=anchor aria-hidden=true href=#14253-참조-비트-reference-bit>#</a></h3><p><img loading=lazy src=/images/before/image-20240502233841566.png alt=image-20240502233841566.png width=680 height=auto></p><ul><li>참조 비트 <strong>CPU</strong>가 이 페이지에 <strong>접근</strong>한 적이 있는지 여부를 나타냄.</li><li>적재 이후 <strong>CPU</strong>가 <strong>읽거나 쓴</strong> 페이지는 참조 비트가 1로 세팅되고, 적재 이후 읽거나 쓴 적이 없는 페이지는 0으로 유지</li></ul><h3 id=14254-수정-비트-modified-bit-dirty-bit>14.2.5.4 수정 비트; modified bit, dirty bit<a hidden class=anchor aria-hidden=true href=#14254-수정-비트-modified-bit-dirty-bit>#</a></h3><p><img loading=lazy src=/images/before/image-20240502233902194.png alt=image-20240502233902194.png width=680 height=auto></p><ul><li><p>수정 비트는 해당 페이지에 데이터를 <strong>쓴 적(write)</strong> 이 있는지 없는지 <strong>수정 여부</strong>를 알려줌.</p></li><li><p>이 비트가 1이면 변경된 적이 있는 페이지, 0이면 변경된 적이 없는 페이지(한 번도 접근한 적 없거나, <strong>read</strong>만 했던 페이지)임을 나타냄.</p></li><li><p>수정 비트는 페이지가 메모리에서 사라질 때, 보조기억장치에 쓰기 작업을 해야 하는지, 할 필요가 없는지를 판단하기 위해 존재</p><ul><li>이렇게 수정된 적이 있는 페이지가 스왑 아웃될 경우 변경된 값을 보조기억장치에 기록하는 작업이 추가되어야 함.</li><li>페이지 테이블 엔트리에 <strong>수정 비트</strong>를 통해 이 작업 필요성을 판단</li></ul></li></ul><p><img loading=lazy src=/images/before/image-20240502234520310.png alt=image-20240502234520310.png width=680 height=auto></p><p><img loading=lazy src=/images/before/image-20240502234512638.png alt=image-20240502234512638.png width=680 height=auto></p><h1 id=143-페이지-교체와-프레임-할당>14.3 페이지 교체와 프레임 할당<a hidden class=anchor aria-hidden=true href=#143-페이지-교체와-프레임-할당>#</a></h1><h2 id=1431-요구-페이징>14.3.1 요구 페이징<a hidden class=anchor aria-hidden=true href=#1431-요구-페이징>#</a></h2><ul><li><strong>요구 페이징; demand paging</strong>: 프로세스를 메모리에 적재할 때 <strong>처음부터 모든 페이지를 적재하지 않고 필요한 페이지만을 메모리에 적재하는 기법</strong></li><li>요구 페이징의 기본적인 양상<ol><li>CPU가 특정 페이지에 접근하는 명령어를 실행한다.</li><li>해당 페이지가 현재 메모리에 있을 경우 (유효 비트가 1일 경우) CPU는 페이지가 적재된 프레임에 접근한다.</li><li>해당 페이지가 현재 메모리에 없을 경우 (유효 비트가 0일 경우) <strong>페이지 폴트</strong>가 발생한다.</li><li>페이지 폴트 처리 루틴은 해당 페이지를 메모리로 적재하고 유효 비트를 1로 설정한다.</li><li>다시 1번을 수행한다.</li></ol></li></ul><h2 id=1432-페이지-교체-알고리즘>14.3.2 페이지 교체 알고리즘<a hidden class=anchor aria-hidden=true href=#1432-페이지-교체-알고리즘>#</a></h2><ul><li><p>요구 페이징 기법으로 페이지들을 적재하다 보면 언젠가 메모리가 가득 참</p><ul><li>이때는 당장 실행에 필요한 페이지를 적재하기 위해 메모리에 적재된 페이지를 보조기억장치로 내보내야 한다.</li></ul></li><li><p><strong>페이지 교체 알고리즘</strong>: 메모리에 적재된 많고 많은 페이지 중 어떤 페이지를 내보내는 것이 최선인지 결정하는 방법</p><ul><li>쫓아낼 페이지를 결정하는 방법</li></ul></li><li><p>좋은 페이지 교체 알고리즘</p><ul><li>일반적으로 <strong>페이지 폴트를 가장 적게</strong> 일으키는 알고리즘</li><li>어떤 알고리즘을 통해 고른 페이지를 <strong>스왑 아웃</strong>시켜도 페이지 폴트가 자주 발생하지 않는다면 이는 성능 저하를 방지하는 좋은 알고리즘</li><li>페이지 폴트가 일어나면 보조기억장치로부터 페이지를 가져와야 하기에 메모리에 적재된 페이지를 가져오는 것보다 느려지기 때문</li></ul></li><li><p>한 알고리즘을 통해 고른 페이지를 스왑 아웃시켰을 때 페이지 폴트가 자주 발생하면 이는 좋은 알고리즘이 아님.</p><ul><li>내보내면 안 되는 페이지를 보조기억장치로 내보냈기 때문</li></ul></li></ul><p><img loading=lazy src=/images/before/image-20240502235920862.png alt=image-20240502235920862.png width=680 height=auto></p><ul><li><p>페이지 교체 알고리즘을 이해하려면 <strong>페이지 폴트 횟수</strong>를 알 아야 한다.</p><ul><li>페이지 폴트 횟수는 <strong>페이지 참조열; page reference sting</strong>을 통해 알 수 있다.</li></ul></li><li><p><strong>페이지 참조열; page reference sting</strong>: CPU가 참조하는 페이지들 중 <strong>연속된 페이지를 생략</strong>한 페이지열</p><ul><li>연속된 페이지를 생략하는 이유는 <strong>중복된 페이지를 참조</strong>하는 행위는 <strong>페이지 폴트를 발생시키지 않기 때문</strong></li></ul></li></ul><h3 id=14321-fifo-페이지-교체-알고리즘>14.3.2.1 FIFO, 페이지 교체 알고리즘<a hidden class=anchor aria-hidden=true href=#14321-fifo-페이지-교체-알고리즘>#</a></h3><p><img loading=lazy src=/images/before/image-20240503101812971.png alt=image-20240503101812971.png width=680 height=auto></p><ul><li>First-in First-Out 이름 그대로 메모리에 가장 먼저 올라온 페이지부터 내쫓는 방식<ul><li>&ldquo;&ldquo;오래 머물렀다면 나가라"는 알고리즘</li></ul></li><li>장점: 아이디어와 구현이 간단</li><li>단점: 실행 초기에 적재된 페이지 속에는 프로그램 실행 내내 사용될 내용을 포함하고 있을 수도 있다.<ul><li>이런 페이지는메모리에 먼저 적재되었다고 해서 내쫓아내는 것은 비효율</li></ul></li></ul><p><img loading=lazy src=/images/before/image-20240503102047278.png alt=image-20240503102047278.png width=680 height=auto></p><h3 id=14321-optimal최적-페이지-교체-알고리즘>14.3.2.1 Optimal(최적), 페이지 교체 알고리즘<a hidden class=anchor aria-hidden=true href=#14321-optimal최적-페이지-교체-알고리즘>#</a></h3><p><img loading=lazy src=/images/before/image-20240503102404392.png alt=image-20240503102404392.png width=680 height=auto></p><ul><li><p>앞으로의 <strong>사용 빈도가 가장 낮은 페이지를 교체</strong>하는 알고리즘</p></li><li><p>CPU에 의해 참조되는 횟수를 고려</p><ul><li>잘 생각해 보면 메모리에 오랫동안 남아야 할 페이지는 자주 사용될 페이지</li><li>보조기억장치로 내보내야 할 페이지는 앞으로 사용 빈도가 가장 낮은 페이지</li></ul></li><li><p>장점: 타 페이지 교체 알고리즘에 비해 페이지 폴트 발생 빈도가 가장 낮다.</p></li><li><p>단점: 최적 페이지 교체 알고리즘은 <strong>실제 구현이 어려움</strong>: <strong>&lsquo;앞으로 오랫동안 사용되지 않을 페이지&rsquo;를 예측하기란 어렵다.</strong></p><ul><li>프로세스가 앞으로 메모리 어느 부분을 어떻게 참조할지 미리 알아야 하는데, 이는 현실적으로 불가능</li></ul></li><li><p>다른 페이지 교체 알고리즘의 이론상 성능을 평가하기 위한 목적으로 사용</p><ul><li>최적 페이지 교체 알고리즘(하한선)에 비해 얼만큼 <strong>페이지 폴트 횟수</strong>가 발생하느냐를 통해 페이지 교체 알고리즘을 평가하기 위해 사용</li></ul></li></ul><h3 id=14321-lru-페이지-교체-알고리즘>14.3.2.1 LRU, 페이지 교체 알고리즘<a hidden class=anchor aria-hidden=true href=#14321-lru-페이지-교체-알고리즘>#</a></h3><p><img loading=lazy src=/images/before/image-20240503102754623.png alt=image-20240503102754623.png width=680 height=auto></p><ul><li>가장 오랫동안 사용되지 <strong>&lsquo;않은&rsquo;</strong> 페이지를 교체하는 알고리즘은 구현이 가능, <strong>Least Recenty Used</strong></li><li>&lsquo;최근에 사용되지 않은 페이지는 앞으로도 사용되지 않을 것&rsquo;이라는 아이디어를 토대로 만들어짐</li><li>페이지마다 마지막으로 사용한 시간을 토대로 최근에 가장 사용이 적었던 페이지를 교체</li></ul><h2 id=1433-스래싱과-프레임-할당>14.3.3 스래싱과 프레임 할당<a hidden class=anchor aria-hidden=true href=#1433-스래싱과-프레임-할당>#</a></h2><p><img loading=lazy src=/images/before/image-20240503103045359.png alt=image-20240503103045359.png width=680 height=auto></p><p><img loading=lazy src=/images/before/image-20240503103330547.png alt=image-20240503103330547.png width=680 height=auto></p><ul><li>페이지 폴트가 자주 발생하는 이유에 나쁜 페이지 교체 알고리즘만 있는 건 아니다.</li><li>프로세스가 사용할 수 있는 프레임 수가 적어도 페이지 폴트는 자주 발생<ul><li>사실 이것이 더 근본적인 이유라고 볼 수 있다.</li></ul></li><li>이처럼 프레임이 부족하면 CPU는 페이지 폴트가 자주 발생할 수밖에 없다.<ul><li>실행의 맥이 탁 탁끊기고, 결과적으로 CPU의 이용률도 떨어짐</li><li>페이지 교체에 너무 많은 시간을 쏟으면 당연히 성능에도 큰 악영향</li></ul></li><li><strong>프로세스가 실제 실행되는 시간</strong>보다 <strong>페이징에 더 많은 시간을 소요</strong>하여 성능이 저해되는 것을 <strong>스래싱; thrashling</strong> 이라 한다.</li></ul><p><img loading=lazy src=/images/before/image-20240503103344277.png alt=image-20240503103344277.png width=680 height=auto></p><ul><li><p>가로축인 <strong>멀티프로그래밍의 정도</strong>를 통해 메모리에 올라와 있는 프로세스의 수를 알 수 있다.</p><ul><li><strong>멀티프로그래밍의 정도</strong>: 메모리에서 <strong>동시 실행되는 프로세스의 수</strong></li><li>멀티프로그래밍의 정도가 높다면 현재 메모리에는 많은 프로세스가 동시에 실행 중이라는 이야기</li></ul></li><li><p>동시에 실행되는 프로세스의 수 (멀티프로그래밍의 정도)를 늘린다고 해서 <strong>CPU 이용률이 비례해서 증가하는 것이 아님</strong></p></li><li><p>필요 이상으로 늘리면 <strong>각 프로세스들이 사용할 수 있는 프레임 수가 적어</strong>지기 때문에 <strong>페이지 폴트가 지나치게 빈번히 발생</strong></p></li><li><p>스래싱이 발생하는 근본적인 원인은 각 프로세스가 필요로 하는 최소한의 프레임 수가 보장되지 않았기 때문</p></li><li><p><strong>균등 할당; equal allocation</strong>: 모든 프로세스에 균등하게 프레임을 제공하는 방식</p><ul><li>실행되는 프로세스들의 크기는각기 다른데, 천편일률적으로 동일한 프레임 개수를 할당하는 것은 비합리적</li><li>가장 단순한 형태의 프레임 할당 방식</li></ul></li><li><p><strong>비례 할당; proportional allocation</strong>: 프로세스의 크기가 크면 프레임을 많이 할당하고 크기가 작으면 프레임을 적게 나눠주는 방식</p><ul><li>프로세스의 크기와 프레임이 필요한 경우의 수는 비례하지 않을 수 있다.</li><li>한계점: 프로세스가 실제로 얼마나 많은 프레임이 필요할지는 결국 실행해 봐야 아는 경우가 많다.</li></ul></li></ul><blockquote><p>균등 할당과 비례 할당 방식은 프로세스의 <strong>실행 과정을 고려하지 않고</strong> 단순히 프로세스의 크기와 물리 메모리의 크기만을 고려한 방식이라는 점에서 <strong>정적 할당 방식</strong> 이라 한다.</p></blockquote><ul><li>프로세스를 실행하는 과정에서 배분할 프레임을 결정하는 방식 (<strong>동적 할당 방식</strong>)<ul><li><strong>작업 집합 모델; working set model</strong> 을 사용하는 방식</li><li><strong>페이지 폴트 빈도 PPF; Page-Fault Frequency</strong>를 사용하는 방식</li><li>이 두 개 방식은 프로세스의 실행을 보고 할당할 프레임 수를 결정한다는 점에서 <strong>동적 할당 방식</strong> 이라 한다.</li></ul></li></ul><p><img loading=lazy src=/images/before/image-20240503104611598.png alt=image-20240503104611598.png width=680 height=auto></p><ul><li><strong>작업 집합; working set</strong>: 실행 중인 프로세스가 일정 시간 동안 참조한 페이지의 집합</li><li><strong>작업 집합 모델</strong> 기반 프레임 할당 방식은 &lsquo;프로세스가 일정 기간 동안 참조한 페이지 집합&rsquo;을 기억하여 빈번한 페이지 교체를 방지<ul><li>CPU가 메모리를 참조할 때에는 <strong>참조 지역성</strong>의 원리에 의거해 주로 <strong>비슷한 구역을 집중적</strong>으로 참조</li><li>만약 CPU가 어떤 프로세스를 실행하는 동안 3초에 20개의 페이지를 집중적으로 참조했다면</li><li>운영체제는 그 프로세스를 위해 그 순간만큼은 최소 20개의 프레임을 할당하면 된다.</li></ul></li></ul><p><img loading=lazy src=/images/before/image-20240503104757011.png alt=image-20240503104757011.png width=680 height=auto></p><ul><li><p><strong>페이지 폴트 기반</strong>, 두 개의 가정에서 생겨난 아이디어</p><ol><li>페이지 폴트율이 너무 높으면 그 프로세스는 너무 적은 프레임을 갖고 있다.</li><li>페이지 폴트율이 너무 낮으면 그 프로세스가 너무 많은 프레임을 갖고 있다.</li></ol></li><li><p>만일 페이지 폴트율이 상한선보다 더 높아지면 그 프로세스는 너무 적은 프레임을 갖고 있다고 볼 수있다.</p><ul><li>이 경우 프레임을 더 할당해 주면 됩니다.</li></ul></li><li><p>반대로 페이지 폴트율이 하한선보다 더 낮아지면 그 프로세스는 너무 많은 프레임을 갖고 있다고 볼 수 있다.</p><ul><li>이 경우 다른 프로세스에 할당하기 위해 프레임을 회수합니다.</li></ul></li><li><p><strong>페이지 폴트 빈도 기반</strong> 프레임 할당 방식은 <strong>페이지 폴트율 에 상한선과 하한선</strong>을 정하고, 이 범위 안에서만 프레임을 할당</p></li></ul><h1 id=reference>Reference<a hidden class=anchor aria-hidden=true href=#reference>#</a></h1><ul><li>혼자 공부하는 컴퓨터구조+운영체제 (강민철, 한빛미디어) <a href=https://product.kyobobook.co.kr/detail/S000061584886>https://product.kyobobook.co.kr/detail/S000061584886</a></li></ul></div><footer class=post-footer><ul class=post-tags><li><a href=https://2taezeat.github.io/tags/os/>OS</a></li><li><a href=https://2taezeat.github.io/tags/cs/>CS</a></li></ul><nav class=paginav><a class=prev href=https://2taezeat.github.io/posts/os/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0-+-%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C-ch15.-%ED%8C%8C%EC%9D%BC-%EC%8B%9C%EC%8A%A4%ED%85%9C/><span class=title>« Prev</span><br><span>[컴퓨터구조 + 운영체제] ch15. 파일 시스템</span>
</a><a class=next href=https://2taezeat.github.io/posts/os/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0-+-%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C-ch13.-%EA%B5%90%EC%B0%A9-%EC%83%81%ED%83%9C/><span class=title>Next »</span><br><span>[컴퓨터구조 + 운영체제] ch13. 교착 상태</span></a></nav><ul class=share-buttons><li><a target=_blank rel="noopener noreferrer" aria-label="share [컴퓨터구조 + 운영체제] ch14. 가상 메모리 on x" href="https://x.com/intent/tweet/?text=%5b%ec%bb%b4%ed%93%a8%ed%84%b0%ea%b5%ac%ec%a1%b0%20%2b%20%ec%9a%b4%ec%98%81%ec%b2%b4%ec%a0%9c%5d%20ch14.%20%ea%b0%80%ec%83%81%20%eb%a9%94%eb%aa%a8%eb%a6%ac&amp;url=https%3a%2f%2f2taezeat.github.io%2fposts%2fos%2f%25EC%25BB%25B4%25ED%2593%25A8%25ED%2584%25B0%25EA%25B5%25AC%25EC%25A1%25B0-%2b-%25EC%259A%25B4%25EC%2598%2581%25EC%25B2%25B4%25EC%25A0%259C-ch14.-%25EA%25B0%2580%25EC%2583%2581-%25EB%25A9%2594%25EB%25AA%25A8%25EB%25A6%25AC%2f&amp;hashtags=OS%2cCS"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446C483.971.0 512 28.03 512 62.554zM269.951 190.75 182.567 75.216H56L207.216 272.95 63.9 436.783h61.366L235.9 310.383l96.667 126.4H456L298.367 228.367l134-153.151H371.033zM127.633 110h36.468l219.38 290.065H349.5z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share [컴퓨터구조 + 운영체제] ch14. 가상 메모리 on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2f2taezeat.github.io%2fposts%2fos%2f%25EC%25BB%25B4%25ED%2593%25A8%25ED%2584%25B0%25EA%25B5%25AC%25EC%25A1%25B0-%2b-%25EC%259A%25B4%25EC%2598%2581%25EC%25B2%25B4%25EC%25A0%259C-ch14.-%25EA%25B0%2580%25EC%2583%2581-%25EB%25A9%2594%25EB%25AA%25A8%25EB%25A6%25AC%2f&amp;title=%5b%ec%bb%b4%ed%93%a8%ed%84%b0%ea%b5%ac%ec%a1%b0%20%2b%20%ec%9a%b4%ec%98%81%ec%b2%b4%ec%a0%9c%5d%20ch14.%20%ea%b0%80%ec%83%81%20%eb%a9%94%eb%aa%a8%eb%a6%ac&amp;summary=%5b%ec%bb%b4%ed%93%a8%ed%84%b0%ea%b5%ac%ec%a1%b0%20%2b%20%ec%9a%b4%ec%98%81%ec%b2%b4%ec%a0%9c%5d%20ch14.%20%ea%b0%80%ec%83%81%20%eb%a9%94%eb%aa%a8%eb%a6%ac&amp;source=https%3a%2f%2f2taezeat.github.io%2fposts%2fos%2f%25EC%25BB%25B4%25ED%2593%25A8%25ED%2584%25B0%25EA%25B5%25AC%25EC%25A1%25B0-%2b-%25EC%259A%25B4%25EC%2598%2581%25EC%25B2%25B4%25EC%25A0%259C-ch14.-%25EA%25B0%2580%25EC%2583%2581-%25EB%25A9%2594%25EB%25AA%25A8%25EB%25A6%25AC%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share [컴퓨터구조 + 운영체제] ch14. 가상 메모리 on reddit" href="https://reddit.com/submit?url=https%3a%2f%2f2taezeat.github.io%2fposts%2fos%2f%25EC%25BB%25B4%25ED%2593%25A8%25ED%2584%25B0%25EA%25B5%25AC%25EC%25A1%25B0-%2b-%25EC%259A%25B4%25EC%2598%2581%25EC%25B2%25B4%25EC%25A0%259C-ch14.-%25EA%25B0%2580%25EC%2583%2581-%25EB%25A9%2594%25EB%25AA%25A8%25EB%25A6%25AC%2f&title=%5b%ec%bb%b4%ed%93%a8%ed%84%b0%ea%b5%ac%ec%a1%b0%20%2b%20%ec%9a%b4%ec%98%81%ec%b2%b4%ec%a0%9c%5d%20ch14.%20%ea%b0%80%ec%83%81%20%eb%a9%94%eb%aa%a8%eb%a6%ac"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share [컴퓨터구조 + 운영체제] ch14. 가상 메모리 on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2f2taezeat.github.io%2fposts%2fos%2f%25EC%25BB%25B4%25ED%2593%25A8%25ED%2584%25B0%25EA%25B5%25AC%25EC%25A1%25B0-%2b-%25EC%259A%25B4%25EC%2598%2581%25EC%25B2%25B4%25EC%25A0%259C-ch14.-%25EA%25B0%2580%25EC%2583%2581-%25EB%25A9%2594%25EB%25AA%25A8%25EB%25A6%25AC%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share [컴퓨터구조 + 운영체제] ch14. 가상 메모리 on whatsapp" href="https://api.whatsapp.com/send?text=%5b%ec%bb%b4%ed%93%a8%ed%84%b0%ea%b5%ac%ec%a1%b0%20%2b%20%ec%9a%b4%ec%98%81%ec%b2%b4%ec%a0%9c%5d%20ch14.%20%ea%b0%80%ec%83%81%20%eb%a9%94%eb%aa%a8%eb%a6%ac%20-%20https%3a%2f%2f2taezeat.github.io%2fposts%2fos%2f%25EC%25BB%25B4%25ED%2593%25A8%25ED%2584%25B0%25EA%25B5%25AC%25EC%25A1%25B0-%2b-%25EC%259A%25B4%25EC%2598%2581%25EC%25B2%25B4%25EC%25A0%259C-ch14.-%25EA%25B0%2580%25EC%2583%2581-%25EB%25A9%2594%25EB%25AA%25A8%25EB%25A6%25AC%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share [컴퓨터구조 + 운영체제] ch14. 가상 메모리 on telegram" href="https://telegram.me/share/url?text=%5b%ec%bb%b4%ed%93%a8%ed%84%b0%ea%b5%ac%ec%a1%b0%20%2b%20%ec%9a%b4%ec%98%81%ec%b2%b4%ec%a0%9c%5d%20ch14.%20%ea%b0%80%ec%83%81%20%eb%a9%94%eb%aa%a8%eb%a6%ac&amp;url=https%3a%2f%2f2taezeat.github.io%2fposts%2fos%2f%25EC%25BB%25B4%25ED%2593%25A8%25ED%2584%25B0%25EA%25B5%25AC%25EC%25A1%25B0-%2b-%25EC%259A%25B4%25EC%2598%2581%25EC%25B2%25B4%25EC%25A0%259C-ch14.-%25EA%25B0%2580%25EC%2583%2581-%25EB%25A9%2594%25EB%25AA%25A8%25EB%25A6%25AC%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentcolor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share [컴퓨터구조 + 운영체제] ch14. 가상 메모리 on ycombinator" href="https://news.ycombinator.com/submitlink?t=%5b%ec%bb%b4%ed%93%a8%ed%84%b0%ea%b5%ac%ec%a1%b0%20%2b%20%ec%9a%b4%ec%98%81%ec%b2%b4%ec%a0%9c%5d%20ch14.%20%ea%b0%80%ec%83%81%20%eb%a9%94%eb%aa%a8%eb%a6%ac&u=https%3a%2f%2f2taezeat.github.io%2fposts%2fos%2f%25EC%25BB%25B4%25ED%2593%25A8%25ED%2584%25B0%25EA%25B5%25AC%25EC%25A1%25B0-%2b-%25EC%259A%25B4%25EC%2598%2581%25EC%25B2%25B4%25EC%25A0%259C-ch14.-%25EA%25B0%2580%25EC%2583%2581-%25EB%25A9%2594%25EB%25AA%25A8%25EB%25A6%25AC%2f"><svg width="30" height="30" viewBox="0 0 512 512" fill="currentcolor" xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"><path d="M449.446.0C483.971.0 512 28.03 512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446zM183.8767 87.9921h-62.034L230.6673 292.4508V424.0079h50.6655V292.4508L390.1575 87.9921H328.1233L256 238.2489z"/></svg></a></li></ul></footer><script src=https://utteranc.es/client.js repo=2taezeat/blog_comment issue-term=pathname label=comment theme=github-light crossorigin=anonymous async></script></article></main><footer class=footer><span>&copy; 2024 <a href=https://2taezeat.github.io/>2taezeat, blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>