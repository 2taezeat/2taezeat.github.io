<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>[자바 ORM 표준 JPA] ch03. 영속성 관리 | 2taezeat, blog</title>
<meta name=keywords content="JPA,Backend"><meta name=description content="자바 ORM 표준 JPA 프로그래밍, ch03. 영속성 관리, 간단 정리"><meta name=author content="2taezeat"><link rel=canonical href=https://2taezeat.github.io/posts/jpa/%EC%9E%90%EB%B0%94-orm-%ED%91%9C%EC%A4%80-jpa-ch03.-%EC%98%81%EC%86%8D%EC%84%B1-%EA%B4%80%EB%A6%AC/><meta name=google-site-verification content="YaEERzgrvu-ZwPg7gswZdTzRMufkHw3uIH7i8hVal1c"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.cc8105bf49785484525cafc7883272c26982bf06e1663dcfa3b55c3bb3f773b6.css integrity="sha256-zIEFv0l4VIRSXK/HiDJywmmCvwbhZj3Po7VcO7P3c7Y=" rel="preload stylesheet" as=style><link rel=icon href=https://2taezeat.github.io/icon/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://2taezeat.github.io/icon/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://2taezeat.github.io/icon/favicon-32x32.png><link rel=apple-touch-icon href=https://2taezeat.github.io/icon/apple-touch-icon.png><link rel=mask-icon href=https://2taezeat.github.io/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://2taezeat.github.io/posts/jpa/%EC%9E%90%EB%B0%94-orm-%ED%91%9C%EC%A4%80-jpa-ch03.-%EC%98%81%EC%86%8D%EC%84%B1-%EA%B4%80%EB%A6%AC/><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><meta property="og:title" content="[자바 ORM 표준 JPA] ch03. 영속성 관리"><meta property="og:description" content="자바 ORM 표준 JPA 프로그래밍, ch03. 영속성 관리, 간단 정리"><meta property="og:type" content="article"><meta property="og:url" content="https://2taezeat.github.io/posts/jpa/%EC%9E%90%EB%B0%94-orm-%ED%91%9C%EC%A4%80-jpa-ch03.-%EC%98%81%EC%86%8D%EC%84%B1-%EA%B4%80%EB%A6%AC/"><meta property="og:image" content="https://2taezeat.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-08-03T11:30:03+00:00"><meta property="article:modified_time" content="2024-08-03T11:30:03+00:00"><meta property="og:site_name" content="2taezeat, blog"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://2taezeat.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="[자바 ORM 표준 JPA] ch03. 영속성 관리"><meta name=twitter:description content="자바 ORM 표준 JPA 프로그래밍, ch03. 영속성 관리, 간단 정리"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://2taezeat.github.io/posts/"},{"@type":"ListItem","position":2,"name":"[자바 ORM 표준 JPA] ch03. 영속성 관리","item":"https://2taezeat.github.io/posts/jpa/%EC%9E%90%EB%B0%94-orm-%ED%91%9C%EC%A4%80-jpa-ch03.-%EC%98%81%EC%86%8D%EC%84%B1-%EA%B4%80%EB%A6%AC/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"[자바 ORM 표준 JPA] ch03. 영속성 관리","name":"[자바 ORM 표준 JPA] ch03. 영속성 관리","description":"자바 ORM 표준 JPA 프로그래밍, ch03. 영속성 관리, 간단 정리","keywords":["JPA","Backend"],"articleBody":"3.1 엔티티 매니저 팩토리와 엔티티 매니저 엔티티 매니저는 엔티티와 관련된 모든 일을 처리 (CRUD 등) 개발자 입장에서는 엔티티 매니저를 가상의 DB라고 생각하면 된다 엔티티 매니저 팩토리는 여러 스레드가 동시에 접근해도 안전하므로 서로 다른 스레드 간에 공유해도 된다 엔티티 매니저는 여러 스레드가 동시에 접근하면 동시성 문제가 발생하므로 스레드 간에 절대 공유하면 안 된다. 엔티티 매니저는 데이터베이스 연결(connection)은 트랜잭션을 시작할 때 획득 3.2 영속성 컨텍스트란? 영속성 컨텍스트(persistence context) 는 엔티티를 영구 저장하는 환경 이다. 엔티티 매니저는 영속성 컨텍스트에 엔티티를 보관 및 관리 persist() 메서드는 엔티티 매니저를 사용해서 회원 엔티티를 영속성 컨텍스트에 저장 논리적인 개념에 가깝다. 3.3 엔티티의 생명주기 비영속(new/transient) : 영속성 컨텍스트와 전혀 관계가 없는 상태\n영속(managed) : 영속성 컨텍스트에 저장된 상태, 영속성 컨텍스트가 관리하는 상태\n​\tem.find() 나 JPQL 을 사용해서 조회한 엔티티도 영속 상태이다. 준영속(detached) : 영속성 컨텍스트에 저장되었다가 분리된 상태\n특정 엔티티를 준영속 상태로 만들려면 em.detach() 를 호출하면 된다 em.close() ,em.clear() 로 영속성 컨텍스트를 초기화 해도 관리하던 엔티티는 준영속 상태가 된다 삭제(removed) : 엔티티를 영속성 컨텍스트와 DB에 삭제된 상태\n3.4 영속성 컨텍스트의 특징 영속성 컨텍스트와 식별자 값\n영속성 컨텍스트는 엔티티를 식별자 값(@Id 로 테이블의 기본 키와 매핑한 값)으로 구분한다.\n따라서 영속 상태는 식별자 값이 반드시 있어야 한다.\n식별자 값이 없으면 예외가 발생한다.\n영속성 컨텍스트에 엔티티를 저장하면 이 엔티티는 언제 데이터베이스에 저장될까?\nJPA는 보통 트랜잭션을 커밋하는 순간 영속성 컨텍스트에 새로 저장된 엔티티를 데이터베이스에 반영, 이것을 플러시(flush) 라 한다. 영속성 컨텍스트가 엔티티를 관리할 때 장점\n1차 캐시\n동일성 보장\n트랜잭션을 지원하는 쓰기 지연\n변경 감지\n지연 로딩\n3.4.1 엔티티 조회 영속성 컨텍스트는 내부에 캐시를 가지고 있는데 이것을 1차 캐시라 한다.\n1차 캐시의 키는 식별자 값, 영속성 컨텍스트에 데이터를 저장, 조회하는 모든 기준은 DB의 기본 키 값\n1차 캐시에서 조회 DB에서 조회 만약 em.find() 를 호출했는데 엔티티가 1차 캐시에 없으면 엔티티 매니저는 데이터베이스를 조회해서 엔티티를 생성한다. 그리고 1차 캐시에 저장한 후에 영속 상태의 엔티티를 반환한다. 영속 엔티티의 동일성 보장 1 2 3 4 Menber a = em.find(Member.class, \"member1\"); Member b = em.find(Member.class, \"member1\"); a == b // true em.find(Member.class, \"member1\"); 을 반복 호출 해도, 1차 캐시에 있는 같은 엔티티 인스턴스를 반환한다. JPA는 1차 캐시를 통해 반복 가능한 읽기(REPEATABLE READ) 등급의 트랜잭션 격리 수준을 DB가 아닌 App 차원에서 제공한다는 장점이 있다.\n3.4.2 엔티티 등록 엔티티 매니저는 트랜잭션을 커밋하기 직전까지 데이터베이스에 엔티티를 저장하지 않고, 내부 쿼리 저장소에 INSERT SQL을 차곡차곡 모아둔다.\n트랜잭션을 커밋할 때 모아둔 쿼리를 데이터베이스에 보낸다.\n이것을 트랜잭션을 지원하는 쓰기 지연 transactional write-behind이라 한다. 트랜잭션을 커밋하면 엔티티 매니저는 우선 영속성 컨텍스트를 플러시한다.\n플러시는 영속성 컨텍스트의 변경 내용을 데이터베이스에 동기화하는 작업\n이때 등록, 수정, 삭제한 엔티티를 데이터베이스에 반영한다. 쓰기 지연 SQL 저장소에 모인 쿼리를 데이터베이스에 보낸다. 이렇게 영속성 컨텍스트의 변경 내용을 데이터베이스에 동기화한 후에 실제 데이터베이스 트랜잭션을 커밋한다. 트랜잭션을 지원하는 쓰기 지연이 가능한 이유 데이터베이스에 전달해도 트랜잭션을 커밋하지 않으면 아무 소용이 없다. 어떻게든 커밋 직전에만 데이터베이스에 SOL을 전달하면 된다. 이것이 트랜잭션을 지원하는 쓰기 지연이 가능한 이유 이를 활용해, 모아둔 등록 쿼리를 데이터베이스에 한 번에 전달해서 성능을 최적화할 수 있다. 3.4.3 엔티티 수정 JPA로 엔티티를 수정할 때는 단순히 엔티티를 조회해서 데이터만 변경하면 된다. 트랜잭션 커밋 직전에 주석으로 처리된 em.update() 메소드를 실행해야 할 것 같지만 이런 메소드는 없다. 엔티티의 변경사항을 데이터베이스에 자동으로 반영하는 기능을 변경 감지(dirty checking) 라 한다. JPA는 엔티티를 영속성 컨텍스트에 보관할 때. 최초 상태를 복사해서 저장해두는데 이것을 스냅샷이라 한다. 그리고 플러시 시점에 스냅샷과 엔티티를 비교해서 변경된 엔티티를 찾는다. 변경된 엔티티가 있으면 수정 쿼리를 생성해서 쓰기 지연 SQL 저장소에 보내고, 이후 등록 과정이 진행된다. 변경 감지는 영속성 컨텍스트가 관리하는 영속 상태의 엔티티에만 적용된다.\nJPA의 기본 전략은 엔티티의 모든 필드를 업데이트한다.\n모든 필드를 사용하면 수정 쿼리가 항상 같다(물론 바인딩되는 데이터는 다르다). 따라서 애플리케이션 로딩 시점에 수정 쿼리를 미리 생성해두고 재사용할 수 있다. 데이터베이스에 동일한 쿼리를 보내면 데이터베이스는 이전에 한 번 파싱된 쿼리를 재사용할 수 있다. org.hibernate.annotations.Dynamicupdate 어노테이션으로 수정된 데이터만 사용해서 동적으로 UPDATE SQL을 생성할 수 도 있다.\n3.4.4 엔티티 삭제 엔티티 삭제하려면 삭제 대상 엔티티를 조회(find) 해야 한다. 삭제 과정은 엔티티 등록 과정과 비슷하다 삭제된 엔티티는 재사용 하지 말고, GC의 대상이 두는 것이 좋다. 3.5 플러시 플러시;flush() 는 영속성 컨텍스트의 변경 내용을 데이터베이스에 반영, 동기화한다.\n플러시를 실행하면 일어나는 일 변경 감지가 동작해서 영속성 컨텍스트에 있는 모든 엔티티를 스냅샷과 비교해서 수정된 엔티티를 찾는다.\n수정된 엔티티는 수정 쿼리를 만들어 쓰기 지연 SQL 저장소에 등록 쓰기 지연 SQL 저장소의 쿼리를 데이터베이스에 전송한다 (등록, 수정, 삭제 쿼리)\n영속성 컨텍스트를 플러시하는 방법 em.flush() 를 직접 호출한다.\n테스트때 에만 주로 사용 트랜잭션 커밋 시, 플러시가 자동 호출 된다.\n커밋만 하고, SQL을 하지 않으면 DB에 데이터 갱신이 일어나지 않는다.\n이 문제 예방하기 위해 커밋할 때 플러시를 자동 호출\nJPQL 쿼리 실행 시, 플러시가 자동 호출 된다.\n​\t변경 내용을 DB에 반영해야 JPQL으로 엔티티 조회가 가능하다.\n참고로 식별자를 기준으로 조회하는 find() 메서드를 호출할 때는 플러시가 실행되지 않는다.\n3.5.1 플러시 모드 옵션 FlushModeType.AUTO: 커밋이나 쿼리를 실행할 때 플러시 (기본값) FlushModeType.COMMIT: 커밋할 때만 플러시 데이터베이스와 동기화를 최대한 늦추는 것이 가능한 이유는 트랜잭션이라는 작업 단위가 있기 때문이다.\n트랜잭션 커밋 직전에만 변경 내용을 데이터베이스에 보내 동기화하면 된다.\n3.6 준영속 준영속 상태의 엔티티는 영속성 컨텍스트가 제공하는 기능을 사용할 수 없다.\n엔티티를 준영속 상태로 만드는 방법 em.detach(entity): 특정 엔티티만 준영속 상태로 전환한다. em.clear(): 영속성 컨텍스트를 완전히 초기화한다. em.close(): 영속성 컨텍스트를 종료한다. 병합; merge() = 준영속에서 다시 영속상태로 변경 병합(merge)은 준영속, 비영속을 신경 쓰지 않는다.\n식별자 값으로 엔티티를 조회할 수 있으면 불러서 병합하고 조회할 수 없으면 새로 엔티티를 생성해서 병합한다.\n따라서 병합은 save or update 기능을 수행한다.\nReference 자바 ORM 표준 JPA 프로그래밍 (김영한) https://product.kyobobook.co.kr/detail/S000001766367 ","wordCount":"856","inLanguage":"en","image":"https://2taezeat.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E","datePublished":"2024-08-03T11:30:03Z","dateModified":"2024-08-03T11:30:03Z","author":{"@type":"Person","name":"2taezeat"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://2taezeat.github.io/posts/jpa/%EC%9E%90%EB%B0%94-orm-%ED%91%9C%EC%A4%80-jpa-ch03.-%EC%98%81%EC%86%8D%EC%84%B1-%EA%B4%80%EB%A6%AC/"},"publisher":{"@type":"Organization","name":"2taezeat, blog","logo":{"@type":"ImageObject","url":"https://2taezeat.github.io/icon/favicon.ico"}}}</script></head><body id=top><header class=header><nav class=nav><div class=logo><a href=https://2taezeat.github.io/ accesskey=h title="2taezeat blog (Alt + H)"><img src=https://2taezeat.github.io/icon/apple-touch-icon.png alt aria-label=logo height=30>2taezeat blog</a><div class=logo-switches></div></div><ul id=menu><li><a href=https://2taezeat.github.io/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://2taezeat.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://2taezeat.github.io/searchs/ title=Search><span>Search</span></a></li><li><a href=https://github.com/2taezeat title=Github><span>Github</span>&nbsp;<svg fill="none" shape-rendering="geometricPrecision" stroke="currentcolor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2.5" viewBox="0 0 24 24" height="12" width="12"><path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"/><path d="M15 3h6v6"/><path d="M10 14 21 3"/></svg></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://2taezeat.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://2taezeat.github.io/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">[자바 ORM 표준 JPA] ch03. 영속성 관리</h1><div class=post-description>자바 ORM 표준 JPA 프로그래밍, ch03. 영속성 관리, 간단 정리</div><div class=post-meta><span title='2024-08-03 11:30:03 +0000 +0000'>2024-08-03</span>&nbsp;·&nbsp;5 min&nbsp;·&nbsp;856 words&nbsp;·&nbsp;2taezeat</div></header><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#31-엔티티-매니저-팩토리와-엔티티-매니저>3.1 엔티티 매니저 팩토리와 엔티티 매니저</a></li><li><a href=#32-영속성-컨텍스트란>3.2 영속성 컨텍스트란?</a></li><li><a href=#33-엔티티의-생명주기>3.3 엔티티의 생명주기</a></li><li><a href=#34-영속성-컨텍스트의-특징>3.4 영속성 컨텍스트의 특징</a><ul><li><a href=#341-엔티티-조회>3.4.1 엔티티 조회</a><ul><li><a href=#1차-캐시에서-조회>1차 캐시에서 조회</a></li><li><a href=#db에서-조회>DB에서 조회</a></li><li><a href=#영속-엔티티의-동일성-보장>영속 엔티티의 동일성 보장</a></li></ul></li><li><a href=#342-엔티티-등록>3.4.2 엔티티 등록</a><ul><li><a href=#트랜잭션을-지원하는-쓰기-지연이-가능한-이유>트랜잭션을 지원하는 쓰기 지연이 가능한 이유</a></li></ul></li><li><a href=#343-엔티티-수정>3.4.3 엔티티 수정</a></li><li><a href=#344-엔티티-삭제>3.4.4 엔티티 삭제</a></li></ul></li><li><a href=#35-플러시>3.5 플러시</a><ul><li><ul><li><a href=#플러시를-실행하면-일어나는-일>플러시를 실행하면 일어나는 일</a></li><li><a href=#영속성-컨텍스트를-플러시하는-방법>영속성 컨텍스트를 플러시하는 방법</a></li></ul></li><li><a href=#351-플러시-모드-옵션>3.5.1 플러시 모드 옵션</a></li></ul></li><li><a href=#36-준영속>3.6 준영속</a><ul><li><ul><li><a href=#엔티티를-준영속-상태로-만드는-방법>엔티티를 준영속 상태로 만드는 방법</a></li></ul></li><li><a href=#병합-merge--준영속에서-다시-영속상태로-변경>병합; <code>merge()</code> = 준영속에서 다시 영속상태로 변경</a></li></ul></li><li><a href=#reference>Reference</a></li></ul></nav></div></details></div><div class=post-content><h1 id=31-엔티티-매니저-팩토리와-엔티티-매니저>3.1 엔티티 매니저 팩토리와 엔티티 매니저<a hidden class=anchor aria-hidden=true href=#31-엔티티-매니저-팩토리와-엔티티-매니저>#</a></h1><ul><li>엔티티 매니저는 엔티티와 관련된 모든 일을 처리 (CRUD 등)<ul><li>개발자 입장에서는 엔티티 매니저를 가상의 DB라고 생각하면 된다</li></ul></li></ul><p><img loading=lazy src=/images/JPA/SCR-20240828-qjjm.png alt=SCR-20240828-qjjm width=680 height=auto></p><ul><li><strong>엔티티 매니저 팩토리</strong>는 여러 스레드가 동시에 접근해도 안전하므로 서로 다른 스레드 간에 공유해도 된다</li><li><strong>엔티티 매니저</strong>는 여러 스레드가 동시에 접근하면 동시성 문제가 발생하므로 스레드 간에 절대 공유하면 안 된다.</li><li>엔티티 매니저는 데이터베이스 연결(connection)은 트랜잭션을 시작할 때 획득</li></ul><h1 id=32-영속성-컨텍스트란>3.2 영속성 컨텍스트란?<a hidden class=anchor aria-hidden=true href=#32-영속성-컨텍스트란>#</a></h1><ul><li><strong>영속성 컨텍스트(persistence context)</strong> 는 엔티티를 영구 저장하는 환경 이다.<ul><li>엔티티 매니저는 영속성 컨텍스트에 엔티티를 보관 및 관리</li><li><code>persist()</code> 메서드는 엔티티 매니저를 사용해서 회원 엔티티를 영속성 컨텍스트에 저장</li><li>논리적인 개념에 가깝다.</li></ul></li></ul><h1 id=33-엔티티의-생명주기>3.3 엔티티의 생명주기<a hidden class=anchor aria-hidden=true href=#33-엔티티의-생명주기>#</a></h1><p><img loading=lazy src=/images/JPA/SCR-20240828-qkwg.png alt=SCR-20240828-qkwg width=680 height=auto></p><ul><li><p><strong>비영속(new/transient)</strong> : 영속성 컨텍스트와 전혀 관계가 없는 상태</p><p><img loading=lazy src=/images/JPA/SCR-20240828-qliz.png alt=SCR-20240828-qliz width=680 height=auto></p></li><li><p><strong>영속(managed)</strong> : 영속성 컨텍스트에 저장된 상태, 영속성 컨텍스트가 관리하는 상태</p><p>​ <img loading=lazy src=/images/JPA/SCR-20240828-qlkt.png alt=SCR-20240828-qlkt width=680 height=auto></p><ul><li><code>em.find()</code> 나 JPQL 을 사용해서 조회한 엔티티도 영속 상태이다.</li></ul></li><li><p><strong>준영속(detached)</strong> : 영속성 컨텍스트에 저장되었다가 분리된 상태</p><ul><li>특정 엔티티를 준영속 상태로 만들려면 <code>em.detach()</code> 를 호출하면 된다</li><li><code>em.close()</code> ,<code>em.clear()</code> 로 영속성 컨텍스트를 초기화 해도 관리하던 엔티티는 준영속 상태가 된다</li></ul></li><li><p><strong>삭제(removed)</strong> : 엔티티를 영속성 컨텍스트와 DB에 삭제된 상태</p></li></ul><h1 id=34-영속성-컨텍스트의-특징>3.4 영속성 컨텍스트의 특징<a hidden class=anchor aria-hidden=true href=#34-영속성-컨텍스트의-특징>#</a></h1><ul><li><p><strong>영속성 컨텍스트와 식별자 값</strong></p><ul><li><p>영속성 컨텍스트는 엔티티를 식별자 값(<code>@Id</code> 로 테이블의 기본 키와 매핑한 값)으로 구분한다.</p></li><li><p>따라서 영속 상태는 식별자 값이 반드시 있어야 한다.</p></li><li><p>식별자 값이 없으면 예외가 발생한다.</p></li></ul></li><li><p><strong>영속성 컨텍스트에 엔티티를 저장하면 이 엔티티는 언제 데이터베이스에 저장될까?</strong></p><ul><li>JPA는 보통 트랜잭션을 커밋하는 순간 영속성 컨텍스트에 새로 저장된 엔티티를 데이터베이스에 반영, 이것을 <strong>플러시(flush)</strong> 라 한다.</li></ul></li><li><p><strong>영속성 컨텍스트가 엔티티를 관리할 때 장점</strong></p><ul><li><p>1차 캐시</p></li><li><p>동일성 보장</p></li><li><p>트랜잭션을 지원하는 쓰기 지연</p></li><li><p>변경 감지</p></li><li><p>지연 로딩</p></li></ul></li></ul><h2 id=341-엔티티-조회>3.4.1 엔티티 조회<a hidden class=anchor aria-hidden=true href=#341-엔티티-조회>#</a></h2><p><img loading=lazy src=/images/JPA/SCR-20240828-qntm.png alt=SCR-20240828-qntm width=680 height=auto></p><ul><li><p>영속성 컨텍스트는 내부에 캐시를 가지고 있는데 이것을 1차 캐시라 한다.</p></li><li><p>1차 캐시의 키는 식별자 값, 영속성 컨텍스트에 데이터를 저장, 조회하는 모든 기준은 DB의 <strong>기본 키 값</strong></p></li></ul><h3 id=1차-캐시에서-조회>1차 캐시에서 조회<a hidden class=anchor aria-hidden=true href=#1차-캐시에서-조회>#</a></h3><p><img loading=lazy src=/images/JPA/SCR-20240828-qoga.png alt=SCR-20240828-qoga width=680 height=auto></p><h3 id=db에서-조회>DB에서 조회<a hidden class=anchor aria-hidden=true href=#db에서-조회>#</a></h3><p><img loading=lazy src=/images/JPA/SCR-20240828-qooc.png alt=SCR-20240828-qooc width=680 height=auto></p><ul><li>만약 <code>em.find()</code> 를 호출했는데 엔티티가 1차 캐시에 없으면 엔티티 매니저는 데이터베이스를 조회해서 엔티티를 생성한다.</li><li>그리고 1차 캐시에 저장한 후에 영속 상태의 엔티티를 반환한다.</li></ul><h3 id=영속-엔티티의-동일성-보장>영속 엔티티의 동일성 보장<a hidden class=anchor aria-hidden=true href=#영속-엔티티의-동일성-보장>#</a></h3><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=n>Menber</span><span class=w> </span><span class=n>a</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>em</span><span class=p>.</span><span class=na>find</span><span class=p>(</span><span class=n>Member</span><span class=p>.</span><span class=na>class</span><span class=p>,</span><span class=w> </span><span class=s>&#34;member1&#34;</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>Member</span><span class=w> </span><span class=n>b</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>em</span><span class=p>.</span><span class=na>find</span><span class=p>(</span><span class=n>Member</span><span class=p>.</span><span class=na>class</span><span class=p>,</span><span class=w> </span><span class=s>&#34;member1&#34;</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>a</span><span class=w> </span><span class=o>==</span><span class=w> </span><span class=n>b</span><span class=w> </span><span class=c1>// true</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><ul><li><code>em.find(Member.class, "member1");</code> 을 반복 호출 해도, 1차 캐시에 있는 같은 엔티티 인스턴스를 반환한다.</li></ul><blockquote><p>JPA는 1차 캐시를 통해 <strong>반복 가능한 읽기(REPEATABLE READ)</strong> 등급의 트랜잭션 격리 수준을 <strong>DB가 아닌 App 차원</strong>에서 제공한다는 장점이 있다.</p></blockquote><h2 id=342-엔티티-등록>3.4.2 엔티티 등록<a hidden class=anchor aria-hidden=true href=#342-엔티티-등록>#</a></h2><p><img loading=lazy src=/images/JPA/SCR-20240828-qsbp.png alt=SCR-20240828-qsbp width=680 height=auto></p><p><img loading=lazy src=/images/JPA/SCR-20240828-qrrl.png alt=SCR-20240828-qrrl width=680 height=auto></p><p><img loading=lazy src=/images/JPA/SCR-20240828-qshp.png alt=SCR-20240828-qshp width=680 height=auto></p><ul><li><p>엔티티 매니저는 트랜잭션을 커밋하기 직전까지 데이터베이스에 엔티티를 저장하지 않고, <strong>내부 쿼리 저장소</strong>에 INSERT SQL을 차곡차곡 모아둔다.</p></li><li><p>트랜잭션을 <strong>커밋</strong>할 때 모아둔 쿼리를 데이터베이스에 보낸다.</p><ul><li>이것을 트랜잭션을 지원하는 <strong>쓰기 지연 transactional write-behind</strong>이라 한다.</li></ul></li><li><p>트랜잭션을 커밋하면 엔티티 매니저는 우선 영속성 컨텍스트를 <strong>플러시</strong>한다.</p></li><li><p><strong>플러시</strong>는 <strong>영속성 컨텍스트의 변경 내용을 데이터베이스에 동기화하는 작업</strong></p><ul><li>이때 등록, 수정, 삭제한 엔티티를 데이터베이스에 반영한다.</li><li><strong>쓰기 지연 SQL 저장소</strong>에 모인 쿼리를 데이터베이스에 보낸다.</li><li>이렇게 영속성 컨텍스트의 변경 내용을 <strong>데이터베이스에 동기화한 후</strong>에 <strong>실제 데이터베이스 트랜잭션을 커밋</strong>한다.</li></ul></li></ul><h3 id=트랜잭션을-지원하는-쓰기-지연이-가능한-이유>트랜잭션을 지원하는 쓰기 지연이 가능한 이유<a hidden class=anchor aria-hidden=true href=#트랜잭션을-지원하는-쓰기-지연이-가능한-이유>#</a></h3><ul><li>데이터베이스에 전달해도 트랜잭션을 커밋하지 않으면 아무 소용이 없다.</li><li><strong>어떻게든 커밋 직전에만 데이터베이스에 SOL을 전달하면 된다.</strong><ul><li>이것이 트랜잭션을 지원하는 쓰기 지연이 가능한 이유</li><li>이를 활용해, 모아둔 등록 쿼리를 데이터베이스에 한 번에 전달해서 성능을 최적화할 수 있다.</li></ul></li></ul><h2 id=343-엔티티-수정>3.4.3 엔티티 수정<a hidden class=anchor aria-hidden=true href=#343-엔티티-수정>#</a></h2><p><img loading=lazy src=/images/JPA/SCR-20240828-qwxv.png alt=SCR-20240828-qwxv width=680 height=auto></p><ul><li>JPA로 엔티티를 수정할 때는 단순히 <strong>엔티티를 조회해서 데이터만 변경</strong>하면 된다.</li><li>트랜잭션 커밋 직전에 주석으로 처리된 <code>em.update()</code> 메소드를 실행해야 할 것 같지만 이런 메소드는 없다.</li><li>엔티티의 변경사항을 데이터베이스에 자동으로 반영하는 기능을 <strong>변경 감지(dirty checking)</strong> 라 한다.</li></ul><p><img loading=lazy src=/images/JPA/SCR-20240828-qxdr.png alt=SCR-20240828-qxdr width=680 height=auto></p><ul><li>JPA는 엔티티를 영속성 컨텍스트에 보관할 때. 최초 상태를 복사해서 저장해두는데 이것을 <strong>스냅샷</strong>이라 한다.</li><li>그리고 플러시 시점에 스냅샷과 엔티티를 비교해서 변경된 엔티티를 찾는다.</li><li>변경된 엔티티가 있으면 수정 쿼리를 생성해서 <strong>쓰기 지연 SQL 저장소</strong>에 보내고, 이후 <strong>등록 과정</strong>이 진행된다.</li></ul><blockquote><p>변경 감지는 영속성 컨텍스트가 관리하는 <strong>영속 상태의 엔티티에만</strong> 적용된다.</p></blockquote><ul><li><p>JPA의 기본 전략은 엔티티의 <strong>모든 필드를 업데이트</strong>한다.</p><ul><li>모든 필드를 사용하면 수정 쿼리가 항상 같다(물론 바인딩되는 데이터는 다르다).<ul><li>따라서 애플리케이션 로딩 시점에 <strong>수정 쿼리를 미리 생성해두고 재사용할</strong> 수 있다.</li></ul></li><li>데이터베이스에 동일한 쿼리를 보내면 데이터베이스는 이전에 한 번 파싱된 쿼리를 <strong>재사용</strong>할 수 있다.</li></ul></li><li><p><code>org.hibernate.annotations.Dynamicupdate</code> 어노테이션으로 수정된 데이터만 사용해서 동적으로 UPDATE SQL을 생성할 수 도 있다.</p></li></ul><h2 id=344-엔티티-삭제>3.4.4 엔티티 삭제<a hidden class=anchor aria-hidden=true href=#344-엔티티-삭제>#</a></h2><ul><li>엔티티 삭제하려면 삭제 대상 엔티티를 조회(<code>find</code>) 해야 한다.</li><li>삭제 과정은 엔티티 등록 과정과 비슷하다</li><li>삭제된 엔티티는 재사용 하지 말고, GC의 대상이 두는 것이 좋다.</li></ul><h1 id=35-플러시>3.5 플러시<a hidden class=anchor aria-hidden=true href=#35-플러시>#</a></h1><p>플러시;<code>flush()</code> 는 <strong>영속성 컨텍스트의 변경 내용</strong>을 <strong>데이터베이스에 반영, 동기화</strong>한다.</p><h3 id=플러시를-실행하면-일어나는-일>플러시를 실행하면 일어나는 일<a hidden class=anchor aria-hidden=true href=#플러시를-실행하면-일어나는-일>#</a></h3><ul><li><p>변경 감지가 동작해서 영속성 컨텍스트에 있는 모든 엔티티를 스냅샷과 비교해서 수정된 엔티티를 찾는다.</p><ul><li>수정된 엔티티는 수정 쿼리를 만들어 쓰기 지연 SQL 저장소에 등록</li></ul></li><li><p><strong>쓰기 지연 SQL 저장소의 쿼리</strong>를 <strong>데이터베이스에 전송</strong>한다 (등록, 수정, 삭제 쿼리)</p></li></ul><h3 id=영속성-컨텍스트를-플러시하는-방법>영속성 컨텍스트를 플러시하는 방법<a hidden class=anchor aria-hidden=true href=#영속성-컨텍스트를-플러시하는-방법>#</a></h3><ol><li><p><code>em.flush()</code> 를 직접 호출한다.</p><ul><li>테스트때 에만 주로 사용</li></ul></li><li><p>트랜잭션 커밋 시, 플러시가 자동 호출 된다.</p><ul><li><p>커밋만 하고, SQL을 하지 않으면 DB에 데이터 갱신이 일어나지 않는다.</p></li><li><p>이 문제 예방하기 위해 커밋할 때 플러시를 자동 호출</p></li></ul></li><li><p>JPQL 쿼리 실행 시, 플러시가 자동 호출 된다.</p><p>​ <img loading=lazy src=/images/JPA/SCR-20240828-rcbc.png alt=SCR-20240828-rcbc width=680 height=auto></p><ul><li><p>변경 내용을 DB에 반영해야 JPQL으로 엔티티 조회가 가능하다.</p></li><li><p>참고로 식별자를 기준으로 조회하는 <code>find()</code> 메서드를 호출할 때는 플러시가 실행되지 않는다.</p></li></ul></li></ol><h2 id=351-플러시-모드-옵션>3.5.1 플러시 모드 옵션<a hidden class=anchor aria-hidden=true href=#351-플러시-모드-옵션>#</a></h2><ul><li><code>FlushModeType.AUTO</code>: 커밋이나 쿼리를 실행할 때 플러시 (<strong>기본값</strong>)</li><li><code>FlushModeType.COMMIT</code>: 커밋할 때만 플러시</li></ul><blockquote><p>데이터베이스와 동기화를 최대한 늦추는 것이 가능한 이유는 트랜잭션이라는 작업 단위가 있기 때문이다.</p><p>트랜잭션 커밋 직전에만 변경 내용을 데이터베이스에 보내 동기화하면 된다.</p></blockquote><h1 id=36-준영속>3.6 준영속<a hidden class=anchor aria-hidden=true href=#36-준영속>#</a></h1><p>준영속 상태의 엔티티는 영속성 컨텍스트가 제공하는 기능을 사용할 수 없다.</p><h3 id=엔티티를-준영속-상태로-만드는-방법>엔티티를 준영속 상태로 만드는 방법<a hidden class=anchor aria-hidden=true href=#엔티티를-준영속-상태로-만드는-방법>#</a></h3><ol><li><code>em.detach(entity)</code>: 특정 엔티티만 준영속 상태로 전환한다.</li><li><code>em.clear()</code>: 영속성 컨텍스트를 완전히 초기화한다.</li><li><code>em.close()</code>: 영속성 컨텍스트를 종료한다.</li></ol><h2 id=병합-merge--준영속에서-다시-영속상태로-변경>병합; <code>merge()</code> = 준영속에서 다시 영속상태로 변경<a hidden class=anchor aria-hidden=true href=#병합-merge--준영속에서-다시-영속상태로-변경>#</a></h2><p><img loading=lazy src=/images/JPA/SCR-20240828-reoz.png alt=SCR-20240828-reoz width=680 height=auto></p><blockquote><p>병합(merge)은 <strong>준영속, 비영속</strong>을 신경 쓰지 않는다.</p><p>식별자 값으로 엔티티를 조회할 수 있으면 불러서 병합하고 조회할 수 없으면 새로 엔티티를 생성해서 병합한다.</p><p>따라서 병합은 <strong>save or update</strong> 기능을 수행한다.</p></blockquote><h1 id=reference>Reference<a hidden class=anchor aria-hidden=true href=#reference>#</a></h1><ul><li>자바 ORM 표준 JPA 프로그래밍 (김영한) <a href=https://product.kyobobook.co.kr/detail/S000001766367>https://product.kyobobook.co.kr/detail/S000001766367</a></li></ul></div><footer class=post-footer><ul class=post-tags><li><a href=https://2taezeat.github.io/tags/jpa/>JPA</a></li><li><a href=https://2taezeat.github.io/tags/backend/>Backend</a></li></ul><nav class=paginav><a class=prev href=https://2taezeat.github.io/posts/jpa/%EC%9E%90%EB%B0%94-orm-%ED%91%9C%EC%A4%80-jpa-ch04.-%EC%97%94%ED%8B%B0%ED%8B%B0-%EB%A7%A4%ED%95%91/><span class=title>« Prev</span><br><span>[자바 ORM 표준 JPA] ch04. 엔티티 매핑</span>
</a><a class=next href=https://2taezeat.github.io/posts/jpa/%EC%9E%90%EB%B0%94-orm-%ED%91%9C%EC%A4%80-jpa-ch02.-jpa-%EC%8B%9C%EC%9E%91/><span class=title>Next »</span><br><span>[자바 ORM 표준 JPA] ch02. JPA 시작</span></a></nav><ul class=share-buttons><li><a target=_blank rel="noopener noreferrer" aria-label="share [자바 ORM 표준 JPA] ch03. 영속성 관리 on x" href="https://x.com/intent/tweet/?text=%5b%ec%9e%90%eb%b0%94%20ORM%20%ed%91%9c%ec%a4%80%20JPA%5d%20ch03.%20%ec%98%81%ec%86%8d%ec%84%b1%20%ea%b4%80%eb%a6%ac&amp;url=https%3a%2f%2f2taezeat.github.io%2fposts%2fjpa%2f%25EC%259E%2590%25EB%25B0%2594-orm-%25ED%2591%259C%25EC%25A4%2580-jpa-ch03.-%25EC%2598%2581%25EC%2586%258D%25EC%2584%25B1-%25EA%25B4%2580%25EB%25A6%25AC%2f&amp;hashtags=JPA%2cBackend"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446C483.971.0 512 28.03 512 62.554zM269.951 190.75 182.567 75.216H56L207.216 272.95 63.9 436.783h61.366L235.9 310.383l96.667 126.4H456L298.367 228.367l134-153.151H371.033zM127.633 110h36.468l219.38 290.065H349.5z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share [자바 ORM 표준 JPA] ch03. 영속성 관리 on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2f2taezeat.github.io%2fposts%2fjpa%2f%25EC%259E%2590%25EB%25B0%2594-orm-%25ED%2591%259C%25EC%25A4%2580-jpa-ch03.-%25EC%2598%2581%25EC%2586%258D%25EC%2584%25B1-%25EA%25B4%2580%25EB%25A6%25AC%2f&amp;title=%5b%ec%9e%90%eb%b0%94%20ORM%20%ed%91%9c%ec%a4%80%20JPA%5d%20ch03.%20%ec%98%81%ec%86%8d%ec%84%b1%20%ea%b4%80%eb%a6%ac&amp;summary=%5b%ec%9e%90%eb%b0%94%20ORM%20%ed%91%9c%ec%a4%80%20JPA%5d%20ch03.%20%ec%98%81%ec%86%8d%ec%84%b1%20%ea%b4%80%eb%a6%ac&amp;source=https%3a%2f%2f2taezeat.github.io%2fposts%2fjpa%2f%25EC%259E%2590%25EB%25B0%2594-orm-%25ED%2591%259C%25EC%25A4%2580-jpa-ch03.-%25EC%2598%2581%25EC%2586%258D%25EC%2584%25B1-%25EA%25B4%2580%25EB%25A6%25AC%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share [자바 ORM 표준 JPA] ch03. 영속성 관리 on reddit" href="https://reddit.com/submit?url=https%3a%2f%2f2taezeat.github.io%2fposts%2fjpa%2f%25EC%259E%2590%25EB%25B0%2594-orm-%25ED%2591%259C%25EC%25A4%2580-jpa-ch03.-%25EC%2598%2581%25EC%2586%258D%25EC%2584%25B1-%25EA%25B4%2580%25EB%25A6%25AC%2f&title=%5b%ec%9e%90%eb%b0%94%20ORM%20%ed%91%9c%ec%a4%80%20JPA%5d%20ch03.%20%ec%98%81%ec%86%8d%ec%84%b1%20%ea%b4%80%eb%a6%ac"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share [자바 ORM 표준 JPA] ch03. 영속성 관리 on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2f2taezeat.github.io%2fposts%2fjpa%2f%25EC%259E%2590%25EB%25B0%2594-orm-%25ED%2591%259C%25EC%25A4%2580-jpa-ch03.-%25EC%2598%2581%25EC%2586%258D%25EC%2584%25B1-%25EA%25B4%2580%25EB%25A6%25AC%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share [자바 ORM 표준 JPA] ch03. 영속성 관리 on whatsapp" href="https://api.whatsapp.com/send?text=%5b%ec%9e%90%eb%b0%94%20ORM%20%ed%91%9c%ec%a4%80%20JPA%5d%20ch03.%20%ec%98%81%ec%86%8d%ec%84%b1%20%ea%b4%80%eb%a6%ac%20-%20https%3a%2f%2f2taezeat.github.io%2fposts%2fjpa%2f%25EC%259E%2590%25EB%25B0%2594-orm-%25ED%2591%259C%25EC%25A4%2580-jpa-ch03.-%25EC%2598%2581%25EC%2586%258D%25EC%2584%25B1-%25EA%25B4%2580%25EB%25A6%25AC%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share [자바 ORM 표준 JPA] ch03. 영속성 관리 on telegram" href="https://telegram.me/share/url?text=%5b%ec%9e%90%eb%b0%94%20ORM%20%ed%91%9c%ec%a4%80%20JPA%5d%20ch03.%20%ec%98%81%ec%86%8d%ec%84%b1%20%ea%b4%80%eb%a6%ac&amp;url=https%3a%2f%2f2taezeat.github.io%2fposts%2fjpa%2f%25EC%259E%2590%25EB%25B0%2594-orm-%25ED%2591%259C%25EC%25A4%2580-jpa-ch03.-%25EC%2598%2581%25EC%2586%258D%25EC%2584%25B1-%25EA%25B4%2580%25EB%25A6%25AC%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentcolor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share [자바 ORM 표준 JPA] ch03. 영속성 관리 on ycombinator" href="https://news.ycombinator.com/submitlink?t=%5b%ec%9e%90%eb%b0%94%20ORM%20%ed%91%9c%ec%a4%80%20JPA%5d%20ch03.%20%ec%98%81%ec%86%8d%ec%84%b1%20%ea%b4%80%eb%a6%ac&u=https%3a%2f%2f2taezeat.github.io%2fposts%2fjpa%2f%25EC%259E%2590%25EB%25B0%2594-orm-%25ED%2591%259C%25EC%25A4%2580-jpa-ch03.-%25EC%2598%2581%25EC%2586%258D%25EC%2584%25B1-%25EA%25B4%2580%25EB%25A6%25AC%2f"><svg width="30" height="30" viewBox="0 0 512 512" fill="currentcolor" xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"><path d="M449.446.0C483.971.0 512 28.03 512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446zM183.8767 87.9921h-62.034L230.6673 292.4508V424.0079h50.6655V292.4508L390.1575 87.9921H328.1233L256 238.2489z"/></svg></a></li></ul></footer><script src=https://utteranc.es/client.js repo=2taezeat/blog_comment issue-term=pathname label=comment theme=github-light crossorigin=anonymous async></script></article></main><footer class=footer><span>&copy; 2024 <a href=https://2taezeat.github.io/>2taezeat, blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>