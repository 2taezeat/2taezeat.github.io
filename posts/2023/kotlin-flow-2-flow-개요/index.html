<!doctype html><html lang=en dir=auto><head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Kotlin Flow, (2) Flow 개요 | 2taezeat, blog</title>
<meta name=keywords content><meta name=description content="Flow란 무엇인가?"><meta name=author content="2taezeat"><link rel=canonical href=http://localhost:1313/posts/2023/kotlin-flow-2-flow-%EA%B0%9C%EC%9A%94/><meta name=google-site-verification content="YaEERzgrvu-ZwPg7gswZdTzRMufkHw3uIH7i8hVal1c"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.6e2e604ea5f627f6fb97a6a218445753397c457285e9bb47bd4cea346337d49e.css integrity="sha256-bi5gTqX2J/b7l6aiGERXUzl8RXKF6btHvUzqNGM31J4=" rel="preload stylesheet" as=style><link rel=icon href=http://localhost:1313/icon/favicon.ico><link rel=icon type=image/png sizes=16x16 href=http://localhost:1313/icon/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=http://localhost:1313/icon/favicon-32x32.png><link rel=apple-touch-icon href=http://localhost:1313/icon/apple-touch-icon.png><link rel=mask-icon href=http://localhost:1313/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=http://localhost:1313/posts/2023/kotlin-flow-2-flow-%EA%B0%9C%EC%9A%94/><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><meta property="og:title" content="Kotlin Flow, (2) Flow 개요"><meta property="og:description" content="Flow란 무엇인가?"><meta property="og:type" content="article"><meta property="og:url" content="http://localhost:1313/posts/2023/kotlin-flow-2-flow-%EA%B0%9C%EC%9A%94/"><meta property="og:image" content="http://localhost:1313/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-11-12T01:54:46+09:00"><meta property="article:modified_time" content="2023-11-12T01:54:46+09:00"><meta property="og:site_name" content="2taezeat, blog"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="http://localhost:1313/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="Kotlin Flow, (2) Flow 개요"><meta name=twitter:description content="Flow란 무엇인가?"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"http://localhost:1313/posts/"},{"@type":"ListItem","position":2,"name":"Kotlin Flow, (2) Flow 개요","item":"http://localhost:1313/posts/2023/kotlin-flow-2-flow-%EA%B0%9C%EC%9A%94/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Kotlin Flow, (2) Flow 개요","name":"Kotlin Flow, (2) Flow 개요","description":"Flow란 무엇인가?\n","keywords":[],"articleBody":"Flow란 무엇인가?\n플로우란 무엇인가? 플로우(flow)는 비동기적으로 계산해야 할 값의 스트림을 나타낸다. 플로우는 시퀀스와 달리 코루틴을 지원하며, 비동기적으로 계산되는 값을 나타낸다. Flow 인터페이스 자체는 떠다니는 원소들을 모으는 역할을 하며, 플로우의 끝에 도달할 때까지 각 값을 처리하는 것 의미한다. Flow의 collect 는 컬렉션의 forEach와 비슷하다. Flow의 유일한 멤버 함수는 collect(최종 연산) 이다. 다른 함수는 확장 함수로 정의되어 있다. 1 2 3 interface Flow\u003cout T\u003e { suspend fun collect(collector: FlowCollector\u003cT\u003e) } 시퀀스(Sequence)의 최종 연산은 중단 함수가 아니기 때문에, 시퀀스 빌더 내부에 중단점이 있다면 값을 기다리는 스레드가 블로킹 된다. 따라서 sequencee 빌더의 스코프에서는 yield, yieldAll 외에 다른 중단 함수를 사용할 수 없다. Sequence의 iterator가 중단 함수가 아니기 때문에, 시퀀스의 원소를 소비할 때 블로킹이 되는 것이 문제가 된다. 1 2 3 4 5 6 7 8 9 10 11 // Don't do that, we should use Flow instead of Sequence fun allUsersSequence( api: UserApi ): Sequence\u003cUser\u003e = sequence { var page = 0 do { val users = api.takePage(page++) //suspend 함수 임으로, so compilation error yieldAll(users) } while (!users.isNullOrEmpty()) } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 // 하나의 코루틴이 다른 코루틴을 블로킹하게 된다. // 같은 스레드에서 launch로 시작된 코루틴이 대기 하게 된다. fun getSequence(): Sequence\u003cString\u003e = sequence { repeat(3) { Thread.sleep(1000) // the same result as if there were delay(1000) here yield(\"User$it\") } } suspend fun main() { withContext(newSingleThreadContext(\"main\")) { launch { repeat(3) { delay(100) println(\"Processing on coroutine\") } } val list = getSequence() list.forEach { println(it) } } } // (1 sec) // User0 // (1 sec) // User1 // (1 sec) // User2 // Processing on coroutine // (0.1 sec) // Processing on coroutine // (0.1 sec) // Processing on coroutine Sequence를 사용했기 때문에 forEach가 블로킹 연산이 된다.\n따라서 같은 스레드에서 launch로 시작된 코루틴이 대기하게 되며, 하나의 코루틴이 다른 코루틴을 블로킹하게 된다. 이런 상황에서 Sequence 대신 Flow를 사용해야 한다.\n플로우를 사용하면 코루틴이 연산을 수행하는 데 필요한 기능을 전부 사용할 수 있다.\n플로우의 빌더와 연산은 중단 함수(suspend) 이며, 구조화된 동시성과 적절한 예외 처리를 지원한다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 fun getFlow(): Flow\u003cString\u003e = flow { repeat(3) { delay(1000) emit(\"User$it\") } } suspend fun main() { withContext(newSingleThreadContext(\"main\")) { launch { repeat(3) { delay(100) println(\"Processing on coroutine\") } } val list = getFlow() list.collect { println(it) } } } // (0.1 sec) // Processing on coroutine // (0.1 sec) // Processing on coroutine // (0.1 sec) // Processing on coroutine // (1 - 3 * 0.1 = 0.7 sec) // User0 // (1 sec) // User1 // (1 sec) // User2 플로우의 특징 collect(중단 함수)와 같은 플로우의 최종 연산은 스레드를 블로킹하는 대신 코루틴을 중단시킨다. 플로우는 Coroutine Context 를 활용하고, 예외를 처리하는 등의 코루틴 기능도 제공한다. 플로우 처리는 취소(cancel) 가능하며, 구조화된 동시성을 갖추고 있다. flow 빌더는 중단 함수가 아니며, 어떠한 스코프도 필요하지 않다. 플로우의 최종 연산은 중단 가능하며, 연산이 실행될 때, 부모 코루틴과의 관계가 정립된다. (coroutineScope 함수와 비슷) launch 를 취소하면, 플로우 처리도 적절하게 취소된다. 플로우 명명법 플로우는 어딘가에서 시작 되어야 한다. (플로우 빌더, 다른 객체에서의 변환 또는 헬퍼 함수로 시작된다.)\n플로우의 마지막 연산은 최종 연산이라고 불리며, 중단 가능하거나 스코프를 필요로 하는 유일한 연산이다.\n최종 연산은 주로 람다 표현식을 가지거나 가지지 않는 collect 가 된다. 시작 연산과 최종 연산 사이에 플로우를 변경하는 중간 연산(intermediate operation)을 가질 수 있다.\n플로우 사용 예시 주로 이벤트를 감지해야 할 필요가 있을 때, 사용 서버가 보낸 이벤트를 통해 전달된 메시지를 받는 경우 텍스트 입력 또는 클릭과 같은 사용자 액션이 감지된 경우 센서 또는 위치나 지도와 같은 기기의 정보 변경을 받는 경우 데이터베이스의 변경을 감지하는 경우 플로우는 이 밖의 경우에도 동시성 처리 를 위해 유용하게 사용 될 수 있다.\n1 2 3 4 5 6 7 8 9 suspend fun getOffers( sellers: List\u003cSeller\u003e ): List\u003cOffer\u003e = coroutineScope { sellers .map { seller -\u003e async { api.requestOffers(seller.id) } } .flatMap { it.await() } } 컬렉션 처리 내부에서 async를 사용하면 동시 처리를 할 수 있지만,\n많은 요청을 한번에 보내면 client 뿐 아니라 server 모두에게 좋지 않다.\n1 2 3 4 5 6 7 8 suspend fun getOffers( sellers: List\u003cSeller\u003e ): List\u003cOffer\u003e = sellers .asFlow() .flatMapMerge(concurrency = 20) { seller -\u003e suspend { api.requestOffers(seller.id) }.asFlow() } .toList() 컬렉션 대신 플로우로 처리하면 동시 처리, 컨텍스트, 예외를 조절할 수 있다.\nReference https://kotlinlang.org/docs/coroutines-guide.html 코틀린 코루틴 Kotlin Coroutines: Deep Dive (Marcin Moskała, 인사이트) ","wordCount":"738","inLanguage":"en","image":"http://localhost:1313/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E","datePublished":"2023-11-12T01:54:46+09:00","dateModified":"2023-11-12T01:54:46+09:00","author":{"@type":"Person","name":"2taezeat"},"mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:1313/posts/2023/kotlin-flow-2-flow-%EA%B0%9C%EC%9A%94/"},"publisher":{"@type":"Organization","name":"2taezeat, blog","logo":{"@type":"ImageObject","url":"http://localhost:1313/icon/favicon.ico"}}}</script></head><body id=top><header class=header><nav class=nav><div class=logo><a href=http://localhost:1313/ accesskey=h title="2taezeat blog (Alt + H)"><img src=http://localhost:1313/icon/apple-touch-icon.png alt aria-label=logo height=30>2taezeat blog</a><div class=logo-switches></div></div><ul id=menu><li><a href=http://localhost:1313/tags/ title=Tags><span>Tags</span></a></li><li><a href=http://localhost:1313/archives/ title=Archives><span>Archives</span></a></li><li><a href=http://localhost:1313/searchs/ title=Search><span>Search</span></a></li><li><a href=https://github.com/2taezeat title=Github><span>Github</span>&nbsp;<svg fill="none" shape-rendering="geometricPrecision" stroke="currentcolor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2.5" viewBox="0 0 24 24" height="12" width="12"><path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"/><path d="M15 3h6v6"/><path d="M10 14 21 3"/></svg></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=http://localhost:1313/>Home</a>&nbsp;»&nbsp;<a href=http://localhost:1313/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">Kotlin Flow, (2) Flow 개요</h1><div class=post-meta><span title='2023-11-12 01:54:46 +0900 KST'>2023-11-12</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;738 words&nbsp;·&nbsp;2taezeat</div></header><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#플로우란-무엇인가>플로우란 무엇인가?</a><ul><li><a href=#플로우의-특징>플로우의 특징</a></li><li><a href=#플로우-명명법>플로우 명명법</a></li><li><a href=#플로우-사용-예시>플로우 사용 예시</a></li></ul></li><li><a href=#reference>Reference</a></li></ul></nav></div></details></div><div class=post-content><p><strong>Flow란 무엇인가?</strong></p><hr><h1 id=플로우란-무엇인가>플로우란 무엇인가?<a hidden class=anchor aria-hidden=true href=#플로우란-무엇인가>#</a></h1><ul><li>플로우(flow)는 <strong>비동기적으로 계산해야 할 값의 스트림</strong>을 나타낸다.</li><li>플로우는 시퀀스와 달리 <strong>코루틴을 지원하며, 비동기적으로 계산되는 값</strong>을 나타낸다.</li><li>Flow 인터페이스 자체는 떠다니는 원소들을 모으는 역할을 하며, 플로우의 끝에 도달할 때까지 각 값을 처리하는 것 의미한다.<ul><li><code>Flow의 collect</code> 는 <code>컬렉션의 forEach</code>와 비슷하다.</li><li>Flow의 <strong>유일한 멤버 함수는 collect(최종 연산)</strong> 이다. 다른 함수는 확장 함수로 정의되어 있다.</li></ul></li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-kotlin data-lang=kotlin><span class=line><span class=cl><span class=k>interface</span> <span class=nc>Flow</span><span class=p>&lt;</span><span class=k>out</span> <span class=n>T</span><span class=p>&gt;</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>suspend</span> <span class=k>fun</span> <span class=nf>collect</span><span class=p>(</span><span class=n>collector</span><span class=p>:</span> <span class=n>FlowCollector</span><span class=p>&lt;</span><span class=n>T</span><span class=p>&gt;)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><ul><li>시퀀스(Sequence)의 최종 연산은 중단 함수가 아니기 때문에, 시퀀스 빌더 내부에 중단점이 있다면 값을 기다리는 <strong>스레드</strong>가 <strong>블로킹</strong> 된다.<ul><li>따라서 sequencee 빌더의 스코프에서는 yield, yieldAll 외에 다른 <strong>중단 함수</strong>를 사용할 수 없다.</li><li>Sequence의 iterator가 중단 함수가 아니기 때문에, 시퀀스의 원소를 소비할 때 <strong>블로킹이 되는 것이 문제가 된다.</strong></li></ul></li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-kotlin data-lang=kotlin><span class=line><span class=cl><span class=c1>// Don&#39;t do that, we should use Flow instead of Sequence
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>fun</span> <span class=nf>allUsersSequence</span><span class=p>(</span>
</span></span><span class=line><span class=cl>    <span class=n>api</span><span class=p>:</span> <span class=n>UserApi</span>
</span></span><span class=line><span class=cl><span class=p>):</span> <span class=n>Sequence</span><span class=p>&lt;</span><span class=n>User</span><span class=p>&gt;</span> <span class=p>=</span> <span class=n>sequence</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>var</span> <span class=py>page</span> <span class=p>=</span> <span class=m>0</span>
</span></span><span class=line><span class=cl>        <span class=k>do</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=k>val</span> <span class=py>users</span> <span class=p>=</span> <span class=n>api</span><span class=p>.</span><span class=n>takePage</span><span class=p>(</span><span class=n>page</span><span class=o>++</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=c1>//suspend 함수 임으로, so compilation error
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=n>yieldAll</span><span class=p>(</span><span class=n>users</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span> <span class=k>while</span> <span class=p>(!</span><span class=n>users</span><span class=p>.</span><span class=n>isNullOrEmpty</span><span class=p>())</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-kotlin data-lang=kotlin><span class=line><span class=cl><span class=c1>// 하나의 코루틴이 다른 코루틴을 블로킹하게 된다.
</span></span></span><span class=line><span class=cl><span class=c1>// 같은 스레드에서 launch로 시작된 코루틴이 대기 하게 된다.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>fun</span> <span class=nf>getSequence</span><span class=p>():</span> <span class=n>Sequence</span><span class=p>&lt;</span><span class=n>String</span><span class=p>&gt;</span> <span class=p>=</span> <span class=n>sequence</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>repeat</span><span class=p>(</span><span class=m>3</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=nc>Thread</span><span class=p>.</span><span class=n>sleep</span><span class=p>(</span><span class=m>1000</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=c1>// the same result as if there were delay(1000) here
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=n>yield</span><span class=p>(</span><span class=s2>&#34;User</span><span class=si>$it</span><span class=s2>&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>suspend</span> <span class=k>fun</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>withContext</span><span class=p>(</span><span class=n>newSingleThreadContext</span><span class=p>(</span><span class=s2>&#34;main&#34;</span><span class=p>))</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>launch</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=n>repeat</span><span class=p>(</span><span class=m>3</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=n>delay</span><span class=p>(</span><span class=m>100</span><span class=p>)</span>
</span></span><span class=line><span class=cl>                <span class=n>println</span><span class=p>(</span><span class=s2>&#34;Processing on coroutine&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=k>val</span> <span class=py>list</span> <span class=p>=</span> <span class=n>getSequence</span><span class=p>()</span>
</span></span><span class=line><span class=cl>        <span class=n>list</span><span class=p>.</span><span class=n>forEach</span> <span class=p>{</span> <span class=n>println</span><span class=p>(</span><span class=k>it</span><span class=p>)</span> <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=c1>// (1 sec)
</span></span></span><span class=line><span class=cl><span class=c1>// User0
</span></span></span><span class=line><span class=cl><span class=c1>// (1 sec)
</span></span></span><span class=line><span class=cl><span class=c1>// User1
</span></span></span><span class=line><span class=cl><span class=c1>// (1 sec)
</span></span></span><span class=line><span class=cl><span class=c1>// User2
</span></span></span><span class=line><span class=cl><span class=c1>// Processing on coroutine
</span></span></span><span class=line><span class=cl><span class=c1>// (0.1 sec)
</span></span></span><span class=line><span class=cl><span class=c1>// Processing on coroutine
</span></span></span><span class=line><span class=cl><span class=c1>// (0.1 sec)
</span></span></span><span class=line><span class=cl><span class=c1>// Processing on coroutine
</span></span></span></code></pre></td></tr></table></div></div><ul><li><p>Sequence를 사용했기 때문에 <strong>forEach가 블로킹 연산</strong>이 된다.</p><ul><li>따라서 같은 스레드에서 launch로 시작된 코루틴이 대기하게 되며, 하나의 코루틴이 다른 코루틴을 블로킹하게 된다.</li></ul></li><li><p>이런 상황에서 Sequence 대신 <strong>Flow</strong>를 사용해야 한다.</p></li><li><p>플로우를 사용하면 <strong>코루틴이 연산을 수행하는 데 필요한 기능을 전부 사용</strong>할 수 있다.</p></li><li><p>플로우의 빌더와 연산은 <code>중단 함수(suspend)</code> 이며, <code>구조화된 동시성</code>과 적절한 <strong>예외 처리</strong>를 지원한다.</p></li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-kotlin data-lang=kotlin><span class=line><span class=cl><span class=k>fun</span> <span class=nf>getFlow</span><span class=p>():</span> <span class=n>Flow</span><span class=p>&lt;</span><span class=n>String</span><span class=p>&gt;</span> <span class=p>=</span> <span class=n>flow</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>repeat</span><span class=p>(</span><span class=m>3</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>delay</span><span class=p>(</span><span class=m>1000</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=n>emit</span><span class=p>(</span><span class=s2>&#34;User</span><span class=si>$it</span><span class=s2>&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>suspend</span> <span class=k>fun</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>withContext</span><span class=p>(</span><span class=n>newSingleThreadContext</span><span class=p>(</span><span class=s2>&#34;main&#34;</span><span class=p>))</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>launch</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=n>repeat</span><span class=p>(</span><span class=m>3</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=n>delay</span><span class=p>(</span><span class=m>100</span><span class=p>)</span>
</span></span><span class=line><span class=cl>                <span class=n>println</span><span class=p>(</span><span class=s2>&#34;Processing on coroutine&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=k>val</span> <span class=py>list</span> <span class=p>=</span> <span class=n>getFlow</span><span class=p>()</span>
</span></span><span class=line><span class=cl>        <span class=n>list</span><span class=p>.</span><span class=n>collect</span> <span class=p>{</span> <span class=n>println</span><span class=p>(</span><span class=k>it</span><span class=p>)</span> <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=c1>// (0.1 sec)
</span></span></span><span class=line><span class=cl><span class=c1>// Processing on coroutine
</span></span></span><span class=line><span class=cl><span class=c1>// (0.1 sec)
</span></span></span><span class=line><span class=cl><span class=c1>// Processing on coroutine
</span></span></span><span class=line><span class=cl><span class=c1>// (0.1 sec)
</span></span></span><span class=line><span class=cl><span class=c1>// Processing on coroutine
</span></span></span><span class=line><span class=cl><span class=c1>// (1 - 3 * 0.1 = 0.7 sec)
</span></span></span><span class=line><span class=cl><span class=c1>// User0
</span></span></span><span class=line><span class=cl><span class=c1>// (1 sec)
</span></span></span><span class=line><span class=cl><span class=c1>// User1
</span></span></span><span class=line><span class=cl><span class=c1>// (1 sec)
</span></span></span><span class=line><span class=cl><span class=c1>// User2
</span></span></span></code></pre></td></tr></table></div></div><h2 id=플로우의-특징>플로우의 특징<a hidden class=anchor aria-hidden=true href=#플로우의-특징>#</a></h2><ul><li><strong>collect</strong>(중단 함수)와 같은 플로우의 최종 연산은 <strong>스레드를 블로킹</strong>하는 대신 <strong>코루틴을 중단</strong>시킨다.</li><li>플로우는 <code>Coroutine Context</code> 를 활용하고, 예외를 처리하는 등의 <strong>코루틴 기능</strong>도 제공한다.</li><li>플로우 처리는 <strong>취소</strong>(cancel) 가능하며, <code>구조화된 동시성</code>을 갖추고 있다.</li><li><strong>flow 빌더는</strong> 중단 함수가 아니며, 어떠한 스코프도 필요하지 않다.</li><li>플로우의 <code>최종 연산</code>은 <strong>중단 가능</strong>하며, 연산이 실행될 때, 부모 코루틴과의 관계가 정립된다. (<code>coroutineScope 함수</code>와 비슷)<ul><li><code>launch</code> 를 취소하면, 플로우 처리도 적절하게 취소된다.</li></ul></li></ul><h2 id=플로우-명명법>플로우 명명법<a hidden class=anchor aria-hidden=true href=#플로우-명명법>#</a></h2><ul><li><p>플로우는 어딘가에서 시작 되어야 한다. (<strong>플로우 빌더</strong>, 다른 객체에서의 <strong>변환</strong> 또는 <strong>헬퍼 함수</strong>로 시작된다.)</p></li><li><p>플로우의 마지막 연산은 <code>최종 연산</code>이라고 불리며, <strong>중단 가능</strong>하거나 <strong>스코프를 필요로</strong> 하는 <strong>유일한 연산</strong>이다.</p><ul><li><code>최종 연산</code>은 주로 람다 표현식을 가지거나 가지지 않는 <strong>collect</strong> 가 된다.</li></ul></li><li><p>시작 연산과 최종 연산 사이에 플로우를 변경하는 <code>중간 연산</code>(intermediate operation)을 가질 수 있다.</p></li></ul><h2 id=플로우-사용-예시>플로우 사용 예시<a hidden class=anchor aria-hidden=true href=#플로우-사용-예시>#</a></h2><ul><li>주로 <strong>이벤트를 감지</strong>해야 할 필요가 있을 때, 사용</li><li>서버가 보낸 이벤트를 통해 전달된 메시지를 받는 경우</li><li>텍스트 입력 또는 클릭과 같은 사용자 액션이 감지된 경우</li><li>센서 또는 위치나 지도와 같은 기기의 정보 변경을 받는 경우</li><li>데이터베이스의 변경을 감지하는 경우</li></ul><p>플로우는 이 밖의 경우에도 <strong>동시성 처리</strong> 를 위해 유용하게 사용 될 수 있다.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span><span class=lnt>9
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-kotlin data-lang=kotlin><span class=line><span class=cl><span class=k>suspend</span> <span class=k>fun</span> <span class=nf>getOffers</span><span class=p>(</span>
</span></span><span class=line><span class=cl>    <span class=n>sellers</span><span class=p>:</span> <span class=n>List</span><span class=p>&lt;</span><span class=n>Seller</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl><span class=p>):</span> <span class=n>List</span><span class=p>&lt;</span><span class=n>Offer</span><span class=p>&gt;</span> <span class=p>=</span> <span class=n>coroutineScope</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>sellers</span>
</span></span><span class=line><span class=cl>        <span class=p>.</span><span class=n>map</span> <span class=p>{</span> <span class=n>seller</span> <span class=o>-&gt;</span>
</span></span><span class=line><span class=cl>            <span class=n>async</span> <span class=p>{</span> <span class=n>api</span><span class=p>.</span><span class=n>requestOffers</span><span class=p>(</span><span class=n>seller</span><span class=p>.</span><span class=n>id</span><span class=p>)</span> <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=p>.</span><span class=n>flatMap</span> <span class=p>{</span> <span class=k>it</span><span class=p>.</span><span class=n>await</span><span class=p>()</span> <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>컬렉션 처리 내부에서 <code>async</code>를 사용하면 동시 처리를 할 수 있지만,</p><p><strong>많은 요청을 한번에 보내면 client 뿐 아니라 server 모두에게 좋지 않다.</strong></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-kotlin data-lang=kotlin><span class=line><span class=cl><span class=k>suspend</span> <span class=k>fun</span> <span class=nf>getOffers</span><span class=p>(</span>
</span></span><span class=line><span class=cl>    <span class=n>sellers</span><span class=p>:</span> <span class=n>List</span><span class=p>&lt;</span><span class=n>Seller</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl><span class=p>):</span> <span class=n>List</span><span class=p>&lt;</span><span class=n>Offer</span><span class=p>&gt;</span> <span class=p>=</span> <span class=n>sellers</span>
</span></span><span class=line><span class=cl>    <span class=p>.</span><span class=n>asFlow</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=p>.</span><span class=n>flatMapMerge</span><span class=p>(</span><span class=n>concurrency</span> <span class=p>=</span> <span class=m>20</span><span class=p>)</span> <span class=p>{</span> <span class=n>seller</span> <span class=o>-&gt;</span>
</span></span><span class=line><span class=cl>        <span class=k>suspend</span> <span class=p>{</span> <span class=n>api</span><span class=p>.</span><span class=n>requestOffers</span><span class=p>(</span><span class=n>seller</span><span class=p>.</span><span class=n>id</span><span class=p>)</span> <span class=p>}.</span><span class=n>asFlow</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>.</span><span class=n>toList</span><span class=p>()</span>
</span></span></code></pre></td></tr></table></div></div><p>컬렉션 대신 플로우로 처리하면 <strong>동시 처리, 컨텍스트, 예외</strong>를 조절할 수 있다.</p><h1 id=reference>Reference<a hidden class=anchor aria-hidden=true href=#reference>#</a></h1><ul><li><a href=https://kotlinlang.org/docs/coroutines-guide.html>https://kotlinlang.org/docs/coroutines-guide.html</a></li><li>코틀린 코루틴 Kotlin Coroutines: Deep Dive (Marcin Moskała, 인사이트)</li></ul></div><footer class=post-footer><ul class=post-tags></ul><nav class=paginav><a class=prev href=http://localhost:1313/posts/2023/kotlin-flow-3-flow%EC%9D%98-%EC%8B%A4%EC%A0%9C-%EA%B5%AC%ED%98%84/><span class=title>« Prev</span><br><span>Kotlin Flow, (3) Flow의 실제 구현</span>
</a><a class=next href=http://localhost:1313/posts/2023/kotlin-flow-1-hot-vs-cold/><span class=title>Next »</span><br><span>Kotlin Flow, (1) Hot vs Cold</span></a></nav><ul class=share-buttons><li><a target=_blank rel="noopener noreferrer" aria-label="share Kotlin Flow, (2) Flow 개요 on x" href="https://x.com/intent/tweet/?text=Kotlin%20Flow%2c%20%282%29%20Flow%20%ea%b0%9c%ec%9a%94&amp;url=http%3a%2f%2flocalhost%3a1313%2fposts%2f2023%2fkotlin-flow-2-flow-%25EA%25B0%259C%25EC%259A%2594%2f&amp;hashtags="><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446C483.971.0 512 28.03 512 62.554zM269.951 190.75 182.567 75.216H56L207.216 272.95 63.9 436.783h61.366L235.9 310.383l96.667 126.4H456L298.367 228.367l134-153.151H371.033zM127.633 110h36.468l219.38 290.065H349.5z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Kotlin Flow, (2) Flow 개요 on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=http%3a%2f%2flocalhost%3a1313%2fposts%2f2023%2fkotlin-flow-2-flow-%25EA%25B0%259C%25EC%259A%2594%2f&amp;title=Kotlin%20Flow%2c%20%282%29%20Flow%20%ea%b0%9c%ec%9a%94&amp;summary=Kotlin%20Flow%2c%20%282%29%20Flow%20%ea%b0%9c%ec%9a%94&amp;source=http%3a%2f%2flocalhost%3a1313%2fposts%2f2023%2fkotlin-flow-2-flow-%25EA%25B0%259C%25EC%259A%2594%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Kotlin Flow, (2) Flow 개요 on reddit" href="https://reddit.com/submit?url=http%3a%2f%2flocalhost%3a1313%2fposts%2f2023%2fkotlin-flow-2-flow-%25EA%25B0%259C%25EC%259A%2594%2f&title=Kotlin%20Flow%2c%20%282%29%20Flow%20%ea%b0%9c%ec%9a%94"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Kotlin Flow, (2) Flow 개요 on facebook" href="https://facebook.com/sharer/sharer.php?u=http%3a%2f%2flocalhost%3a1313%2fposts%2f2023%2fkotlin-flow-2-flow-%25EA%25B0%259C%25EC%259A%2594%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Kotlin Flow, (2) Flow 개요 on whatsapp" href="https://api.whatsapp.com/send?text=Kotlin%20Flow%2c%20%282%29%20Flow%20%ea%b0%9c%ec%9a%94%20-%20http%3a%2f%2flocalhost%3a1313%2fposts%2f2023%2fkotlin-flow-2-flow-%25EA%25B0%259C%25EC%259A%2594%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Kotlin Flow, (2) Flow 개요 on telegram" href="https://telegram.me/share/url?text=Kotlin%20Flow%2c%20%282%29%20Flow%20%ea%b0%9c%ec%9a%94&amp;url=http%3a%2f%2flocalhost%3a1313%2fposts%2f2023%2fkotlin-flow-2-flow-%25EA%25B0%259C%25EC%259A%2594%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentcolor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Kotlin Flow, (2) Flow 개요 on ycombinator" href="https://news.ycombinator.com/submitlink?t=Kotlin%20Flow%2c%20%282%29%20Flow%20%ea%b0%9c%ec%9a%94&u=http%3a%2f%2flocalhost%3a1313%2fposts%2f2023%2fkotlin-flow-2-flow-%25EA%25B0%259C%25EC%259A%2594%2f"><svg width="30" height="30" viewBox="0 0 512 512" fill="currentcolor" xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"><path d="M449.446.0C483.971.0 512 28.03 512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446zM183.8767 87.9921h-62.034L230.6673 292.4508V424.0079h50.6655V292.4508L390.1575 87.9921H328.1233L256 238.2489z"/></svg></a></li></ul></footer><script src=https://utteranc.es/client.js repo=2taezeat/blog_comment issue-term=pathname label=comment theme=github-light crossorigin=anonymous async></script></article></main><footer class=footer><span>&copy; 2024 <a href=http://localhost:1313/>2taezeat, blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>