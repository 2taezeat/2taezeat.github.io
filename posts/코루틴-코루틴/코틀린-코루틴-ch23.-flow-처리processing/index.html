<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>[코루틴 코루틴] ch23. Flow 처리(Processing) | 2taezeat, blog</title>
<meta name=keywords content="Kotlin,Coroutine"><meta name=description content="ch22. Flow 처리(Processing)"><meta name=author content="2taezeat"><link rel=canonical href=https://2taezeat.github.io/posts/%EC%BD%94%EB%A3%A8%ED%8B%B4-%EC%BD%94%EB%A3%A8%ED%8B%B4/%EC%BD%94%ED%8B%80%EB%A6%B0-%EC%BD%94%EB%A3%A8%ED%8B%B4-ch23.-flow-%EC%B2%98%EB%A6%ACprocessing/><meta name=google-site-verification content="YaEERzgrvu-ZwPg7gswZdTzRMufkHw3uIH7i8hVal1c"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.0653c5fc8a439a898cd1fe8a206477ec49246832c1f79c575f5c6b9e1810bdb9.css integrity="sha256-BlPF/IpDmomM0f6KIGR37EkkaDLB95xXX1xrnhgQvbk=" rel="preload stylesheet" as=style><link rel=icon href=https://2taezeat.github.io/icon/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://2taezeat.github.io/icon/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://2taezeat.github.io/icon/favicon-32x32.png><link rel=apple-touch-icon href=https://2taezeat.github.io/icon/apple-touch-icon.png><link rel=mask-icon href=https://2taezeat.github.io/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://2taezeat.github.io/posts/%EC%BD%94%EB%A3%A8%ED%8B%B4-%EC%BD%94%EB%A3%A8%ED%8B%B4/%EC%BD%94%ED%8B%80%EB%A6%B0-%EC%BD%94%EB%A3%A8%ED%8B%B4-ch23.-flow-%EC%B2%98%EB%A6%ACprocessing/><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><meta property="og:title" content="[코루틴 코루틴] ch23. Flow 처리(Processing)"><meta property="og:description" content="ch22. Flow 처리(Processing)"><meta property="og:type" content="article"><meta property="og:url" content="https://2taezeat.github.io/posts/%EC%BD%94%EB%A3%A8%ED%8B%B4-%EC%BD%94%EB%A3%A8%ED%8B%B4/%EC%BD%94%ED%8B%80%EB%A6%B0-%EC%BD%94%EB%A3%A8%ED%8B%B4-ch23.-flow-%EC%B2%98%EB%A6%ACprocessing/"><meta property="og:image" content="https://2taezeat.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-02-23T11:30:03+00:00"><meta property="article:modified_time" content="2024-02-23T11:30:03+00:00"><meta property="og:site_name" content="2taezeat, blog"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://2taezeat.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="[코루틴 코루틴] ch23. Flow 처리(Processing)"><meta name=twitter:description content="ch22. Flow 처리(Processing)"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://2taezeat.github.io/posts/"},{"@type":"ListItem","position":2,"name":"[코루틴 코루틴] ch23. Flow 처리(Processing)","item":"https://2taezeat.github.io/posts/%EC%BD%94%EB%A3%A8%ED%8B%B4-%EC%BD%94%EB%A3%A8%ED%8B%B4/%EC%BD%94%ED%8B%80%EB%A6%B0-%EC%BD%94%EB%A3%A8%ED%8B%B4-ch23.-flow-%EC%B2%98%EB%A6%ACprocessing/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"[코루틴 코루틴] ch23. Flow 처리(Processing)","name":"[코루틴 코루틴] ch23. Flow 처리(Processing)","description":"ch22. Flow 처리(Processing)","keywords":["Kotlin","Coroutine"],"articleBody":"플로우 처리 플로우 생성과 최종 연산 사이의 값을 변경하는 연산들을 플로우 처리(flow processing) 이라고 한다. 플로우는 값이 흐르기 때문에 제외하고, 곱하고, 변형하거나, 합치는 등의 여러 가지 방법으로 변경 가능하다. 컬렉션 처리는 어떻게 작동할까? flow 빌더와 람다식을 가진 collect 만으로 구현 가능하다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 suspend fun main() { flowOf('a', 'b') .map { it.uppercase() } .collect { print(it) } // AB } fun \u003cT, R\u003e Flow\u003cT\u003e.map( transform: suspend (value: T) -\u003e R ): Flow\u003cR\u003e = flow { collect { value -\u003e emit(transform(value)) } } fun \u003cT\u003e flowOf(vararg elements: T): Flow\u003cT\u003e = flow { for (element in elements) { emit(element) } } suspend fun main() { flow map@{ // 1 flow flowOf@{ // 2 for (element in arrayOf('a', 'b')) { // 3 this@flowOf.emit(element) // 4 } }.collect { value -\u003e // 5 this@map.emit(value.uppercase()) // 6 } }.collect { // 7 print(it) // 8 } } 1에서 플로우 시작, 7에서 원소들을 모은다. 모으기 시작할 때, 1에서 시작하는 @map 람다식을 수행하며, 이 람다식은 2에서 또 다른 빌더를 호출하고, 5에서 원소들을 모은다. 원소 들을 모을 때, 2에서 시작하는 @flowOf 람다식을 시작한다. 2의 람다식은 ‘a’, ‘b’를 가진 배열을 탐색한다. 첫 번째 값인 ‘a’를 4에서 내보내며, 5 람다식이 호출된다. 5의 람다식은 갑을 ‘A’로 변경하며 @map 플로우로 내보낸 뒤, 7의 람다식이 호출 된다. 값이 출력된 후 7의 람다식이 종료되고 6에서 람다식이 재개 된다. 람다식이 끝났기 때문에 4의 @flowOf가 재개되며, 탐색이 다시 시작되어 4에서 ‘b’를 내보낸다. 5에서 람다식이 호출되고, ‘B’로 값을 변형한 뒤 6에서 @map 플로우로 내보낸다. 값은 7에서 모이며 8에서 출력된다. 7의 람다식이 종료되므로 6의 람다식이 재개 된다. 이 람다식도 종료되었기 때문에 4의 @flowOf 람다식이 다시 시작된다. 4도 종료되었기 때문에 5의 collect에서 @map이 재개된다. 더 이상 남은 것이 없기 때문에 @map의 마지막 부분에 도달한다. 7의 collect에서 다시 시작하면 main 함수의 끝에 도달한다. map 플로우의 각 원소를 변환 함수에 따라 변환하는 map 함수. 1 2 3 4 5 6 7 fun \u003cT, R\u003e Flow\u003cT\u003e.map( transform: suspend (value: T) -\u003e R ): Flow\u003cR\u003e = flow { // here we create a new flow collect { value -\u003e // here we collect from receiver emit(transform(value)) } } filter 원래 플로우에서 주어진 조건에 맞는 값들만 가진 플로우를 반환한다. 관심 없는 원소를 제거할 때 주로 사용 1 2 3 4 5 6 7 8 suspend fun main() { (1..10).asFlow() // [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] .filter { it \u003c= 5 } // [1, 2, 3, 4, 5] .filter { isEven(it) } // [2, 4] .collect { print(it) } // 24 } fun isEven(num: Int): Boolean = num % 2 == 0 take 특정 수의 원소만 통과시킬 때 사용 1 2 3 4 5 suspend fun main() { ('A'..'Z').asFlow() .take(5) // [A, B, C, D, E] .collect { print(it) } // ABCDE } drop 특정 수의 원소를 무시할 때 사용 1 2 3 4 5 suspend fun main() { ('A'..'Z').asFlow() .drop(20) // [U, V, W, X, Y, Z] .collect { print(it) } // UVWXYZ } merge 두 개의 플로우를 하나의 플로우로 합칠 때 사용되는 함수 =\u003e merge, zip, combine merge: 두 개의 플로우에서 생성된 원소들을 하나로 합칠 때 사용 merge를 사용하면 한 플로우의 원소가 다른 플로우를 기다리지 않는다는 것이 중요하다. 첫 번째 플로우의 원소 생성이 지연된다고 해서, 두 번째 플로우의 원소 생성이 중단되지 않는다. 여러 개의 이벤트들을 똑같은 방법으로 처리할 때 merge를 사용한다. 1 2 3 4 5 6 7 8 9 10 11 suspend fun main() { val ints: Flow\u003cInt\u003e = flowOf(1, 2, 3) val doubles: Flow\u003cDouble\u003e = flowOf(0.1, 0.2, 0.3) val together: Flow\u003cNumber\u003e = merge(ints, doubles) print(together.toList()) // [1, 0.1, 0.2, 0.3, 2, 3] // or [1, 0.1, 0.2, 0.3, 2, 3] // or [0.1, 1, 2, 3, 0.2, 0.3] // or any other combination } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 suspend fun main() { val ints: Flow\u003cInt\u003e = flowOf(1, 2, 3) .onEach { delay(1000) } val doubles: Flow\u003cDouble\u003e = flowOf(0.1, 0.2, 0.3) val together: Flow\u003cNumber\u003e = merge(ints, doubles) together.collect { println(it) } } // 0.1 // 0.2 // 0.3 // (1 sec) // 1 // (1 sec) // 2 // (1 sec) // 3 zip 두 플로우로 부터 쌍을 만들때 사용한다. 원소가 쌍을 이루는 방법을 정하는 함수도 필요하다. 각 원소는 한 쌍의 일부가 되므로 쌍이 될 원소를 기다려야 한다. 쌍을 이루지 못하고 남은 원소는 유실되므로 한 플로우에서 zipping이 완료되면 생성되는 플로우 또한 완료된다. zip은 쌍을 필요로 하기 때문에 첫 번째 플로우가 닫히면 함수 또한 끝나게 된다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 suspend fun main() { val flow1 = flowOf(\"A\", \"B\", \"C\") .onEach { delay(400) } val flow2 = flowOf(1, 2, 3, 4) .onEach { delay(1000) } flow1.zip(flow2) { f1, f2 -\u003e \"${f1}_${f2}\" } .collect { println(it) } } // (1 sec) // A_1 // (1 sec) // B_2 // (1 sec) // C_3 combine combine을 사용하면 모든 새로운 원소가 전임자를 대체 하게 된다. zip의 경우 느린 플로우를 기다려야 한다. 첫 번째 쌍이 이미 만들어졌다면 다른 플로우의 이전 원소와 함께 새로운 쌍이 만들어진다. combine은 두 플로우 모두 닫힐 때까지 원소를 내보낸다. combine은 두 데이터 소스의 변화를 능동적으로 감지할 때 주로 사용된다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 suspend fun main() { val flow1 = flowOf(\"A\", \"B\", \"C\") .onEach { delay(400) } val flow2 = flowOf(1, 2, 3, 4) .onEach { delay(1000) } flow1.combine(flow2) { f1, f2 -\u003e \"${f1}_${f2}\" } .collect { println(it) } } // (1 sec) // B_1 // (0.2 sec) // C_1 // (0.8 sec) // C_2 // (1 sec) // C_3 // (1 sec) // C_4 변화가 발생할 때마다 원소가 내보내지길 원한다면 합쳐질 각 플로우에 초기 값을 더하면 된다. Ex. View가 감지 가능한 원소 두 가지 중에 하나라도 변경될 때 반응해야 하는 경우 combine을 주로 사용한다. 1 2 3 4 5 userUpdateFlow.onStart { emit(currentUser) } AFlow.combine(BFlow) { a, b -\u003e updateView(a, b) }.collect fold 초기 값부터 시작하여 주어진 원소 각각에 대해 두 개의 값을 하나로 합치는 연산을 적용하여 컬렉션의 모든 값을 하나로 합칠때 사용 fold는 최종 연산이고, 플로우에서도 사용할 수 있으며, collect 처럼 플로우가 완료될 때까지 중단(suspend) 된다. 1 2 3 4 5 6 7 8 suspend fun main() { val list = flowOf(1, 2, 3, 4) .onEach { delay(1000) } val res = list.fold(0) { acc, i -\u003e acc + i } println(res) } // (4 sec) // 10 scan scan은 누적되는 과정의 모든 값을 생성하는 중간 연산이다. scan은 이전 단계에서 값을 받은 즉시 새로운 값을 만들기 만든다. flatMapConcat 컬렉션의 경우 flatMap은 map 과 비슷하지만 변환 함수가 평탄화된 컬렉션 을 반환해야 한다는 점이 다르다. 플로우의 경우 변환 함수가 평탄화된 플로우를 반환한다고 생각하는게 직관적이다. 문제는 플로우 원소가 나오는 시간이 다르다는 점이다. 이러한 이유로 플로우에는 flatMap 함수가 없으며, 대신 flatMapConcat, flatMapMerge, flatMapLatest와 같은 함수가 존재한다. flatMapConcat 함수는 생성된 플로우를 하나씩 처리한다. 그래서 두 번째 플로우는 첫 번째 플로우가 완료되었을 때 시작할 수 있다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 fun flowFrom(elem: String) = flowOf(1, 2, 3) .onEach { delay(1000) } .map { \"${it}_${elem} \" } suspend fun main() { flowOf(\"A\", \"B\", \"C\") .flatMapConcat { flowFrom(it) } .collect { println(it) } } // (1 sec) // 1_A // (1 sec) // 2_A // (1 sec) // 3_A // (1 sec) // 1_B // (1 sec) // 2_B // (1 sec) // 3_B // (1 sec) // 1_C // (1 sec) // 2_C // (1 sec) // 3_C flatMapMerge 특징: 만들어진 플로우를 동시에 처리한다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 fun flowFrom(elem: String) = flowOf(1, 2, 3) .onEach { delay(1000) } .map { \"${it}_${elem} \" } suspend fun main() { flowOf(\"A\", \"B\", \"C\") .flatMapMerge { flowFrom(it) } .collect { println(it) } } // (1 sec) // 1_A // 1_B // 1_C // (1 sec) // 2_A // 2_B // 2_C // (1 sec) // 3_A // 3_B // 3_C concurreny 인자를 사용해 동시에 처리할 수 있는 플로우의 수를 설정할 수 있다. 기본값은 16이지만, 변경 가능하다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 fun flowFrom(elem: String) = flowOf(1, 2, 3) .onEach { delay(1000) } .map { \"${it}_${elem} \" } suspend fun main() { flowOf(\"A\", \"B\", \"C\") .flatMapMerge(concurrency = 2) { flowFrom(it) } .collect { println(it) } } // (1 sec) // 1_A // 1_B // (1 sec) // 2_A // 2_B // (1 sec) // 3_A // 3_B // (1 sec) // 1_C // (1 sec) // 2_C // (1 sec) // 3_C flatMapMerge는 플로우의 각 원소에 대한 데이터를 요청할 때 주로 사용된다. 예를 들어 종류를 목록으로 가지고 있다면, 종류별로 요청을 보내야 한다. async 함수 대신, 플로우와 함께 flatMapMerge를 사용하면 두 가지 이점이 있다. 동시성 인자를 제어하고(같은 시간에 수백 개의 요청을 보내는 걸 피하기 위해) 같은 시간에 얼마만큼의 종류를 처리할지 결정할 수 있다. Flow를 반환하여 데이터가 생성될 때마다, 다음 원소를 보낼 수 있다. 함수를 사용하는 측면에서 보면, 데이터를 즉시 처리할 수 있다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 suspend fun getOffers( categories: List\u003cCategory\u003e ): List\u003cOffer\u003e = coroutineScope { categories .map { async { api.requestOffers(it) } } .flatMap { it.await() } } // 더 나은 방법 이다. suspend fun getOffers( categories: List\u003cCategory\u003e ): Flow\u003cOffer\u003e = categories .asFlow() .flatMapMerge(concurrency = 20) { suspend { api.requestOffers(it) }.asFlow() // or flow { emit(api.requestOffers(it)) } } flatMapLatest 특징: 새로운 플로우가 나타나면 이전에 처리하던 플로우를 잊어버린다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 fun flowFrom(elem: String) = flowOf(1, 2, 3) .onEach { delay(1000) } .map { \"${it}_${elem} \" } suspend fun main() { flowOf(\"A\", \"B\", \"C\") .flatMapLatest { flowFrom(it) } .collect { println(it) } } // (1 sec) // 1_C // (1 sec) // 2_C // (1 sec) // 3_C 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 fun flowFrom(elem: String) = flowOf(1, 2, 3) .onEach { delay(1000) } .map { \"${it}_${elem} \" } suspend fun main() { flowOf(\"A\", \"B\", \"C\") .onEach { delay(1200) } .flatMapLatest { flowFrom(it) } .collect { println(it) } } // (2.2 sec) // 1_A // (1.2 sec) // 1_B // (1.2 sec) // 1_C // (1 sec) // 2_C // (1 sec) // 3_C retry(재시도) 예외는 플로우를 따라 흐르면서 각 단계를 하나씩 종료한다. 종료된 단계는 비활성화되기 때문에, 예외가 발생한 뒤 메시지를 보내는 건 불가능하지만, 각 단계가 이전 단계에 대한 참조를 가지고 있으며, 플로우를 다시 시작하기 위해 참조를 사용할 수 있다. 이 원리에 기반하여, 코틀린은 retry와 retryWhen 함수를 제공한다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 fun \u003cT\u003e Flow\u003cT\u003e.retryWhen( predicate: suspend FlowCollector\u003cT\u003e.( cause: Throwable, attempt: Long, ) -\u003e Boolean, ): Flow\u003cT\u003e = flow { var attempt = 0L do { val shallRetry = try { collect { emit(it) } false } catch (e: Throwable) { predicate(e, attempt++) .also { if (!it) throw e } } } while (shallRetry) } 1 2 3 4 5 6 7 8 9 10 11 fun \u003cT\u003e Flow\u003cT\u003e.retry( retries: Long = Long.MAX_VALUE, predicate: suspend (cause: Throwable) -\u003e Boolean = { true } ): Flow\u003cT\u003e { require(retries \u003e 0) { \"Expected positive amount of retries, but had $retries\" } return retryWhen { cause, attempt -\u003e attempt \u003c retries \u0026\u0026 predicate(cause) } } retryWhen 은 플로우의 이전 단계에서 예외가 발생할 때마다 조건자(predicate) 를 확인한다. 몇 번까지 재시도할지와 특정 예외 클래스가 발생했을 때만 처리할지를 명시한다. 1 2 3 4 5 6 7 8 9 10 11 suspend fun main() { flow { emit(1) emit(2) error(\"E\") emit(3) }.retry(3) { print(it.message) true }.collect { print(it) } // 12E12E12E12(exception thrown) } 어떤 예외든지 항상 재시도 하는 경우, log를 남기고 새로운 연결 맺는 걸 시도할 때 시간 간격을 주기 위해 predict(조건자) 를 정의한다. 1 2 3 4 5 6 7 fun makeConnection(config: ConnectionConfig) = api .startConnection(config) .retry { e -\u003e delay(1000) log.error(e) { \"Error for $config\" } true } 연결을 계속해서 재시도할 때 시간 간격을 점진적으로 증가시키는 방법도 자주 사용된다. 예외가 특정 타입일 때 재시도하는 조건자를 구현할 수 도 있다. 1 2 3 4 5 6 7 fun makeConnection(config: ConnectionConfig) = api .startConnection(config) .retryWhen { e, attempt -\u003e delay(100 * attempt) log.error(e) { \"Error for $config\" } e is ApiException \u0026\u0026 e.code !in 400..499 } 최종 연산 플로우를 처리를 끝내는 연산 =\u003e 최종 연산 이라고 부른다. 기본적인 collect 외에도, Collection(컬렉션)과 Sequence 가 제공하는 것과 비슷한 count, first, firstOrNull, fold, reduce 또한 최종 연산이다. 최종 연산은 중단 가능(suspend) 가능하며, 플로우가 완료되었을 때 또는 최종 연산 자체가 플로우를 완료 시켰을 때 값을 반환한다. collect 메서드를 사용해서 또 다른 최종 연산을 얼마든지 구현할 수 도 있다. 1 2 3 4 5 6 7 8 9 10 suspend fun main() { val flow = flowOf(1, 2, 3, 4) // [1, 2, 3, 4] .map { it * it } // [1, 4, 9, 16] println(flow.first()) // 1 println(flow.count()) // 4 println(flow.reduce { acc, value -\u003e acc * value }) // 576 println(flow.fold(0) { acc, value -\u003e acc + value }) // 30 } Reference https://kotlinlang.org/docs/coroutines-guide.html 코틀린 코루틴 Kotlin Coroutines: Deep Dive (Marcin Moskała, 인사이트) ","wordCount":"2203","inLanguage":"en","image":"https://2taezeat.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E","datePublished":"2024-02-23T11:30:03Z","dateModified":"2024-02-23T11:30:03Z","author":{"@type":"Person","name":"2taezeat"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://2taezeat.github.io/posts/%EC%BD%94%EB%A3%A8%ED%8B%B4-%EC%BD%94%EB%A3%A8%ED%8B%B4/%EC%BD%94%ED%8B%80%EB%A6%B0-%EC%BD%94%EB%A3%A8%ED%8B%B4-ch23.-flow-%EC%B2%98%EB%A6%ACprocessing/"},"publisher":{"@type":"Organization","name":"2taezeat, blog","logo":{"@type":"ImageObject","url":"https://2taezeat.github.io/icon/favicon.ico"}}}</script></head><body id=top><header class=header><nav class=nav><div class=logo><a href=https://2taezeat.github.io/ accesskey=h title="2taezeat blog (Alt + H)"><img src=https://2taezeat.github.io/icon/apple-touch-icon.png alt aria-label=logo height=30>2taezeat blog</a><div class=logo-switches></div></div><ul id=menu><li><a href=https://2taezeat.github.io/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://2taezeat.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://2taezeat.github.io/searchs/ title=Search><span>Search</span></a></li><li><a href=https://github.com/2taezeat title=Github><span>Github</span>&nbsp;<svg fill="none" shape-rendering="geometricPrecision" stroke="currentcolor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2.5" viewBox="0 0 24 24" height="12" width="12"><path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"/><path d="M15 3h6v6"/><path d="M10 14 21 3"/></svg></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://2taezeat.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://2taezeat.github.io/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">[코루틴 코루틴] ch23. Flow 처리(Processing)</h1><div class=post-description>ch22. Flow 처리(Processing)</div><div class=post-meta><span title='2024-02-23 11:30:03 +0000 +0000'>2024-02-23</span>&nbsp;·&nbsp;11 min&nbsp;·&nbsp;2203 words&nbsp;·&nbsp;2taezeat</div></header><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#플로우-처리>플로우 처리</a><ul><li><a href=#컬렉션-처리는-어떻게-작동할까>컬렉션 처리는 어떻게 작동할까?</a></li><li><a href=#map>map</a></li><li><a href=#filter>filter</a></li><li><a href=#take>take</a></li><li><a href=#drop>drop</a></li><li><a href=#merge>merge</a></li><li><a href=#zip>zip</a></li><li><a href=#combine>combine</a></li><li><a href=#fold>fold</a></li><li><a href=#scan>scan</a></li><li><a href=#flatmapconcat>flatMapConcat</a></li><li><a href=#flatmapmerge>flatMapMerge</a></li><li><a href=#flatmaplatest>flatMapLatest</a></li><li><a href=#retry재시도>retry(재시도)</a></li><li><a href=#최종-연산>최종 연산</a></li></ul></li><li><a href=#reference>Reference</a></li></ul></nav></div></details></div><div class=post-content><h1 id=플로우-처리>플로우 처리<a hidden class=anchor aria-hidden=true href=#플로우-처리>#</a></h1><ul><li>플로우 <strong>생성</strong>과 <strong>최종 연산</strong> 사이의 값을 변경하는 연산들을 <strong>플로우 처리(flow processing)</strong> 이라고 한다.</li><li>플로우는 값이 흐르기 때문에 제외하고, 곱하고, 변형하거나, 합치는 등의 여러 가지 방법으로 변경 가능하다.</li></ul><h2 id=컬렉션-처리는-어떻게-작동할까>컬렉션 처리는 어떻게 작동할까?<a hidden class=anchor aria-hidden=true href=#컬렉션-처리는-어떻게-작동할까>#</a></h2><ul><li><code>flow 빌더</code>와 람다식을 가진 <code>collect</code> 만으로 구현 가능하다.</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-kotlin data-lang=kotlin><span class=line><span class=cl><span class=k>suspend</span> <span class=k>fun</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>flowOf</span><span class=p>(</span><span class=sc>&#39;a&#39;</span><span class=p>,</span> <span class=sc>&#39;b&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=p>.</span><span class=n>map</span> <span class=p>{</span> <span class=k>it</span><span class=p>.</span><span class=n>uppercase</span><span class=p>()</span> <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=p>.</span><span class=n>collect</span> <span class=p>{</span> <span class=n>print</span><span class=p>(</span><span class=k>it</span><span class=p>)</span> <span class=p>}</span> <span class=c1>// AB
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>fun</span> <span class=p>&lt;</span><span class=nc>T</span><span class=p>,</span> <span class=nc>R</span><span class=p>&gt;</span> <span class=nf>Flow</span><span class=p>&lt;</span><span class=n>T</span><span class=p>&gt;.</span><span class=n>map</span><span class=p>(</span>
</span></span><span class=line><span class=cl>    <span class=n>transform</span><span class=p>:</span> <span class=k>suspend</span> <span class=p>(</span><span class=k>value</span><span class=p>:</span> <span class=n>T</span><span class=p>)</span> <span class=o>-&gt;</span> <span class=n>R</span>
</span></span><span class=line><span class=cl><span class=p>):</span> <span class=n>Flow</span><span class=p>&lt;</span><span class=n>R</span><span class=p>&gt;</span> <span class=p>=</span> <span class=n>flow</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>collect</span> <span class=p>{</span> <span class=k>value</span> <span class=o>-&gt;</span> <span class=n>emit</span><span class=p>(</span><span class=n>transform</span><span class=p>(</span><span class=k>value</span><span class=p>))</span> <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>fun</span> <span class=p>&lt;</span><span class=nc>T</span><span class=p>&gt;</span> <span class=nf>flowOf</span><span class=p>(</span><span class=k>vararg</span> <span class=n>elements</span><span class=p>:</span> <span class=n>T</span><span class=p>):</span> <span class=n>Flow</span><span class=p>&lt;</span><span class=n>T</span><span class=p>&gt;</span> <span class=p>=</span> <span class=n>flow</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=p>(</span><span class=n>element</span> <span class=k>in</span> <span class=n>elements</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>emit</span><span class=p>(</span><span class=n>element</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>suspend</span> <span class=k>fun</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>flow</span> <span class=n>map</span><span class=err>@</span><span class=p>{</span> <span class=c1>// 1
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=n>flow</span> <span class=n>flowOf</span><span class=err>@</span><span class=p>{</span> <span class=c1>// 2
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=k>for</span> <span class=p>(</span><span class=n>element</span> <span class=k>in</span> <span class=n>arrayOf</span><span class=p>(</span><span class=sc>&#39;a&#39;</span><span class=p>,</span> <span class=sc>&#39;b&#39;</span><span class=p>))</span> <span class=p>{</span> <span class=c1>// 3
</span></span></span><span class=line><span class=cl><span class=c1></span>                <span class=k>this</span><span class=nd>@flowOf</span><span class=p>.</span><span class=n>emit</span><span class=p>(</span><span class=n>element</span><span class=p>)</span> <span class=c1>// 4
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=p>}.</span><span class=n>collect</span> <span class=p>{</span> <span class=k>value</span> <span class=o>-&gt;</span> <span class=c1>// 5
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=k>this</span><span class=nd>@map</span><span class=p>.</span><span class=n>emit</span><span class=p>(</span><span class=k>value</span><span class=p>.</span><span class=n>uppercase</span><span class=p>())</span> <span class=c1>// 6
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}.</span><span class=n>collect</span> <span class=p>{</span> <span class=c1>// 7
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=n>print</span><span class=p>(</span><span class=k>it</span><span class=p>)</span> <span class=c1>// 8
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><ul><li><strong>1</strong>에서 플로우 시작, <strong>7</strong>에서 원소들을 모은다.</li><li>모으기 시작할 때, <strong>1</strong>에서 시작하는 <code>@map</code> 람다식을 수행하며, 이 람다식은 <strong>2</strong>에서 또 다른 빌더를 호출하고, <strong>5</strong>에서 원소들을 모은다.</li><li>원소 들을 모을 때, <strong>2</strong>에서 시작하는 <code>@flowOf</code> 람다식을 시작한다.</li><li><strong>2</strong>의 람다식은 &lsquo;a&rsquo;, &lsquo;b&rsquo;를 가진 배열을 탐색한다.</li><li>첫 번째 값인 &lsquo;a&rsquo;를 <strong>4</strong>에서 내보내며, <strong>5</strong> 람다식이 호출된다.</li><li><strong>5</strong>의 람다식은 갑을 &lsquo;A&rsquo;로 변경하며 <code>@map</code> 플로우로 내보낸 뒤, <strong>7</strong>의 람다식이 호출 된다.</li><li>값이 출력된 후 <strong>7</strong>의 람다식이 종료되고 <strong>6</strong>에서 람다식이 재개 된다.</li><li>람다식이 끝났기 때문에 <strong>4</strong>의 <code>@flowOf</code>가 재개되며, 탐색이 다시 시작되어 <strong>4</strong>에서 &lsquo;b&rsquo;를 내보낸다.</li><li><strong>5</strong>에서 람다식이 호출되고, &lsquo;B&rsquo;로 값을 변형한 뒤 <strong>6</strong>에서 <code>@map</code> 플로우로 내보낸다.</li><li>값은 <strong>7</strong>에서 모이며 <strong>8</strong>에서 출력된다.</li><li><strong>7</strong>의 람다식이 종료되므로 <strong>6</strong>의 람다식이 재개 된다. 이 람다식도 종료되었기 때문에 <strong>4</strong>의 <code>@flowOf</code> 람다식이 다시 시작된다.</li><li><strong>4</strong>도 종료되었기 때문에 <strong>5</strong>의 <code>collect</code>에서 <code>@map</code>이 재개된다. 더 이상 남은 것이 없기 때문에 <code>@map</code>의 마지막 부분에 도달한다.</li><li><strong>7</strong>의 <code>collect</code>에서 다시 시작하면 <code>main 함수</code>의 끝에 도달한다.</li></ul><h2 id=map>map<a hidden class=anchor aria-hidden=true href=#map>#</a></h2><ul><li>플로우의 각 원소를 <strong>변환 함수</strong>에 따라 변환하는 <code>map</code> 함수.</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-kotlin data-lang=kotlin><span class=line><span class=cl><span class=k>fun</span> <span class=p>&lt;</span><span class=nc>T</span><span class=p>,</span> <span class=nc>R</span><span class=p>&gt;</span> <span class=nf>Flow</span><span class=p>&lt;</span><span class=n>T</span><span class=p>&gt;.</span><span class=n>map</span><span class=p>(</span>
</span></span><span class=line><span class=cl>    <span class=n>transform</span><span class=p>:</span> <span class=k>suspend</span> <span class=p>(</span><span class=k>value</span><span class=p>:</span> <span class=n>T</span><span class=p>)</span> <span class=o>-&gt;</span> <span class=n>R</span>
</span></span><span class=line><span class=cl><span class=p>):</span> <span class=n>Flow</span><span class=p>&lt;</span><span class=n>R</span><span class=p>&gt;</span> <span class=p>=</span> <span class=n>flow</span> <span class=p>{</span> <span class=c1>// here we create a new flow
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>collect</span> <span class=p>{</span> <span class=k>value</span> <span class=o>-&gt;</span> <span class=c1>// here we collect from receiver
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=n>emit</span><span class=p>(</span><span class=n>transform</span><span class=p>(</span><span class=k>value</span><span class=p>))</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><h2 id=filter>filter<a hidden class=anchor aria-hidden=true href=#filter>#</a></h2><ul><li>원래 플로우에서 주어진 <strong>조건에 맞는 값</strong>들만 가진 플로우를 반환한다.</li><li>관심 없는 원소를 <strong>제거</strong>할 때 주로 사용</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-kotlin data-lang=kotlin><span class=line><span class=cl><span class=k>suspend</span> <span class=k>fun</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=p>(</span><span class=m>1.</span><span class=p>.</span><span class=m>10</span><span class=p>).</span><span class=n>asFlow</span><span class=p>()</span> <span class=c1>// [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=p>.</span><span class=n>filter</span> <span class=p>{</span> <span class=k>it</span> <span class=o>&lt;=</span> <span class=m>5</span> <span class=p>}</span> <span class=c1>// [1, 2, 3, 4, 5]
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=p>.</span><span class=n>filter</span> <span class=p>{</span> <span class=n>isEven</span><span class=p>(</span><span class=k>it</span><span class=p>)</span> <span class=p>}</span> <span class=c1>// [2, 4]
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=p>.</span><span class=n>collect</span> <span class=p>{</span> <span class=n>print</span><span class=p>(</span><span class=k>it</span><span class=p>)</span> <span class=p>}</span> <span class=c1>// 24
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>fun</span> <span class=nf>isEven</span><span class=p>(</span><span class=n>num</span><span class=p>:</span> <span class=n>Int</span><span class=p>):</span> <span class=n>Boolean</span> <span class=p>=</span> <span class=n>num</span> <span class=p>%</span> <span class=m>2</span> <span class=o>==</span> <span class=m>0</span>
</span></span></code></pre></td></tr></table></div></div><h2 id=take>take<a hidden class=anchor aria-hidden=true href=#take>#</a></h2><ul><li>특정 수의 원소만 <strong>통과</strong>시킬 때 사용</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-kotlin data-lang=kotlin><span class=line><span class=cl><span class=k>suspend</span> <span class=k>fun</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=p>(</span><span class=sc>&#39;A&#39;</span><span class=o>..</span><span class=sc>&#39;Z&#39;</span><span class=p>).</span><span class=n>asFlow</span><span class=p>()</span>
</span></span><span class=line><span class=cl>        <span class=p>.</span><span class=n>take</span><span class=p>(</span><span class=m>5</span><span class=p>)</span> <span class=c1>// [A, B, C, D, E]
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=p>.</span><span class=n>collect</span> <span class=p>{</span> <span class=n>print</span><span class=p>(</span><span class=k>it</span><span class=p>)</span> <span class=p>}</span> <span class=c1>// ABCDE
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><h2 id=drop>drop<a hidden class=anchor aria-hidden=true href=#drop>#</a></h2><ul><li>특정 수의 원소를 <strong>무시</strong>할 때 사용</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-kotlin data-lang=kotlin><span class=line><span class=cl><span class=k>suspend</span> <span class=k>fun</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=p>(</span><span class=sc>&#39;A&#39;</span><span class=o>..</span><span class=sc>&#39;Z&#39;</span><span class=p>).</span><span class=n>asFlow</span><span class=p>()</span>
</span></span><span class=line><span class=cl>        <span class=p>.</span><span class=n>drop</span><span class=p>(</span><span class=m>20</span><span class=p>)</span> <span class=c1>// [U, V, W, X, Y, Z]
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=p>.</span><span class=n>collect</span> <span class=p>{</span> <span class=n>print</span><span class=p>(</span><span class=k>it</span><span class=p>)</span> <span class=p>}</span> <span class=c1>// UVWXYZ
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><h2 id=merge>merge<a hidden class=anchor aria-hidden=true href=#merge>#</a></h2><ul><li>두 개의 플로우를 하나의 플로우로 <strong>합칠 때</strong> 사용되는 함수 => <code>merge, zip, combine</code></li><li><code>merge</code>: 두 개의 플로우에서 생성된 원소들을 하나로 합칠 때 사용<ul><li><code>merge</code>를 사용하면 한 플로우의 원소가 다른 플로우를 <strong>기다리지 않는다</strong>는 것이 중요하다.</li><li>첫 번째 플로우의 원소 생성이 <strong>지연</strong>된다고 해서, 두 번째 플로우의 원소 생성이 <strong>중단되지 않는다.</strong></li></ul></li><li><strong>여러 개의 이벤트들을 똑같은 방법</strong>으로 처리할 때 <code>merge</code>를 사용한다.</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-kotlin data-lang=kotlin><span class=line><span class=cl><span class=k>suspend</span> <span class=k>fun</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>val</span> <span class=py>ints</span><span class=p>:</span> <span class=n>Flow</span><span class=p>&lt;</span><span class=n>Int</span><span class=p>&gt;</span> <span class=p>=</span> <span class=n>flowOf</span><span class=p>(</span><span class=m>1</span><span class=p>,</span> <span class=m>2</span><span class=p>,</span> <span class=m>3</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>val</span> <span class=py>doubles</span><span class=p>:</span> <span class=n>Flow</span><span class=p>&lt;</span><span class=n>Double</span><span class=p>&gt;</span> <span class=p>=</span> <span class=n>flowOf</span><span class=p>(</span><span class=m>0.1</span><span class=p>,</span> <span class=m>0.2</span><span class=p>,</span> <span class=m>0.3</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>val</span> <span class=py>together</span><span class=p>:</span> <span class=n>Flow</span><span class=p>&lt;</span><span class=n>Number</span><span class=p>&gt;</span> <span class=p>=</span> <span class=n>merge</span><span class=p>(</span><span class=n>ints</span><span class=p>,</span> <span class=n>doubles</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>print</span><span class=p>(</span><span class=n>together</span><span class=p>.</span><span class=n>toList</span><span class=p>())</span>
</span></span><span class=line><span class=cl>    <span class=c1>// [1, 0.1, 0.2, 0.3, 2, 3]
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// or [1, 0.1, 0.2, 0.3, 2, 3]
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// or [0.1, 1, 2, 3, 0.2, 0.3]
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// or any other combination
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-kotlin data-lang=kotlin><span class=line><span class=cl><span class=k>suspend</span> <span class=k>fun</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>val</span> <span class=py>ints</span><span class=p>:</span> <span class=n>Flow</span><span class=p>&lt;</span><span class=n>Int</span><span class=p>&gt;</span> <span class=p>=</span> <span class=n>flowOf</span><span class=p>(</span><span class=m>1</span><span class=p>,</span> <span class=m>2</span><span class=p>,</span> <span class=m>3</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=p>.</span><span class=n>onEach</span> <span class=p>{</span> <span class=n>delay</span><span class=p>(</span><span class=m>1000</span><span class=p>)</span> <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>val</span> <span class=py>doubles</span><span class=p>:</span> <span class=n>Flow</span><span class=p>&lt;</span><span class=n>Double</span><span class=p>&gt;</span> <span class=p>=</span> <span class=n>flowOf</span><span class=p>(</span><span class=m>0.1</span><span class=p>,</span> <span class=m>0.2</span><span class=p>,</span> <span class=m>0.3</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>val</span> <span class=py>together</span><span class=p>:</span> <span class=n>Flow</span><span class=p>&lt;</span><span class=n>Number</span><span class=p>&gt;</span> <span class=p>=</span> <span class=n>merge</span><span class=p>(</span><span class=n>ints</span><span class=p>,</span> <span class=n>doubles</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>together</span><span class=p>.</span><span class=n>collect</span> <span class=p>{</span> <span class=n>println</span><span class=p>(</span><span class=k>it</span><span class=p>)</span> <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=c1>// 0.1
</span></span></span><span class=line><span class=cl><span class=c1>// 0.2
</span></span></span><span class=line><span class=cl><span class=c1>// 0.3
</span></span></span><span class=line><span class=cl><span class=c1>// (1 sec)
</span></span></span><span class=line><span class=cl><span class=c1>// 1
</span></span></span><span class=line><span class=cl><span class=c1>// (1 sec)
</span></span></span><span class=line><span class=cl><span class=c1>// 2
</span></span></span><span class=line><span class=cl><span class=c1>// (1 sec)
</span></span></span><span class=line><span class=cl><span class=c1>// 3
</span></span></span></code></pre></td></tr></table></div></div><h2 id=zip>zip<a hidden class=anchor aria-hidden=true href=#zip>#</a></h2><ul><li>두 플로우로 부터 <strong>쌍</strong>을 만들때 사용한다.</li><li><strong>원소가 쌍을 이루는 방법을 정하는 함수</strong>도 필요하다.</li><li>각 원소는 한 쌍의 일부가 되므로 <strong>쌍이 될 원소를 기다려야 한다.</strong></li><li>쌍을 이루지 못하고 남은 원소는 <strong>유실</strong>되므로 한 플로우에서 <strong>zipping</strong>이 완료되면 <strong>생성되는 플로우 또한 완료된다.</strong></li><li><code>zip</code>은 쌍을 필요로 하기 때문에 <strong>첫 번째 플로우가 닫히면 함수 또한 끝나게 된다.</strong></li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-kotlin data-lang=kotlin><span class=line><span class=cl><span class=k>suspend</span> <span class=k>fun</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>val</span> <span class=py>flow1</span> <span class=p>=</span> <span class=n>flowOf</span><span class=p>(</span><span class=s2>&#34;A&#34;</span><span class=p>,</span> <span class=s2>&#34;B&#34;</span><span class=p>,</span> <span class=s2>&#34;C&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=p>.</span><span class=n>onEach</span> <span class=p>{</span> <span class=n>delay</span><span class=p>(</span><span class=m>400</span><span class=p>)</span> <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>val</span> <span class=py>flow2</span> <span class=p>=</span> <span class=n>flowOf</span><span class=p>(</span><span class=m>1</span><span class=p>,</span> <span class=m>2</span><span class=p>,</span> <span class=m>3</span><span class=p>,</span> <span class=m>4</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=p>.</span><span class=n>onEach</span> <span class=p>{</span> <span class=n>delay</span><span class=p>(</span><span class=m>1000</span><span class=p>)</span> <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=n>flow1</span><span class=p>.</span><span class=n>zip</span><span class=p>(</span><span class=n>flow2</span><span class=p>)</span> <span class=p>{</span> <span class=n>f1</span><span class=p>,</span> <span class=n>f2</span> <span class=o>-&gt;</span> <span class=s2>&#34;</span><span class=si>${f1}</span><span class=s2>_</span><span class=si>${f2}</span><span class=s2>&#34;</span> <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=p>.</span><span class=n>collect</span> <span class=p>{</span> <span class=n>println</span><span class=p>(</span><span class=k>it</span><span class=p>)</span> <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=c1>// (1 sec)
</span></span></span><span class=line><span class=cl><span class=c1>// A_1
</span></span></span><span class=line><span class=cl><span class=c1>// (1 sec)
</span></span></span><span class=line><span class=cl><span class=c1>// B_2
</span></span></span><span class=line><span class=cl><span class=c1>// (1 sec)
</span></span></span><span class=line><span class=cl><span class=c1>// C_3
</span></span></span></code></pre></td></tr></table></div></div><h2 id=combine>combine<a hidden class=anchor aria-hidden=true href=#combine>#</a></h2><ul><li><code>combine</code>을 사용하면 모든 새로운 원소가 전임자를 <strong>대체</strong> 하게 된다.<ul><li><code>zip</code>의 경우 느린 플로우를 기다려야 한다.</li></ul></li><li>첫 번째 쌍이 이미 만들어졌다면 다른 플로우의 이전 원소와 함께 <strong>새로운 쌍이 만들어진다.</strong></li><li><code>combine</code>은 두 플로우 <strong>모두 닫힐 때까지 원소를 내보낸다.</strong></li><li><code>combine</code>은 <strong>두 데이터 소스의 변화를 능동적으로 감지할 때</strong> 주로 사용된다.</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-kotlin data-lang=kotlin><span class=line><span class=cl><span class=k>suspend</span> <span class=k>fun</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>val</span> <span class=py>flow1</span> <span class=p>=</span> <span class=n>flowOf</span><span class=p>(</span><span class=s2>&#34;A&#34;</span><span class=p>,</span> <span class=s2>&#34;B&#34;</span><span class=p>,</span> <span class=s2>&#34;C&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=p>.</span><span class=n>onEach</span> <span class=p>{</span> <span class=n>delay</span><span class=p>(</span><span class=m>400</span><span class=p>)</span> <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>val</span> <span class=py>flow2</span> <span class=p>=</span> <span class=n>flowOf</span><span class=p>(</span><span class=m>1</span><span class=p>,</span> <span class=m>2</span><span class=p>,</span> <span class=m>3</span><span class=p>,</span> <span class=m>4</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=p>.</span><span class=n>onEach</span> <span class=p>{</span> <span class=n>delay</span><span class=p>(</span><span class=m>1000</span><span class=p>)</span> <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=n>flow1</span><span class=p>.</span><span class=n>combine</span><span class=p>(</span><span class=n>flow2</span><span class=p>)</span> <span class=p>{</span> <span class=n>f1</span><span class=p>,</span> <span class=n>f2</span> <span class=o>-&gt;</span> <span class=s2>&#34;</span><span class=si>${f1}</span><span class=s2>_</span><span class=si>${f2}</span><span class=s2>&#34;</span> <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=p>.</span><span class=n>collect</span> <span class=p>{</span> <span class=n>println</span><span class=p>(</span><span class=k>it</span><span class=p>)</span> <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=c1>// (1 sec)
</span></span></span><span class=line><span class=cl><span class=c1>// B_1
</span></span></span><span class=line><span class=cl><span class=c1>// (0.2 sec)
</span></span></span><span class=line><span class=cl><span class=c1>// C_1
</span></span></span><span class=line><span class=cl><span class=c1>// (0.8 sec)
</span></span></span><span class=line><span class=cl><span class=c1>// C_2
</span></span></span><span class=line><span class=cl><span class=c1>// (1 sec)
</span></span></span><span class=line><span class=cl><span class=c1>// C_3
</span></span></span><span class=line><span class=cl><span class=c1>// (1 sec)
</span></span></span><span class=line><span class=cl><span class=c1>// C_4
</span></span></span></code></pre></td></tr></table></div></div><ul><li>변화가 발생할 때마다 원소가 내보내지길 원한다면 합쳐질 각 플로우에 <strong>초기 값을 더하면 된다.</strong></li><li>Ex. <code>View</code>가 감지 가능한 원소 <strong>두 가지 중에 하나라도 변경될 때 반응</strong>해야 하는 경우 <code>combine</code>을 주로 사용한다.</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-kotlin data-lang=kotlin><span class=line><span class=cl><span class=n>userUpdateFlow</span><span class=p>.</span><span class=n>onStart</span> <span class=p>{</span> <span class=n>emit</span><span class=p>(</span><span class=n>currentUser</span><span class=p>)</span> <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nc>AFlow</span><span class=p>.</span><span class=n>combine</span><span class=p>(</span><span class=n>BFlow</span><span class=p>)</span> <span class=p>{</span> <span class=n>a</span><span class=p>,</span> <span class=n>b</span> <span class=o>-&gt;</span>
</span></span><span class=line><span class=cl>    <span class=n>updateView</span><span class=p>(</span><span class=n>a</span><span class=p>,</span> <span class=n>b</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}.</span><span class=n>collect</span>
</span></span></code></pre></td></tr></table></div></div><h2 id=fold>fold<a hidden class=anchor aria-hidden=true href=#fold>#</a></h2><ul><li>초기 값부터 시작하여 주어진 원소 각각에 대해 <strong>두 개의 값을 하나로 합치는 연산</strong>을 적용하여 <code>컬렉션</code>의 모든 값을 하나로 합칠때 사용</li><li><code>fold</code>는 <strong>최종 연산</strong>이고, 플로우에서도 사용할 수 있으며, <code>collect</code> 처럼 플로우가 완료될 때까지 <strong>중단(suspend)</strong> 된다.</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-kotlin data-lang=kotlin><span class=line><span class=cl><span class=k>suspend</span> <span class=k>fun</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>val</span> <span class=py>list</span> <span class=p>=</span> <span class=n>flowOf</span><span class=p>(</span><span class=m>1</span><span class=p>,</span> <span class=m>2</span><span class=p>,</span> <span class=m>3</span><span class=p>,</span> <span class=m>4</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=p>.</span><span class=n>onEach</span> <span class=p>{</span> <span class=n>delay</span><span class=p>(</span><span class=m>1000</span><span class=p>)</span> <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>val</span> <span class=py>res</span> <span class=p>=</span> <span class=n>list</span><span class=p>.</span><span class=n>fold</span><span class=p>(</span><span class=m>0</span><span class=p>)</span> <span class=p>{</span> <span class=n>acc</span><span class=p>,</span> <span class=n>i</span> <span class=o>-&gt;</span> <span class=n>acc</span> <span class=p>+</span> <span class=n>i</span> <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=n>println</span><span class=p>(</span><span class=n>res</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=c1>// (4 sec)
</span></span></span><span class=line><span class=cl><span class=c1>// 10
</span></span></span></code></pre></td></tr></table></div></div><h2 id=scan>scan<a hidden class=anchor aria-hidden=true href=#scan>#</a></h2><ul><li><code>scan</code>은 <strong>누적되는 과정의 모든 값을 생성</strong>하는 <strong>중간 연산</strong>이다.</li><li><code>scan</code>은 이전 단계에서 값을 받은 <strong>즉시 새로운 값을 만들기</strong> 만든다.</li></ul><h2 id=flatmapconcat>flatMapConcat<a hidden class=anchor aria-hidden=true href=#flatmapconcat>#</a></h2><ul><li><code>컬렉션</code>의 경우 <code>flatMap</code>은 <code>map</code> 과 비슷하지만 변환 함수가 <strong>평탄화된 컬렉션</strong> 을 반환해야 한다는 점이 다르다.</li><li>플로우의 경우 변환 함수가 <strong>평탄화된 플로우</strong>를 반환한다고 생각하는게 직관적이다.<ul><li>문제는 플로우 원소가 나오는 <strong>시간이 다르다는 점이다.</strong></li><li>이러한 이유로 플로우에는 <code>flatMap</code> 함수가 없으며, 대신 <code>flatMapConcat, flatMapMerge, flatMapLatest</code>와 같은 함수가 존재한다.</li></ul></li><li><code>flatMapConcat</code> 함수는 생성된 플로우를 <strong>하나씩 처리한다.</strong><ul><li>그래서 두 번째 플로우는 첫 번째 플로우가 <strong>완료</strong>되었을 때 시작할 수 있다.</li></ul></li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-kotlin data-lang=kotlin><span class=line><span class=cl><span class=k>fun</span> <span class=nf>flowFrom</span><span class=p>(</span><span class=n>elem</span><span class=p>:</span> <span class=n>String</span><span class=p>)</span> <span class=p>=</span> <span class=n>flowOf</span><span class=p>(</span><span class=m>1</span><span class=p>,</span> <span class=m>2</span><span class=p>,</span> <span class=m>3</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>.</span><span class=n>onEach</span> <span class=p>{</span> <span class=n>delay</span><span class=p>(</span><span class=m>1000</span><span class=p>)</span> <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>.</span><span class=n>map</span> <span class=p>{</span> <span class=s2>&#34;</span><span class=si>${it}</span><span class=s2>_</span><span class=si>${elem}</span><span class=s2> &#34;</span> <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>suspend</span> <span class=k>fun</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>flowOf</span><span class=p>(</span><span class=s2>&#34;A&#34;</span><span class=p>,</span> <span class=s2>&#34;B&#34;</span><span class=p>,</span> <span class=s2>&#34;C&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=p>.</span><span class=n>flatMapConcat</span> <span class=p>{</span> <span class=n>flowFrom</span><span class=p>(</span><span class=k>it</span><span class=p>)</span> <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=p>.</span><span class=n>collect</span> <span class=p>{</span> <span class=n>println</span><span class=p>(</span><span class=k>it</span><span class=p>)</span> <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=c1>// (1 sec)
</span></span></span><span class=line><span class=cl><span class=c1>// 1_A
</span></span></span><span class=line><span class=cl><span class=c1>// (1 sec)
</span></span></span><span class=line><span class=cl><span class=c1>// 2_A
</span></span></span><span class=line><span class=cl><span class=c1>// (1 sec)
</span></span></span><span class=line><span class=cl><span class=c1>// 3_A
</span></span></span><span class=line><span class=cl><span class=c1>// (1 sec)
</span></span></span><span class=line><span class=cl><span class=c1>// 1_B
</span></span></span><span class=line><span class=cl><span class=c1>// (1 sec)
</span></span></span><span class=line><span class=cl><span class=c1>// 2_B
</span></span></span><span class=line><span class=cl><span class=c1>// (1 sec)
</span></span></span><span class=line><span class=cl><span class=c1>// 3_B
</span></span></span><span class=line><span class=cl><span class=c1>// (1 sec)
</span></span></span><span class=line><span class=cl><span class=c1>// 1_C
</span></span></span><span class=line><span class=cl><span class=c1>// (1 sec)
</span></span></span><span class=line><span class=cl><span class=c1>// 2_C
</span></span></span><span class=line><span class=cl><span class=c1>// (1 sec)
</span></span></span><span class=line><span class=cl><span class=c1>// 3_C
</span></span></span></code></pre></td></tr></table></div></div><h2 id=flatmapmerge>flatMapMerge<a hidden class=anchor aria-hidden=true href=#flatmapmerge>#</a></h2><ul><li>특징: 만들어진 플로우를 <strong>동시에</strong> 처리한다.</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-kotlin data-lang=kotlin><span class=line><span class=cl><span class=k>fun</span> <span class=nf>flowFrom</span><span class=p>(</span><span class=n>elem</span><span class=p>:</span> <span class=n>String</span><span class=p>)</span> <span class=p>=</span> <span class=n>flowOf</span><span class=p>(</span><span class=m>1</span><span class=p>,</span> <span class=m>2</span><span class=p>,</span> <span class=m>3</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>.</span><span class=n>onEach</span> <span class=p>{</span> <span class=n>delay</span><span class=p>(</span><span class=m>1000</span><span class=p>)</span> <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>.</span><span class=n>map</span> <span class=p>{</span> <span class=s2>&#34;</span><span class=si>${it}</span><span class=s2>_</span><span class=si>${elem}</span><span class=s2> &#34;</span> <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>suspend</span> <span class=k>fun</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>flowOf</span><span class=p>(</span><span class=s2>&#34;A&#34;</span><span class=p>,</span> <span class=s2>&#34;B&#34;</span><span class=p>,</span> <span class=s2>&#34;C&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=p>.</span><span class=n>flatMapMerge</span> <span class=p>{</span> <span class=n>flowFrom</span><span class=p>(</span><span class=k>it</span><span class=p>)</span> <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=p>.</span><span class=n>collect</span> <span class=p>{</span> <span class=n>println</span><span class=p>(</span><span class=k>it</span><span class=p>)</span> <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=c1>// (1 sec)
</span></span></span><span class=line><span class=cl><span class=c1>// 1_A
</span></span></span><span class=line><span class=cl><span class=c1>// 1_B
</span></span></span><span class=line><span class=cl><span class=c1>// 1_C
</span></span></span><span class=line><span class=cl><span class=c1>// (1 sec)
</span></span></span><span class=line><span class=cl><span class=c1>// 2_A
</span></span></span><span class=line><span class=cl><span class=c1>// 2_B
</span></span></span><span class=line><span class=cl><span class=c1>// 2_C
</span></span></span><span class=line><span class=cl><span class=c1>// (1 sec)
</span></span></span><span class=line><span class=cl><span class=c1>// 3_A
</span></span></span><span class=line><span class=cl><span class=c1>// 3_B
</span></span></span><span class=line><span class=cl><span class=c1>// 3_C
</span></span></span></code></pre></td></tr></table></div></div><ul><li><code>concurreny</code> 인자를 사용해 <strong>동시에</strong> 처리할 수 있는 플로우의 수를 설정할 수 있다.<ul><li>기본값은 <strong>16</strong>이지만, 변경 가능하다.</li></ul></li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-kotlin data-lang=kotlin><span class=line><span class=cl><span class=k>fun</span> <span class=nf>flowFrom</span><span class=p>(</span><span class=n>elem</span><span class=p>:</span> <span class=n>String</span><span class=p>)</span> <span class=p>=</span> <span class=n>flowOf</span><span class=p>(</span><span class=m>1</span><span class=p>,</span> <span class=m>2</span><span class=p>,</span> <span class=m>3</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>.</span><span class=n>onEach</span> <span class=p>{</span> <span class=n>delay</span><span class=p>(</span><span class=m>1000</span><span class=p>)</span> <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>.</span><span class=n>map</span> <span class=p>{</span> <span class=s2>&#34;</span><span class=si>${it}</span><span class=s2>_</span><span class=si>${elem}</span><span class=s2> &#34;</span> <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>suspend</span> <span class=k>fun</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>flowOf</span><span class=p>(</span><span class=s2>&#34;A&#34;</span><span class=p>,</span> <span class=s2>&#34;B&#34;</span><span class=p>,</span> <span class=s2>&#34;C&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=p>.</span><span class=n>flatMapMerge</span><span class=p>(</span><span class=n>concurrency</span> <span class=p>=</span> <span class=m>2</span><span class=p>)</span> <span class=p>{</span> <span class=n>flowFrom</span><span class=p>(</span><span class=k>it</span><span class=p>)</span> <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=p>.</span><span class=n>collect</span> <span class=p>{</span> <span class=n>println</span><span class=p>(</span><span class=k>it</span><span class=p>)</span> <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=c1>// (1 sec)
</span></span></span><span class=line><span class=cl><span class=c1>// 1_A
</span></span></span><span class=line><span class=cl><span class=c1>// 1_B
</span></span></span><span class=line><span class=cl><span class=c1>// (1 sec)
</span></span></span><span class=line><span class=cl><span class=c1>// 2_A
</span></span></span><span class=line><span class=cl><span class=c1>// 2_B
</span></span></span><span class=line><span class=cl><span class=c1>// (1 sec)
</span></span></span><span class=line><span class=cl><span class=c1>// 3_A
</span></span></span><span class=line><span class=cl><span class=c1>// 3_B
</span></span></span><span class=line><span class=cl><span class=c1>// (1 sec)
</span></span></span><span class=line><span class=cl><span class=c1>// 1_C
</span></span></span><span class=line><span class=cl><span class=c1>// (1 sec)
</span></span></span><span class=line><span class=cl><span class=c1>// 2_C
</span></span></span><span class=line><span class=cl><span class=c1>// (1 sec)
</span></span></span><span class=line><span class=cl><span class=c1>// 3_C
</span></span></span></code></pre></td></tr></table></div></div><ul><li><code>flatMapMerge</code>는 플로우의 <strong>각 원소에 대한 데이터를 요청</strong>할 때 주로 사용된다.</li><li>예를 들어 종류를 목록으로 가지고 있다면, 종류별로 요청을 보내야 한다.</li><li><code>async</code> 함수 대신, 플로우와 함께 <code>flatMapMerge</code>를 사용하면 두 가지 이점이 있다.<ul><li><strong>동시성 인자</strong>를 제어하고(같은 시간에 수백 개의 요청을 보내는 걸 피하기 위해) 같은 시간에 얼마만큼의 종류를 처리할지 <strong>결정</strong>할 수 있다.</li><li><code>Flow</code>를 반환하여 데이터가 생성될 때마다, 다음 원소를 보낼 수 있다.<ul><li>함수를 사용하는 측면에서 보면, 데이터를 즉시 처리할 수 있다.</li></ul></li></ul></li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-kotlin data-lang=kotlin><span class=line><span class=cl><span class=k>suspend</span> <span class=k>fun</span> <span class=nf>getOffers</span><span class=p>(</span>
</span></span><span class=line><span class=cl>    <span class=n>categories</span><span class=p>:</span> <span class=n>List</span><span class=p>&lt;</span><span class=n>Category</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl><span class=p>):</span> <span class=n>List</span><span class=p>&lt;</span><span class=n>Offer</span><span class=p>&gt;</span> <span class=p>=</span> <span class=n>coroutineScope</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>categories</span>
</span></span><span class=line><span class=cl>        <span class=p>.</span><span class=n>map</span> <span class=p>{</span> <span class=n>async</span> <span class=p>{</span> <span class=n>api</span><span class=p>.</span><span class=n>requestOffers</span><span class=p>(</span><span class=k>it</span><span class=p>)</span> <span class=p>}</span> <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=p>.</span><span class=n>flatMap</span> <span class=p>{</span> <span class=k>it</span><span class=p>.</span><span class=n>await</span><span class=p>()</span> <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 더 나은 방법 이다.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>suspend</span> <span class=k>fun</span> <span class=nf>getOffers</span><span class=p>(</span>
</span></span><span class=line><span class=cl>    <span class=n>categories</span><span class=p>:</span> <span class=n>List</span><span class=p>&lt;</span><span class=n>Category</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl><span class=p>):</span> <span class=n>Flow</span><span class=p>&lt;</span><span class=n>Offer</span><span class=p>&gt;</span> <span class=p>=</span> <span class=n>categories</span>
</span></span><span class=line><span class=cl>    <span class=p>.</span><span class=n>asFlow</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=p>.</span><span class=n>flatMapMerge</span><span class=p>(</span><span class=n>concurrency</span> <span class=p>=</span> <span class=m>20</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>suspend</span> <span class=p>{</span> <span class=n>api</span><span class=p>.</span><span class=n>requestOffers</span><span class=p>(</span><span class=k>it</span><span class=p>)</span> <span class=p>}.</span><span class=n>asFlow</span><span class=p>()</span>
</span></span><span class=line><span class=cl>        <span class=c1>// or flow { emit(api.requestOffers(it)) }
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><h2 id=flatmaplatest>flatMapLatest<a hidden class=anchor aria-hidden=true href=#flatmaplatest>#</a></h2><ul><li>특징: 새로운 플로우가 나타나면 이전에 처리하던 플로우를 <strong>잊어버린다.</strong></li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-kotlin data-lang=kotlin><span class=line><span class=cl><span class=k>fun</span> <span class=nf>flowFrom</span><span class=p>(</span><span class=n>elem</span><span class=p>:</span> <span class=n>String</span><span class=p>)</span> <span class=p>=</span> <span class=n>flowOf</span><span class=p>(</span><span class=m>1</span><span class=p>,</span> <span class=m>2</span><span class=p>,</span> <span class=m>3</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>.</span><span class=n>onEach</span> <span class=p>{</span> <span class=n>delay</span><span class=p>(</span><span class=m>1000</span><span class=p>)</span> <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>.</span><span class=n>map</span> <span class=p>{</span> <span class=s2>&#34;</span><span class=si>${it}</span><span class=s2>_</span><span class=si>${elem}</span><span class=s2> &#34;</span> <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>suspend</span> <span class=k>fun</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>flowOf</span><span class=p>(</span><span class=s2>&#34;A&#34;</span><span class=p>,</span> <span class=s2>&#34;B&#34;</span><span class=p>,</span> <span class=s2>&#34;C&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=p>.</span><span class=n>flatMapLatest</span> <span class=p>{</span> <span class=n>flowFrom</span><span class=p>(</span><span class=k>it</span><span class=p>)</span> <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=p>.</span><span class=n>collect</span> <span class=p>{</span> <span class=n>println</span><span class=p>(</span><span class=k>it</span><span class=p>)</span> <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=c1>// (1 sec)
</span></span></span><span class=line><span class=cl><span class=c1>// 1_C
</span></span></span><span class=line><span class=cl><span class=c1>// (1 sec)
</span></span></span><span class=line><span class=cl><span class=c1>// 2_C
</span></span></span><span class=line><span class=cl><span class=c1>// (1 sec)
</span></span></span><span class=line><span class=cl><span class=c1>// 3_C
</span></span></span></code></pre></td></tr></table></div></div><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-kotlin data-lang=kotlin><span class=line><span class=cl><span class=k>fun</span> <span class=nf>flowFrom</span><span class=p>(</span><span class=n>elem</span><span class=p>:</span> <span class=n>String</span><span class=p>)</span> <span class=p>=</span> <span class=n>flowOf</span><span class=p>(</span><span class=m>1</span><span class=p>,</span> <span class=m>2</span><span class=p>,</span> <span class=m>3</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>.</span><span class=n>onEach</span> <span class=p>{</span> <span class=n>delay</span><span class=p>(</span><span class=m>1000</span><span class=p>)</span> <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>.</span><span class=n>map</span> <span class=p>{</span> <span class=s2>&#34;</span><span class=si>${it}</span><span class=s2>_</span><span class=si>${elem}</span><span class=s2> &#34;</span> <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>suspend</span> <span class=k>fun</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>flowOf</span><span class=p>(</span><span class=s2>&#34;A&#34;</span><span class=p>,</span> <span class=s2>&#34;B&#34;</span><span class=p>,</span> <span class=s2>&#34;C&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=p>.</span><span class=n>onEach</span> <span class=p>{</span> <span class=n>delay</span><span class=p>(</span><span class=m>1200</span><span class=p>)</span> <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=p>.</span><span class=n>flatMapLatest</span> <span class=p>{</span> <span class=n>flowFrom</span><span class=p>(</span><span class=k>it</span><span class=p>)</span> <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=p>.</span><span class=n>collect</span> <span class=p>{</span> <span class=n>println</span><span class=p>(</span><span class=k>it</span><span class=p>)</span> <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=c1>// (2.2 sec)
</span></span></span><span class=line><span class=cl><span class=c1>// 1_A
</span></span></span><span class=line><span class=cl><span class=c1>// (1.2 sec)
</span></span></span><span class=line><span class=cl><span class=c1>// 1_B
</span></span></span><span class=line><span class=cl><span class=c1>// (1.2 sec)
</span></span></span><span class=line><span class=cl><span class=c1>// 1_C
</span></span></span><span class=line><span class=cl><span class=c1>// (1 sec)
</span></span></span><span class=line><span class=cl><span class=c1>// 2_C
</span></span></span><span class=line><span class=cl><span class=c1>// (1 sec)
</span></span></span><span class=line><span class=cl><span class=c1>// 3_C
</span></span></span></code></pre></td></tr></table></div></div><h2 id=retry재시도>retry(재시도)<a hidden class=anchor aria-hidden=true href=#retry재시도>#</a></h2><ul><li><strong>예외</strong>는 플로우를 따라 흐르면서 <strong>각 단계를 하나씩 종료한다.</strong></li><li>종료된 단계는 <strong>비활성화</strong>되기 때문에, <strong>예외</strong>가 발생한 뒤 메시지를 보내는 건 불가능하지만, <strong>각 단계</strong>가 <strong>이전 단계에 대한 참조</strong>를 가지고 있으며, 플로우를 <strong>다시 시작</strong>하기 위해 <strong>참조</strong>를 사용할 수 있다.</li><li>이 원리에 기반하여, 코틀린은 <code>retry</code>와 <code>retryWhen</code> 함수를 제공한다.</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-kotlin data-lang=kotlin><span class=line><span class=cl><span class=k>fun</span> <span class=p>&lt;</span><span class=nc>T</span><span class=p>&gt;</span> <span class=nf>Flow</span><span class=p>&lt;</span><span class=n>T</span><span class=p>&gt;.</span><span class=n>retryWhen</span><span class=p>(</span>
</span></span><span class=line><span class=cl>    <span class=n>predicate</span><span class=p>:</span> <span class=k>suspend</span> <span class=n>FlowCollector</span><span class=p>&lt;</span><span class=n>T</span><span class=p>&gt;.(</span>
</span></span><span class=line><span class=cl>        <span class=n>cause</span><span class=p>:</span> <span class=n>Throwable</span><span class=p>,</span>
</span></span><span class=line><span class=cl>        <span class=n>attempt</span><span class=p>:</span> <span class=n>Long</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=p>)</span> <span class=o>-&gt;</span> <span class=n>Boolean</span><span class=p>,</span>
</span></span><span class=line><span class=cl><span class=p>):</span> <span class=n>Flow</span><span class=p>&lt;</span><span class=n>T</span><span class=p>&gt;</span> <span class=p>=</span> <span class=n>flow</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>var</span> <span class=py>attempt</span> <span class=p>=</span> <span class=m>0L</span>
</span></span><span class=line><span class=cl>    <span class=k>do</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>val</span> <span class=py>shallRetry</span> <span class=p>=</span> <span class=k>try</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=n>collect</span> <span class=p>{</span> <span class=n>emit</span><span class=p>(</span><span class=k>it</span><span class=p>)</span> <span class=p>}</span>
</span></span><span class=line><span class=cl>            <span class=k>false</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span> <span class=k>catch</span> <span class=p>(</span><span class=n>e</span><span class=p>:</span> <span class=n>Throwable</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=n>predicate</span><span class=p>(</span><span class=n>e</span><span class=p>,</span> <span class=n>attempt</span><span class=o>++</span><span class=p>)</span>
</span></span><span class=line><span class=cl>                <span class=p>.</span><span class=n>also</span> <span class=p>{</span> <span class=k>if</span> <span class=p>(!</span><span class=k>it</span><span class=p>)</span> <span class=k>throw</span> <span class=n>e</span> <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span> <span class=k>while</span> <span class=p>(</span><span class=n>shallRetry</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-kotlin data-lang=kotlin><span class=line><span class=cl><span class=k>fun</span> <span class=p>&lt;</span><span class=nc>T</span><span class=p>&gt;</span> <span class=nf>Flow</span><span class=p>&lt;</span><span class=n>T</span><span class=p>&gt;.</span><span class=n>retry</span><span class=p>(</span>
</span></span><span class=line><span class=cl>    <span class=n>retries</span><span class=p>:</span> <span class=n>Long</span> <span class=p>=</span> <span class=nc>Long</span><span class=p>.</span><span class=n>MAX_VALUE</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=n>predicate</span><span class=p>:</span> <span class=k>suspend</span> <span class=p>(</span><span class=n>cause</span><span class=p>:</span> <span class=n>Throwable</span><span class=p>)</span> <span class=o>-&gt;</span> <span class=n>Boolean</span> <span class=p>=</span> <span class=p>{</span> <span class=k>true</span> <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>):</span> <span class=n>Flow</span><span class=p>&lt;</span><span class=n>T</span><span class=p>&gt;</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>require</span><span class=p>(</span><span class=n>retries</span> <span class=p>&gt;</span> <span class=m>0</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=s2>&#34;Expected positive amount of retries, but had </span><span class=si>$retries</span><span class=s2>&#34;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>retryWhen</span> <span class=p>{</span> <span class=n>cause</span><span class=p>,</span> <span class=n>attempt</span> <span class=o>-&gt;</span>
</span></span><span class=line><span class=cl>        <span class=n>attempt</span> <span class=p>&lt;</span> <span class=n>retries</span> <span class=o>&amp;&amp;</span> <span class=n>predicate</span><span class=p>(</span><span class=n>cause</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><ul><li><code>retryWhen</code> 은 플로우의 이전 단계에서 <strong>예외</strong>가 발생할 때마다 <code>조건자(predicate)</code> 를 확인한다.</li><li>몇 번까지 <strong>재시도</strong>할지와 <strong>특정 예외 클래스</strong>가 발생했을 때만 처리할지를 명시한다.</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-kotlin data-lang=kotlin><span class=line><span class=cl><span class=k>suspend</span> <span class=k>fun</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>flow</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>emit</span><span class=p>(</span><span class=m>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=n>emit</span><span class=p>(</span><span class=m>2</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=n>error</span><span class=p>(</span><span class=s2>&#34;E&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=n>emit</span><span class=p>(</span><span class=m>3</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>}.</span><span class=n>retry</span><span class=p>(</span><span class=m>3</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>print</span><span class=p>(</span><span class=k>it</span><span class=p>.</span><span class=n>message</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=k>true</span>
</span></span><span class=line><span class=cl>    <span class=p>}.</span><span class=n>collect</span> <span class=p>{</span> <span class=n>print</span><span class=p>(</span><span class=k>it</span><span class=p>)</span> <span class=p>}</span> <span class=c1>// 12E12E12E12(exception thrown)
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><ul><li>어떤 <strong>예외</strong>든지 항상 <strong>재시도</strong> 하는 경우, <strong>log</strong>를 남기고 새로운 연결 맺는 걸 시도할 때 <strong>시간 간격</strong>을 주기 위해 <strong>predict(조건자)</strong> 를 정의한다.</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-kotlin data-lang=kotlin><span class=line><span class=cl><span class=k>fun</span> <span class=nf>makeConnection</span><span class=p>(</span><span class=n>config</span><span class=p>:</span> <span class=n>ConnectionConfig</span><span class=p>)</span> <span class=p>=</span> <span class=n>api</span>
</span></span><span class=line><span class=cl>    <span class=p>.</span><span class=n>startConnection</span><span class=p>(</span><span class=n>config</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>.</span><span class=n>retry</span> <span class=p>{</span> <span class=n>e</span> <span class=o>-&gt;</span>
</span></span><span class=line><span class=cl>        <span class=n>delay</span><span class=p>(</span><span class=m>1000</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=n>log</span><span class=p>.</span><span class=n>error</span><span class=p>(</span><span class=n>e</span><span class=p>)</span> <span class=p>{</span> <span class=s2>&#34;Error for </span><span class=si>$config</span><span class=s2>&#34;</span> <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=k>true</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><ul><li>연결을 계속해서 <strong>재시도</strong>할 때 <strong>시간 간격</strong>을 점진적으로 증가시키는 방법도 자주 사용된다.</li><li><strong>예외가 특정 타입</strong>일 때 <strong>재시도</strong>하는 <strong>조건자</strong>를 구현할 수 도 있다.</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-kotlin data-lang=kotlin><span class=line><span class=cl><span class=k>fun</span> <span class=nf>makeConnection</span><span class=p>(</span><span class=n>config</span><span class=p>:</span> <span class=n>ConnectionConfig</span><span class=p>)</span> <span class=p>=</span> <span class=n>api</span>
</span></span><span class=line><span class=cl>    <span class=p>.</span><span class=n>startConnection</span><span class=p>(</span><span class=n>config</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>.</span><span class=n>retryWhen</span> <span class=p>{</span> <span class=n>e</span><span class=p>,</span> <span class=n>attempt</span> <span class=o>-&gt;</span>
</span></span><span class=line><span class=cl>        <span class=n>delay</span><span class=p>(</span><span class=m>100</span> <span class=p>*</span> <span class=n>attempt</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=n>log</span><span class=p>.</span><span class=n>error</span><span class=p>(</span><span class=n>e</span><span class=p>)</span> <span class=p>{</span> <span class=s2>&#34;Error for </span><span class=si>$config</span><span class=s2>&#34;</span> <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=n>e</span> <span class=k>is</span> <span class=n>ApiException</span> <span class=o>&amp;&amp;</span> <span class=n>e</span><span class=p>.</span><span class=n>code</span> <span class=o>!in</span> <span class=m>400.</span><span class=p>.</span><span class=m>499</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><h2 id=최종-연산>최종 연산<a hidden class=anchor aria-hidden=true href=#최종-연산>#</a></h2><ul><li>플로우를 처리를 끝내는 연산 => <strong>최종 연산</strong> 이라고 부른다.</li><li>기본적인 <code>collect</code> 외에도, <code>Collection(컬렉션)</code>과 <code>Sequence</code> 가 제공하는 것과 비슷한 <code>count, first, firstOrNull, fold, reduce</code> 또한 <strong>최종 연산</strong>이다.</li><li><strong>최종 연산</strong>은 <strong>중단 가능(suspend)</strong> 가능하며, 플로우가 <strong>완료</strong>되었을 때 또는 <strong>최종 연산 자체가 플로우를 완료</strong> 시켰을 때 <strong>값을 반환</strong>한다.</li><li><code>collect</code> 메서드를 사용해서 또 다른 <strong>최종 연산</strong>을 얼마든지 <strong>구현</strong>할 수 도 있다.</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-kotlin data-lang=kotlin><span class=line><span class=cl><span class=k>suspend</span> <span class=k>fun</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>val</span> <span class=py>flow</span> <span class=p>=</span> <span class=n>flowOf</span><span class=p>(</span><span class=m>1</span><span class=p>,</span> <span class=m>2</span><span class=p>,</span> <span class=m>3</span><span class=p>,</span> <span class=m>4</span><span class=p>)</span> <span class=c1>// [1, 2, 3, 4]
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=p>.</span><span class=n>map</span> <span class=p>{</span> <span class=k>it</span> <span class=p>*</span> <span class=k>it</span> <span class=p>}</span> <span class=c1>// [1, 4, 9, 16]
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>    <span class=n>println</span><span class=p>(</span><span class=n>flow</span><span class=p>.</span><span class=n>first</span><span class=p>())</span> <span class=c1>// 1
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>println</span><span class=p>(</span><span class=n>flow</span><span class=p>.</span><span class=n>count</span><span class=p>())</span> <span class=c1>// 4
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>    <span class=n>println</span><span class=p>(</span><span class=n>flow</span><span class=p>.</span><span class=n>reduce</span> <span class=p>{</span> <span class=n>acc</span><span class=p>,</span> <span class=k>value</span> <span class=o>-&gt;</span> <span class=n>acc</span> <span class=p>*</span> <span class=k>value</span> <span class=p>})</span> <span class=c1>// 576
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>println</span><span class=p>(</span><span class=n>flow</span><span class=p>.</span><span class=n>fold</span><span class=p>(</span><span class=m>0</span><span class=p>)</span> <span class=p>{</span> <span class=n>acc</span><span class=p>,</span> <span class=k>value</span> <span class=o>-&gt;</span> <span class=n>acc</span> <span class=p>+</span> <span class=k>value</span> <span class=p>})</span> <span class=c1>// 30
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><h1 id=reference>Reference<a hidden class=anchor aria-hidden=true href=#reference>#</a></h1><ul><li><a href=https://kotlinlang.org/docs/coroutines-guide.html>https://kotlinlang.org/docs/coroutines-guide.html</a></li><li>코틀린 코루틴 Kotlin Coroutines: Deep Dive (Marcin Moskała, 인사이트)</li></ul></div><footer class=post-footer><ul class=post-tags><li><a href=https://2taezeat.github.io/tags/kotlin/>Kotlin</a></li><li><a href=https://2taezeat.github.io/tags/coroutine/>Coroutine</a></li></ul><nav class=paginav><a class=prev href=https://2taezeat.github.io/posts/%EC%BD%94%EB%A3%A8%ED%8B%B4-%EC%BD%94%EB%A3%A8%ED%8B%B4/%EC%BD%94%ED%8B%80%EB%A6%B0-%EC%BD%94%EB%A3%A8%ED%8B%B4-ch24.-sharedflow-stateflow/><span class=title>« Prev</span><br><span>[코틀린 코루틴] ch24. SharedFlow, StateFlow</span>
</a><a class=next href=https://2taezeat.github.io/posts/%EC%BD%94%EB%A3%A8%ED%8B%B4-%EC%BD%94%EB%A3%A8%ED%8B%B4/%EC%BD%94%ED%8B%80%EB%A6%B0-%EC%BD%94%EB%A3%A8%ED%8B%B4-ch22.-flow-%EC%83%9D%EB%AA%85%EC%A3%BC%EA%B8%B0-%ED%95%A8%EC%88%98/><span class=title>Next »</span><br><span>[코루틴 코루틴] ch22. Flow 생명주기 함수</span></a></nav><ul class=share-buttons><li><a target=_blank rel="noopener noreferrer" aria-label="share [코루틴 코루틴] ch23. Flow 처리(Processing) on x" href="https://x.com/intent/tweet/?text=%5b%ec%bd%94%eb%a3%a8%ed%8b%b4%20%ec%bd%94%eb%a3%a8%ed%8b%b4%5d%20ch23.%20Flow%20%ec%b2%98%eb%a6%ac%28Processing%29&amp;url=https%3a%2f%2f2taezeat.github.io%2fposts%2f%25EC%25BD%2594%25EB%25A3%25A8%25ED%258B%25B4-%25EC%25BD%2594%25EB%25A3%25A8%25ED%258B%25B4%2f%25EC%25BD%2594%25ED%258B%2580%25EB%25A6%25B0-%25EC%25BD%2594%25EB%25A3%25A8%25ED%258B%25B4-ch23.-flow-%25EC%25B2%2598%25EB%25A6%25ACprocessing%2f&amp;hashtags=Kotlin%2cCoroutine"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446C483.971.0 512 28.03 512 62.554zM269.951 190.75 182.567 75.216H56L207.216 272.95 63.9 436.783h61.366L235.9 310.383l96.667 126.4H456L298.367 228.367l134-153.151H371.033zM127.633 110h36.468l219.38 290.065H349.5z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share [코루틴 코루틴] ch23. Flow 처리(Processing) on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2f2taezeat.github.io%2fposts%2f%25EC%25BD%2594%25EB%25A3%25A8%25ED%258B%25B4-%25EC%25BD%2594%25EB%25A3%25A8%25ED%258B%25B4%2f%25EC%25BD%2594%25ED%258B%2580%25EB%25A6%25B0-%25EC%25BD%2594%25EB%25A3%25A8%25ED%258B%25B4-ch23.-flow-%25EC%25B2%2598%25EB%25A6%25ACprocessing%2f&amp;title=%5b%ec%bd%94%eb%a3%a8%ed%8b%b4%20%ec%bd%94%eb%a3%a8%ed%8b%b4%5d%20ch23.%20Flow%20%ec%b2%98%eb%a6%ac%28Processing%29&amp;summary=%5b%ec%bd%94%eb%a3%a8%ed%8b%b4%20%ec%bd%94%eb%a3%a8%ed%8b%b4%5d%20ch23.%20Flow%20%ec%b2%98%eb%a6%ac%28Processing%29&amp;source=https%3a%2f%2f2taezeat.github.io%2fposts%2f%25EC%25BD%2594%25EB%25A3%25A8%25ED%258B%25B4-%25EC%25BD%2594%25EB%25A3%25A8%25ED%258B%25B4%2f%25EC%25BD%2594%25ED%258B%2580%25EB%25A6%25B0-%25EC%25BD%2594%25EB%25A3%25A8%25ED%258B%25B4-ch23.-flow-%25EC%25B2%2598%25EB%25A6%25ACprocessing%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share [코루틴 코루틴] ch23. Flow 처리(Processing) on reddit" href="https://reddit.com/submit?url=https%3a%2f%2f2taezeat.github.io%2fposts%2f%25EC%25BD%2594%25EB%25A3%25A8%25ED%258B%25B4-%25EC%25BD%2594%25EB%25A3%25A8%25ED%258B%25B4%2f%25EC%25BD%2594%25ED%258B%2580%25EB%25A6%25B0-%25EC%25BD%2594%25EB%25A3%25A8%25ED%258B%25B4-ch23.-flow-%25EC%25B2%2598%25EB%25A6%25ACprocessing%2f&title=%5b%ec%bd%94%eb%a3%a8%ed%8b%b4%20%ec%bd%94%eb%a3%a8%ed%8b%b4%5d%20ch23.%20Flow%20%ec%b2%98%eb%a6%ac%28Processing%29"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share [코루틴 코루틴] ch23. Flow 처리(Processing) on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2f2taezeat.github.io%2fposts%2f%25EC%25BD%2594%25EB%25A3%25A8%25ED%258B%25B4-%25EC%25BD%2594%25EB%25A3%25A8%25ED%258B%25B4%2f%25EC%25BD%2594%25ED%258B%2580%25EB%25A6%25B0-%25EC%25BD%2594%25EB%25A3%25A8%25ED%258B%25B4-ch23.-flow-%25EC%25B2%2598%25EB%25A6%25ACprocessing%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share [코루틴 코루틴] ch23. Flow 처리(Processing) on whatsapp" href="https://api.whatsapp.com/send?text=%5b%ec%bd%94%eb%a3%a8%ed%8b%b4%20%ec%bd%94%eb%a3%a8%ed%8b%b4%5d%20ch23.%20Flow%20%ec%b2%98%eb%a6%ac%28Processing%29%20-%20https%3a%2f%2f2taezeat.github.io%2fposts%2f%25EC%25BD%2594%25EB%25A3%25A8%25ED%258B%25B4-%25EC%25BD%2594%25EB%25A3%25A8%25ED%258B%25B4%2f%25EC%25BD%2594%25ED%258B%2580%25EB%25A6%25B0-%25EC%25BD%2594%25EB%25A3%25A8%25ED%258B%25B4-ch23.-flow-%25EC%25B2%2598%25EB%25A6%25ACprocessing%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share [코루틴 코루틴] ch23. Flow 처리(Processing) on telegram" href="https://telegram.me/share/url?text=%5b%ec%bd%94%eb%a3%a8%ed%8b%b4%20%ec%bd%94%eb%a3%a8%ed%8b%b4%5d%20ch23.%20Flow%20%ec%b2%98%eb%a6%ac%28Processing%29&amp;url=https%3a%2f%2f2taezeat.github.io%2fposts%2f%25EC%25BD%2594%25EB%25A3%25A8%25ED%258B%25B4-%25EC%25BD%2594%25EB%25A3%25A8%25ED%258B%25B4%2f%25EC%25BD%2594%25ED%258B%2580%25EB%25A6%25B0-%25EC%25BD%2594%25EB%25A3%25A8%25ED%258B%25B4-ch23.-flow-%25EC%25B2%2598%25EB%25A6%25ACprocessing%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentcolor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share [코루틴 코루틴] ch23. Flow 처리(Processing) on ycombinator" href="https://news.ycombinator.com/submitlink?t=%5b%ec%bd%94%eb%a3%a8%ed%8b%b4%20%ec%bd%94%eb%a3%a8%ed%8b%b4%5d%20ch23.%20Flow%20%ec%b2%98%eb%a6%ac%28Processing%29&u=https%3a%2f%2f2taezeat.github.io%2fposts%2f%25EC%25BD%2594%25EB%25A3%25A8%25ED%258B%25B4-%25EC%25BD%2594%25EB%25A3%25A8%25ED%258B%25B4%2f%25EC%25BD%2594%25ED%258B%2580%25EB%25A6%25B0-%25EC%25BD%2594%25EB%25A3%25A8%25ED%258B%25B4-ch23.-flow-%25EC%25B2%2598%25EB%25A6%25ACprocessing%2f"><svg width="30" height="30" viewBox="0 0 512 512" fill="currentcolor" xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"><path d="M449.446.0C483.971.0 512 28.03 512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446zM183.8767 87.9921h-62.034L230.6673 292.4508V424.0079h50.6655V292.4508L390.1575 87.9921H328.1233L256 238.2489z"/></svg></a></li></ul></footer><script src=https://utteranc.es/client.js repo=2taezeat/blog_comment issue-term=pathname label=comment theme=github-light crossorigin=anonymous async></script></article></main><footer class=footer><span>&copy; 2024 <a href=https://2taezeat.github.io/>2taezeat, blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>