<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>[알고리즘 문제 해결 전략] ch21. 트리 | 2taezeat, blog</title>
<meta name=keywords content="Algorithm"><meta name=description content="ch21. 트리의 구현과 순회"><meta name=author content="2taezeat"><link rel=canonical href=https://2taezeat.github.io/posts/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EB%AC%B8%EC%A0%9C-%ED%95%B4%EA%B2%B0-%EC%A0%84%EB%9E%B5/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EB%AC%B8%EC%A0%9C-%ED%95%B4%EA%B2%B0-%EC%A0%84%EB%9E%B5-ch21.-%ED%8A%B8%EB%A6%AC/><meta name=google-site-verification content="YaEERzgrvu-ZwPg7gswZdTzRMufkHw3uIH7i8hVal1c"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.0653c5fc8a439a898cd1fe8a206477ec49246832c1f79c575f5c6b9e1810bdb9.css integrity="sha256-BlPF/IpDmomM0f6KIGR37EkkaDLB95xXX1xrnhgQvbk=" rel="preload stylesheet" as=style><link rel=icon href=https://2taezeat.github.io/icon/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://2taezeat.github.io/icon/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://2taezeat.github.io/icon/favicon-32x32.png><link rel=apple-touch-icon href=https://2taezeat.github.io/icon/apple-touch-icon.png><link rel=mask-icon href=https://2taezeat.github.io/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://2taezeat.github.io/posts/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EB%AC%B8%EC%A0%9C-%ED%95%B4%EA%B2%B0-%EC%A0%84%EB%9E%B5/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EB%AC%B8%EC%A0%9C-%ED%95%B4%EA%B2%B0-%EC%A0%84%EB%9E%B5-ch21.-%ED%8A%B8%EB%A6%AC/><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><meta property="og:title" content="[알고리즘 문제 해결 전략] ch21. 트리"><meta property="og:description" content="ch21. 트리의 구현과 순회"><meta property="og:type" content="article"><meta property="og:url" content="https://2taezeat.github.io/posts/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EB%AC%B8%EC%A0%9C-%ED%95%B4%EA%B2%B0-%EC%A0%84%EB%9E%B5/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EB%AC%B8%EC%A0%9C-%ED%95%B4%EA%B2%B0-%EC%A0%84%EB%9E%B5-ch21.-%ED%8A%B8%EB%A6%AC/"><meta property="og:image" content="https://2taezeat.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-01-16T11:30:03+00:00"><meta property="article:modified_time" content="2024-01-16T11:30:03+00:00"><meta property="og:site_name" content="2taezeat, blog"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://2taezeat.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="[알고리즘 문제 해결 전략] ch21. 트리"><meta name=twitter:description content="ch21. 트리의 구현과 순회"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://2taezeat.github.io/posts/"},{"@type":"ListItem","position":2,"name":"[알고리즘 문제 해결 전략] ch21. 트리","item":"https://2taezeat.github.io/posts/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EB%AC%B8%EC%A0%9C-%ED%95%B4%EA%B2%B0-%EC%A0%84%EB%9E%B5/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EB%AC%B8%EC%A0%9C-%ED%95%B4%EA%B2%B0-%EC%A0%84%EB%9E%B5-ch21.-%ED%8A%B8%EB%A6%AC/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"[알고리즘 문제 해결 전략] ch21. 트리","name":"[알고리즘 문제 해결 전략] ch21. 트리","description":"ch21. 트리의 구현과 순회","keywords":["Algorithm"],"articleBody":"21. 트리의 구현과 순회 21.1 도입 선형으로 표현하기 어려운 형태의 자료 중 흔한 것이 계층 구조 이다. 자료 간에 상하위, 포함 관계 조직도, 상품 분류 기준 등 등 트리는 계층 관계를 갖는 객체들을 표현하기 위한 자료구조 그러나 실제 계층 관계가 없는 자료들도 트리를 표현해서 같은 연산을 더 빠르게 할 수 있다. 하나의 상위 개념에서 가지를 쳐서 뻗어가는 모습이 실제 나무(상하가 뒤집혔지만)와 닮았다 해서 트리라고 부른다, 트리는 처음에 현실 세계의 개념을 추상화해 표현하는 자료 구조로 고안되었지만, 탐색형 자료 구조로도 유용하게 쓰인다. 특정한 조건을 지키도록 구성된 트리를 이용하면, 배열, 리스트를 사용하는 것보다 빠르게 작업을 할 수 있다. 21.1.1 트리의 기초적인 정의와 용어 21.1.2 트리의 구성 요소 트리는 자료가 저장된 node(노드)와 edge(간선)으로 서로 연결되어 있다. 노드 간에는 상/하위 관계가 있다. 두 노드가 연결되었을 때 한 노드는 좀더 상위, 다른 노드는 좀 더 하위에 있어야 한다. 상위 노드: 부모(parent) 노드 하위 노드: 자식(child) 노드 부모가 같은 노드: 형제(sibling) 노드 부모 노드와 그의 부모들을 통들어: 선조(ancestor) 자식 노드와 그의 자식들을 통들어: 자손(descendant) 부모-자식 비유 처럼, 트리에서 한 노드는 여러 개의 자식을 가질 수 있어도, 부모는 하나만 가질 수 있다. 모든 노드들을 자손으로 갖는 단 하나의 노드: 뿌리, 루트(root) 노드 자식이 하나도 없느 노드: 트리의 잎 노드, 리프(leaf) 노드 21.1.3 트리의 노드의 속성 깊이(depth): 루트에서 어떤 노드에 도달하기 위해 거쳐야 하는 간선의 수\n높이(height): 트리에서 가장 깊숙히 있는 노드의 깊이\n트리의 레벨(Level): 깊이가 같은 노드들의 집합\n21.1.4 트리의 재귀적 속성 트리는 재귀적인 성질을 가지고 있다. 트리를 다루는 코드들은 대개 재귀 호출을 이용해 구현 트리에서 한 노드와 그의 자손들을 모두 모으면 그들도 하나의 트리가 된다. 어떤 노드 t와 그 자손들로 구성된 트리를 t를 루트로 하는 서브트리(subtree) 라고 한다. 따라서, 모든 트리는 루트와 루트 밑에 있는 서브트리들의 집합 21.1.5 트리의 표현 트리는 다양한 방법으로 구현할 수 있다 가장 일반적인 형태는 각 노드를 하나의 구조체/객체로 표현하고, 이들을 서로의 포인터로 연결하는 것이다. 이때, 각 노드들은 자신의 부모와 모든 자손들에 대한 포인터를 가지고 있다. 기본적인(범용적인) 트리 구현 1 2 3 4 5 6 data class TreeNode\u003cT\u003e( val value: T, val parent: TreeNode\u003cT\u003e?, val children: MutableList\u003cTreeNode\u003cT\u003e\u003e ) // parent 없이, children 만 있어도 된다. 자식 노드의 포인터를 담는 배열 대신, 두 포인터 left, right를 이용해 자식들을 저장할 수 도 있다. (이진 검색 트리) 21.2 트리의 순회 트리는 트리의 재귀적 속성을 이용해서 순회를 해야 한다. 트리에 N개의 노드가 있을 때, 시간복잡도: 모든 노드에 대해서 한 번씩 재귀 함수가 호출 됨으로, O(N) 서브트리의 개념을 이용하면 트리의 높이 또한 재귀적으로 정의할 수 있다. 21.5 요새, FORTRESS, 난이도: 중 트리의 최장 경로 찾기 문제로 접근\n트리의 경로(path): 두 노드 사이를 연결하는 간선들을 트리의 경로라고 한다.\n트리의 최장 경로 =\u003e 1,2번 둘 중 큰 값이다.\n양 끝 노드가 항상 루트 혹은 리프 노드 여야 한다. 가장 긴 루트-리프 경로의 길이 (== 트리의 height, 높이)\n가장 긴 리프-리프의 경로의 길이\n리프-리프 경로들은 항상 어떤 노드까지 쭉 위로 올라가다 쭉 아래로 내려가는 형태이다.\n최상위 노드: 경로가 올라가다가 내려가는 지점을 이 경로의 최상위 노드라 한다. 각 노드 마다 취상위 노드로 갖는 가장 긴 리프-리프 노드를 계산하고, 그중 최댓값을 구하면 된다. =\u003e 각 서브트리의 높이를 계산한 뒤, 가장 높은 두개의 서브 트리를 선택하면 가장 긴 리프-리프 경로를 구할 수 있다. Reference 프로그래밍 대회에서 배우는 알고리즘 문제 해결 전략 (구종만, 인사이트) https://www.algospot.com/ ","wordCount":"510","inLanguage":"en","image":"https://2taezeat.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E","datePublished":"2024-01-16T11:30:03Z","dateModified":"2024-01-16T11:30:03Z","author":{"@type":"Person","name":"2taezeat"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://2taezeat.github.io/posts/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EB%AC%B8%EC%A0%9C-%ED%95%B4%EA%B2%B0-%EC%A0%84%EB%9E%B5/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EB%AC%B8%EC%A0%9C-%ED%95%B4%EA%B2%B0-%EC%A0%84%EB%9E%B5-ch21.-%ED%8A%B8%EB%A6%AC/"},"publisher":{"@type":"Organization","name":"2taezeat, blog","logo":{"@type":"ImageObject","url":"https://2taezeat.github.io/icon/favicon.ico"}}}</script></head><body id=top><header class=header><nav class=nav><div class=logo><a href=https://2taezeat.github.io/ accesskey=h title="2taezeat blog (Alt + H)"><img src=https://2taezeat.github.io/icon/apple-touch-icon.png alt aria-label=logo height=30>2taezeat blog</a><div class=logo-switches></div></div><ul id=menu><li><a href=https://2taezeat.github.io/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://2taezeat.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://2taezeat.github.io/searchs/ title=Search><span>Search</span></a></li><li><a href=https://github.com/2taezeat title=Github><span>Github</span>&nbsp;<svg fill="none" shape-rendering="geometricPrecision" stroke="currentcolor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2.5" viewBox="0 0 24 24" height="12" width="12"><path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"/><path d="M15 3h6v6"/><path d="M10 14 21 3"/></svg></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://2taezeat.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://2taezeat.github.io/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">[알고리즘 문제 해결 전략] ch21. 트리</h1><div class=post-description>ch21. 트리의 구현과 순회</div><div class=post-meta><span title='2024-01-16 11:30:03 +0000 +0000'>2024-01-16</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;510 words&nbsp;·&nbsp;2taezeat</div></header><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#21-트리의-구현과-순회>21. 트리의 구현과 순회</a><ul><li><a href=#211-도입>21.1 도입</a><ul><li><a href=#2111-트리의-기초적인-정의와-용어>21.1.1 트리의 기초적인 정의와 용어</a></li><li><a href=#2112-트리의-구성-요소>21.1.2 트리의 구성 요소</a></li><li><a href=#2113-트리의-노드의-속성>21.1.3 트리의 노드의 속성</a></li><li><a href=#2114-트리의-재귀적-속성>21.1.4 트리의 재귀적 속성</a></li><li><a href=#2115-트리의-표현>21.1.5 트리의 표현</a></li></ul></li><li><a href=#212-트리의-순회>21.2 트리의 순회</a></li><li><a href=#215-요새-fortress-난이도-중>21.5 요새, FORTRESS, 난이도: 중</a></li></ul></li><li><a href=#reference>Reference</a></li></ul></nav></div></details></div><div class=post-content><h1 id=21-트리의-구현과-순회>21. 트리의 구현과 순회<a hidden class=anchor aria-hidden=true href=#21-트리의-구현과-순회>#</a></h1><h2 id=211-도입>21.1 도입<a hidden class=anchor aria-hidden=true href=#211-도입>#</a></h2><ul><li><strong>선형</strong>으로 표현하기 어려운 형태의 자료 중 흔한 것이 <strong>계층 구조</strong> 이다.<ul><li>자료 간에 상하위, 포함 관계</li><li>조직도, 상품 분류 기준 등 등</li></ul></li><li>트리는 <strong>계층 관계</strong>를 갖는 객체들을 표현하기 위한 자료구조</li><li>그러나 <strong>실제 계층 관계</strong>가 없는 자료들도 <strong>트리</strong>를 표현해서 같은 연산을 더 빠르게 할 수 있다.</li><li>하나의 상위 개념에서 가지를 쳐서 뻗어가는 모습이 실제 나무(상하가 뒤집혔지만)와 닮았다 해서 <strong>트리</strong>라고 부른다,</li><li>트리는 처음에 현실 세계의 개념을 추상화해 표현하는 자료 구조로 고안되었지만, <strong>탐색형</strong> 자료 구조로도 유용하게 쓰인다.<ul><li>특정한 조건을 지키도록 구성된 트리를 이용하면, 배열, 리스트를 사용하는 것보다 빠르게 작업을 할 수 있다.</li></ul></li></ul><h3 id=2111-트리의-기초적인-정의와-용어>21.1.1 트리의 기초적인 정의와 용어<a hidden class=anchor aria-hidden=true href=#2111-트리의-기초적인-정의와-용어>#</a></h3><h3 id=2112-트리의-구성-요소>21.1.2 트리의 구성 요소<a hidden class=anchor aria-hidden=true href=#2112-트리의-구성-요소>#</a></h3><ul><li>트리는 자료가 저장된 node(노드)와 edge(간선)으로 서로 연결되어 있다.</li><li>노드 간에는 상/하위 관계가 있다. 두 노드가 연결되었을 때 한 노드는 좀더 상위, 다른 노드는 좀 더 하위에 있어야 한다.</li><li>상위 노드: 부모(parent) 노드</li><li>하위 노드: 자식(child) 노드</li><li>부모가 같은 노드: 형제(sibling) 노드</li><li>부모 노드와 그의 부모들을 통들어: 선조(ancestor)</li><li>자식 노드와 그의 자식들을 통들어: 자손(descendant)</li><li>부모-자식 비유 처럼, 트리에서 한 노드는 여러 개의 자식을 가질 수 있어도, 부모는 하나만 가질 수 있다.</li><li>모든 노드들을 자손으로 갖는 단 하나의 노드: 뿌리, 루트(root) 노드</li><li>자식이 하나도 없느 노드: 트리의 잎 노드, 리프(leaf) 노드</li></ul><h3 id=2113-트리의-노드의-속성>21.1.3 트리의 노드의 속성<a hidden class=anchor aria-hidden=true href=#2113-트리의-노드의-속성>#</a></h3><ul><li><p>깊이(depth): 루트에서 어떤 노드에 도달하기 위해 거쳐야 하는 <strong>간선의 수</strong></p></li><li><p>높이(height): 트리에서 가장 깊숙히 있는 <strong>노드의 깊이</strong></p></li><li><p>트리의 레벨(Level): <strong>깊이가 같은 노드들의 집합</strong></p></li></ul><h3 id=2114-트리의-재귀적-속성>21.1.4 트리의 재귀적 속성<a hidden class=anchor aria-hidden=true href=#2114-트리의-재귀적-속성>#</a></h3><ul><li>트리는 재귀적인 성질을 가지고 있다.<ul><li>트리를 다루는 코드들은 대개 재귀 호출을 이용해 구현</li></ul></li><li>트리에서 한 노드와 그의 자손들을 모두 모으면 그들도 하나의 트리가 된다.</li><li>어떤 노드 t와 그 자손들로 구성된 트리를 <strong>t를 루트로 하는 서브트리(subtree)</strong> 라고 한다.<ul><li>따라서, 모든 트리는 <strong>루트</strong>와 <strong>루트 밑에 있는 서브트리들</strong>의 집합</li></ul></li></ul><h3 id=2115-트리의-표현>21.1.5 트리의 표현<a hidden class=anchor aria-hidden=true href=#2115-트리의-표현>#</a></h3><ul><li>트리는 다양한 방법으로 구현할 수 있다<ul><li>가장 일반적인 형태는 각 노드를 하나의 구조체/객체로 표현하고, 이들을 서로의 포인터로 연결하는 것이다.</li><li>이때, 각 노드들은 자신의 부모와 모든 자손들에 대한 포인터를 가지고 있다.</li></ul></li></ul><p><img loading=lazy src=/images/before/image-20240404143229766.png alt=image-20240404143229766.png width=680 height=auto></p><ul><li>기본적인(범용적인) 트리 구현</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-kotlin data-lang=kotlin><span class=line><span class=cl><span class=k>data</span> <span class=k>class</span> <span class=nc>TreeNode</span><span class=p>&lt;</span><span class=n>T</span><span class=p>&gt;(</span>
</span></span><span class=line><span class=cl>    <span class=k>val</span> <span class=py>value</span><span class=p>:</span> <span class=n>T</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=k>val</span> <span class=py>parent</span><span class=p>:</span> <span class=n>TreeNode</span><span class=p>&lt;</span><span class=n>T</span><span class=p>&gt;?,</span>
</span></span><span class=line><span class=cl>    <span class=k>val</span> <span class=py>children</span><span class=p>:</span> <span class=n>MutableList</span><span class=p>&lt;</span><span class=n>TreeNode</span><span class=p>&lt;</span><span class=n>T</span><span class=p>&gt;&gt;</span>
</span></span><span class=line><span class=cl><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=c1>// parent 없이, children 만 있어도 된다.
</span></span></span></code></pre></td></tr></table></div></div><ul><li>자식 노드의 포인터를 담는 배열 대신, 두 포인터 left, right를 이용해 자식들을 저장할 수 도 있다. (이진 검색 트리)</li></ul><h2 id=212-트리의-순회>21.2 트리의 순회<a hidden class=anchor aria-hidden=true href=#212-트리의-순회>#</a></h2><ul><li>트리는 트리의 재귀적 속성을 이용해서 순회를 해야 한다.<ul><li>트리에 N개의 노드가 있을 때, 시간복잡도: 모든 노드에 대해서 한 번씩 재귀 함수가 호출 됨으로, O(N)</li></ul></li><li>서브트리의 개념을 이용하면 트리의 높이 또한 재귀적으로 정의할 수 있다.</li></ul><h2 id=215-요새-fortress-난이도-중>21.5 요새, FORTRESS, 난이도: 중<a hidden class=anchor aria-hidden=true href=#215-요새-fortress-난이도-중>#</a></h2><ul><li><p><strong><code>트리의 최장 경로</code></strong> 찾기 문제로 접근</p></li><li><p><strong>트리의 경로(path)</strong>: 두 노드 사이를 연결하는 간선들을 <strong>트리의 경로</strong>라고 한다.</p></li><li><p><strong><code>트리의 최장 경로</code></strong> => <em><strong>1,2번</strong></em> 둘 중 큰 값이다.</p><ul><li>양 끝 노드가 항상 <strong>루트 혹은 리프 노드</strong> 여야 한다.</li></ul><ol><li><p><em><strong>가장 긴 루트-리프</strong></em> 경로의 길이 (== 트리의 height, 높이)</p></li><li><p><em><strong>가장 긴 리프-리프</strong></em>의 경로의 길이</p></li></ol></li><li><p>리프-리프 경로들은 항상 어떤 노드까지 쭉 위로 올라가다 쭉 아래로 내려가는 형태이다.</p><ul><li>최상위 노드: 경로가 올라가다가 내려가는 지점을 이 경로의 <strong>최상위 노드</strong>라 한다.</li><li>각 노드 마다 취상위 노드로 갖는 가장 긴 리프-리프 노드를 계산하고, 그중 최댓값을 구하면 된다.<ul><li>=> <strong>각 서브트리의 높이를 계산한 뒤, 가장 높은 두개의 서브 트리를 선택하면</strong> 가장 긴 리프-리프 경로를 구할 수 있다.</li></ul></li></ul></li></ul><h1 id=reference>Reference<a hidden class=anchor aria-hidden=true href=#reference>#</a></h1><ul><li>프로그래밍 대회에서 배우는 알고리즘 문제 해결 전략 (구종만, 인사이트)</li><li><a href=https://www.algospot.com/>https://www.algospot.com/</a></li></ul></div><footer class=post-footer><ul class=post-tags><li><a href=https://2taezeat.github.io/tags/algorithm/>Algorithm</a></li></ul><nav class=paginav><a class=prev href=https://2taezeat.github.io/posts/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EB%AC%B8%EC%A0%9C-%ED%95%B4%EA%B2%B0-%EC%A0%84%EB%9E%B5/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EB%AC%B8%EC%A0%9C-%ED%95%B4%EA%B2%B0-%EC%A0%84%EB%9E%B5-ch22.-%ED%8A%B8%EB%A6%AC/><span class=title>« Prev</span><br><span>[알고리즘 문제 해결 전략] ch22. 트리</span>
</a><a class=next href=https://2taezeat.github.io/posts/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EB%AC%B8%EC%A0%9C-%ED%95%B4%EA%B2%B0-%EC%A0%84%EB%9E%B5/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EB%AC%B8%EC%A0%9C-%ED%95%B4%EA%B2%B0-%EC%A0%84%EB%9E%B5-ch20.-%EA%B8%B0%EC%B4%88-%EC%9E%90%EB%A3%8C-%EA%B5%AC%EC%A1%B0/><span class=title>Next »</span><br><span>[알고리즘 문제 해결 전략] ch20. 기초 자료 구조</span></a></nav><ul class=share-buttons><li><a target=_blank rel="noopener noreferrer" aria-label="share [알고리즘 문제 해결 전략] ch21. 트리 on x" href="https://x.com/intent/tweet/?text=%5b%ec%95%8c%ea%b3%a0%eb%a6%ac%ec%a6%98%20%eb%ac%b8%ec%a0%9c%20%ed%95%b4%ea%b2%b0%20%ec%a0%84%eb%9e%b5%5d%20ch21.%20%ed%8a%b8%eb%a6%ac&amp;url=https%3a%2f%2f2taezeat.github.io%2fposts%2f%25EC%2595%258C%25EA%25B3%25A0%25EB%25A6%25AC%25EC%25A6%2598-%25EB%25AC%25B8%25EC%25A0%259C-%25ED%2595%25B4%25EA%25B2%25B0-%25EC%25A0%2584%25EB%259E%25B5%2f%25EC%2595%258C%25EA%25B3%25A0%25EB%25A6%25AC%25EC%25A6%2598-%25EB%25AC%25B8%25EC%25A0%259C-%25ED%2595%25B4%25EA%25B2%25B0-%25EC%25A0%2584%25EB%259E%25B5-ch21.-%25ED%258A%25B8%25EB%25A6%25AC%2f&amp;hashtags=Algorithm"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446C483.971.0 512 28.03 512 62.554zM269.951 190.75 182.567 75.216H56L207.216 272.95 63.9 436.783h61.366L235.9 310.383l96.667 126.4H456L298.367 228.367l134-153.151H371.033zM127.633 110h36.468l219.38 290.065H349.5z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share [알고리즘 문제 해결 전략] ch21. 트리 on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2f2taezeat.github.io%2fposts%2f%25EC%2595%258C%25EA%25B3%25A0%25EB%25A6%25AC%25EC%25A6%2598-%25EB%25AC%25B8%25EC%25A0%259C-%25ED%2595%25B4%25EA%25B2%25B0-%25EC%25A0%2584%25EB%259E%25B5%2f%25EC%2595%258C%25EA%25B3%25A0%25EB%25A6%25AC%25EC%25A6%2598-%25EB%25AC%25B8%25EC%25A0%259C-%25ED%2595%25B4%25EA%25B2%25B0-%25EC%25A0%2584%25EB%259E%25B5-ch21.-%25ED%258A%25B8%25EB%25A6%25AC%2f&amp;title=%5b%ec%95%8c%ea%b3%a0%eb%a6%ac%ec%a6%98%20%eb%ac%b8%ec%a0%9c%20%ed%95%b4%ea%b2%b0%20%ec%a0%84%eb%9e%b5%5d%20ch21.%20%ed%8a%b8%eb%a6%ac&amp;summary=%5b%ec%95%8c%ea%b3%a0%eb%a6%ac%ec%a6%98%20%eb%ac%b8%ec%a0%9c%20%ed%95%b4%ea%b2%b0%20%ec%a0%84%eb%9e%b5%5d%20ch21.%20%ed%8a%b8%eb%a6%ac&amp;source=https%3a%2f%2f2taezeat.github.io%2fposts%2f%25EC%2595%258C%25EA%25B3%25A0%25EB%25A6%25AC%25EC%25A6%2598-%25EB%25AC%25B8%25EC%25A0%259C-%25ED%2595%25B4%25EA%25B2%25B0-%25EC%25A0%2584%25EB%259E%25B5%2f%25EC%2595%258C%25EA%25B3%25A0%25EB%25A6%25AC%25EC%25A6%2598-%25EB%25AC%25B8%25EC%25A0%259C-%25ED%2595%25B4%25EA%25B2%25B0-%25EC%25A0%2584%25EB%259E%25B5-ch21.-%25ED%258A%25B8%25EB%25A6%25AC%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share [알고리즘 문제 해결 전략] ch21. 트리 on reddit" href="https://reddit.com/submit?url=https%3a%2f%2f2taezeat.github.io%2fposts%2f%25EC%2595%258C%25EA%25B3%25A0%25EB%25A6%25AC%25EC%25A6%2598-%25EB%25AC%25B8%25EC%25A0%259C-%25ED%2595%25B4%25EA%25B2%25B0-%25EC%25A0%2584%25EB%259E%25B5%2f%25EC%2595%258C%25EA%25B3%25A0%25EB%25A6%25AC%25EC%25A6%2598-%25EB%25AC%25B8%25EC%25A0%259C-%25ED%2595%25B4%25EA%25B2%25B0-%25EC%25A0%2584%25EB%259E%25B5-ch21.-%25ED%258A%25B8%25EB%25A6%25AC%2f&title=%5b%ec%95%8c%ea%b3%a0%eb%a6%ac%ec%a6%98%20%eb%ac%b8%ec%a0%9c%20%ed%95%b4%ea%b2%b0%20%ec%a0%84%eb%9e%b5%5d%20ch21.%20%ed%8a%b8%eb%a6%ac"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share [알고리즘 문제 해결 전략] ch21. 트리 on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2f2taezeat.github.io%2fposts%2f%25EC%2595%258C%25EA%25B3%25A0%25EB%25A6%25AC%25EC%25A6%2598-%25EB%25AC%25B8%25EC%25A0%259C-%25ED%2595%25B4%25EA%25B2%25B0-%25EC%25A0%2584%25EB%259E%25B5%2f%25EC%2595%258C%25EA%25B3%25A0%25EB%25A6%25AC%25EC%25A6%2598-%25EB%25AC%25B8%25EC%25A0%259C-%25ED%2595%25B4%25EA%25B2%25B0-%25EC%25A0%2584%25EB%259E%25B5-ch21.-%25ED%258A%25B8%25EB%25A6%25AC%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share [알고리즘 문제 해결 전략] ch21. 트리 on whatsapp" href="https://api.whatsapp.com/send?text=%5b%ec%95%8c%ea%b3%a0%eb%a6%ac%ec%a6%98%20%eb%ac%b8%ec%a0%9c%20%ed%95%b4%ea%b2%b0%20%ec%a0%84%eb%9e%b5%5d%20ch21.%20%ed%8a%b8%eb%a6%ac%20-%20https%3a%2f%2f2taezeat.github.io%2fposts%2f%25EC%2595%258C%25EA%25B3%25A0%25EB%25A6%25AC%25EC%25A6%2598-%25EB%25AC%25B8%25EC%25A0%259C-%25ED%2595%25B4%25EA%25B2%25B0-%25EC%25A0%2584%25EB%259E%25B5%2f%25EC%2595%258C%25EA%25B3%25A0%25EB%25A6%25AC%25EC%25A6%2598-%25EB%25AC%25B8%25EC%25A0%259C-%25ED%2595%25B4%25EA%25B2%25B0-%25EC%25A0%2584%25EB%259E%25B5-ch21.-%25ED%258A%25B8%25EB%25A6%25AC%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share [알고리즘 문제 해결 전략] ch21. 트리 on telegram" href="https://telegram.me/share/url?text=%5b%ec%95%8c%ea%b3%a0%eb%a6%ac%ec%a6%98%20%eb%ac%b8%ec%a0%9c%20%ed%95%b4%ea%b2%b0%20%ec%a0%84%eb%9e%b5%5d%20ch21.%20%ed%8a%b8%eb%a6%ac&amp;url=https%3a%2f%2f2taezeat.github.io%2fposts%2f%25EC%2595%258C%25EA%25B3%25A0%25EB%25A6%25AC%25EC%25A6%2598-%25EB%25AC%25B8%25EC%25A0%259C-%25ED%2595%25B4%25EA%25B2%25B0-%25EC%25A0%2584%25EB%259E%25B5%2f%25EC%2595%258C%25EA%25B3%25A0%25EB%25A6%25AC%25EC%25A6%2598-%25EB%25AC%25B8%25EC%25A0%259C-%25ED%2595%25B4%25EA%25B2%25B0-%25EC%25A0%2584%25EB%259E%25B5-ch21.-%25ED%258A%25B8%25EB%25A6%25AC%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentcolor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share [알고리즘 문제 해결 전략] ch21. 트리 on ycombinator" href="https://news.ycombinator.com/submitlink?t=%5b%ec%95%8c%ea%b3%a0%eb%a6%ac%ec%a6%98%20%eb%ac%b8%ec%a0%9c%20%ed%95%b4%ea%b2%b0%20%ec%a0%84%eb%9e%b5%5d%20ch21.%20%ed%8a%b8%eb%a6%ac&u=https%3a%2f%2f2taezeat.github.io%2fposts%2f%25EC%2595%258C%25EA%25B3%25A0%25EB%25A6%25AC%25EC%25A6%2598-%25EB%25AC%25B8%25EC%25A0%259C-%25ED%2595%25B4%25EA%25B2%25B0-%25EC%25A0%2584%25EB%259E%25B5%2f%25EC%2595%258C%25EA%25B3%25A0%25EB%25A6%25AC%25EC%25A6%2598-%25EB%25AC%25B8%25EC%25A0%259C-%25ED%2595%25B4%25EA%25B2%25B0-%25EC%25A0%2584%25EB%259E%25B5-ch21.-%25ED%258A%25B8%25EB%25A6%25AC%2f"><svg width="30" height="30" viewBox="0 0 512 512" fill="currentcolor" xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"><path d="M449.446.0C483.971.0 512 28.03 512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446zM183.8767 87.9921h-62.034L230.6673 292.4508V424.0079h50.6655V292.4508L390.1575 87.9921H328.1233L256 238.2489z"/></svg></a></li></ul></footer><script src=https://utteranc.es/client.js repo=2taezeat/blog_comment issue-term=pathname label=comment theme=github-light crossorigin=anonymous async></script></article></main><footer class=footer><span>&copy; 2024 <a href=https://2taezeat.github.io/>2taezeat, blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>