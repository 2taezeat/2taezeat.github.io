<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>[알고리즘 문제 해결 전략] ch13, 14, 15. 유명한 알고리즘들 | 2taezeat, blog</title>
<meta name=keywords content="Algorithm"><meta name=description content="ch13. 수치해석, ch14. 정수론, ch15. 계산 기하"><meta name=author content="2taezeat"><link rel=canonical href=https://2taezeat.github.io/posts/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EB%AC%B8%EC%A0%9C-%ED%95%B4%EA%B2%B0-%EC%A0%84%EB%9E%B5/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EB%AC%B8%EC%A0%9C-%ED%95%B4%EA%B2%B0-%EC%A0%84%EB%9E%B5-ch13-14-15.-%EC%9C%A0%EB%AA%85%ED%95%9C-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98%EB%93%A4/><meta name=google-site-verification content="YaEERzgrvu-ZwPg7gswZdTzRMufkHw3uIH7i8hVal1c"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.cc8105bf49785484525cafc7883272c26982bf06e1663dcfa3b55c3bb3f773b6.css integrity="sha256-zIEFv0l4VIRSXK/HiDJywmmCvwbhZj3Po7VcO7P3c7Y=" rel="preload stylesheet" as=style><link rel=icon href=https://2taezeat.github.io/icon/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://2taezeat.github.io/icon/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://2taezeat.github.io/icon/favicon-32x32.png><link rel=apple-touch-icon href=https://2taezeat.github.io/icon/apple-touch-icon.png><link rel=mask-icon href=https://2taezeat.github.io/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://2taezeat.github.io/posts/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EB%AC%B8%EC%A0%9C-%ED%95%B4%EA%B2%B0-%EC%A0%84%EB%9E%B5/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EB%AC%B8%EC%A0%9C-%ED%95%B4%EA%B2%B0-%EC%A0%84%EB%9E%B5-ch13-14-15.-%EC%9C%A0%EB%AA%85%ED%95%9C-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98%EB%93%A4/><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><meta property="og:title" content="[알고리즘 문제 해결 전략] ch13, 14, 15. 유명한 알고리즘들"><meta property="og:description" content="ch13. 수치해석, ch14. 정수론, ch15. 계산 기하"><meta property="og:type" content="article"><meta property="og:url" content="https://2taezeat.github.io/posts/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EB%AC%B8%EC%A0%9C-%ED%95%B4%EA%B2%B0-%EC%A0%84%EB%9E%B5/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EB%AC%B8%EC%A0%9C-%ED%95%B4%EA%B2%B0-%EC%A0%84%EB%9E%B5-ch13-14-15.-%EC%9C%A0%EB%AA%85%ED%95%9C-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98%EB%93%A4/"><meta property="og:image" content="https://2taezeat.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-01-10T11:30:03+00:00"><meta property="article:modified_time" content="2024-01-10T11:30:03+00:00"><meta property="og:site_name" content="2taezeat, blog"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://2taezeat.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="[알고리즘 문제 해결 전략] ch13, 14, 15. 유명한 알고리즘들"><meta name=twitter:description content="ch13. 수치해석, ch14. 정수론, ch15. 계산 기하"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://2taezeat.github.io/posts/"},{"@type":"ListItem","position":2,"name":"[알고리즘 문제 해결 전략] ch13, 14, 15. 유명한 알고리즘들","item":"https://2taezeat.github.io/posts/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EB%AC%B8%EC%A0%9C-%ED%95%B4%EA%B2%B0-%EC%A0%84%EB%9E%B5/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EB%AC%B8%EC%A0%9C-%ED%95%B4%EA%B2%B0-%EC%A0%84%EB%9E%B5-ch13-14-15.-%EC%9C%A0%EB%AA%85%ED%95%9C-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98%EB%93%A4/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"[알고리즘 문제 해결 전략] ch13, 14, 15. 유명한 알고리즘들","name":"[알고리즘 문제 해결 전략] ch13, 14, 15. 유명한 알고리즘들","description":"ch13. 수치해석, ch14. 정수론, ch15. 계산 기하","keywords":["Algorithm"],"articleBody":"유명한 알고리즘이나 자료 구조를 도구로 사용해 풀어야 하는 문제들에 대해 다룸\n13. 수치 해석 13.1 도입 수치 해석: 직접 풀기 힘든 수학 문제를 근사적으로 푸는 알고리즘과 오차의 범위, 수치적 안정성을 연구하는 전산학의 분야 13.2 이분법 이분법: 주어진 범위 [lo, hi] 내에서 어떤 함수 f(x)의 값이 0이 되는 지점을 수치적으로 찾아내는 기법 이분법은 이분탐색의 토대가 된다. 정해진 횟수만큼 반복하기 반복문을 100번 반복하면, 절대 오차가 최대 lo-hi / 2 ^101 이 된다. 이 오차는 10 ^ -7 보다 작다. 따라서 큰 숫자를 다루는 경우에도 충분히 답을 구할 수 있다. 14. 정수론 14.1 소수 판별 O( √N ) 소수 판별 알고리즘 (다른 알고리즘 보다 빠르다.)\nnum이 합성 수 이면, p x q 꼴로 나타내어지고, p는 항상 √Num 이하, q는 항상 √Num 이상 이다. 따라서, num-1 까지 순회하지 않고, √Num 까지만 순회 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 def isPrime1(n): if n \u003c= 1: return False if n == 2: return True if (n % 2) == 0: return False sqrtn = sqrt(n) for div in range(3, sprt + 1, 2): if (n % div) == 0: return False def isPrime2(n): end = int(n**(1/2)) for i in range(2, end+1): if n % i == 0: return False return True 14.2 에라토스테네스의 체 주어진 수 Num 이하의 소수들을 모두 찾아낸다. (배열로 return이 가능)\nn 까지의 수를 배열로 만든 상태에서 시작\n시간 복잡도: O(NloglogN) // 실용적인 범위에서 O(N)와 거의 비슷\n시간 보다는 메모리 사용량이 관건이다.\n1 2 3 4 5 6 7 8 9 10 def getPrimeNumbers(num): # by 에라토스테네스의 체 arr = [i for i in range(num + 1)] # 인덱싱을 수월하게 하기 위해 0부터 배열 선언 end = int(num ** (1 / 2)) for i in range(2, end + 1): if arr[i] == 0: # 이미 소수가 아님이 판별된 수는 건너뜀 continue for j in range(i * i, num + 1, i): # 자기 자신을 제외한 i의 배수는 모두 0으로 처리함. arr[j] = 0 return [i for i in arr[2:] if arr[i]] 14.5 유클리드 알고리즘 최대 공약수를 구하는 알고리즘 두 수, p, q (p \u003e q)의 공약수의 집합은 p - q와 q의 공약수 집합과 같다는 점을 이용 gcd(q, p) = gcd(p-q, q) 1 2 3 4 5 6 7 8 9 10 11 12 def gcd(a, b): # 재귀 if a % b == 0: return b return gcd(b, a % b) def gcd(a, b): # 반복문 while b \u003e 0: a, b = b, a % b return a def lcd(a, b): return a * b // gcd(a, b) 14.8 모듈러 연산 모듈러 연산: 모듈러(modulus) M에 도달하면 다시, 0으로 돌아가는 정수들을 가지고 하는 연산이다.\nEx) 시계는 25시나 42시가 없다, 1시나, 18시로 표현해야 한다. 시간(hour): 0~23 / M = 24 a % b 는 a 를 b로 나눈 나머지를 의미한다. (%: 나머지 연산자)\n두 수를 더한 뒤 나머지를 취하는 것은 미리 두 수의 나머지를 구한 뒤 더하고, 다시 나머지를 취하는 것과 같다.\n덧셈, 곱셈, 뺄셈에 적용, 나눗셈은 적용 안됨 15. 계산 기하 15.1 다각형 면적 구하기 1 2 3 4 5 6 figure.append(figure[0]) area = 0 for i in range(N): area += figure[i][0]*figure[i+1][1] - figure[i+1][0]*figure[i][1] area = area / 2 15.2 스위핑 알고리즘 평면 스위핑(Plane Wweeping), 라인 스위핑(Line Sweeping)이라고 불리는 패턴이 있습니다.\n평면 스위핑을 이용하는 알고리즘들은 수평선 혹은 수직선으로 주어진 평면을 ‘쓸고 지나가면서’ 문제를 해결합니다.\n스위핑 알고리즘이란 단어의 뜻 그대로 휩쓸고 지나가며 문제를 해결하는 방식으로,\n특정 기준에 따라 정렬한 후 순서대로 처리하는 알고리즘이다.\n보통 문제들의 경우 인풋의 범위만큼 브루트 포스를 사용하게 되면 선분일 경우 N의 시간복잡도 이다. 평면: N^2\n스위핑 알고리즘은 정렬의 시간복잡도인 NlogN이 대부분이다.\n투 포인터 투 포인터의 기본 개념 포인터: 배열이나 리스트의 특정 인덱스를 가리키는 변수입니다.\n투 포인터: 두 개의 포인터를 사용하여 배열의 양쪽 끝이나, 두 위치에서 출발하여 동시에 배열을 탐색하는 방식입니다.\nPython 예시 코드\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 n = 5 # 데이터의 개수 N m = 5 # 찾고자 하는 부분합 M data = [1,2,3,2,5] count = 0 interval_sum = 0 end = 0 for start in range(n): # start를 차례대로 증가시키며 반복 while interval_sum \u003c m and end \u003c n: # end를 가능한 만큼 이동시키기 interval_sum += data[end] end += 1 if interval_sum == m: # 부분합이 m일 때 카운트 증가 count += 1 # start 가 증가 되기 때문에 (맨 위 for문) data[start] 값 만큼 빼주어야 한다. interval_sum -= data[start] 투 포인터의 동작 원리 두 개의 포인터를 배열이나 리스트의 다른 위치에 두고, 각 포인터를 조절하면서 문제를 해결합니다. 주로 하나의 포인터가 시작점을 가리키고, 다른 포인터가 끝점 또는 그 외의 적절한 지점을 가리킵니다. 각 포인터는 문제 조건에 맞게 이동하며 탐색 범위를 좁혀 나가거나 넓혀 나갑니다. 투 포인터의 사용 사례 (1) 정렬된 배열에서 두 수의 합을 구하는 문제 (Two Sum Problem) 배열에서 두 숫자의 합이 특정 값이 되는 쌍을 찾는 문제.\n동작 방식:\n배열이 정렬되어 있는 상태에서, 하나의 포인터는 시작 지점(왼쪽 끝), 다른 포인터는 끝 지점(오른쪽 끝) 에서 시작합니다. 두 수의 합이 목표 값보다 작으면 왼쪽 포인터를 오른쪽으로 이동시킵니다(값을 크게 하기 위해). 두 수의 합이 목표 값보다 크면 오른쪽 포인터를 왼쪽으로 이동시킵니다(값을 작게 하기 위해). 두 포인터가 만날 때까지 이 과정을 반복하며, 목표 값을 찾습니다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 fun twoSum(arr: IntArray, target: Int): Pair\u003cInt, Int\u003e? { var left = 0 var right = arr.size - 1 while (left \u003c right) { val sum = arr[left] + arr[right] if (sum == target) { return Pair(left, right) // 두 수의 인덱스를 반환 } else if (sum \u003c target) { left++ // 합이 작으면 왼쪽 포인터를 오른쪽으로 } else { right-- // 합이 크면 오른쪽 포인터를 왼쪽으로 } } return null // 목표 값에 맞는 두 수를 찾지 못함 } fun main() { val arr = intArrayOf(1, 2, 3, 4, 6) val target = 6 val result = twoSum(arr, target) println(result) // 출력: (1, 3), 즉 arr[1] + arr[3] = 2 + 4 = 6 } (2) 부분 배열의 합 문제 (Subarray Sum Problem) 배열에서 연속된 부분 배열의 합이 특정 값이 되는 경우를 찾는 문제. 동작 방식: 하나의 포인터는 부분 배열의 시작점, 다른 포인터는 부분 배열의 끝점을 가리킵니다. 부분 배열의 합이 목표 값보다 작으면 끝 포인터를 오른쪽으로 이동시켜 배열을 확장하고, 합이 목표 값보다 크면 시작 포인터를 오른쪽으로 이동시켜 배열을 축소합니다. (3) 두 배열 병합 (Merging Two Sorted Arrays) 정렬된 두 배열을 하나의 배열로 합치는 문제.\n동작 방식:\n각 배열에 하나씩 포인터를 두고, 각 배열의 포인터가 가리키는 값을 비교하면서 작은 값을 결과 배열에 추가합니다. 한 배열의 모든 요소가 처리될 때까지 이 과정을 반복합니다. (4) 세 수의 합 문제 (Three Sum Problem) 배열에서 세 수의 합이 특정 값이 되는 세 숫자를 찾는 문제. 해결 방법: 첫 번째 수는 배열을 순회하면서 선택하고, 나머지 두 수의 합을 찾는 부분은 투 포인터 알고리즘을 사용하여 해결합니다. 예시 코드 (세 수의 합 문제는 중복 처리와 관련된 추가적인 로직이 필요합니다). 투 포인터의 복잡도 메모리 사용량이 적습니다. 추가적인 메모리 공간을 거의 사용하지 않으며, 대부분의 경우 상수 공간 복잡도(O(1)) 를 유지합니다.\n투 포인터(Two Pointers) 알고리즘의 시간 복잡도는 일반적으로 O(N) 입니다. 이는 대부분의 투 포인터 문제에서, 배열이나 문자열을 한 번만 순회하기 때문입니다.\n투 포인터의 시간 복잡도 분석 기본 원리: 투 포인터 알고리즘은 보통 배열의 양 끝 또는 특정 위치에서 두 개의 포인터를 설정하고, 각 포인터가 배열을 한 방향으로 이동합니다.\n두 포인터는 서로를 향해, 또는 같은 방향으로 이동하면서 배열을 한 번에 한 요소씩 처리합니다.\n포인터들이 한 번에 하나의 요소만 스캔하기 때문에 전체 배열을 한 번만 순회하게 됩니다.\n상세 분석: 배열이나 문자열의 길이를 N이라고 할 때\n각 포인터는 배열의 한 끝에서 시작해서, 배열의 다른 끝까지 한 번만 이동합니다.\n두 포인터의 움직임이 반복될 때, 한 번의 움직임은 배열의 한 요소만을 처리하므로, 각 포인터는 최대 N번의 연산을 수행하게 됩니다.\n정렬된 배열에서 두 수의 합 찾기 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 fun twoSum(arr: IntArray, target: Int): Pair\u003cInt, Int\u003e? { var left = 0 var right = arr.size - 1 while (left \u003c right) { val sum = arr[left] + arr[right] if (sum == target) { return Pair(left, right) } else if (sum \u003c target) { left++ } else { right-- } } return null } left 포인터는 시작점에서 오른쪽으로 이동하고, right 포인터는 끝점에서 왼쪽으로 이동합니다. 각 포인터가 배열을 최대 한 번씩만 이동하므로, 시간 복잡도는 O(N) 입니다. 부분 배열의 합 구하기 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 fun subarraySum(arr: IntArray, target: Int): Pair\u003cInt, Int\u003e? { var currentSum = 0 var start = 0 for (end in arr.indices) { currentSum += arr[end] while (currentSum \u003e target \u0026\u0026 start \u003c= end) { currentSum -= arr[start] start++ } if (currentSum == target) { return Pair(start, end) } } return null } end 포인터는 배열을 순차적으로 탐색하면서 오른쪽으로 이동합니다. start 포인터는 필요할 때만 오른쪽으로 이동합니다. 여기서도 start와 end 모두 배열의 각 요소를 최대 한 번씩만 방문하므로, 시간 복잡도는 O(N) 입니다. 투 포인터가 유용한 상황 정렬된 배열이나 리스트에서 특정 조건을 만족하는 쌍을 찾거나, 부분 배열을 탐색할 때.\n연속된 부분 배열 또는 서로 다른 배열을 동시에 탐색해야 하는 문제.\n배열의 양쪽 끝에서부터 범위를 줄여가며 최적의 해를 구해야 할 때.\nSlow-Fast 알고리즘 Slow-Fast 알고리즘(또는 토끼와 거북이 알고리즘, Floyd’s Tortoise and Hare Algorithm)은 연결 리스트나 배열에서 두 개의 포인터를 사용하는 기법입니다. 두 포인터를 서로 다른 속도로 움직여 문제를 해결하는 방식으로, 특히 순환이 있는지 또는 사이클을 탐지하는 문제에서 자주 사용됩니다. 시간 복잡도는 일반적으로 O(N), 공간 복잡도는 O(1) 로 매우 효율적입니다. 개념 Slow 포인터는 한 번에 한 칸씩 이동하고, Fast 포인터는 한 번에 두 칸씩 이동합니다. 두 포인터가 이동하다가 같은 지점에 도달하면, 그 구조에는 순환(사이클)이 존재한다는 것을 의미합니다. 반대로, Fast 포인터가 끝에 도달하면 순환이 없다는 것을 알 수 있습니다. 활용 사례 연결 리스트에서 사이클 탐지 중간 노드 찾기 사이클 시작 지점 찾기 대표적인 문제들 연결 리스트에서 사이클 탐지 주어진 연결 리스트가 순환(Cycle) 이 있는지 여부를 판별하는 문제입니다.\nSlow 포인터는 한 번에 한 칸씩 이동하고, Fast 포인터는 한 번에 두 칸씩 이동합니다. 두 포인터가 어느 순간 만나면 순환이 있다는 것을 의미합니다. 만약 Fast 포인터가 끝까지 도달하면 순환이 없다는 뜻입니다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class ListNode(val value: Int) { var next: ListNode? = null } fun hasCycle(head: ListNode?): Boolean { var slow = head var fast = head while (fast?.next != null) { slow = slow?.next // 한 칸 이동 fast = fast.next?.next // 두 칸 이동 if (slow == fast) { return true // 두 포인터가 만나면 순환이 있음 } } return false // fast가 끝에 도달하면 순환이 없음 } 사이클의 시작 지점 찾기 연결 리스트에 사이클이 존재하는 경우, 그 사이클의 시작 지점을 찾아내는 문제입니다.\n사이클을 감지하기 위해 Slow-Fast 알고리즘을 먼저 사용합니다. 두 포인터가 만나면, Slow 포인터를 다시 리스트의 시작 지점으로 이동시킵니다. 그 후 Slow 포인터와 Fast 포인터를 각각 한 칸씩 이동시키면, 두 포인터는 사이클의 시작 지점에서 만나게 됩니다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 fun detectCycle(head: ListNode?): ListNode? { var slow = head var fast = head // 사이클 존재 여부 확인 while (fast?.next != null) { slow = slow?.next fast = fast.next?.next if (slow == fast) { // 사이클 발견 시, slow를 시작점으로 이동 var cycleStart = head while (cycleStart != slow) { cycleStart = cycleStart?.next slow = slow?.next } return cycleStart // 사이클 시작 지점 반환 } } return null // 사이클이 없는 경우 null 반환 } 배열에서 중복 요소 찾기 배열에서 1부터 N까지의 숫자가 들어있을 때, 하나의 숫자가 중복되어 들어있는 배열이 있다고 가정합니다. 이때 중복된 숫자를 찾아내는 문제입니다.\n중복된 숫자는 사이클을 형성하는 것으로 간주할 수 있으며, 이를 찾는 방식은 연결 리스트의 사이클 탐지와 유사합니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 fun findDuplicate(nums: IntArray): Int { var slow = nums[0] var fast = nums[0] // 사이클 존재 여부 확인 do { slow = nums[slow] fast = nums[nums[fast]] } while (slow != fast) // 사이클 시작 지점 찾기 var finder = nums[0] while (finder != slow) { finder = nums[finder] slow = nums[slow] } return finder // 중복된 숫자 반환 } Reference 프로그래밍 대회에서 배우는 알고리즘 문제 해결 전략 (구종만, 인사이트) https://www.algospot.com/ ","wordCount":"1997","inLanguage":"en","image":"https://2taezeat.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E","datePublished":"2024-01-10T11:30:03Z","dateModified":"2024-01-10T11:30:03Z","author":{"@type":"Person","name":"2taezeat"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://2taezeat.github.io/posts/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EB%AC%B8%EC%A0%9C-%ED%95%B4%EA%B2%B0-%EC%A0%84%EB%9E%B5/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EB%AC%B8%EC%A0%9C-%ED%95%B4%EA%B2%B0-%EC%A0%84%EB%9E%B5-ch13-14-15.-%EC%9C%A0%EB%AA%85%ED%95%9C-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98%EB%93%A4/"},"publisher":{"@type":"Organization","name":"2taezeat, blog","logo":{"@type":"ImageObject","url":"https://2taezeat.github.io/icon/favicon.ico"}}}</script></head><body id=top><header class=header><nav class=nav><div class=logo><a href=https://2taezeat.github.io/ accesskey=h title="2taezeat blog (Alt + H)"><img src=https://2taezeat.github.io/icon/apple-touch-icon.png alt aria-label=logo height=30>2taezeat blog</a><div class=logo-switches></div></div><ul id=menu><li><a href=https://2taezeat.github.io/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://2taezeat.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://2taezeat.github.io/searchs/ title=Search><span>Search</span></a></li><li><a href=https://github.com/2taezeat title=Github><span>Github</span>&nbsp;<svg fill="none" shape-rendering="geometricPrecision" stroke="currentcolor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2.5" viewBox="0 0 24 24" height="12" width="12"><path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"/><path d="M15 3h6v6"/><path d="M10 14 21 3"/></svg></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://2taezeat.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://2taezeat.github.io/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">[알고리즘 문제 해결 전략] ch13, 14, 15. 유명한 알고리즘들</h1><div class=post-description>ch13. 수치해석, ch14. 정수론, ch15. 계산 기하</div><div class=post-meta><span title='2024-01-10 11:30:03 +0000 +0000'>2024-01-10</span>&nbsp;·&nbsp;10 min&nbsp;·&nbsp;1997 words&nbsp;·&nbsp;2taezeat</div></header><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#13-수치-해석>13. 수치 해석</a><ul><li><a href=#131-도입>13.1 도입</a></li><li><a href=#132-이분법>13.2 이분법</a></li></ul></li><li><a href=#14-정수론>14. 정수론</a><ul><li><a href=#141-소수-판별>14.1 소수 판별</a></li><li><a href=#142-에라토스테네스의-체>14.2 에라토스테네스의 체</a></li><li><a href=#145-유클리드-알고리즘>14.5 유클리드 알고리즘</a></li><li><a href=#148-모듈러-연산>14.8 모듈러 연산</a></li></ul></li><li><a href=#15-계산-기하>15. 계산 기하</a><ul><li><a href=#151-다각형-면적-구하기>15.1 다각형 면적 구하기</a></li><li><a href=#152-스위핑-알고리즘>15.2 스위핑 알고리즘</a></li></ul></li><li><a href=#투-포인터>투 포인터</a><ul><li><a href=#투-포인터의-기본-개념>투 포인터의 기본 개념</a></li><li><a href=#투-포인터의-동작-원리>투 포인터의 동작 원리</a></li><li><a href=#투-포인터의-사용-사례>투 포인터의 사용 사례</a><ul><li><a href=#1-정렬된-배열에서-두-수의-합을-구하는-문제-two-sum-problem>(1) 정렬된 배열에서 두 수의 합을 구하는 문제 (Two Sum Problem)</a></li><li><a href=#2-부분-배열의-합-문제-subarray-sum-problem>(2) 부분 배열의 합 문제 (Subarray Sum Problem)</a></li><li><a href=#3-두-배열-병합-merging-two-sorted-arrays>(3) 두 배열 병합 (Merging Two Sorted Arrays)</a></li><li><a href=#4-세-수의-합-문제-three-sum-problem>(4) 세 수의 합 문제 (Three Sum Problem)</a></li></ul></li><li><a href=#투-포인터의-복잡도>투 포인터의 복잡도</a><ul><li><a href=#투-포인터의-시간-복잡도-분석>투 포인터의 시간 복잡도 분석</a></li><li><a href=#정렬된-배열에서-두-수의-합-찾기>정렬된 배열에서 두 수의 합 찾기</a></li><li><a href=#부분-배열의-합-구하기>부분 배열의 합 구하기</a></li></ul></li><li><a href=#투-포인터가-유용한-상황>투 포인터가 유용한 상황</a></li><li><a href=#slow-fast-알고리즘>Slow-Fast 알고리즘</a><ul><li><a href=#개념>개념</a></li><li><a href=#활용-사례>활용 사례</a></li><li><a href=#대표적인-문제들>대표적인 문제들</a><ul><li><a href=#연결-리스트에서-사이클-탐지>연결 리스트에서 사이클 탐지</a></li><li><a href=#사이클의-시작-지점-찾기>사이클의 시작 지점 찾기</a></li><li><a href=#배열에서-중복-요소-찾기>배열에서 중복 요소 찾기</a></li></ul></li></ul></li></ul></li><li><a href=#reference>Reference</a></li></ul></nav></div></details></div><div class=post-content><p>유명한 알고리즘이나 자료 구조를 도구로 사용해 풀어야 하는 문제들에 대해 다룸</p><h1 id=13-수치-해석>13. 수치 해석<a hidden class=anchor aria-hidden=true href=#13-수치-해석>#</a></h1><h2 id=131-도입>13.1 도입<a hidden class=anchor aria-hidden=true href=#131-도입>#</a></h2><ul><li>수치 해석: 직접 풀기 힘든 수학 문제를 <strong>근사적</strong>으로 푸는 알고리즘과 오차의 범위, 수치적 안정성을 연구하는 전산학의 분야</li></ul><h2 id=132-이분법>13.2 이분법<a hidden class=anchor aria-hidden=true href=#132-이분법>#</a></h2><ul><li><strong>이분법</strong>: 주어진 범위 [lo, hi] 내에서 어떤 함수 f(x)의 값이 0이 되는 지점을 수치적으로 찾아내는 기법<ul><li>이분법은 <strong>이분탐색</strong>의 토대가 된다.</li></ul></li><li>정해진 횟수만큼 반복하기<ul><li>반복문을 100번 반복하면, 절대 오차가 최대 <code>lo-hi / 2 ^101</code> 이 된다.</li><li>이 오차는 10 ^ -7 보다 작다. 따라서 큰 숫자를 다루는 경우에도 충분히 답을 구할 수 있다.</li></ul></li></ul><h1 id=14-정수론>14. 정수론<a hidden class=anchor aria-hidden=true href=#14-정수론>#</a></h1><h2 id=141-소수-판별>14.1 소수 판별<a hidden class=anchor aria-hidden=true href=#141-소수-판별>#</a></h2><ul><li><p>O( <code>√N</code> ) 소수 판별 알고리즘 (다른 알고리즘 보다 빠르다.)</p><ul><li>num이 합성 수 이면, p x q 꼴로 나타내어지고, p는 항상 √Num 이하, q는 항상 √Num 이상 이다.</li><li>따라서, num-1 까지 순회하지 않고, √Num 까지만 순회</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>def</span> <span class=nf>isPrime1</span><span class=p>(</span><span class=n>n</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=n>n</span> <span class=o>&lt;=</span> <span class=mi>1</span><span class=p>:</span> <span class=k>return</span> <span class=kc>False</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=n>n</span> <span class=o>==</span> <span class=mi>2</span><span class=p>:</span> <span class=k>return</span> <span class=kc>True</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=p>(</span><span class=n>n</span> <span class=o>%</span> <span class=mi>2</span><span class=p>)</span> <span class=o>==</span> <span class=mi>0</span><span class=p>:</span> <span class=k>return</span> <span class=kc>False</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>sqrtn</span> <span class=o>=</span> <span class=n>sqrt</span><span class=p>(</span><span class=n>n</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=n>div</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=mi>3</span><span class=p>,</span> <span class=n>sprt</span> <span class=o>+</span> <span class=mi>1</span><span class=p>,</span> <span class=mi>2</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=n>n</span> <span class=o>%</span> <span class=n>div</span><span class=p>)</span> <span class=o>==</span> <span class=mi>0</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=kc>False</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>isPrime2</span><span class=p>(</span><span class=n>n</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=n>end</span> <span class=o>=</span> <span class=nb>int</span><span class=p>(</span><span class=n>n</span><span class=o>**</span><span class=p>(</span><span class=mi>1</span><span class=o>/</span><span class=mi>2</span><span class=p>))</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=n>i</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=mi>2</span><span class=p>,</span> <span class=n>end</span><span class=o>+</span><span class=mi>1</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=n>n</span> <span class=o>%</span> <span class=n>i</span> <span class=o>==</span> <span class=mi>0</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=kc>False</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=kc>True</span>
</span></span></code></pre></td></tr></table></div></div></li></ul><h2 id=142-에라토스테네스의-체>14.2 에라토스테네스의 체<a hidden class=anchor aria-hidden=true href=#142-에라토스테네스의-체>#</a></h2><ul><li><p>주어진 수 Num 이하의 소수들을 모두 <strong>찾아</strong>낸다. (배열로 return이 가능)</p></li><li><p>n 까지의 수를 배열로 만든 상태에서 시작</p></li><li><p>시간 복잡도: <code>O(NloglogN)</code> // 실용적인 범위에서 <code>O(N)</code>와 거의 비슷</p></li><li><p>시간 보다는 메모리 사용량이 관건이다.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>def</span> <span class=nf>getPrimeNumbers</span><span class=p>(</span><span class=n>num</span><span class=p>):</span> <span class=c1># by 에라토스테네스의 체</span>
</span></span><span class=line><span class=cl>    <span class=n>arr</span> <span class=o>=</span> <span class=p>[</span><span class=n>i</span> <span class=k>for</span> <span class=n>i</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=n>num</span> <span class=o>+</span> <span class=mi>1</span><span class=p>)]</span>  <span class=c1># 인덱싱을 수월하게 하기 위해 0부터 배열 선언</span>
</span></span><span class=line><span class=cl>    <span class=n>end</span> <span class=o>=</span> <span class=nb>int</span><span class=p>(</span><span class=n>num</span> <span class=o>**</span> <span class=p>(</span><span class=mi>1</span> <span class=o>/</span> <span class=mi>2</span><span class=p>))</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=n>i</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=mi>2</span><span class=p>,</span> <span class=n>end</span> <span class=o>+</span> <span class=mi>1</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=n>arr</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>==</span> <span class=mi>0</span><span class=p>:</span>  <span class=c1># 이미 소수가 아님이 판별된 수는 건너뜀</span>
</span></span><span class=line><span class=cl>            <span class=k>continue</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=n>j</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=n>i</span> <span class=o>*</span> <span class=n>i</span><span class=p>,</span> <span class=n>num</span> <span class=o>+</span> <span class=mi>1</span><span class=p>,</span> <span class=n>i</span><span class=p>):</span>  <span class=c1># 자기 자신을 제외한 i의 배수는 모두 0으로 처리함.</span>
</span></span><span class=line><span class=cl>            <span class=n>arr</span><span class=p>[</span><span class=n>j</span><span class=p>]</span> <span class=o>=</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=p>[</span><span class=n>i</span> <span class=k>for</span> <span class=n>i</span> <span class=ow>in</span> <span class=n>arr</span><span class=p>[</span><span class=mi>2</span><span class=p>:]</span> <span class=k>if</span> <span class=n>arr</span><span class=p>[</span><span class=n>i</span><span class=p>]]</span>
</span></span></code></pre></td></tr></table></div></div></li></ul><h2 id=145-유클리드-알고리즘>14.5 유클리드 알고리즘<a hidden class=anchor aria-hidden=true href=#145-유클리드-알고리즘>#</a></h2><ul><li>최대 공약수를 구하는 알고리즘</li><li>두 수, <strong>p, q (p > q)의 공약수의 집합</strong>은 <strong>p - q와 q의 공약수 집합</strong>과 같다는 점을 이용</li><li><code>gcd(q, p)</code> = <code>gcd(p-q, q)</code></li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>def</span> <span class=nf>gcd</span><span class=p>(</span><span class=n>a</span><span class=p>,</span> <span class=n>b</span><span class=p>):</span> <span class=c1># 재귀 </span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=n>a</span> <span class=o>%</span> <span class=n>b</span> <span class=o>==</span> <span class=mi>0</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>b</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>gcd</span><span class=p>(</span><span class=n>b</span><span class=p>,</span> <span class=n>a</span> <span class=o>%</span> <span class=n>b</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>gcd</span><span class=p>(</span><span class=n>a</span><span class=p>,</span> <span class=n>b</span><span class=p>):</span> <span class=c1># 반복문</span>
</span></span><span class=line><span class=cl>    <span class=k>while</span> <span class=n>b</span> <span class=o>&gt;</span> <span class=mi>0</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=n>a</span><span class=p>,</span> <span class=n>b</span> <span class=o>=</span> <span class=n>b</span><span class=p>,</span> <span class=n>a</span> <span class=o>%</span> <span class=n>b</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>a</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>lcd</span><span class=p>(</span><span class=n>a</span><span class=p>,</span> <span class=n>b</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>a</span> <span class=o>*</span> <span class=n>b</span> <span class=o>//</span> <span class=n>gcd</span><span class=p>(</span><span class=n>a</span><span class=p>,</span> <span class=n>b</span><span class=p>)</span>
</span></span></code></pre></td></tr></table></div></div><h2 id=148-모듈러-연산>14.8 모듈러 연산<a hidden class=anchor aria-hidden=true href=#148-모듈러-연산>#</a></h2><ul><li><p><strong>모듈러 연산</strong>: 모듈러(modulus) M에 도달하면 다시, 0으로 돌아가는 정수들을 가지고 하는 연산이다.</p><ul><li>Ex) 시계는 25시나 42시가 없다, 1시나, 18시로 표현해야 한다.<ul><li>시간(hour): 0~23 / M = 24</li></ul></li></ul></li><li><p><code>a % b</code> 는 <strong>a 를 b로 나눈 나머지</strong>를 의미한다. (<strong>%: 나머지 연산자</strong>)</p></li><li><p>두 수를 더한 뒤 나머지를 취하는 것은 미리 두 수의 나머지를 구한 뒤 더하고, 다시 나머지를 취하는 것과 같다.</p><ul><li><strong>덧셈, 곱셈, 뺄셈에 적용, 나눗셈은 적용 안됨</strong></li></ul></li></ul><p><img loading=lazy src=https://images.velog.io/images/qlwb7187/post/81b2833c-edc1-4d14-8602-204fe8855249/2550F94B5744419A20.png alt="모듈러 연산(Modular arithmetic)" width=680 height=auto></p><h1 id=15-계산-기하>15. 계산 기하<a hidden class=anchor aria-hidden=true href=#15-계산-기하>#</a></h1><h2 id=151-다각형-면적-구하기>15.1 다각형 면적 구하기<a hidden class=anchor aria-hidden=true href=#151-다각형-면적-구하기>#</a></h2><p><img loading=lazy src=https://velog.velcdn.com/images/chocochip/post/c577f71b-d9df-4769-a65a-d14a6d6218c5/image.png alt=img width=680 height=auto></p><p><img loading=lazy src=/images/SCR-20240930-rpat.png alt=SCR-20240930-rpat width=680 height=auto></p><p><img loading=lazy src=https://velog.velcdn.com/images/chocochip/post/d4adefd0-3fae-4c75-b0b6-2f70bf342382/image.png alt=img width=680 height=auto></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=n>figure</span><span class=o>.</span><span class=n>append</span><span class=p>(</span><span class=n>figure</span><span class=p>[</span><span class=mi>0</span><span class=p>])</span>
</span></span><span class=line><span class=cl><span class=n>area</span> <span class=o>=</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl><span class=k>for</span> <span class=n>i</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=n>N</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=n>area</span> <span class=o>+=</span> <span class=n>figure</span><span class=p>[</span><span class=n>i</span><span class=p>][</span><span class=mi>0</span><span class=p>]</span><span class=o>*</span><span class=n>figure</span><span class=p>[</span><span class=n>i</span><span class=o>+</span><span class=mi>1</span><span class=p>][</span><span class=mi>1</span><span class=p>]</span> <span class=o>-</span> <span class=n>figure</span><span class=p>[</span><span class=n>i</span><span class=o>+</span><span class=mi>1</span><span class=p>][</span><span class=mi>0</span><span class=p>]</span><span class=o>*</span><span class=n>figure</span><span class=p>[</span><span class=n>i</span><span class=p>][</span><span class=mi>1</span><span class=p>]</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl><span class=n>area</span> <span class=o>=</span> <span class=n>area</span> <span class=o>/</span> <span class=mi>2</span>
</span></span></code></pre></td></tr></table></div></div><h2 id=152-스위핑-알고리즘>15.2 스위핑 알고리즘<a hidden class=anchor aria-hidden=true href=#152-스위핑-알고리즘>#</a></h2><ul><li><p>평면 스위핑(Plane Wweeping), 라인 스위핑(Line Sweeping)이라고 불리는 패턴이 있습니다.</p></li><li><p>평면 스위핑을 이용하는 알고리즘들은 <strong>수평선 혹은 수직선으로 주어진 평면</strong>을 &lsquo;<strong>쓸고 지나가면서</strong>&rsquo; 문제를 해결합니다.</p></li><li><p>스위핑 알고리즘이란 단어의 뜻 그대로 휩쓸고 지나가며 문제를 해결하는 방식으로,</p></li><li><p>특정 기준에 따라 <strong>정렬한 후 순서대로 처리</strong>하는 알고리즘이다.</p><ul><li><p>보통 문제들의 경우 인풋의 범위만큼 브루트 포스를 사용하게 되면 선분일 경우 N의 시간복잡도 이다. 평면: N^2</p></li><li><p>스위핑 알고리즘은 정렬의 시간복잡도인 <strong>NlogN</strong>이 대부분이다.</p></li></ul></li></ul><h1 id=투-포인터>투 포인터<a hidden class=anchor aria-hidden=true href=#투-포인터>#</a></h1><h2 id=투-포인터의-기본-개념>투 포인터의 기본 개념<a hidden class=anchor aria-hidden=true href=#투-포인터의-기본-개념>#</a></h2><ul><li><p><strong>포인터</strong>: 배열이나 리스트의 특정 인덱스를 가리키는 변수입니다.</p></li><li><p><strong>투 포인터</strong>: 두 개의 포인터를 사용하여 <strong>배열의 양쪽 끝</strong>이나, <strong>두 위치</strong>에서 출발하여 <strong>동시에 배열을 탐색</strong>하는 방식입니다.</p></li><li><p>Python 예시 코드</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-py data-lang=py><span class=line><span class=cl><span class=n>n</span> <span class=o>=</span> <span class=mi>5</span> <span class=c1># 데이터의 개수 N</span>
</span></span><span class=line><span class=cl><span class=n>m</span> <span class=o>=</span> <span class=mi>5</span> <span class=c1># 찾고자 하는 부분합 M</span>
</span></span><span class=line><span class=cl><span class=n>data</span> <span class=o>=</span> <span class=p>[</span><span class=mi>1</span><span class=p>,</span><span class=mi>2</span><span class=p>,</span><span class=mi>3</span><span class=p>,</span><span class=mi>2</span><span class=p>,</span><span class=mi>5</span><span class=p>]</span>
</span></span><span class=line><span class=cl><span class=n>count</span> <span class=o>=</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl><span class=n>interval_sum</span> <span class=o>=</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl><span class=n>end</span> <span class=o>=</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>for</span> <span class=n>start</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=n>n</span><span class=p>):</span> <span class=c1># start를 차례대로 증가시키며 반복</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>while</span> <span class=n>interval_sum</span> <span class=o>&lt;</span> <span class=n>m</span> <span class=ow>and</span> <span class=n>end</span> <span class=o>&lt;</span> <span class=n>n</span><span class=p>:</span> <span class=c1># end를 가능한 만큼 이동시키기</span>
</span></span><span class=line><span class=cl>        <span class=n>interval_sum</span> <span class=o>+=</span> <span class=n>data</span><span class=p>[</span><span class=n>end</span><span class=p>]</span>
</span></span><span class=line><span class=cl>        <span class=n>end</span> <span class=o>+=</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=n>interval_sum</span> <span class=o>==</span> <span class=n>m</span><span class=p>:</span> <span class=c1># 부분합이 m일 때 카운트 증가</span>
</span></span><span class=line><span class=cl>        <span class=n>count</span> <span class=o>+=</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1># start 가 증가 되기 때문에 (맨 위 for문) data[start] 값 만큼 빼주어야 한다.</span>
</span></span><span class=line><span class=cl>    <span class=n>interval_sum</span> <span class=o>-=</span> <span class=n>data</span><span class=p>[</span><span class=n>start</span><span class=p>]</span>
</span></span></code></pre></td></tr></table></div></div></li></ul><h2 id=투-포인터의-동작-원리>투 포인터의 동작 원리<a hidden class=anchor aria-hidden=true href=#투-포인터의-동작-원리>#</a></h2><ul><li>두 개의 포인터를 배열이나 리스트의 <strong>다른 위치</strong>에 두고, 각 포인터를 <strong>조절하면서</strong> 문제를 해결합니다.</li><li>주로 하나의 포인터가 시작점을 가리키고, 다른 포인터가 끝점 또는 그 외의 적절한 지점을 가리킵니다.</li><li>각 포인터는 문제 조건에 맞게 이동하며 탐색 범위를 좁혀 나가거나 넓혀 나갑니다.</li></ul><h2 id=투-포인터의-사용-사례>투 포인터의 사용 사례<a hidden class=anchor aria-hidden=true href=#투-포인터의-사용-사례>#</a></h2><h3 id=1-정렬된-배열에서-두-수의-합을-구하는-문제-two-sum-problem>(1) 정렬된 배열에서 두 수의 합을 구하는 문제 (Two Sum Problem)<a hidden class=anchor aria-hidden=true href=#1-정렬된-배열에서-두-수의-합을-구하는-문제-two-sum-problem>#</a></h3><ul><li><p>배열에서 두 숫자의 합이 특정 값이 되는 쌍을 찾는 문제.</p></li><li><p><strong>동작 방식</strong>:</p><ol><li>배열이 <strong>정렬되어 있는 상태</strong>에서, 하나의 포인터는 <strong>시작 지점(왼쪽 끝)</strong>, 다른 포인터는 <strong>끝 지점(오른쪽 끝)</strong> 에서 시작합니다.</li><li>두 수의 합이 목표 값보다 작으면 왼쪽 포인터를 오른쪽으로 이동시킵니다(값을 크게 하기 위해).</li><li>두 수의 합이 목표 값보다 크면 오른쪽 포인터를 왼쪽으로 이동시킵니다(값을 작게 하기 위해).</li><li>두 포인터가 만날 때까지 이 과정을 반복하며, 목표 값을 찾습니다.</li></ol><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-kotlin data-lang=kotlin><span class=line><span class=cl><span class=k>fun</span> <span class=nf>twoSum</span><span class=p>(</span><span class=n>arr</span><span class=p>:</span> <span class=n>IntArray</span><span class=p>,</span> <span class=n>target</span><span class=p>:</span> <span class=n>Int</span><span class=p>):</span> <span class=n>Pair</span><span class=p>&lt;</span><span class=n>Int</span><span class=p>,</span> <span class=n>Int</span><span class=p>&gt;?</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>var</span> <span class=py>left</span> <span class=p>=</span> <span class=m>0</span>
</span></span><span class=line><span class=cl>    <span class=k>var</span> <span class=py>right</span> <span class=p>=</span> <span class=n>arr</span><span class=p>.</span><span class=n>size</span> <span class=p>-</span> <span class=m>1</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>while</span> <span class=p>(</span><span class=n>left</span> <span class=p>&lt;</span> <span class=n>right</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>val</span> <span class=py>sum</span> <span class=p>=</span> <span class=n>arr</span><span class=p>[</span><span class=n>left</span><span class=p>]</span> <span class=p>+</span> <span class=n>arr</span><span class=p>[</span><span class=n>right</span><span class=p>]</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=n>sum</span> <span class=o>==</span> <span class=n>target</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=n>Pair</span><span class=p>(</span><span class=n>left</span><span class=p>,</span> <span class=n>right</span><span class=p>)</span>  <span class=c1>// 두 수의 인덱스를 반환
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=p>}</span> <span class=k>else</span> <span class=k>if</span> <span class=p>(</span><span class=n>sum</span> <span class=p>&lt;</span> <span class=n>target</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=n>left</span><span class=o>++</span>  <span class=c1>// 합이 작으면 왼쪽 포인터를 오른쪽으로
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=n>right</span><span class=o>--</span>  <span class=c1>// 합이 크면 오른쪽 포인터를 왼쪽으로
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=k>null</span>  <span class=c1>// 목표 값에 맞는 두 수를 찾지 못함
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>fun</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>val</span> <span class=py>arr</span> <span class=p>=</span> <span class=n>intArrayOf</span><span class=p>(</span><span class=m>1</span><span class=p>,</span> <span class=m>2</span><span class=p>,</span> <span class=m>3</span><span class=p>,</span> <span class=m>4</span><span class=p>,</span> <span class=m>6</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>val</span> <span class=py>target</span> <span class=p>=</span> <span class=m>6</span>
</span></span><span class=line><span class=cl>    <span class=k>val</span> <span class=py>result</span> <span class=p>=</span> <span class=n>twoSum</span><span class=p>(</span><span class=n>arr</span><span class=p>,</span> <span class=n>target</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>println</span><span class=p>(</span><span class=n>result</span><span class=p>)</span>  <span class=c1>// 출력: (1, 3), 즉 arr[1] + arr[3] = 2 + 4 = 6
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div></li></ul><h3 id=2-부분-배열의-합-문제-subarray-sum-problem>(2) 부분 배열의 합 문제 (Subarray Sum Problem)<a hidden class=anchor aria-hidden=true href=#2-부분-배열의-합-문제-subarray-sum-problem>#</a></h3><ul><li>배열에서 <strong>연속된 부분 배열의 합</strong>이 특정 값이 되는 경우를 찾는 문제.</li><li><strong>동작 방식</strong>:<ol><li>하나의 포인터는 <strong>부분 배열의 시작점</strong>, 다른 포인터는 <strong>부분 배열의 끝점</strong>을 가리킵니다.</li><li>부분 배열의 합이 목표 값보다 작으면 끝 포인터를 오른쪽으로 이동시켜 배열을 확장하고, 합이 목표 값보다 크면 시작 포인터를 오른쪽으로 이동시켜 배열을 축소합니다.</li></ol></li></ul><h3 id=3-두-배열-병합-merging-two-sorted-arrays>(3) 두 배열 병합 (Merging Two Sorted Arrays)<a hidden class=anchor aria-hidden=true href=#3-두-배열-병합-merging-two-sorted-arrays>#</a></h3><ul><li><p><strong>정렬된 두 배열</strong>을 하나의 배열로 합치는 문제.</p></li><li><p><strong>동작 방식</strong>:</p><ol><li>각 배열에 하나씩 포인터를 두고, 각 배열의 포인터가 가리키는 값을 비교하면서 작은 값을 결과 배열에 추가합니다.</li><li>한 배열의 모든 요소가 처리될 때까지 이 과정을 반복합니다.</li></ol></li></ul><h3 id=4-세-수의-합-문제-three-sum-problem>(4) 세 수의 합 문제 (Three Sum Problem)<a hidden class=anchor aria-hidden=true href=#4-세-수의-합-문제-three-sum-problem>#</a></h3><ul><li>배열에서 <strong>세 수의 합</strong>이 특정 값이 되는 세 숫자를 찾는 문제.</li><li><strong>해결 방법</strong>:<ul><li>첫 번째 수는 배열을 순회하면서 선택하고, 나머지 두 수의 합을 찾는 부분은 <strong>투 포인터</strong> 알고리즘을 사용하여 해결합니다.</li><li>예시 코드 (세 수의 합 문제는 중복 처리와 관련된 추가적인 로직이 필요합니다).</li></ul></li></ul><h2 id=투-포인터의-복잡도>투 포인터의 복잡도<a hidden class=anchor aria-hidden=true href=#투-포인터의-복잡도>#</a></h2><ul><li><p><strong>메모리 사용량</strong>이 적습니다. 추가적인 메모리 공간을 거의 사용하지 않으며, 대부분의 경우 <strong>상수 공간 복잡도(O(1))</strong> 를 유지합니다.</p></li><li><p>투 포인터(Two Pointers) 알고리즘의 <strong>시간 복잡도</strong>는 일반적으로 <strong>O(N)</strong> 입니다. 이는 대부분의 투 포인터 문제에서, 배열이나 문자열을 한 번만 순회하기 때문입니다.</p></li></ul><h3 id=투-포인터의-시간-복잡도-분석>투 포인터의 시간 복잡도 분석<a hidden class=anchor aria-hidden=true href=#투-포인터의-시간-복잡도-분석>#</a></h3><ul><li><p><strong>기본 원리</strong>: 투 포인터 알고리즘은 보통 배열의 양 끝 또는 특정 위치에서 두 개의 포인터를 설정하고, 각 포인터가 배열을 한 방향으로 이동합니다.</p><ul><li><p>두 포인터는 서로를 향해, 또는 같은 방향으로 이동하면서 배열을 한 번에 한 요소씩 처리합니다.</p></li><li><p>포인터들이 한 번에 하나의 요소만 스캔하기 때문에 전체 배열을 <strong>한 번만 순회</strong>하게 됩니다.</p></li></ul></li><li><p><strong>상세 분석</strong>: 배열이나 문자열의 길이를 <strong>N</strong>이라고 할 때</p><ul><li><p>각 포인터는 배열의 한 끝에서 시작해서, 배열의 다른 끝까지 한 번만 이동합니다.</p></li><li><p>두 포인터의 움직임이 반복될 때, 한 번의 움직임은 배열의 한 요소만을 처리하므로, 각 포인터는 최대 <strong>N번</strong>의 연산을 수행하게 됩니다.</p></li></ul></li></ul><h3 id=정렬된-배열에서-두-수의-합-찾기>정렬된 배열에서 두 수의 합 찾기<a hidden class=anchor aria-hidden=true href=#정렬된-배열에서-두-수의-합-찾기>#</a></h3><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-kotlin data-lang=kotlin><span class=line><span class=cl><span class=k>fun</span> <span class=nf>twoSum</span><span class=p>(</span><span class=n>arr</span><span class=p>:</span> <span class=n>IntArray</span><span class=p>,</span> <span class=n>target</span><span class=p>:</span> <span class=n>Int</span><span class=p>):</span> <span class=n>Pair</span><span class=p>&lt;</span><span class=n>Int</span><span class=p>,</span> <span class=n>Int</span><span class=p>&gt;?</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>var</span> <span class=py>left</span> <span class=p>=</span> <span class=m>0</span>
</span></span><span class=line><span class=cl>    <span class=k>var</span> <span class=py>right</span> <span class=p>=</span> <span class=n>arr</span><span class=p>.</span><span class=n>size</span> <span class=p>-</span> <span class=m>1</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>while</span> <span class=p>(</span><span class=n>left</span> <span class=p>&lt;</span> <span class=n>right</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>val</span> <span class=py>sum</span> <span class=p>=</span> <span class=n>arr</span><span class=p>[</span><span class=n>left</span><span class=p>]</span> <span class=p>+</span> <span class=n>arr</span><span class=p>[</span><span class=n>right</span><span class=p>]</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=n>sum</span> <span class=o>==</span> <span class=n>target</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=n>Pair</span><span class=p>(</span><span class=n>left</span><span class=p>,</span> <span class=n>right</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span> <span class=k>else</span> <span class=k>if</span> <span class=p>(</span><span class=n>sum</span> <span class=p>&lt;</span> <span class=n>target</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=n>left</span><span class=o>++</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=n>right</span><span class=o>--</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=k>null</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><ul><li><strong>left</strong> 포인터는 시작점에서 오른쪽으로 이동하고, <strong>right</strong> 포인터는 끝점에서 왼쪽으로 이동합니다.</li><li>각 포인터가 배열을 최대 <strong>한 번</strong>씩만 이동하므로, 시간 복잡도는 <strong>O(N)</strong> 입니다.</li></ul><h3 id=부분-배열의-합-구하기>부분 배열의 합 구하기<a hidden class=anchor aria-hidden=true href=#부분-배열의-합-구하기>#</a></h3><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-kotlin data-lang=kotlin><span class=line><span class=cl><span class=k>fun</span> <span class=nf>subarraySum</span><span class=p>(</span><span class=n>arr</span><span class=p>:</span> <span class=n>IntArray</span><span class=p>,</span> <span class=n>target</span><span class=p>:</span> <span class=n>Int</span><span class=p>):</span> <span class=n>Pair</span><span class=p>&lt;</span><span class=n>Int</span><span class=p>,</span> <span class=n>Int</span><span class=p>&gt;?</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>var</span> <span class=py>currentSum</span> <span class=p>=</span> <span class=m>0</span>
</span></span><span class=line><span class=cl>    <span class=k>var</span> <span class=py>start</span> <span class=p>=</span> <span class=m>0</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=p>(</span><span class=n>end</span> <span class=k>in</span> <span class=n>arr</span><span class=p>.</span><span class=n>indices</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>currentSum</span> <span class=o>+=</span> <span class=n>arr</span><span class=p>[</span><span class=n>end</span><span class=p>]</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=k>while</span> <span class=p>(</span><span class=n>currentSum</span> <span class=p>&gt;</span> <span class=n>target</span> <span class=o>&amp;&amp;</span> <span class=n>start</span> <span class=o>&lt;=</span> <span class=n>end</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=n>currentSum</span> <span class=o>-=</span> <span class=n>arr</span><span class=p>[</span><span class=n>start</span><span class=p>]</span>
</span></span><span class=line><span class=cl>            <span class=n>start</span><span class=o>++</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=n>currentSum</span> <span class=o>==</span> <span class=n>target</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=n>Pair</span><span class=p>(</span><span class=n>start</span><span class=p>,</span> <span class=n>end</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=k>null</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><ul><li><strong>end</strong> 포인터는 배열을 순차적으로 탐색하면서 오른쪽으로 이동합니다.</li><li><strong>start</strong> 포인터는 필요할 때만 오른쪽으로 이동합니다.</li><li>여기서도 <strong>start</strong>와 <strong>end</strong> 모두 배열의 각 요소를 최대 한 번씩만 방문하므로, 시간 복잡도는 <strong>O(N)</strong> 입니다.</li></ul><h2 id=투-포인터가-유용한-상황>투 포인터가 유용한 상황<a hidden class=anchor aria-hidden=true href=#투-포인터가-유용한-상황>#</a></h2><ul><li><p><strong>정렬된 배열</strong>이나 <strong>리스트</strong>에서 특정 조건을 만족하는 쌍을 찾거나, 부분 배열을 탐색할 때.</p></li><li><p><strong>연속된 부분 배열</strong> 또는 <strong>서로 다른 배열</strong>을 동시에 탐색해야 하는 문제.</p></li><li><p>배열의 <strong>양쪽 끝에서부터</strong> 범위를 줄여가며 최적의 해를 구해야 할 때.</p></li></ul><hr><h2 id=slow-fast-알고리즘>Slow-Fast 알고리즘<a hidden class=anchor aria-hidden=true href=#slow-fast-알고리즘>#</a></h2><ul><li><strong>Slow-Fast 알고리즘</strong>(또는 <strong>토끼와 거북이 알고리즘</strong>, <strong>Floyd’s Tortoise and Hare Algorithm</strong>)은 연결 리스트나 배열에서 두 개의 포인터를 사용하는 기법입니다.</li><li>두 포인터를 서로 다른 속도로 움직여 문제를 해결하는 방식으로, 특히 <strong>순환이 있는지</strong> 또는 <strong>사이클</strong>을 탐지하는 문제에서 자주 사용됩니다.</li><li><strong>시간 복잡도</strong>는 일반적으로 <strong>O(N)</strong>, <strong>공간 복잡도</strong>는 <strong>O(1)</strong> 로 매우 효율적입니다.</li></ul><h3 id=개념>개념<a hidden class=anchor aria-hidden=true href=#개념>#</a></h3><ul><li><strong>Slow 포인터</strong>는 한 번에 한 칸씩 이동하고,</li><li><strong>Fast 포인터</strong>는 한 번에 두 칸씩 이동합니다.</li><li>두 포인터가 이동하다가 같은 지점에 도달하면, 그 구조에는 순환(사이클)이 존재한다는 것을 의미합니다. 반대로, Fast 포인터가 끝에 도달하면 순환이 없다는 것을 알 수 있습니다.</li></ul><h3 id=활용-사례>활용 사례<a hidden class=anchor aria-hidden=true href=#활용-사례>#</a></h3><ul><li><strong>연결 리스트에서 사이클 탐지</strong></li><li><strong>중간 노드 찾기</strong></li><li><strong>사이클 시작 지점 찾기</strong></li></ul><h3 id=대표적인-문제들>대표적인 문제들<a hidden class=anchor aria-hidden=true href=#대표적인-문제들>#</a></h3><h4 id=연결-리스트에서-사이클-탐지>연결 리스트에서 사이클 탐지<a hidden class=anchor aria-hidden=true href=#연결-리스트에서-사이클-탐지>#</a></h4><p>주어진 연결 리스트가 <strong>순환(Cycle)</strong> 이 있는지 여부를 판별하는 문제입니다.</p><ol><li><strong>Slow 포인터</strong>는 한 번에 한 칸씩 이동하고,</li><li><strong>Fast 포인터</strong>는 한 번에 두 칸씩 이동합니다.</li><li>두 포인터가 어느 순간 만나면 순환이 있다는 것을 의미합니다.</li><li>만약 Fast 포인터가 끝까지 도달하면 순환이 없다는 뜻입니다.</li></ol><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-kotlin data-lang=kotlin><span class=line><span class=cl><span class=k>class</span> <span class=nc>ListNode</span><span class=p>(</span><span class=k>val</span> <span class=py>value</span><span class=p>:</span> <span class=n>Int</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>var</span> <span class=py>next</span><span class=p>:</span> <span class=n>ListNode</span><span class=p>?</span> <span class=p>=</span> <span class=k>null</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>fun</span> <span class=nf>hasCycle</span><span class=p>(</span><span class=n>head</span><span class=p>:</span> <span class=n>ListNode</span><span class=p>?):</span> <span class=n>Boolean</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>var</span> <span class=py>slow</span> <span class=p>=</span> <span class=n>head</span>
</span></span><span class=line><span class=cl>    <span class=k>var</span> <span class=py>fast</span> <span class=p>=</span> <span class=n>head</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>while</span> <span class=p>(</span><span class=n>fast</span><span class=o>?.</span><span class=n>next</span> <span class=o>!=</span> <span class=k>null</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>slow</span> <span class=p>=</span> <span class=n>slow</span><span class=o>?.</span><span class=n>next</span>          <span class=c1>// 한 칸 이동
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=n>fast</span> <span class=p>=</span> <span class=n>fast</span><span class=p>.</span><span class=n>next</span><span class=o>?.</span><span class=n>next</span>     <span class=c1>// 두 칸 이동
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=n>slow</span> <span class=o>==</span> <span class=n>fast</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=k>true</span>  <span class=c1>// 두 포인터가 만나면 순환이 있음
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=k>false</span>  <span class=c1>// fast가 끝에 도달하면 순환이 없음
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><h4 id=사이클의-시작-지점-찾기>사이클의 시작 지점 찾기<a hidden class=anchor aria-hidden=true href=#사이클의-시작-지점-찾기>#</a></h4><p>연결 리스트에 사이클이 존재하는 경우, 그 <strong>사이클의 시작 지점</strong>을 찾아내는 문제입니다.</p><ol><li><strong>사이클을 감지</strong>하기 위해 Slow-Fast 알고리즘을 먼저 사용합니다.</li><li>두 포인터가 만나면, <strong>Slow 포인터</strong>를 다시 <strong>리스트의 시작 지점</strong>으로 이동시킵니다.</li><li>그 후 Slow 포인터와 Fast 포인터를 각각 한 칸씩 이동시키면, 두 포인터는 사이클의 시작 지점에서 만나게 됩니다.</li></ol><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-kotlin data-lang=kotlin><span class=line><span class=cl><span class=k>fun</span> <span class=nf>detectCycle</span><span class=p>(</span><span class=n>head</span><span class=p>:</span> <span class=n>ListNode</span><span class=p>?):</span> <span class=n>ListNode</span><span class=p>?</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>var</span> <span class=py>slow</span> <span class=p>=</span> <span class=n>head</span>
</span></span><span class=line><span class=cl>    <span class=k>var</span> <span class=py>fast</span> <span class=p>=</span> <span class=n>head</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// 사이클 존재 여부 확인
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>while</span> <span class=p>(</span><span class=n>fast</span><span class=o>?.</span><span class=n>next</span> <span class=o>!=</span> <span class=k>null</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>slow</span> <span class=p>=</span> <span class=n>slow</span><span class=o>?.</span><span class=n>next</span>
</span></span><span class=line><span class=cl>        <span class=n>fast</span> <span class=p>=</span> <span class=n>fast</span><span class=p>.</span><span class=n>next</span><span class=o>?.</span><span class=n>next</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=n>slow</span> <span class=o>==</span> <span class=n>fast</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=c1>// 사이클 발견 시, slow를 시작점으로 이동
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=k>var</span> <span class=py>cycleStart</span> <span class=p>=</span> <span class=n>head</span>
</span></span><span class=line><span class=cl>            <span class=k>while</span> <span class=p>(</span><span class=n>cycleStart</span> <span class=o>!=</span> <span class=n>slow</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=n>cycleStart</span> <span class=p>=</span> <span class=n>cycleStart</span><span class=o>?.</span><span class=n>next</span>
</span></span><span class=line><span class=cl>                <span class=n>slow</span> <span class=p>=</span> <span class=n>slow</span><span class=o>?.</span><span class=n>next</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=n>cycleStart</span>  <span class=c1>// 사이클 시작 지점 반환
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=k>null</span>  <span class=c1>// 사이클이 없는 경우 null 반환
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><h4 id=배열에서-중복-요소-찾기>배열에서 중복 요소 찾기<a hidden class=anchor aria-hidden=true href=#배열에서-중복-요소-찾기>#</a></h4><p>배열에서 <strong>1부터 N까지의 숫자</strong>가 들어있을 때, 하나의 숫자가 중복되어 들어있는 배열이 있다고 가정합니다. 이때 <strong>중복된 숫자</strong>를 찾아내는 문제입니다.</p><p>중복된 숫자는 사이클을 형성하는 것으로 간주할 수 있으며, 이를 찾는 방식은 연결 리스트의 사이클 탐지와 유사합니다.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-kotlin data-lang=kotlin><span class=line><span class=cl><span class=k>fun</span> <span class=nf>findDuplicate</span><span class=p>(</span><span class=n>nums</span><span class=p>:</span> <span class=n>IntArray</span><span class=p>):</span> <span class=n>Int</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>var</span> <span class=py>slow</span> <span class=p>=</span> <span class=n>nums</span><span class=p>[</span><span class=m>0</span><span class=p>]</span>
</span></span><span class=line><span class=cl>    <span class=k>var</span> <span class=py>fast</span> <span class=p>=</span> <span class=n>nums</span><span class=p>[</span><span class=m>0</span><span class=p>]</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// 사이클 존재 여부 확인
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>do</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>slow</span> <span class=p>=</span> <span class=n>nums</span><span class=p>[</span><span class=n>slow</span><span class=p>]</span>
</span></span><span class=line><span class=cl>        <span class=n>fast</span> <span class=p>=</span> <span class=n>nums</span><span class=p>[</span><span class=n>nums</span><span class=p>[</span><span class=n>fast</span><span class=p>]]</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span> <span class=k>while</span> <span class=p>(</span><span class=n>slow</span> <span class=o>!=</span> <span class=n>fast</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// 사이클 시작 지점 찾기
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>var</span> <span class=py>finder</span> <span class=p>=</span> <span class=n>nums</span><span class=p>[</span><span class=m>0</span><span class=p>]</span>
</span></span><span class=line><span class=cl>    <span class=k>while</span> <span class=p>(</span><span class=n>finder</span> <span class=o>!=</span> <span class=n>slow</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>finder</span> <span class=p>=</span> <span class=n>nums</span><span class=p>[</span><span class=n>finder</span><span class=p>]</span>
</span></span><span class=line><span class=cl>        <span class=n>slow</span> <span class=p>=</span> <span class=n>nums</span><span class=p>[</span><span class=n>slow</span><span class=p>]</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>finder</span>  <span class=c1>// 중복된 숫자 반환
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><h1 id=reference>Reference<a hidden class=anchor aria-hidden=true href=#reference>#</a></h1><ul><li>프로그래밍 대회에서 배우는 알고리즘 문제 해결 전략 (구종만, 인사이트)</li><li><a href=https://www.algospot.com/>https://www.algospot.com/</a></li></ul></div><footer class=post-footer><ul class=post-tags><li><a href=https://2taezeat.github.io/tags/algorithm/>Algorithm</a></li></ul><nav class=paginav><a class=prev href=https://2taezeat.github.io/posts/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EB%AC%B8%EC%A0%9C-%ED%95%B4%EA%B2%B0-%EC%A0%84%EB%9E%B5/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EB%AC%B8%EC%A0%9C-%ED%95%B4%EA%B2%B0-%EC%A0%84%EB%9E%B5-ch16.-%EA%B8%B0%EC%B4%88-%EC%9E%90%EB%A3%8C-%EA%B5%AC%EC%A1%B0/><span class=title>« Prev</span><br><span>[알고리즘 문제 해결 전략] ch16. 기초 자료 구조</span>
</a><a class=next href=https://2taezeat.github.io/posts/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EB%AC%B8%EC%A0%9C-%ED%95%B4%EA%B2%B0-%EC%A0%84%EB%9E%B5/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EB%AC%B8%EC%A0%9C-%ED%95%B4%EA%B2%B0-%EC%A0%84%EB%9E%B5-ch12.-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EC%84%A4%EA%B3%84-%ED%8C%A8%EB%9F%AC%EB%8B%A4%EC%9E%84/><span class=title>Next »</span><br><span>[알고리즘 문제 해결 전략] ch12. 알고리즘 설계 패러다임</span></a></nav><ul class=share-buttons><li><a target=_blank rel="noopener noreferrer" aria-label="share [알고리즘 문제 해결 전략] ch13, 14, 15. 유명한 알고리즘들 on x" href="https://x.com/intent/tweet/?text=%5b%ec%95%8c%ea%b3%a0%eb%a6%ac%ec%a6%98%20%eb%ac%b8%ec%a0%9c%20%ed%95%b4%ea%b2%b0%20%ec%a0%84%eb%9e%b5%5d%20ch13%2c%2014%2c%2015.%20%ec%9c%a0%eb%aa%85%ed%95%9c%20%ec%95%8c%ea%b3%a0%eb%a6%ac%ec%a6%98%eb%93%a4&amp;url=https%3a%2f%2f2taezeat.github.io%2fposts%2f%25EC%2595%258C%25EA%25B3%25A0%25EB%25A6%25AC%25EC%25A6%2598-%25EB%25AC%25B8%25EC%25A0%259C-%25ED%2595%25B4%25EA%25B2%25B0-%25EC%25A0%2584%25EB%259E%25B5%2f%25EC%2595%258C%25EA%25B3%25A0%25EB%25A6%25AC%25EC%25A6%2598-%25EB%25AC%25B8%25EC%25A0%259C-%25ED%2595%25B4%25EA%25B2%25B0-%25EC%25A0%2584%25EB%259E%25B5-ch13-14-15.-%25EC%259C%25A0%25EB%25AA%2585%25ED%2595%259C-%25EC%2595%258C%25EA%25B3%25A0%25EB%25A6%25AC%25EC%25A6%2598%25EB%2593%25A4%2f&amp;hashtags=Algorithm"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446C483.971.0 512 28.03 512 62.554zM269.951 190.75 182.567 75.216H56L207.216 272.95 63.9 436.783h61.366L235.9 310.383l96.667 126.4H456L298.367 228.367l134-153.151H371.033zM127.633 110h36.468l219.38 290.065H349.5z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share [알고리즘 문제 해결 전략] ch13, 14, 15. 유명한 알고리즘들 on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2f2taezeat.github.io%2fposts%2f%25EC%2595%258C%25EA%25B3%25A0%25EB%25A6%25AC%25EC%25A6%2598-%25EB%25AC%25B8%25EC%25A0%259C-%25ED%2595%25B4%25EA%25B2%25B0-%25EC%25A0%2584%25EB%259E%25B5%2f%25EC%2595%258C%25EA%25B3%25A0%25EB%25A6%25AC%25EC%25A6%2598-%25EB%25AC%25B8%25EC%25A0%259C-%25ED%2595%25B4%25EA%25B2%25B0-%25EC%25A0%2584%25EB%259E%25B5-ch13-14-15.-%25EC%259C%25A0%25EB%25AA%2585%25ED%2595%259C-%25EC%2595%258C%25EA%25B3%25A0%25EB%25A6%25AC%25EC%25A6%2598%25EB%2593%25A4%2f&amp;title=%5b%ec%95%8c%ea%b3%a0%eb%a6%ac%ec%a6%98%20%eb%ac%b8%ec%a0%9c%20%ed%95%b4%ea%b2%b0%20%ec%a0%84%eb%9e%b5%5d%20ch13%2c%2014%2c%2015.%20%ec%9c%a0%eb%aa%85%ed%95%9c%20%ec%95%8c%ea%b3%a0%eb%a6%ac%ec%a6%98%eb%93%a4&amp;summary=%5b%ec%95%8c%ea%b3%a0%eb%a6%ac%ec%a6%98%20%eb%ac%b8%ec%a0%9c%20%ed%95%b4%ea%b2%b0%20%ec%a0%84%eb%9e%b5%5d%20ch13%2c%2014%2c%2015.%20%ec%9c%a0%eb%aa%85%ed%95%9c%20%ec%95%8c%ea%b3%a0%eb%a6%ac%ec%a6%98%eb%93%a4&amp;source=https%3a%2f%2f2taezeat.github.io%2fposts%2f%25EC%2595%258C%25EA%25B3%25A0%25EB%25A6%25AC%25EC%25A6%2598-%25EB%25AC%25B8%25EC%25A0%259C-%25ED%2595%25B4%25EA%25B2%25B0-%25EC%25A0%2584%25EB%259E%25B5%2f%25EC%2595%258C%25EA%25B3%25A0%25EB%25A6%25AC%25EC%25A6%2598-%25EB%25AC%25B8%25EC%25A0%259C-%25ED%2595%25B4%25EA%25B2%25B0-%25EC%25A0%2584%25EB%259E%25B5-ch13-14-15.-%25EC%259C%25A0%25EB%25AA%2585%25ED%2595%259C-%25EC%2595%258C%25EA%25B3%25A0%25EB%25A6%25AC%25EC%25A6%2598%25EB%2593%25A4%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share [알고리즘 문제 해결 전략] ch13, 14, 15. 유명한 알고리즘들 on reddit" href="https://reddit.com/submit?url=https%3a%2f%2f2taezeat.github.io%2fposts%2f%25EC%2595%258C%25EA%25B3%25A0%25EB%25A6%25AC%25EC%25A6%2598-%25EB%25AC%25B8%25EC%25A0%259C-%25ED%2595%25B4%25EA%25B2%25B0-%25EC%25A0%2584%25EB%259E%25B5%2f%25EC%2595%258C%25EA%25B3%25A0%25EB%25A6%25AC%25EC%25A6%2598-%25EB%25AC%25B8%25EC%25A0%259C-%25ED%2595%25B4%25EA%25B2%25B0-%25EC%25A0%2584%25EB%259E%25B5-ch13-14-15.-%25EC%259C%25A0%25EB%25AA%2585%25ED%2595%259C-%25EC%2595%258C%25EA%25B3%25A0%25EB%25A6%25AC%25EC%25A6%2598%25EB%2593%25A4%2f&title=%5b%ec%95%8c%ea%b3%a0%eb%a6%ac%ec%a6%98%20%eb%ac%b8%ec%a0%9c%20%ed%95%b4%ea%b2%b0%20%ec%a0%84%eb%9e%b5%5d%20ch13%2c%2014%2c%2015.%20%ec%9c%a0%eb%aa%85%ed%95%9c%20%ec%95%8c%ea%b3%a0%eb%a6%ac%ec%a6%98%eb%93%a4"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share [알고리즘 문제 해결 전략] ch13, 14, 15. 유명한 알고리즘들 on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2f2taezeat.github.io%2fposts%2f%25EC%2595%258C%25EA%25B3%25A0%25EB%25A6%25AC%25EC%25A6%2598-%25EB%25AC%25B8%25EC%25A0%259C-%25ED%2595%25B4%25EA%25B2%25B0-%25EC%25A0%2584%25EB%259E%25B5%2f%25EC%2595%258C%25EA%25B3%25A0%25EB%25A6%25AC%25EC%25A6%2598-%25EB%25AC%25B8%25EC%25A0%259C-%25ED%2595%25B4%25EA%25B2%25B0-%25EC%25A0%2584%25EB%259E%25B5-ch13-14-15.-%25EC%259C%25A0%25EB%25AA%2585%25ED%2595%259C-%25EC%2595%258C%25EA%25B3%25A0%25EB%25A6%25AC%25EC%25A6%2598%25EB%2593%25A4%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share [알고리즘 문제 해결 전략] ch13, 14, 15. 유명한 알고리즘들 on whatsapp" href="https://api.whatsapp.com/send?text=%5b%ec%95%8c%ea%b3%a0%eb%a6%ac%ec%a6%98%20%eb%ac%b8%ec%a0%9c%20%ed%95%b4%ea%b2%b0%20%ec%a0%84%eb%9e%b5%5d%20ch13%2c%2014%2c%2015.%20%ec%9c%a0%eb%aa%85%ed%95%9c%20%ec%95%8c%ea%b3%a0%eb%a6%ac%ec%a6%98%eb%93%a4%20-%20https%3a%2f%2f2taezeat.github.io%2fposts%2f%25EC%2595%258C%25EA%25B3%25A0%25EB%25A6%25AC%25EC%25A6%2598-%25EB%25AC%25B8%25EC%25A0%259C-%25ED%2595%25B4%25EA%25B2%25B0-%25EC%25A0%2584%25EB%259E%25B5%2f%25EC%2595%258C%25EA%25B3%25A0%25EB%25A6%25AC%25EC%25A6%2598-%25EB%25AC%25B8%25EC%25A0%259C-%25ED%2595%25B4%25EA%25B2%25B0-%25EC%25A0%2584%25EB%259E%25B5-ch13-14-15.-%25EC%259C%25A0%25EB%25AA%2585%25ED%2595%259C-%25EC%2595%258C%25EA%25B3%25A0%25EB%25A6%25AC%25EC%25A6%2598%25EB%2593%25A4%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share [알고리즘 문제 해결 전략] ch13, 14, 15. 유명한 알고리즘들 on telegram" href="https://telegram.me/share/url?text=%5b%ec%95%8c%ea%b3%a0%eb%a6%ac%ec%a6%98%20%eb%ac%b8%ec%a0%9c%20%ed%95%b4%ea%b2%b0%20%ec%a0%84%eb%9e%b5%5d%20ch13%2c%2014%2c%2015.%20%ec%9c%a0%eb%aa%85%ed%95%9c%20%ec%95%8c%ea%b3%a0%eb%a6%ac%ec%a6%98%eb%93%a4&amp;url=https%3a%2f%2f2taezeat.github.io%2fposts%2f%25EC%2595%258C%25EA%25B3%25A0%25EB%25A6%25AC%25EC%25A6%2598-%25EB%25AC%25B8%25EC%25A0%259C-%25ED%2595%25B4%25EA%25B2%25B0-%25EC%25A0%2584%25EB%259E%25B5%2f%25EC%2595%258C%25EA%25B3%25A0%25EB%25A6%25AC%25EC%25A6%2598-%25EB%25AC%25B8%25EC%25A0%259C-%25ED%2595%25B4%25EA%25B2%25B0-%25EC%25A0%2584%25EB%259E%25B5-ch13-14-15.-%25EC%259C%25A0%25EB%25AA%2585%25ED%2595%259C-%25EC%2595%258C%25EA%25B3%25A0%25EB%25A6%25AC%25EC%25A6%2598%25EB%2593%25A4%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentcolor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share [알고리즘 문제 해결 전략] ch13, 14, 15. 유명한 알고리즘들 on ycombinator" href="https://news.ycombinator.com/submitlink?t=%5b%ec%95%8c%ea%b3%a0%eb%a6%ac%ec%a6%98%20%eb%ac%b8%ec%a0%9c%20%ed%95%b4%ea%b2%b0%20%ec%a0%84%eb%9e%b5%5d%20ch13%2c%2014%2c%2015.%20%ec%9c%a0%eb%aa%85%ed%95%9c%20%ec%95%8c%ea%b3%a0%eb%a6%ac%ec%a6%98%eb%93%a4&u=https%3a%2f%2f2taezeat.github.io%2fposts%2f%25EC%2595%258C%25EA%25B3%25A0%25EB%25A6%25AC%25EC%25A6%2598-%25EB%25AC%25B8%25EC%25A0%259C-%25ED%2595%25B4%25EA%25B2%25B0-%25EC%25A0%2584%25EB%259E%25B5%2f%25EC%2595%258C%25EA%25B3%25A0%25EB%25A6%25AC%25EC%25A6%2598-%25EB%25AC%25B8%25EC%25A0%259C-%25ED%2595%25B4%25EA%25B2%25B0-%25EC%25A0%2584%25EB%259E%25B5-ch13-14-15.-%25EC%259C%25A0%25EB%25AA%2585%25ED%2595%259C-%25EC%2595%258C%25EA%25B3%25A0%25EB%25A6%25AC%25EC%25A6%2598%25EB%2593%25A4%2f"><svg width="30" height="30" viewBox="0 0 512 512" fill="currentcolor" xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"><path d="M449.446.0C483.971.0 512 28.03 512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446zM183.8767 87.9921h-62.034L230.6673 292.4508V424.0079h50.6655V292.4508L390.1575 87.9921H328.1233L256 238.2489z"/></svg></a></li></ul></footer><script src=https://utteranc.es/client.js repo=2taezeat/blog_comment issue-term=pathname label=comment theme=github-light crossorigin=anonymous async></script></article></main><footer class=footer><span>&copy; 2024 <a href=https://2taezeat.github.io/>2taezeat, blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>