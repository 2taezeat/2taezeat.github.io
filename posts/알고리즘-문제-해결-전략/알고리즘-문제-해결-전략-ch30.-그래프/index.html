<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>[알고리즘 문제 해결 전략] ch30. 그래프 | 2taezeat, blog</title>
<meta name=keywords content="Algorithm"><meta name=description content="ch30. 최단 경로 알고리즘)"><meta name=author content="2taezeat"><link rel=canonical href=https://2taezeat.github.io/posts/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EB%AC%B8%EC%A0%9C-%ED%95%B4%EA%B2%B0-%EC%A0%84%EB%9E%B5/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EB%AC%B8%EC%A0%9C-%ED%95%B4%EA%B2%B0-%EC%A0%84%EB%9E%B5-ch30.-%EA%B7%B8%EB%9E%98%ED%94%84/><meta name=google-site-verification content="YaEERzgrvu-ZwPg7gswZdTzRMufkHw3uIH7i8hVal1c"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.ea60659c93fb4b6c01b6d070d5c41d96e09523812e590b1978e305c09ca02c83.css integrity="sha256-6mBlnJP7S2wBttBw1cQdluCVI4EuWQsZeOMFwJygLIM=" rel="preload stylesheet" as=style><link rel=icon href=https://2taezeat.github.io/icon/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://2taezeat.github.io/icon/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://2taezeat.github.io/icon/favicon-32x32.png><link rel=apple-touch-icon href=https://2taezeat.github.io/icon/apple-touch-icon.png><link rel=mask-icon href=https://2taezeat.github.io/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://2taezeat.github.io/posts/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EB%AC%B8%EC%A0%9C-%ED%95%B4%EA%B2%B0-%EC%A0%84%EB%9E%B5/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EB%AC%B8%EC%A0%9C-%ED%95%B4%EA%B2%B0-%EC%A0%84%EB%9E%B5-ch30.-%EA%B7%B8%EB%9E%98%ED%94%84/><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><meta property="og:title" content="[알고리즘 문제 해결 전략] ch30. 그래프"><meta property="og:description" content="ch30. 최단 경로 알고리즘)"><meta property="og:type" content="article"><meta property="og:url" content="https://2taezeat.github.io/posts/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EB%AC%B8%EC%A0%9C-%ED%95%B4%EA%B2%B0-%EC%A0%84%EB%9E%B5/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EB%AC%B8%EC%A0%9C-%ED%95%B4%EA%B2%B0-%EC%A0%84%EB%9E%B5-ch30.-%EA%B7%B8%EB%9E%98%ED%94%84/"><meta property="og:image" content="https://2taezeat.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-01-25T11:30:03+00:00"><meta property="article:modified_time" content="2024-01-25T11:30:03+00:00"><meta property="og:site_name" content="2taezeat, blog"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://2taezeat.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="[알고리즘 문제 해결 전략] ch30. 그래프"><meta name=twitter:description content="ch30. 최단 경로 알고리즘)"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://2taezeat.github.io/posts/"},{"@type":"ListItem","position":2,"name":"[알고리즘 문제 해결 전략] ch30. 그래프","item":"https://2taezeat.github.io/posts/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EB%AC%B8%EC%A0%9C-%ED%95%B4%EA%B2%B0-%EC%A0%84%EB%9E%B5/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EB%AC%B8%EC%A0%9C-%ED%95%B4%EA%B2%B0-%EC%A0%84%EB%9E%B5-ch30.-%EA%B7%B8%EB%9E%98%ED%94%84/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"[알고리즘 문제 해결 전략] ch30. 그래프","name":"[알고리즘 문제 해결 전략] ch30. 그래프","description":"ch30. 최단 경로 알고리즘)","keywords":["Algorithm"],"articleBody":"30. 최단 경로 알고리즘 30.1 도입 최단 경로 문제(shortest path problem)은 주어진 그래프에서 주어진 두 정점을 연결하는 가장 짧은 경로의 길이를 찾는 문제 가중치가 없는 그래프(가중치가 모두 1인)에 대한 최단 경로는 BFS로 찾을 수 있다. ‘최단 경로를 구성하는 정점들의 목록’을 구해 주는 것이 아니라 최단 경로의 길이를 찾아 줄 뿐이다. 실제 경로를 계산하기 위해서는 BFS에서 그랬듯이 탐색 과정에서 별도의 정보를 저장하고, 이것으로 실제 경로를 찾아내는 과정을 구현해야 한다. 다양한 그래프의 종류와 특성에 따라 최적화된 많은 최단 경로 알고리즘이 존재한다. 30.1.1 음수 간선의 중요성 음수 가중치를 갖는 간선(음수 간선) 이 있는지의 여부가 중요\n당연하지만, 음수 간선을 지나가면 전체 경로의 길이가 짧아 진다.\n가중치의 합이 음수인 사이클(음수 사이클) 이 등장할 수 있다.\n음수 사이클이 있는 경우 최단 경로 문제는 제대로 정의되지 않는다.\n음수 사이클이 있는 그래프에서는 어떤 최단 경로 알고리즘도 최단 경로를 정확하게 찾을 수 없다.\n알고리즘에 따라 음수 사이클이 있다는 것을 확인할 수 있다 (벨만-포드 알고리즘)\n30.1.2 단일 시작점과 모든 쌍 알고리즘 단일 시작점 알고리즘과 모든 쌍 알고리즘 으로 나뉜다.\n모든 쌍 알고리즘의 수행 결과는 V x V 크기의 2차원 배열이 된다.\n이 배열의 각 원소는 두 정점 사이의 최단 거리를 나타낸다.\n대표적인 플로이드-워셜 알고리즘이 있다.\n30.1.3 방향 그래프와 무방향 그래프 최단 거리 알고리즘들은 모두 방향 그래프를 기준으로 동작 무방향 그래프에서 최단 경로를 찾기 위해서는 양방향 간선을 두 개의 일반 통행 간선으로 쪼개서, 방향 그래프로 만들어야 한다 음수 가중치가 있는 무방향 그래프는 음수 사이클이 생겨서 불가능하다. 30.2 다익스트라의 최단 경로 알고리즘 다익스트라 알고리즘은 단일 시작점 최단 경로 알고리즘이다. 시작 정점 s 에서 다른 모든 정점들까지의 최단 거리를 계산한다. 30.2.1 우선순위 큐를 사용하는 너비 우선 탐색 핵심: 더 늦게 발견한 정점이라도 더 먼저 방문할 수 있어야 한다.\n큐 대신 우선순위 큐를 사용해서 이 문제를 해결 우선순위 큐에 정점의 번호와 함께 지금까지 찾아낸 해당 정점까지의 최단 거리를 쌍으로 넣는다.\n우선순위 큐는 최단 거리를 기준으로 정점을 배열함으로써, 아직 방문하지 않은 정점 중 시작점으로 거리가 가장 가까운 정점을 찾는 과정을 간단히 해준다.\n각 정점까지의 최단 거리를 저장하는 1차원 배열 dist[]를 유지하며, 정점을 방문할 때 마다 인접한 정점을 모두 검사\n각 정점까지의 최단 경로가 갱신될 수 있다.\n(9, c)는 dist[c]에 갱신하는 것은 간단하지만 이때, 이미 우선순위 큐에 들어있는 정보(12, c)는 어떻게 처리할까?\n우선순위 큐 내에서 (12, c)를 찾아내 (9, ㅊ)fh qkRnsek. (12, c)를 그대로 두고, (9, c)를 추가한 뒤, 나중에 큐에서 (12, c)가 꺼내지면 무시한다. 보통 2번의 방법을 많이 사용한다. 1번은 우선순위 큐에서 지원하지 않을 뿐더러 직접 구현하기 복잡하다..\n2번의 방법을 사용한다면, (12, c)를 무시해야 하는지 어떻게 알 수 있을까?\ndist[u]와 cost를 비교 dist[u] \u003c cost라면, u까지 오는 cost보다 짧은 경로가 이미 발견됐다는 의미임으로 (cost, u) 쌍은 무시하면 된다. -\u003e continue 문 다익스트라 알고리즘이 계산한 dist[] 1차원 배열에는 각 정점까지의 최단 거리가 들어가 있다.\nBFS 스패닝 트리와 마찬가지로, 이 트리의 루트에서 각 정점까지로 가는 경로는 원래 그래프에서의 최단 경로가 된다.\n모든 간선의 가중치가 0 이상일때, 다익스트라 알고리즘이 정당하다.\n음수 간선이 있는 그래프는 정답을 계산 못함 30.2.2 실제 구현 (python 코드) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 from heapq import * n, m = map(int, input().split()) INF = int(1e9) start = int(input()) graph = [[] for i in range(n)] distance = [float('inf') for _ in range(n)] for _ in range(m): a, b, c = map(int, input().split()) graph[a].append((b, c)) def dijkstra(startNode): q = [] heappush(q, (0, startNode)) distance[startNode] = 0 while q: # 큐가 비어 있지 않다면 curCost, node = heappop(q) if distance[node] \u003c curCost: # 만약 지금 꺼낸 것보다 더 짧은 경로를 알고 있다면 지금 꺼낸 것을 무시 continue for nxt, weight in graph[node]: nCost = curCost + weight if nCost \u003c distance[nxt]: # 더 짧은 경로를 발견하면, dist를 갱신하고 우선수위 큐에 넣는다. distance[nxt] = nCost heappush(q, (nCost, nxt)) 30.2.3 다익스트라 시간 복잡도 수행 시간은 크게 두 부분\n강 정점마다 인접한 간선들을 모두 검사하는 작업: O(E) 우선순위 큐에 원소를 넣고 삭제하는 작업: O(ElgE) 우선순위 큐에 최대 크기는 O(V)\n그러나 dist[]를 갱신할 때마다 원소를 우선순위 큐에 넣기 때문에 그보다 많은 원소들이 들어갈 수 있다. 최악의 경우, 그래프의 모든 간선이 검사될 때마다 dist[]가 갱신되고, 우선순위 큐에 정점의 번호가 추가되는 것 추가는 각 간선마다 최대 한번 일어나기 때문에, 추가되는 원소의 수는 최대 O(E)\n추가 삭제에 O(lgE)의 시간이 걸림 추가 삭제 전체 시간 복잡도: O(ElgE) 따라서, 1, 2번을 더하면 O(ElgE)d가 된다\n대게 E는 V^2보다 작기 때문에, O(lgE) === O(lgV) 따라서, 최종 시간복잡도는 O(ElgV) 가 된다. 30.2.4 실제 경로 찾기 다익스트라는 최단 거리만을 계산할 뿐, 실제 경로를 찾으려면, 그래프를 탐색하는 과정에서 스패닝 트리를 계산한 후, 스패닝 트리를 거슬러 올라겨며 경로를 찾는 함수를 작성해야 한다. 30.2.5 O(VlgV)에 다익스트라 구현하기 중복 원소를 우선순위 큐에 넣지 않도록 수정하면 O(VlgV) 에 동작하도록 구현할 수 있다. 그러나 실제로는 이런 식의 코드를 작성하지 않는다. 피보나치 힙이나, 이진 검색 트리를 이용해 우선순위 큐를 작성해야 하는데, 이 같은 자료 구조들은 시간복잡도를 줄여 주지만, 구현이 복잡하거나 실제로 작성해서 속도를 측정하면 더 느린 경우가 많기 때문이다. 30.2.6 우선순위 큐를 사용하지 않는 다익스트라의 구현 정점의 수가 작거나 간선의 수가 매우 많은 경우 우선순위 큐를 사용하지 않고 구현하는 방식이 빠른 경우가 있다. 다음 방문 정점을 큐에 보관하는 대신 매번 반복문을 이용해 방문하지 않는 정점 중 dist[]가 가장 작은 값을 찾는다. 방문해야 할 정점들의 목록을 저장하는 큐가 따로 없기 때문에, 각 정점을 방문했는지 여부는 별도의 visited[]를 통해 추적 이 경우 시간 복잡도: O(V^2 + E) 30.3, 30.4 신호 라우팅, ROUTING, 난이도: 하 간선 가중치의 합이 아니라 곱으로 정의된 문제\n0이 아니라 1.0으로 초기화하면 된다.\nlog는 순증가 함수\n30.5, 30.6 소방차, FIRETRUCKS, 난이도: 중 각 불난 위치에서 다익스트라, 각 소방서까지 거리 계산 각 소방서마다 다익스트라 실행, 각 불난 위치까지의 거리 계산 플로이드 알고리즘 사용해서 모든 쌍 거리 계산 3개 다 너무 시간이 오래 걸림 해법 각 소방서에서 다로 시작할 필요 없이 모든 소방서에서 동시에 다익스트라 수행하게 하자 가상의 시작점을 추가한뒤 이 시작점에서 다른 모든 소방서로 가중치 0인 간선을 연결 이 시작점에서 다익스트라 수행하면 모든 위치에 대해 가상의 소방서로 부터 최단 거리를 얻을 수 있다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 def dijkstra(start): q = [] heappush(q, (0, start)) distance[start] = 0 while q: cost, node = heappop(q) if distance[node] \u003c cost: continue for (nxt, weight) in graph[node]: nxtCost = cost + weight if (nxtCost \u003c distance[nxt]): distance[nxt] = nxtCost heappush(q, (nxtCost, nxt)) INF = float('inf') for _ in range(int(input())): v, e, n, m = map(int, input().split()) distance = [INF for _ in range(v + 1)] graph = [[] for _ in range(v + 1)] for _ in range(e): a, b, w = map(int, input().split()) graph[a].append((b, w)) graph[b].append((a, w)) fires = list(map(int, input().split())) starts = list(map(int, input().split())) for i in starts: graph[0].append((i, 0)) dijkstra(0) answer = 0 for i in fires: answer += distance[i] print(answer) 30.9 벨만-포드 최단 경로 알고리즘 다익스트라와 같은 단일 시작점 최단 경로 알고리즘이지만, 음수 간선이 있어도 최단 경로를 찾을 수 있다. 그래프에 음수 사이클이 있어서 최단 거리가 제대로 정의되지 않을 경우, 이것에 대해 알려줌 시작점에서 각 정점까지 가는 최단 거리의 상한을 적당히 예측한 뒤, 예측 값과 실제 최단 거리 사이의 오차를 반복적으로 줄여가는 방식으로 동작 BFS 기반으로 한 번에 하나씩 최단 거리를 확정해 나가는 다익스트라와 매우 다름 각 정점까지의 최단 거리의 상한을 담은 upper[] 1차원 배열을 유지 이 값은 알고리즘이 진행됨에 따라 점점 줄어들고, 종료될 때는 실제 최단 거리를 담게 된다. 30.9.1 벨만-포드 동작 과정 upper[start] = 0으로 초기화, 나머지 원소들은 INF로 초기화 최단 거리의 특성을 이용 dist[v] \u003c= dist[u] + w(u, v) 이 속성을 이용하면 upper 값을 실제 최단 거리에 가깝게 보정 가능 upper[v]를 감소하는 작업을 (u, v)를 따라 완화(relax) 한다고 말한다. 완화가 성공할때마다, upper는 줄어들고, 최단 거리에 가깝게 된다. 30.9.2 종료 조건과 정당성의 증명 upper[u] = dist[u]가 될 수 있나? 모든 간선에 대해 완화를 시도하는 작업을 x번 반복하면 x개 이하의 간선을 사용하는 최단 경로들은 전부 찾을 수 있다 모든 간선이 전부 완화가 실패할 때까지 반복하면 모든 최단 경로를 찾을 수 있다 몇 번 완화를 반복해야 하는가? 최단 경로가 한 정점을 두 번 지나는 일은 없기때문에, 최단 경로가 포함하는 간선 수의 상한은 쉽게 알 수 있다. 최단 경로는 최대 V개의 정점과 V-1 개의 간선을 가질 수 있다. 따라서, 완화는 전체 V-1번 이면 된다. 30.9.3 음수 사이클의 판정 음수 사이클이 있으면 최단 거리 문제가 제대로 정의 되지 않는다.\n물론, 시잣점에서 음수 사이클로 가는 경로가 아예 없으면 상관 없다. 벨만-포드는 음수 사이클의 존재 여부를 판정할 수 있다.\n의미 없는 값을 반환하는 대신 음수 사이클이 존재한다는 오류를 반환할 수 있다. 음수 사이클이 존재 여부를 판정하려면 V-1 번 완화가 아니라, V번 완화를 시도하면 된다.\n그래프에 음수 사이클이 없다면 V-1번으로 모든 최단 거리를 찾을 수 있기 때문에, 마지막 반복의 완화는 전부 실패하게 된다.\n음수 사이클이 있으면 V번째 반복에서도 항상 완화가 한 번은 성공한다.\n30.9.4 실제 구현 (python 코드) 마지막 반복에서 완화가 성공하면(음수 사이클 존재) 텅 빈 배열을 반환 수행 시간은 모든 간선을 검사하는 중첩 반복문에 의 해 지배 가장 바깥의 for문은 V번 안의 두 for문은 모든 간선을 순회하므로 E번 수행 따라서, 전체 시간 복잡도는 O(VE) 이다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 V, E = map(int, input().split()) INF = float('inf') graph = [] upper = [INF] * (V) for i in range(E): s, e, w = map(int, input().split()) graph.append((s, e, w)) mCycle = False def bellmanFord(): global mCycle upper[0] = 0 for i in range(V - 1): # V-1 번 반복 updated = False for s, e, w in graph: if (upper[s] != INF) and (upper[e] \u003e upper[s] + w): upper[e] = upper[s] + w updated = True if not updated: # 모든 간선에 대해 완화가 실패했을 경우 V-1번 돌 필요 없이 곧장 종료 break for s, e, w in graph: # 음수 사이클 판정 if (upper[s] != INF) and (upper[e] \u003e upper[s] + w): mCycle = True if not mCycle: for i in range(1, V): if upper[i] != INF: print(upper[i]) else: print(-1) else: print(-1) 30.9.5 경로 계산하기 벨만-포드를 수행하는 과정에서 각 정점을 마지막으로 완화시킨 간선들을 모으면 스패닝 트리를 얻을 수 있다. 이 정점들은 항상 최단 경로 위에 있기 때문에, 각 정점에서부터 스패닝 트리의 루트인 시작점까지 거슬러 올라가는 경로는 항상 시작점에서 해단 경로까지의 최단 경로이다. BFS와 다익스트라와 같은 방식으로 실제 경로(정점의 목록)을 계산할 수 있다. 30.9.6 빠지기 쉬운 함정 u로 가는 경로가 존재하는지 확인하기 위해서는 적당히 큰 값 M에 대해 upper[u] \u003c INF - M 인지를 확인해야 한다.\n30.10, 30.11 시간여행, TIMETRIP, 난이도: 중 최단 경로 구하기 간과하기 쉬운 부분은 그래프에 음수 사이클이 존재한다고 해서, 가중치가 음의 무한대인 경로가 항상 존재하지는 않는다 음수 사이클을 발견했을 때 시작점에서 이 사이클로 왔다가 다시 종착점으로 가는 경로가 있는지 확인해야 한다. reachable[][]: 모든 정점의 쌍에 대해 한 정점에서 다른 정점으로 가는 경로의 존재 여부를 저장 최장 경로 구하기 주어진 그래프의 가중치의 부호를 모두 바꾼 다음 최단 경로를 찾으면 된다. 이 문제는 일반적으로 이야기하는 최장 경로 문제와는 다르다 이 문제와 달리 최장 경로 문제에서는 사이클을 포함하지 않는 단순 경로를 찾기 요구한다. 실제로 임의의 문제에서 단순 최장 경로를 찾는 문제는 NP-Complete 문제이다 30.12 플로이드의 모든 쌍 최단 거리 알고리즘 다익스트라, 벨만-포드는 one start node에서 다른 모든 정점까지의 거리를 구해준다. 물론, 각 정점을 시작점으로 다익스트라를 반복해도 모든 정점 쌍 최단 거리를 구할 수 있다. 플로이드는 모든 정점 쌍에 대해 둘 사이의 최단 거리를 구해준다. 2차원 배열 dist[]은 모든 정점 쌍의 최단 거리를 저장 30.12.1 정점의 경유점 경유점: 경로가 거쳐가는 정점들 정점 집합 S에 포함된 정점들을 경유점으로 사용해 u -\u003e v로 가는 최단 경로를 알고 있다고 할때, x 정점은 최단 경로를 경유하거나 경유하지 않는다. 경로가 x를 경유하지 않는다: 이 경로는 S - {x}에 포함된 정점들만을 경유점으로 사용 경로가 x를 경유한다: u-\u003ex 가는 구간과 x-\u003ev로 가는 구간으로 나눌 수 있다. 30.12.2 플로이드 알고리즘의 프로토타입 앞의 점화식을 고치면 모든 쌍에 대한 최단 거리 문제를 동적 계획법으로 풀 수 있다.\nC k의 모든 값은 C k-1에만 의존하기 때문에, 동적 계획법을 이용하면 쉽게 풀 수 있다.\n두 정점 사이의 간선이 없는 경우 아주 큰 값을 넣어 두면, 따로 처리하지 않아도 두 정점 사이의 경로가 존재하지 않은 것을 알 수 있다.\n자기 자신으로 가는 간선은 따로 없더라도 최단 거리는 항상 0이기 때문에 C[0][u][u]는 0으로 초기화\n전체 시간복잡도는 3중 for문이 지배, O(V^3)\n30.12.3 메모리 사용량 줄이기 구현이 간단, 반복문 내부가 단순해서 빠르게 수행된다.\n시간보다는 메모리 사용량이 문제가 된다.\n슬라이딩 윈도우 기법을 사용하면 사용하는 배열의 크기를 O(V^2) 로 줄일 수 있다.\nC k의 답은 C k-1만 있으면 계산할 수 있다.\nC k-2, C k-3 등은 가지고 있을 필요가 없다. C k(u, v)의 값을 C[k%2][u][v]에 저장한다. 별도의 배열을 사용하지 않고, 그래프의 가중치를 담는 인접 행렬 위에서 곧장 점화식의 결과를 계산\nC k-1 (u, k): 시작점 부터 k-1번 정점까지를 경유점으로 이용해 u -\u003e k로 가는 최단 경로의 길이\nC k (u, k): 시작점 부터 k번 정점까지를 경유점으로 이용해 u -\u003e k로 가는 최단 경로의 길이\n출발점이나 도착점이 k일 때, 사용 가능한 경유점의 목록에 k가 추가되는 것은 의미가 없다.\n‘A를 들러 B에 가는 최단 경로’와 ‘A와 B를 들러 B로 가는 최단 경로’는 같다. Ck-1와 Ck의 값을 구분하지 않고 섞어서 써도 된다.\nC[k%2]와 C[(k-1)%2]를 구분할 필요가 없으며, 이들을 한 개의 2차원 배열에 섞어 써도 된다.\n시간 복잡도: O(V^3), 그대로\n공간 복잡도: O(V^2) 으로 줌\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 INF = float('inf') graph = [[INF] * N for _ in range(N)] for a in range(N): # 자기 자신에서 자기 자신으로 가는 비용 0으로 초기화 for b in range(N): if a == b: graph[a][b] = 0 for _ in range(M): # 각 간선에 대한 정보를 입력 받아, 그 값으로 초기화 a, b, c = map(int, input().split()) graph[a][b] = c for k in range(N): # 점화식에 따라 플로이드 워셜 알고리즘을 수행 for a in range(N): for b in range(N): graph[a][b] = min(graph[a][b], graph[a][k] + graph[k][b]) 30.12.4 실제 경로 계산하기 마지막으로 graph[u][v]을 갱신했을 때 사용한 k의 값을 저장 (따로 배열로 변수화 해서 저장) 이 정점의 번호를 w라고 하자 최단 경로가 w를 지난다는 의미 따라서, 재귀 호출을 이용해 u-\u003ew로 가는 최단 경로를 찾고, w-\u003e v로 가는 최단 경로를 찾은 뒤 이 둘을 합친다. Reference 프로그래밍 대회에서 배우는 알고리즘 문제 해결 전략 (구종만, 인사이트) https://www.algospot.com/ ","wordCount":"2286","inLanguage":"en","image":"https://2taezeat.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E","datePublished":"2024-01-25T11:30:03Z","dateModified":"2024-01-25T11:30:03Z","author":{"@type":"Person","name":"2taezeat"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://2taezeat.github.io/posts/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EB%AC%B8%EC%A0%9C-%ED%95%B4%EA%B2%B0-%EC%A0%84%EB%9E%B5/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EB%AC%B8%EC%A0%9C-%ED%95%B4%EA%B2%B0-%EC%A0%84%EB%9E%B5-ch30.-%EA%B7%B8%EB%9E%98%ED%94%84/"},"publisher":{"@type":"Organization","name":"2taezeat, blog","logo":{"@type":"ImageObject","url":"https://2taezeat.github.io/icon/favicon.ico"}}}</script></head><body id=top><header class=header><nav class=nav><div class=logo><a href=https://2taezeat.github.io/ accesskey=h title="2taezeat blog (Alt + H)"><img src=https://2taezeat.github.io/icon/apple-touch-icon.png alt aria-label=logo height=30>2taezeat blog</a><div class=logo-switches></div></div><ul id=menu><li><a href=https://2taezeat.github.io/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://2taezeat.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://2taezeat.github.io/searchs/ title=Search><span>Search</span></a></li><li><a href=https://github.com/2taezeat title=Github><span>Github</span>&nbsp;<svg fill="none" shape-rendering="geometricPrecision" stroke="currentcolor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2.5" viewBox="0 0 24 24" height="12" width="12"><path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"/><path d="M15 3h6v6"/><path d="M10 14 21 3"/></svg></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://2taezeat.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://2taezeat.github.io/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">[알고리즘 문제 해결 전략] ch30. 그래프</h1><div class=post-description>ch30. 최단 경로 알고리즘)</div><div class=post-meta><span title='2024-01-25 11:30:03 +0000 +0000'>2024-01-25</span>&nbsp;·&nbsp;11 min&nbsp;·&nbsp;2286 words&nbsp;·&nbsp;2taezeat</div></header><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#30-최단-경로-알고리즘>30. 최단 경로 알고리즘</a><ul><li><a href=#301-도입>30.1 도입</a><ul><li><a href=#3011-음수-간선의-중요성>30.1.1 음수 간선의 중요성</a></li><li><a href=#3012-단일-시작점과-모든-쌍-알고리즘>30.1.2 단일 시작점과 모든 쌍 알고리즘</a></li><li><a href=#3013-방향-그래프와-무방향-그래프>30.1.3 방향 그래프와 무방향 그래프</a></li></ul></li><li><a href=#302-다익스트라의-최단-경로-알고리즘>30.2 다익스트라의 최단 경로 알고리즘</a><ul><li><a href=#3021-우선순위-큐를-사용하는-너비-우선-탐색>30.2.1 우선순위 큐를 사용하는 너비 우선 탐색</a></li><li><a href=#3022-실제-구현-python-코드>30.2.2 실제 구현 (python 코드)</a></li><li><a href=#3023-다익스트라-시간-복잡도>30.2.3 다익스트라 시간 복잡도</a></li><li><a href=#3024-실제-경로-찾기>30.2.4 실제 경로 찾기</a></li><li><a href=#3025-ovlgv에-다익스트라-구현하기>30.2.5 O(VlgV)에 다익스트라 구현하기</a></li><li><a href=#3026-우선순위-큐를-사용하지-않는-다익스트라의-구현>30.2.6 우선순위 큐를 사용하지 않는 다익스트라의 구현</a></li></ul></li><li><a href=#303-304-신호-라우팅-routing-난이도-하>30.3, 30.4 신호 라우팅, ROUTING, 난이도: 하</a></li><li><a href=#305-306-소방차-firetrucks-난이도-중>30.5, 30.6 소방차, FIRETRUCKS, 난이도: 중</a></li><li><a href=#309-벨만-포드-최단-경로-알고리즘>30.9 벨만-포드 최단 경로 알고리즘</a><ul><li><a href=#3091-벨만-포드-동작-과정>30.9.1 벨만-포드 동작 과정</a></li><li><a href=#3092-종료-조건과-정당성의-증명>30.9.2 종료 조건과 정당성의 증명</a></li><li><a href=#3093-음수-사이클의-판정>30.9.3 음수 사이클의 판정</a></li><li><a href=#3094-실제-구현-python-코드>30.9.4 실제 구현 (python 코드)</a></li><li><a href=#3095-경로-계산하기>30.9.5 경로 계산하기</a></li><li><a href=#3096-빠지기-쉬운-함정>30.9.6 빠지기 쉬운 함정</a></li></ul></li><li><a href=#3010-3011-시간여행-timetrip-난이도-중>30.10, 30.11 시간여행, TIMETRIP, 난이도: 중</a></li><li><a href=#3012-플로이드의-모든-쌍-최단-거리-알고리즘>30.12 플로이드의 모든 쌍 최단 거리 알고리즘</a><ul><li><a href=#30121-정점의-경유점>30.12.1 정점의 경유점</a></li><li><a href=#30122-플로이드-알고리즘의-프로토타입>30.12.2 플로이드 알고리즘의 프로토타입</a></li><li><a href=#30123-메모리-사용량-줄이기>30.12.3 메모리 사용량 줄이기</a></li><li><a href=#30124-실제-경로-계산하기>30.12.4 실제 경로 계산하기</a></li></ul></li></ul></li><li><a href=#reference>Reference</a></li></ul></nav></div></details></div><div class=post-content><h1 id=30-최단-경로-알고리즘>30. 최단 경로 알고리즘<a hidden class=anchor aria-hidden=true href=#30-최단-경로-알고리즘>#</a></h1><h2 id=301-도입>30.1 도입<a hidden class=anchor aria-hidden=true href=#301-도입>#</a></h2><ul><li>최단 경로 문제(shortest path problem)은 주어진 그래프에서 주어진 두 정점을 연결하는 가장 짧은 경로의 길이를 찾는 문제</li><li>가중치가 없는 그래프(가중치가 모두 1인)에 대한 최단 경로는 BFS로 찾을 수 있다.</li><li>&lsquo;최단 경로를 구성하는 정점들의 목록&rsquo;을 구해 주는 것이 아니라 <strong>최단 경로의 길이를 찾아 줄 뿐이다.</strong></li><li>실제 경로를 계산하기 위해서는 BFS에서 그랬듯이 <strong>탐색 과정에서 별도의 정보를 저장</strong>하고, 이것으로 <strong>실제 경로</strong>를 찾아내는 과정을 구현해야 한다.</li><li>다양한 그래프의 종류와 특성에 따라 최적화된 많은 최단 경로 알고리즘이 존재한다.</li></ul><h3 id=3011-음수-간선의-중요성>30.1.1 음수 간선의 중요성<a hidden class=anchor aria-hidden=true href=#3011-음수-간선의-중요성>#</a></h3><ul><li><p><strong>음수 가중치를 갖는 간선(음수 간선)</strong> 이 있는지의 여부가 중요</p></li><li><p>당연하지만, 음수 간선을 지나가면 전체 경로의 길이가 짧아 진다.</p></li><li><p><strong>가중치의 합이 음수인 사이클(음수 사이클)</strong> 이 등장할 수 있다.</p></li><li><p><strong>음수 사이클</strong>이 있는 경우 최단 경로 문제는 제대로 <strong>정의</strong>되지 않는다.</p></li><li><p>음수 사이클이 있는 그래프에서는 어떤 최단 경로 알고리즘도 최단 경로를 정확하게 찾을 수 없다.</p></li><li><p>알고리즘에 따라 음수 사이클이 있다는 것을 확인할 수 있다 <strong>(벨만-포드 알고리즘)</strong></p></li></ul><p><img loading=lazy src=/images/before/image-20240424161423364.png alt=image-20240424161423364.png width=680 height=auto></p><h3 id=3012-단일-시작점과-모든-쌍-알고리즘>30.1.2 단일 시작점과 모든 쌍 알고리즘<a hidden class=anchor aria-hidden=true href=#3012-단일-시작점과-모든-쌍-알고리즘>#</a></h3><ul><li><p><strong>단일 시작점 알고리즘</strong>과 <strong>모든 쌍 알고리즘</strong> 으로 나뉜다.</p></li><li><p>모든 쌍 알고리즘의 수행 결과는 V x V 크기의 2차원 배열이 된다.</p><ul><li><p>이 배열의 각 원소는 두 정점 사이의 최단 거리를 나타낸다.</p></li><li><p>대표적인 플로이드-워셜 알고리즘이 있다.</p></li></ul></li></ul><h3 id=3013-방향-그래프와-무방향-그래프>30.1.3 방향 그래프와 무방향 그래프<a hidden class=anchor aria-hidden=true href=#3013-방향-그래프와-무방향-그래프>#</a></h3><ul><li>최단 거리 알고리즘들은 모두 <strong>방향 그래프</strong>를 기준으로 동작</li><li><strong>무방향 그래프</strong>에서 최단 경로를 찾기 위해서는 양방향 간선을 두 개의 일반 통행 간선으로 쪼개서, <strong>방향 그래프</strong>로 만들어야 한다<ul><li>음수 가중치가 있는 무방향 그래프는 음수 사이클이 생겨서 불가능하다.</li></ul></li></ul><p><img loading=lazy src=/images/before/image-20240424161448541.png alt=image-20240424161448541.png width=680 height=auto></p><h2 id=302-다익스트라의-최단-경로-알고리즘>30.2 다익스트라의 최단 경로 알고리즘<a hidden class=anchor aria-hidden=true href=#302-다익스트라의-최단-경로-알고리즘>#</a></h2><ul><li>다익스트라 알고리즘은 단일 시작점 최단 경로 알고리즘이다. 시작 정점 s 에서 다른 모든 정점들까지의 최단 거리를 계산한다.</li></ul><h3 id=3021-우선순위-큐를-사용하는-너비-우선-탐색>30.2.1 우선순위 큐를 사용하는 너비 우선 탐색<a hidden class=anchor aria-hidden=true href=#3021-우선순위-큐를-사용하는-너비-우선-탐색>#</a></h3><p><img loading=lazy src=/images/before/image-20240424161959094.png alt=image-20240424161959094.png width=680 height=auto></p><ul><li><p>핵심: <strong>더 늦게 발견</strong>한 정점이라도 <strong>더 먼저 방문</strong>할 수 있어야 한다.</p><ul><li>큐 대신 우선순위 큐를 사용해서 이 문제를 해결</li></ul></li><li><p>우선순위 큐에 정점의 번호와 함께 지금까지 찾아낸 해당 정점까지의 최단 거리를 쌍으로 넣는다.</p></li><li><p>우선순위 큐는 최단 거리를 기준으로 정점을 배열함으로써, 아직 방문하지 않은 정점 중 시작점으로 거리가 가장 가까운 정점을 찾는 과정을 간단히 해준다.</p></li><li><p>각 정점까지의 최단 거리를 저장하는 <strong>1차원 배열</strong> <code>dist[]</code>를 유지하며, 정점을 방문할 때 마다 인접한 정점을 모두 검사</p></li><li><p>각 정점까지의 최단 경로가 갱신될 수 있다.</p></li><li><p>(9, c)는 dist[c]에 갱신하는 것은 간단하지만 이때, 이미 우선순위 큐에 들어있는 정보(12, c)는 어떻게 처리할까?</p><ol><li>우선순위 큐 내에서 (12, c)를 찾아내 (9, ㅊ)fh qkRnsek.</li><li>(12, c)를 그대로 두고, (9, c)를 추가한 뒤, 나중에 큐에서 (12, c)가 꺼내지면 <strong>무시</strong>한다.</li></ol></li><li><p>보통 2번의 방법을 많이 사용한다. 1번은 우선순위 큐에서 지원하지 않을 뿐더러 직접 구현하기 복잡하다..</p></li><li><p>2번의 방법을 사용한다면, (12, c)를 무시해야 하는지 어떻게 알 수 있을까?</p><ul><li>dist[u]와 cost를 비교</li><li>dist[u] &lt; cost라면, u까지 오는 cost보다 짧은 경로가 이미 발견됐다는 의미임으로 (cost, u) 쌍은 무시하면 된다. -> continue 문</li></ul></li><li><p>다익스트라 알고리즘이 계산한 <code>dist[]</code> 1차원 배열에는 각 정점까지의 최단 거리가 들어가 있다.</p></li><li><p>BFS 스패닝 트리와 마찬가지로, 이 트리의 루트에서 각 정점까지로 가는 경로는 원래 그래프에서의 <strong>최단 경로</strong>가 된다.</p></li><li><p>모든 간선의 가중치가 0 이상일때, 다익스트라 알고리즘이 정당하다.</p><ul><li>음수 간선이 있는 그래프는 정답을 계산 못함</li></ul></li></ul><p><img loading=lazy src=/images/before/image-20240424161511312.png alt=image-20240424161511312.png width=680 height=auto></p><h3 id=3022-실제-구현-python-코드>30.2.2 실제 구현 (python 코드)<a hidden class=anchor aria-hidden=true href=#3022-실제-구현-python-코드>#</a></h3><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=kn>from</span> <span class=nn>heapq</span> <span class=kn>import</span> <span class=o>*</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>n</span><span class=p>,</span> <span class=n>m</span> <span class=o>=</span> <span class=nb>map</span><span class=p>(</span><span class=nb>int</span><span class=p>,</span> <span class=nb>input</span><span class=p>()</span><span class=o>.</span><span class=n>split</span><span class=p>())</span>
</span></span><span class=line><span class=cl><span class=n>INF</span> <span class=o>=</span> <span class=nb>int</span><span class=p>(</span><span class=mf>1e9</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>start</span> <span class=o>=</span> <span class=nb>int</span><span class=p>(</span><span class=nb>input</span><span class=p>())</span>
</span></span><span class=line><span class=cl><span class=n>graph</span> <span class=o>=</span> <span class=p>[[]</span> <span class=k>for</span> <span class=n>i</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=n>n</span><span class=p>)]</span>
</span></span><span class=line><span class=cl><span class=n>distance</span> <span class=o>=</span> <span class=p>[</span><span class=nb>float</span><span class=p>(</span><span class=s1>&#39;inf&#39;</span><span class=p>)</span> <span class=k>for</span> <span class=n>_</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=n>n</span><span class=p>)]</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>for</span> <span class=n>_</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=n>m</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=n>a</span><span class=p>,</span> <span class=n>b</span><span class=p>,</span> <span class=n>c</span> <span class=o>=</span> <span class=nb>map</span><span class=p>(</span><span class=nb>int</span><span class=p>,</span> <span class=nb>input</span><span class=p>()</span><span class=o>.</span><span class=n>split</span><span class=p>())</span>
</span></span><span class=line><span class=cl>    <span class=n>graph</span><span class=p>[</span><span class=n>a</span><span class=p>]</span><span class=o>.</span><span class=n>append</span><span class=p>((</span><span class=n>b</span><span class=p>,</span> <span class=n>c</span><span class=p>))</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>dijkstra</span><span class=p>(</span><span class=n>startNode</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=n>q</span> <span class=o>=</span> <span class=p>[]</span>
</span></span><span class=line><span class=cl>    <span class=n>heappush</span><span class=p>(</span><span class=n>q</span><span class=p>,</span> <span class=p>(</span><span class=mi>0</span><span class=p>,</span> <span class=n>startNode</span><span class=p>))</span>
</span></span><span class=line><span class=cl>    <span class=n>distance</span><span class=p>[</span><span class=n>startNode</span><span class=p>]</span> <span class=o>=</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>while</span> <span class=n>q</span><span class=p>:</span>  <span class=c1># 큐가 비어 있지 않다면</span>
</span></span><span class=line><span class=cl>        <span class=n>curCost</span><span class=p>,</span> <span class=n>node</span> <span class=o>=</span> <span class=n>heappop</span><span class=p>(</span><span class=n>q</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=n>distance</span><span class=p>[</span><span class=n>node</span><span class=p>]</span> <span class=o>&lt;</span> <span class=n>curCost</span><span class=p>:</span>  <span class=c1># 만약 지금 꺼낸 것보다 더 짧은 경로를 알고 있다면 지금 꺼낸 것을 무시</span>
</span></span><span class=line><span class=cl>            <span class=k>continue</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=n>nxt</span><span class=p>,</span> <span class=n>weight</span> <span class=ow>in</span> <span class=n>graph</span><span class=p>[</span><span class=n>node</span><span class=p>]:</span>
</span></span><span class=line><span class=cl>            <span class=n>nCost</span> <span class=o>=</span> <span class=n>curCost</span> <span class=o>+</span> <span class=n>weight</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=n>nCost</span> <span class=o>&lt;</span> <span class=n>distance</span><span class=p>[</span><span class=n>nxt</span><span class=p>]:</span> <span class=c1># 더 짧은 경로를 발견하면, dist를 갱신하고 우선수위 큐에 넣는다.</span>
</span></span><span class=line><span class=cl>                <span class=n>distance</span><span class=p>[</span><span class=n>nxt</span><span class=p>]</span> <span class=o>=</span> <span class=n>nCost</span>
</span></span><span class=line><span class=cl>                <span class=n>heappush</span><span class=p>(</span><span class=n>q</span><span class=p>,</span> <span class=p>(</span><span class=n>nCost</span><span class=p>,</span> <span class=n>nxt</span><span class=p>))</span>
</span></span></code></pre></td></tr></table></div></div><h3 id=3023-다익스트라-시간-복잡도>30.2.3 다익스트라 시간 복잡도<a hidden class=anchor aria-hidden=true href=#3023-다익스트라-시간-복잡도>#</a></h3><ul><li><p>수행 시간은 크게 두 부분</p><ol><li>강 정점마다 인접한 간선들을 모두 검사하는 작업: O(E)</li><li>우선순위 큐에 원소를 넣고 삭제하는 작업: O(ElgE)</li></ol></li><li><p>우선순위 큐에 최대 크기는 O(V)</p><ul><li>그러나 dist[]를 갱신할 때마다 원소를 우선순위 큐에 넣기 때문에 그보다 많은 원소들이 들어갈 수 있다.</li><li>최악의 경우, 그래프의 모든 간선이 검사될 때마다 <code>dist[]</code>가 갱신되고, 우선순위 큐에 정점의 번호가 추가되는 것</li></ul></li><li><p>추가는 각 간선마다 최대 한번 일어나기 때문에, 추가되는 원소의 수는 최대 O(E)</p><ul><li>추가 삭제에 O(lgE)의 시간이 걸림</li><li>추가 삭제 전체 시간 복잡도: O(ElgE)</li></ul></li><li><p>따라서, 1, 2번을 더하면 O(ElgE)d가 된다</p><ul><li>대게 E는 V^2보다 작기 때문에, O(lgE) === O(lgV)</li><li>따라서, 최종 시간복잡도는 <strong>O(ElgV)</strong> 가 된다.</li></ul></li></ul><h3 id=3024-실제-경로-찾기>30.2.4 실제 경로 찾기<a hidden class=anchor aria-hidden=true href=#3024-실제-경로-찾기>#</a></h3><ul><li>다익스트라는 최단 거리만을 계산할 뿐, <strong>실제 경로</strong>를 찾으려면, 그래프를 탐색하는 과정에서 스패닝 트리를 계산한 후,</li><li>스패닝 트리를 거슬러 올라겨며 경로를 찾는 함수를 작성해야 한다.</li></ul><h3 id=3025-ovlgv에-다익스트라-구현하기>30.2.5 O(VlgV)에 다익스트라 구현하기<a hidden class=anchor aria-hidden=true href=#3025-ovlgv에-다익스트라-구현하기>#</a></h3><ul><li>중복 원소를 우선순위 큐에 넣지 않도록 수정하면 <strong>O(VlgV)</strong> 에 동작하도록 구현할 수 있다.</li><li>그러나 실제로는 이런 식의 코드를 작성하지 않는다.</li><li>피보나치 힙이나, 이진 검색 트리를 이용해 우선순위 큐를 작성해야 하는데,<ul><li>이 같은 자료 구조들은 시간복잡도를 줄여 주지만, 구현이 복잡하거나 실제로 작성해서 속도를 측정하면 더 느린 경우가 많기 때문이다.</li></ul></li></ul><h3 id=3026-우선순위-큐를-사용하지-않는-다익스트라의-구현>30.2.6 우선순위 큐를 사용하지 않는 다익스트라의 구현<a hidden class=anchor aria-hidden=true href=#3026-우선순위-큐를-사용하지-않는-다익스트라의-구현>#</a></h3><ul><li>정점의 수가 작거나 간선의 수가 매우 많은 경우 우선순위 큐를 사용하지 않고 구현하는 방식이 빠른 경우가 있다.</li><li>다음 방문 정점을 큐에 보관하는 대신 매번 반복문을 이용해 방문하지 않는 정점 중 <code>dist[]</code>가 가장 작은 값을 찾는다.</li><li>방문해야 할 정점들의 목록을 저장하는 큐가 따로 없기 때문에, 각 정점을 방문했는지 여부는 별도의 <code>visited[]</code>를 통해 추적</li><li>이 경우 시간 복잡도: <strong>O(V^2 + E)</strong></li></ul><h2 id=303-304-신호-라우팅-routing-난이도-하>30.3, 30.4 신호 라우팅, ROUTING, 난이도: 하<a hidden class=anchor aria-hidden=true href=#303-304-신호-라우팅-routing-난이도-하>#</a></h2><ul><li><p>간선 가중치의 합이 아니라 곱으로 정의된 문제</p></li><li><p>0이 아니라 1.0으로 초기화하면 된다.</p></li><li><p>log는 순증가 함수</p></li></ul><h2 id=305-306-소방차-firetrucks-난이도-중>30.5, 30.6 소방차, FIRETRUCKS, 난이도: 중<a hidden class=anchor aria-hidden=true href=#305-306-소방차-firetrucks-난이도-중>#</a></h2><ul><li>각 불난 위치에서 다익스트라, 각 소방서까지 거리 계산</li><li>각 소방서마다 다익스트라 실행, 각 불난 위치까지의 거리 계산</li><li>플로이드 알고리즘 사용해서 모든 쌍 거리 계산</li><li>3개 다 너무 시간이 오래 걸림</li></ul><p><img loading=lazy src=/images/before/image-20240424161537201.png alt=image-20240424161537201.png width=680 height=auto></p><ul><li>해법<ul><li>각 소방서에서 다로 시작할 필요 없이 모든 소방서에서 동시에 다익스트라 수행하게 하자</li><li><strong>가상의 시작점</strong>을 추가한뒤 이 시작점에서 다른 모든 소방서로 가중치 0인 간선을 연결</li><li>이 시작점에서 다익스트라 수행하면 모든 위치에 대해 <strong>가상의 소방서</strong>로 부터 최단 거리를 얻을 수 있다.</li></ul></li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>def</span> <span class=nf>dijkstra</span><span class=p>(</span><span class=n>start</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=n>q</span> <span class=o>=</span> <span class=p>[]</span>
</span></span><span class=line><span class=cl>    <span class=n>heappush</span><span class=p>(</span><span class=n>q</span><span class=p>,</span> <span class=p>(</span><span class=mi>0</span><span class=p>,</span> <span class=n>start</span><span class=p>))</span>
</span></span><span class=line><span class=cl>    <span class=n>distance</span><span class=p>[</span><span class=n>start</span><span class=p>]</span> <span class=o>=</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>while</span> <span class=n>q</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=n>cost</span><span class=p>,</span> <span class=n>node</span> <span class=o>=</span> <span class=n>heappop</span><span class=p>(</span><span class=n>q</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=n>distance</span><span class=p>[</span><span class=n>node</span><span class=p>]</span> <span class=o>&lt;</span> <span class=n>cost</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=k>continue</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=p>(</span><span class=n>nxt</span><span class=p>,</span> <span class=n>weight</span><span class=p>)</span> <span class=ow>in</span> <span class=n>graph</span><span class=p>[</span><span class=n>node</span><span class=p>]:</span>
</span></span><span class=line><span class=cl>            <span class=n>nxtCost</span> <span class=o>=</span> <span class=n>cost</span> <span class=o>+</span> <span class=n>weight</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=p>(</span><span class=n>nxtCost</span> <span class=o>&lt;</span> <span class=n>distance</span><span class=p>[</span><span class=n>nxt</span><span class=p>]):</span>
</span></span><span class=line><span class=cl>                <span class=n>distance</span><span class=p>[</span><span class=n>nxt</span><span class=p>]</span> <span class=o>=</span> <span class=n>nxtCost</span>
</span></span><span class=line><span class=cl>                <span class=n>heappush</span><span class=p>(</span><span class=n>q</span><span class=p>,</span> <span class=p>(</span><span class=n>nxtCost</span><span class=p>,</span> <span class=n>nxt</span><span class=p>))</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>INF</span> <span class=o>=</span> <span class=nb>float</span><span class=p>(</span><span class=s1>&#39;inf&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=k>for</span> <span class=n>_</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=nb>int</span><span class=p>(</span><span class=nb>input</span><span class=p>())):</span>
</span></span><span class=line><span class=cl>    <span class=n>v</span><span class=p>,</span> <span class=n>e</span><span class=p>,</span> <span class=n>n</span><span class=p>,</span> <span class=n>m</span> <span class=o>=</span> <span class=nb>map</span><span class=p>(</span><span class=nb>int</span><span class=p>,</span> <span class=nb>input</span><span class=p>()</span><span class=o>.</span><span class=n>split</span><span class=p>())</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>distance</span> <span class=o>=</span> <span class=p>[</span><span class=n>INF</span> <span class=k>for</span> <span class=n>_</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=n>v</span> <span class=o>+</span> <span class=mi>1</span><span class=p>)]</span>
</span></span><span class=line><span class=cl>    <span class=n>graph</span> <span class=o>=</span> <span class=p>[[]</span> <span class=k>for</span> <span class=n>_</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=n>v</span> <span class=o>+</span> <span class=mi>1</span><span class=p>)]</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=n>_</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=n>e</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=n>a</span><span class=p>,</span> <span class=n>b</span><span class=p>,</span> <span class=n>w</span> <span class=o>=</span> <span class=nb>map</span><span class=p>(</span><span class=nb>int</span><span class=p>,</span> <span class=nb>input</span><span class=p>()</span><span class=o>.</span><span class=n>split</span><span class=p>())</span>
</span></span><span class=line><span class=cl>        <span class=n>graph</span><span class=p>[</span><span class=n>a</span><span class=p>]</span><span class=o>.</span><span class=n>append</span><span class=p>((</span><span class=n>b</span><span class=p>,</span> <span class=n>w</span><span class=p>))</span>
</span></span><span class=line><span class=cl>        <span class=n>graph</span><span class=p>[</span><span class=n>b</span><span class=p>]</span><span class=o>.</span><span class=n>append</span><span class=p>((</span><span class=n>a</span><span class=p>,</span> <span class=n>w</span><span class=p>))</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>fires</span> <span class=o>=</span> <span class=nb>list</span><span class=p>(</span><span class=nb>map</span><span class=p>(</span><span class=nb>int</span><span class=p>,</span> <span class=nb>input</span><span class=p>()</span><span class=o>.</span><span class=n>split</span><span class=p>()))</span>
</span></span><span class=line><span class=cl>    <span class=n>starts</span> <span class=o>=</span> <span class=nb>list</span><span class=p>(</span><span class=nb>map</span><span class=p>(</span><span class=nb>int</span><span class=p>,</span> <span class=nb>input</span><span class=p>()</span><span class=o>.</span><span class=n>split</span><span class=p>()))</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=n>i</span> <span class=ow>in</span> <span class=n>starts</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=n>graph</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span><span class=o>.</span><span class=n>append</span><span class=p>((</span><span class=n>i</span><span class=p>,</span> <span class=mi>0</span><span class=p>))</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>dijkstra</span><span class=p>(</span><span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>answer</span> <span class=o>=</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=n>i</span> <span class=ow>in</span> <span class=n>fires</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=n>answer</span> <span class=o>+=</span> <span class=n>distance</span><span class=p>[</span><span class=n>i</span><span class=p>]</span>
</span></span><span class=line><span class=cl>    <span class=nb>print</span><span class=p>(</span><span class=n>answer</span><span class=p>)</span>
</span></span></code></pre></td></tr></table></div></div><h2 id=309-벨만-포드-최단-경로-알고리즘>30.9 벨만-포드 최단 경로 알고리즘<a hidden class=anchor aria-hidden=true href=#309-벨만-포드-최단-경로-알고리즘>#</a></h2><ul><li>다익스트라와 같은 단일 시작점 최단 경로 알고리즘이지만, 음수 간선이 있어도 최단 경로를 찾을 수 있다.</li><li>그래프에 음수 사이클이 있어서 최단 거리가 제대로 정의되지 않을 경우, 이것에 대해 알려줌</li><li>시작점에서 각 정점까지 가는 최단 거리의 상한을 적당히 예측한 뒤, 예측 값과 실제 최단 거리 사이의 오차를 반복적으로 줄여가는 방식으로 동작<ul><li>BFS 기반으로 한 번에 하나씩 최단 거리를 확정해 나가는 다익스트라와 매우 다름</li></ul></li><li>각 정점까지의 최단 거리의 상한을 담은 <code>upper[]</code> <strong>1차원 배열</strong>을 유지<ul><li>이 값은 알고리즘이 진행됨에 따라 점점 줄어들고, 종료될 때는 실제 최단 거리를 담게 된다.</li></ul></li></ul><h3 id=3091-벨만-포드-동작-과정>30.9.1 벨만-포드 동작 과정<a hidden class=anchor aria-hidden=true href=#3091-벨만-포드-동작-과정>#</a></h3><ul><li>upper[start] = 0으로 초기화, 나머지 원소들은 INF로 초기화</li><li>최단 거리의 특성을 이용<ul><li><code>dist[v] &lt;= dist[u] + w(u, v)</code></li></ul></li><li>이 속성을 이용하면 upper 값을 실제 최단 거리에 가깝게 보정 가능</li><li><strong>upper[v]를 감소하는 작업</strong>을 (u, v)를 따라 <code>완화(relax)</code> 한다고 말한다.</li><li>완화가 성공할때마다, upper는 줄어들고, 최단 거리에 가깝게 된다.</li></ul><p><img loading=lazy src=/images/before/image-20240424161552430.png alt=image-20240424161552430.png width=680 height=auto></p><h3 id=3092-종료-조건과-정당성의-증명>30.9.2 종료 조건과 정당성의 증명<a hidden class=anchor aria-hidden=true href=#3092-종료-조건과-정당성의-증명>#</a></h3><ul><li><code>upper[u] = dist[u]</code>가 될 수 있나?<ul><li>모든 간선에 대해 완화를 시도하는 작업을 x번 반복하면 x개 이하의 간선을 사용하는 최단 경로들은 전부 찾을 수 있다</li><li>모든 간선이 전부 완화가 실패할 때까지 반복하면 모든 최단 경로를 찾을 수 있다</li></ul></li><li>몇 번 완화를 반복해야 하는가?<ul><li>최단 경로가 한 정점을 두 번 지나는 일은 없기때문에, 최단 경로가 포함하는 간선 수의 상한은 쉽게 알 수 있다.</li><li>최단 경로는 최대 <code>V</code>개의 정점과 <code>V-1</code> 개의 간선을 가질 수 있다.</li><li>따라서, 완화는 전체 <code>V-1</code>번 이면 된다.</li></ul></li></ul><p><img loading=lazy src=/images/before/image-20240424161607815.png alt=image-20240424161607815.png width=680 height=auto></p><h3 id=3093-음수-사이클의-판정>30.9.3 음수 사이클의 판정<a hidden class=anchor aria-hidden=true href=#3093-음수-사이클의-판정>#</a></h3><ul><li><p>음수 사이클이 있으면 최단 거리 문제가 제대로 정의 되지 않는다.</p><ul><li>물론, 시잣점에서 음수 사이클로 가는 경로가 아예 없으면 상관 없다.</li></ul></li><li><p>벨만-포드는 음수 사이클의 존재 여부를 <strong>판정</strong>할 수 있다.</p><ul><li>의미 없는 값을 반환하는 대신 음수 사이클이 존재한다는 오류를 반환할 수 있다.</li></ul></li><li><p>음수 사이클이 존재 여부를 판정하려면 <code>V-1</code> 번 완화가 아니라, <code>V</code>번 완화를 시도하면 된다.</p><ul><li><p>그래프에 음수 사이클이 없다면 <code>V-1</code>번으로 모든 최단 거리를 찾을 수 있기 때문에, 마지막 반복의 완화는 전부 실패하게 된다.</p></li><li><p>음수 사이클이 있으면 <code>V</code>번째 반복에서도 <strong>항상 완화가 한 번</strong>은 <strong>성공</strong>한다.</p></li></ul></li></ul><h3 id=3094-실제-구현-python-코드>30.9.4 실제 구현 (python 코드)<a hidden class=anchor aria-hidden=true href=#3094-실제-구현-python-코드>#</a></h3><ul><li>마지막 반복에서 완화가 성공하면(음수 사이클 존재) 텅 빈 배열을 반환</li><li>수행 시간은 모든 간선을 검사하는 중첩 반복문에 의 해 지배<ul><li>가장 바깥의 for문은 V번</li><li>안의 두 for문은 모든 간선을 순회하므로 E번 수행</li><li>따라서, 전체 시간 복잡도는 <strong>O(VE)</strong> 이다.</li></ul></li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=n>V</span><span class=p>,</span> <span class=n>E</span> <span class=o>=</span> <span class=nb>map</span><span class=p>(</span><span class=nb>int</span><span class=p>,</span> <span class=nb>input</span><span class=p>()</span><span class=o>.</span><span class=n>split</span><span class=p>())</span>
</span></span><span class=line><span class=cl><span class=n>INF</span> <span class=o>=</span> <span class=nb>float</span><span class=p>(</span><span class=s1>&#39;inf&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>graph</span> <span class=o>=</span> <span class=p>[]</span>
</span></span><span class=line><span class=cl><span class=n>upper</span> <span class=o>=</span> <span class=p>[</span><span class=n>INF</span><span class=p>]</span> <span class=o>*</span> <span class=p>(</span><span class=n>V</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=k>for</span> <span class=n>i</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=n>E</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=n>s</span><span class=p>,</span> <span class=n>e</span><span class=p>,</span> <span class=n>w</span> <span class=o>=</span> <span class=nb>map</span><span class=p>(</span><span class=nb>int</span><span class=p>,</span> <span class=nb>input</span><span class=p>()</span><span class=o>.</span><span class=n>split</span><span class=p>())</span>
</span></span><span class=line><span class=cl>    <span class=n>graph</span><span class=o>.</span><span class=n>append</span><span class=p>((</span><span class=n>s</span><span class=p>,</span> <span class=n>e</span><span class=p>,</span> <span class=n>w</span><span class=p>))</span>
</span></span><span class=line><span class=cl><span class=n>mCycle</span> <span class=o>=</span> <span class=kc>False</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>bellmanFord</span><span class=p>():</span>
</span></span><span class=line><span class=cl>    <span class=k>global</span> <span class=n>mCycle</span>
</span></span><span class=line><span class=cl>    <span class=n>upper</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span> <span class=o>=</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=n>i</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=n>V</span> <span class=o>-</span> <span class=mi>1</span><span class=p>):</span>  <span class=c1># V-1 번 반복</span>
</span></span><span class=line><span class=cl>        <span class=n>updated</span> <span class=o>=</span> <span class=kc>False</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=n>s</span><span class=p>,</span> <span class=n>e</span><span class=p>,</span> <span class=n>w</span> <span class=ow>in</span> <span class=n>graph</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=p>(</span><span class=n>upper</span><span class=p>[</span><span class=n>s</span><span class=p>]</span> <span class=o>!=</span> <span class=n>INF</span><span class=p>)</span> <span class=ow>and</span> <span class=p>(</span><span class=n>upper</span><span class=p>[</span><span class=n>e</span><span class=p>]</span> <span class=o>&gt;</span> <span class=n>upper</span><span class=p>[</span><span class=n>s</span><span class=p>]</span> <span class=o>+</span> <span class=n>w</span><span class=p>):</span>
</span></span><span class=line><span class=cl>                <span class=n>upper</span><span class=p>[</span><span class=n>e</span><span class=p>]</span> <span class=o>=</span> <span class=n>upper</span><span class=p>[</span><span class=n>s</span><span class=p>]</span> <span class=o>+</span> <span class=n>w</span>
</span></span><span class=line><span class=cl>                <span class=n>updated</span> <span class=o>=</span> <span class=kc>True</span>
</span></span><span class=line><span class=cl>                
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=ow>not</span> <span class=n>updated</span><span class=p>:</span> <span class=c1># 모든 간선에 대해 완화가 실패했을 경우 V-1번 돌 필요 없이 곧장 종료</span>
</span></span><span class=line><span class=cl>            <span class=k>break</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=n>s</span><span class=p>,</span> <span class=n>e</span><span class=p>,</span> <span class=n>w</span> <span class=ow>in</span> <span class=n>graph</span><span class=p>:</span>  <span class=c1># 음수 사이클 판정</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=n>upper</span><span class=p>[</span><span class=n>s</span><span class=p>]</span> <span class=o>!=</span> <span class=n>INF</span><span class=p>)</span> <span class=ow>and</span> <span class=p>(</span><span class=n>upper</span><span class=p>[</span><span class=n>e</span><span class=p>]</span> <span class=o>&gt;</span> <span class=n>upper</span><span class=p>[</span><span class=n>s</span><span class=p>]</span> <span class=o>+</span> <span class=n>w</span><span class=p>):</span>
</span></span><span class=line><span class=cl>            <span class=n>mCycle</span> <span class=o>=</span> <span class=kc>True</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>if</span> <span class=ow>not</span> <span class=n>mCycle</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=n>i</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=mi>1</span><span class=p>,</span> <span class=n>V</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=n>upper</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>!=</span> <span class=n>INF</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=nb>print</span><span class=p>(</span><span class=n>upper</span><span class=p>[</span><span class=n>i</span><span class=p>])</span>
</span></span><span class=line><span class=cl>        <span class=k>else</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=nb>print</span><span class=p>(</span><span class=o>-</span><span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=k>else</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=nb>print</span><span class=p>(</span><span class=o>-</span><span class=mi>1</span><span class=p>)</span>
</span></span></code></pre></td></tr></table></div></div><h3 id=3095-경로-계산하기>30.9.5 경로 계산하기<a hidden class=anchor aria-hidden=true href=#3095-경로-계산하기>#</a></h3><ul><li>벨만-포드를 수행하는 과정에서 <strong>각 정점을 마지막으로 완화시킨 간선</strong>들을 모으면 <strong>스패닝 트리</strong>를 얻을 수 있다.<ul><li>이 정점들은 항상 최단 경로 위에 있기 때문에, 각 정점에서부터 스패닝 트리의 루트인 시작점까지 거슬러 올라가는 경로는</li><li>항상 시작점에서 해단 경로까지의 최단 경로이다.</li><li>BFS와 다익스트라와 같은 방식으로 실제 경로(정점의 목록)을 계산할 수 있다.</li></ul></li></ul><h3 id=3096-빠지기-쉬운-함정>30.9.6 빠지기 쉬운 함정<a hidden class=anchor aria-hidden=true href=#3096-빠지기-쉬운-함정>#</a></h3><ul><li><p>u로 가는 경로가 존재하는지 확인하기 위해서는 적당히 큰 값 M에 대해 <code>upper[u] &lt; INF - M</code> 인지를 확인해야 한다.</p><p><img loading=lazy src=/images/before/image-20240424161627590.png alt=image-20240424161627590.png width=680 height=auto></p></li></ul><h2 id=3010-3011-시간여행-timetrip-난이도-중>30.10, 30.11 시간여행, TIMETRIP, 난이도: 중<a hidden class=anchor aria-hidden=true href=#3010-3011-시간여행-timetrip-난이도-중>#</a></h2><ul><li><strong>최단 경로</strong> 구하기<ul><li>간과하기 쉬운 부분은 그래프에 음수 사이클이 존재한다고 해서, <strong>가중치가 음의 무한대</strong>인 경로가 항상 존재하지는 않는다</li><li>음수 사이클을 발견했을 때 시작점에서 이 사이클로 왔다가 다시 종착점으로 가는 경로가 있는지 확인해야 한다.</li><li><code>reachable[][]</code>: 모든 정점의 쌍에 대해 한 정점에서 다른 정점으로 가는 경로의 존재 여부를 저장</li></ul></li></ul><p><img loading=lazy src=/images/before/image-20240424161650589.png alt=image-20240424161650589.png width=680 height=auto></p><ul><li><strong>최장 경로</strong> 구하기<ul><li>주어진 그래프의 가중치의 <strong>부호</strong>를 모두 바꾼 다음 <strong>최단 경로</strong>를 찾으면 된다.</li><li>이 문제는 일반적으로 이야기하는 최장 경로 문제와는 다르다</li><li>이 문제와 달리 최장 경로 문제에서는 <strong>사이클을 포함하지 않는 단순 경로</strong>를 찾기 요구한다.</li><li>실제로 임의의 문제에서 <strong>단순 최장 경로</strong>를 찾는 문제는 <strong>NP-Complete</strong> 문제이다</li></ul></li></ul><h2 id=3012-플로이드의-모든-쌍-최단-거리-알고리즘>30.12 플로이드의 모든 쌍 최단 거리 알고리즘<a hidden class=anchor aria-hidden=true href=#3012-플로이드의-모든-쌍-최단-거리-알고리즘>#</a></h2><ul><li><strong>다익스트라, 벨만-포드</strong>는 <strong>one start node</strong>에서 다른 모든 정점까지의 거리를 구해준다.<ul><li>물론, 각 정점을 시작점으로 다익스트라를 반복해도 모든 정점 쌍 최단 거리를 구할 수 있다.</li></ul></li><li><strong>플로이드</strong>는 <strong>모든 정점 쌍</strong>에 대해 둘 사이의 최단 거리를 구해준다.</li><li><code>2차원 배열 dist[]</code>은 모든 정점 쌍의 최단 거리를 저장</li></ul><h3 id=30121-정점의-경유점>30.12.1 정점의 경유점<a hidden class=anchor aria-hidden=true href=#30121-정점의-경유점>#</a></h3><ul><li><strong>경유점</strong>: 경로가 거쳐가는 정점들</li><li>정점 집합 S에 포함된 정점들을 경유점으로 사용해 u -> v로 가는 최단 경로를 알고 있다고 할때, x 정점은 최단 경로를 경유하거나 경유하지 않는다.</li></ul><ol><li><strong>경로가 x를 경유하지 않는다</strong>: 이 경로는 <code>S - {x}</code>에 포함된 정점들만을 경유점으로 사용</li><li><strong>경로가 x를 경유한다</strong>: <code>u->x</code> 가는 구간과 <code>x->v</code>로 가는 구간으로 나눌 수 있다.</li></ol><p><img loading=lazy src=/images/before/image-20240424162053490.png alt=image-20240424162053490.png width=680 height=auto></p><h3 id=30122-플로이드-알고리즘의-프로토타입>30.12.2 플로이드 알고리즘의 프로토타입<a hidden class=anchor aria-hidden=true href=#30122-플로이드-알고리즘의-프로토타입>#</a></h3><ul><li><p>앞의 점화식을 고치면 모든 쌍에 대한 최단 거리 문제를 <strong>동적 계획법</strong>으로 풀 수 있다.</p></li><li><p>C k의 모든 값은 C k-1에만 의존하기 때문에, 동적 계획법을 이용하면 쉽게 풀 수 있다.</p></li><li><p>두 정점 사이의 간선이 없는 경우 아주 큰 값을 넣어 두면, 따로 처리하지 않아도 <strong>두 정점 사이의 경로가 존재하지 않은 것</strong>을 알 수 있다.</p></li><li><p>자기 자신으로 가는 간선은 따로 없더라도 최단 거리는 항상 0이기 때문에 <code>C[0][u][u]</code>는 0으로 초기화</p></li><li><p>전체 시간복잡도는 3중 for문이 지배, O(V^3)</p></li></ul><p><img loading=lazy src=/images/before/image-20240424162116401.png alt=image-20240424162116401.png width=680 height=auto></p><h3 id=30123-메모리-사용량-줄이기>30.12.3 메모리 사용량 줄이기<a hidden class=anchor aria-hidden=true href=#30123-메모리-사용량-줄이기>#</a></h3><ul><li><p>구현이 간단, 반복문 내부가 단순해서 빠르게 수행된다.</p></li><li><p>시간보다는 메모리 사용량이 문제가 된다.</p></li><li><p>슬라이딩 윈도우 기법을 사용하면 사용하는 배열의 크기를 <strong>O(V^2)</strong> 로 줄일 수 있다.</p></li><li><p>C k의 답은 C k-1만 있으면 계산할 수 있다.</p><ul><li>C k-2, C k-3 등은 가지고 있을 필요가 없다.</li><li>C k(u, v)의 값을 <code>C[k%2][u][v]</code>에 저장한다.</li></ul></li><li><p>별도의 배열을 사용하지 않고, 그래프의 가중치를 담는 인접 행렬 위에서 곧장 점화식의 결과를 계산</p><ul><li><p><code>C k-1 (u, k)</code>: 시작점 부터 k-1번 정점까지를 경유점으로 이용해 u -> k로 가는 최단 경로의 길이</p></li><li><p><code>C k (u, k)</code>: 시작점 부터 k번 정점까지를 경유점으로 이용해 u -> k로 가는 최단 경로의 길이</p></li><li><p>출발점이나 도착점이 k일 때, 사용 가능한 경유점의 목록에 k가 추가되는 것은 의미가 없다.</p><ul><li>&lsquo;A를 들러 B에 가는 최단 경로&rsquo;와</li><li>&lsquo;A와 B를 들러 B로 가는 최단 경로&rsquo;는 같다.</li></ul></li><li><p>Ck-1와 Ck의 값을 구분하지 않고 섞어서 써도 된다.</p></li><li><p><code>C[k%2]</code>와 <code>C[(k-1)%2]</code>를 구분할 필요가 없으며, 이들을 한 개의 2차원 배열에 섞어 써도 된다.</p></li></ul></li><li><p>시간 복잡도: O(V^3), 그대로</p></li><li><p>공간 복잡도: O(V^2) 으로 줌</p></li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=n>INF</span> <span class=o>=</span> <span class=nb>float</span><span class=p>(</span><span class=s1>&#39;inf&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>graph</span> <span class=o>=</span> <span class=p>[[</span><span class=n>INF</span><span class=p>]</span> <span class=o>*</span> <span class=n>N</span> <span class=k>for</span> <span class=n>_</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=n>N</span><span class=p>)]</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>for</span> <span class=n>a</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=n>N</span><span class=p>):</span>  <span class=c1># 자기 자신에서 자기 자신으로 가는 비용 0으로 초기화</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=n>b</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=n>N</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=n>a</span> <span class=o>==</span> <span class=n>b</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=n>graph</span><span class=p>[</span><span class=n>a</span><span class=p>][</span><span class=n>b</span><span class=p>]</span> <span class=o>=</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>for</span> <span class=n>_</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=n>M</span><span class=p>):</span>  <span class=c1># 각 간선에 대한 정보를 입력 받아, 그 값으로 초기화</span>
</span></span><span class=line><span class=cl>    <span class=n>a</span><span class=p>,</span> <span class=n>b</span><span class=p>,</span> <span class=n>c</span> <span class=o>=</span> <span class=nb>map</span><span class=p>(</span><span class=nb>int</span><span class=p>,</span> <span class=nb>input</span><span class=p>()</span><span class=o>.</span><span class=n>split</span><span class=p>())</span>
</span></span><span class=line><span class=cl>    <span class=n>graph</span><span class=p>[</span><span class=n>a</span><span class=p>][</span><span class=n>b</span><span class=p>]</span> <span class=o>=</span> <span class=n>c</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>for</span> <span class=n>k</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=n>N</span><span class=p>):</span>  <span class=c1># 점화식에 따라 플로이드 워셜 알고리즘을 수행</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=n>a</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=n>N</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=n>b</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=n>N</span><span class=p>):</span>
</span></span><span class=line><span class=cl>            <span class=n>graph</span><span class=p>[</span><span class=n>a</span><span class=p>][</span><span class=n>b</span><span class=p>]</span> <span class=o>=</span> <span class=nb>min</span><span class=p>(</span><span class=n>graph</span><span class=p>[</span><span class=n>a</span><span class=p>][</span><span class=n>b</span><span class=p>],</span> <span class=n>graph</span><span class=p>[</span><span class=n>a</span><span class=p>][</span><span class=n>k</span><span class=p>]</span> <span class=o>+</span> <span class=n>graph</span><span class=p>[</span><span class=n>k</span><span class=p>][</span><span class=n>b</span><span class=p>])</span>
</span></span></code></pre></td></tr></table></div></div><h3 id=30124-실제-경로-계산하기>30.12.4 실제 경로 계산하기<a hidden class=anchor aria-hidden=true href=#30124-실제-경로-계산하기>#</a></h3><ul><li><strong>마지막</strong>으로 <code>graph[u][v]</code>을 갱신했을 때 사용한 k의 값을 저장 (따로 배열로 변수화 해서 저장)<ul><li>이 정점의 번호를 w라고 하자</li></ul></li><li><strong>최단 경로가 w를 지난다는 의미</strong><ul><li>따라서, 재귀 호출을 이용해 <code>u->w</code>로 가는 최단 경로를 찾고, <code>w-> v</code>로 가는 <strong>최단 경로</strong>를 찾은 뒤 이 둘을 합친다.</li></ul></li></ul><h1 id=reference>Reference<a hidden class=anchor aria-hidden=true href=#reference>#</a></h1><ul><li>프로그래밍 대회에서 배우는 알고리즘 문제 해결 전략 (구종만, 인사이트)</li><li><a href=https://www.algospot.com/>https://www.algospot.com/</a></li></ul></div><footer class=post-footer><ul class=post-tags><li><a href=https://2taezeat.github.io/tags/algorithm/>Algorithm</a></li></ul><nav class=paginav><a class=prev href=https://2taezeat.github.io/posts/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EB%AC%B8%EC%A0%9C-%ED%95%B4%EA%B2%B0-%EC%A0%84%EB%9E%B5/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EB%AC%B8%EC%A0%9C-%ED%95%B4%EA%B2%B0-%EC%A0%84%EB%9E%B5-ch31.-%EA%B7%B8%EB%9E%98%ED%94%84/><span class=title>« Prev</span><br><span>[알고리즘 문제 해결 전략] ch31. 그래프</span>
</a><a class=next href=https://2taezeat.github.io/posts/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EB%AC%B8%EC%A0%9C-%ED%95%B4%EA%B2%B0-%EC%A0%84%EB%9E%B5/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EB%AC%B8%EC%A0%9C-%ED%95%B4%EA%B2%B0-%EC%A0%84%EB%9E%B5-ch29.-%EA%B7%B8%EB%9E%98%ED%94%84/><span class=title>Next »</span><br><span>[알고리즘 문제 해결 전략] ch29. 그래프</span></a></nav><ul class=share-buttons><li><a target=_blank rel="noopener noreferrer" aria-label="share [알고리즘 문제 해결 전략] ch30. 그래프 on x" href="https://x.com/intent/tweet/?text=%5b%ec%95%8c%ea%b3%a0%eb%a6%ac%ec%a6%98%20%eb%ac%b8%ec%a0%9c%20%ed%95%b4%ea%b2%b0%20%ec%a0%84%eb%9e%b5%5d%20ch30.%20%ea%b7%b8%eb%9e%98%ed%94%84&amp;url=https%3a%2f%2f2taezeat.github.io%2fposts%2f%25EC%2595%258C%25EA%25B3%25A0%25EB%25A6%25AC%25EC%25A6%2598-%25EB%25AC%25B8%25EC%25A0%259C-%25ED%2595%25B4%25EA%25B2%25B0-%25EC%25A0%2584%25EB%259E%25B5%2f%25EC%2595%258C%25EA%25B3%25A0%25EB%25A6%25AC%25EC%25A6%2598-%25EB%25AC%25B8%25EC%25A0%259C-%25ED%2595%25B4%25EA%25B2%25B0-%25EC%25A0%2584%25EB%259E%25B5-ch30.-%25EA%25B7%25B8%25EB%259E%2598%25ED%2594%2584%2f&amp;hashtags=Algorithm"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446C483.971.0 512 28.03 512 62.554zM269.951 190.75 182.567 75.216H56L207.216 272.95 63.9 436.783h61.366L235.9 310.383l96.667 126.4H456L298.367 228.367l134-153.151H371.033zM127.633 110h36.468l219.38 290.065H349.5z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share [알고리즘 문제 해결 전략] ch30. 그래프 on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2f2taezeat.github.io%2fposts%2f%25EC%2595%258C%25EA%25B3%25A0%25EB%25A6%25AC%25EC%25A6%2598-%25EB%25AC%25B8%25EC%25A0%259C-%25ED%2595%25B4%25EA%25B2%25B0-%25EC%25A0%2584%25EB%259E%25B5%2f%25EC%2595%258C%25EA%25B3%25A0%25EB%25A6%25AC%25EC%25A6%2598-%25EB%25AC%25B8%25EC%25A0%259C-%25ED%2595%25B4%25EA%25B2%25B0-%25EC%25A0%2584%25EB%259E%25B5-ch30.-%25EA%25B7%25B8%25EB%259E%2598%25ED%2594%2584%2f&amp;title=%5b%ec%95%8c%ea%b3%a0%eb%a6%ac%ec%a6%98%20%eb%ac%b8%ec%a0%9c%20%ed%95%b4%ea%b2%b0%20%ec%a0%84%eb%9e%b5%5d%20ch30.%20%ea%b7%b8%eb%9e%98%ed%94%84&amp;summary=%5b%ec%95%8c%ea%b3%a0%eb%a6%ac%ec%a6%98%20%eb%ac%b8%ec%a0%9c%20%ed%95%b4%ea%b2%b0%20%ec%a0%84%eb%9e%b5%5d%20ch30.%20%ea%b7%b8%eb%9e%98%ed%94%84&amp;source=https%3a%2f%2f2taezeat.github.io%2fposts%2f%25EC%2595%258C%25EA%25B3%25A0%25EB%25A6%25AC%25EC%25A6%2598-%25EB%25AC%25B8%25EC%25A0%259C-%25ED%2595%25B4%25EA%25B2%25B0-%25EC%25A0%2584%25EB%259E%25B5%2f%25EC%2595%258C%25EA%25B3%25A0%25EB%25A6%25AC%25EC%25A6%2598-%25EB%25AC%25B8%25EC%25A0%259C-%25ED%2595%25B4%25EA%25B2%25B0-%25EC%25A0%2584%25EB%259E%25B5-ch30.-%25EA%25B7%25B8%25EB%259E%2598%25ED%2594%2584%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share [알고리즘 문제 해결 전략] ch30. 그래프 on reddit" href="https://reddit.com/submit?url=https%3a%2f%2f2taezeat.github.io%2fposts%2f%25EC%2595%258C%25EA%25B3%25A0%25EB%25A6%25AC%25EC%25A6%2598-%25EB%25AC%25B8%25EC%25A0%259C-%25ED%2595%25B4%25EA%25B2%25B0-%25EC%25A0%2584%25EB%259E%25B5%2f%25EC%2595%258C%25EA%25B3%25A0%25EB%25A6%25AC%25EC%25A6%2598-%25EB%25AC%25B8%25EC%25A0%259C-%25ED%2595%25B4%25EA%25B2%25B0-%25EC%25A0%2584%25EB%259E%25B5-ch30.-%25EA%25B7%25B8%25EB%259E%2598%25ED%2594%2584%2f&title=%5b%ec%95%8c%ea%b3%a0%eb%a6%ac%ec%a6%98%20%eb%ac%b8%ec%a0%9c%20%ed%95%b4%ea%b2%b0%20%ec%a0%84%eb%9e%b5%5d%20ch30.%20%ea%b7%b8%eb%9e%98%ed%94%84"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share [알고리즘 문제 해결 전략] ch30. 그래프 on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2f2taezeat.github.io%2fposts%2f%25EC%2595%258C%25EA%25B3%25A0%25EB%25A6%25AC%25EC%25A6%2598-%25EB%25AC%25B8%25EC%25A0%259C-%25ED%2595%25B4%25EA%25B2%25B0-%25EC%25A0%2584%25EB%259E%25B5%2f%25EC%2595%258C%25EA%25B3%25A0%25EB%25A6%25AC%25EC%25A6%2598-%25EB%25AC%25B8%25EC%25A0%259C-%25ED%2595%25B4%25EA%25B2%25B0-%25EC%25A0%2584%25EB%259E%25B5-ch30.-%25EA%25B7%25B8%25EB%259E%2598%25ED%2594%2584%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share [알고리즘 문제 해결 전략] ch30. 그래프 on whatsapp" href="https://api.whatsapp.com/send?text=%5b%ec%95%8c%ea%b3%a0%eb%a6%ac%ec%a6%98%20%eb%ac%b8%ec%a0%9c%20%ed%95%b4%ea%b2%b0%20%ec%a0%84%eb%9e%b5%5d%20ch30.%20%ea%b7%b8%eb%9e%98%ed%94%84%20-%20https%3a%2f%2f2taezeat.github.io%2fposts%2f%25EC%2595%258C%25EA%25B3%25A0%25EB%25A6%25AC%25EC%25A6%2598-%25EB%25AC%25B8%25EC%25A0%259C-%25ED%2595%25B4%25EA%25B2%25B0-%25EC%25A0%2584%25EB%259E%25B5%2f%25EC%2595%258C%25EA%25B3%25A0%25EB%25A6%25AC%25EC%25A6%2598-%25EB%25AC%25B8%25EC%25A0%259C-%25ED%2595%25B4%25EA%25B2%25B0-%25EC%25A0%2584%25EB%259E%25B5-ch30.-%25EA%25B7%25B8%25EB%259E%2598%25ED%2594%2584%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share [알고리즘 문제 해결 전략] ch30. 그래프 on telegram" href="https://telegram.me/share/url?text=%5b%ec%95%8c%ea%b3%a0%eb%a6%ac%ec%a6%98%20%eb%ac%b8%ec%a0%9c%20%ed%95%b4%ea%b2%b0%20%ec%a0%84%eb%9e%b5%5d%20ch30.%20%ea%b7%b8%eb%9e%98%ed%94%84&amp;url=https%3a%2f%2f2taezeat.github.io%2fposts%2f%25EC%2595%258C%25EA%25B3%25A0%25EB%25A6%25AC%25EC%25A6%2598-%25EB%25AC%25B8%25EC%25A0%259C-%25ED%2595%25B4%25EA%25B2%25B0-%25EC%25A0%2584%25EB%259E%25B5%2f%25EC%2595%258C%25EA%25B3%25A0%25EB%25A6%25AC%25EC%25A6%2598-%25EB%25AC%25B8%25EC%25A0%259C-%25ED%2595%25B4%25EA%25B2%25B0-%25EC%25A0%2584%25EB%259E%25B5-ch30.-%25EA%25B7%25B8%25EB%259E%2598%25ED%2594%2584%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentcolor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share [알고리즘 문제 해결 전략] ch30. 그래프 on ycombinator" href="https://news.ycombinator.com/submitlink?t=%5b%ec%95%8c%ea%b3%a0%eb%a6%ac%ec%a6%98%20%eb%ac%b8%ec%a0%9c%20%ed%95%b4%ea%b2%b0%20%ec%a0%84%eb%9e%b5%5d%20ch30.%20%ea%b7%b8%eb%9e%98%ed%94%84&u=https%3a%2f%2f2taezeat.github.io%2fposts%2f%25EC%2595%258C%25EA%25B3%25A0%25EB%25A6%25AC%25EC%25A6%2598-%25EB%25AC%25B8%25EC%25A0%259C-%25ED%2595%25B4%25EA%25B2%25B0-%25EC%25A0%2584%25EB%259E%25B5%2f%25EC%2595%258C%25EA%25B3%25A0%25EB%25A6%25AC%25EC%25A6%2598-%25EB%25AC%25B8%25EC%25A0%259C-%25ED%2595%25B4%25EA%25B2%25B0-%25EC%25A0%2584%25EB%259E%25B5-ch30.-%25EA%25B7%25B8%25EB%259E%2598%25ED%2594%2584%2f"><svg width="30" height="30" viewBox="0 0 512 512" fill="currentcolor" xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"><path d="M449.446.0C483.971.0 512 28.03 512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446zM183.8767 87.9921h-62.034L230.6673 292.4508V424.0079h50.6655V292.4508L390.1575 87.9921H328.1233L256 238.2489z"/></svg></a></li></ul></footer><script src=https://utteranc.es/client.js repo=2taezeat/blog_comment issue-term=pathname label=comment theme=github-light crossorigin=anonymous async></script></article></main><footer class=footer><span>&copy; 2024 <a href=https://2taezeat.github.io/>2taezeat, blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>