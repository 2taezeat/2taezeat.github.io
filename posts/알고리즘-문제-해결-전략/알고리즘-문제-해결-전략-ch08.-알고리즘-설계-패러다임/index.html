<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>[알고리즘 문제 해결 전략] ch08. 알고리즘 설계 패러다임 | 2taezeat, blog</title>
<meta name=keywords content="Algorithm"><meta name=description content="ch08. 동적 계획법"><meta name=author content="2taezeat"><link rel=canonical href=https://2taezeat.github.io/posts/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EB%AC%B8%EC%A0%9C-%ED%95%B4%EA%B2%B0-%EC%A0%84%EB%9E%B5/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EB%AC%B8%EC%A0%9C-%ED%95%B4%EA%B2%B0-%EC%A0%84%EB%9E%B5-ch08.-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EC%84%A4%EA%B3%84-%ED%8C%A8%EB%9F%AC%EB%8B%A4%EC%9E%84/><meta name=google-site-verification content="YaEERzgrvu-ZwPg7gswZdTzRMufkHw3uIH7i8hVal1c"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.fcb4dca47a3205209ed5ad677bea9ef840216e00cc778e31a6e3943bf8f843e1.css integrity="sha256-/LTcpHoyBSCe1a1ne+qe+EAhbgDMd44xpuOUO/j4Q+E=" rel="preload stylesheet" as=style><link rel=icon href=https://2taezeat.github.io/icon/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://2taezeat.github.io/icon/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://2taezeat.github.io/icon/favicon-32x32.png><link rel=apple-touch-icon href=https://2taezeat.github.io/icon/apple-touch-icon.png><link rel=mask-icon href=https://2taezeat.github.io/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://2taezeat.github.io/posts/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EB%AC%B8%EC%A0%9C-%ED%95%B4%EA%B2%B0-%EC%A0%84%EB%9E%B5/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EB%AC%B8%EC%A0%9C-%ED%95%B4%EA%B2%B0-%EC%A0%84%EB%9E%B5-ch08.-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EC%84%A4%EA%B3%84-%ED%8C%A8%EB%9F%AC%EB%8B%A4%EC%9E%84/><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><meta property="og:title" content="[알고리즘 문제 해결 전략] ch08. 알고리즘 설계 패러다임"><meta property="og:description" content="ch08. 동적 계획법"><meta property="og:type" content="article"><meta property="og:url" content="https://2taezeat.github.io/posts/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EB%AC%B8%EC%A0%9C-%ED%95%B4%EA%B2%B0-%EC%A0%84%EB%9E%B5/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EB%AC%B8%EC%A0%9C-%ED%95%B4%EA%B2%B0-%EC%A0%84%EB%9E%B5-ch08.-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EC%84%A4%EA%B3%84-%ED%8C%A8%EB%9F%AC%EB%8B%A4%EC%9E%84/"><meta property="og:image" content="https://2taezeat.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-01-05T11:30:03+00:00"><meta property="article:modified_time" content="2024-01-05T11:30:03+00:00"><meta property="og:site_name" content="2taezeat, blog"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://2taezeat.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="[알고리즘 문제 해결 전략] ch08. 알고리즘 설계 패러다임"><meta name=twitter:description content="ch08. 동적 계획법"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://2taezeat.github.io/posts/"},{"@type":"ListItem","position":2,"name":"[알고리즘 문제 해결 전략] ch08. 알고리즘 설계 패러다임","item":"https://2taezeat.github.io/posts/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EB%AC%B8%EC%A0%9C-%ED%95%B4%EA%B2%B0-%EC%A0%84%EB%9E%B5/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EB%AC%B8%EC%A0%9C-%ED%95%B4%EA%B2%B0-%EC%A0%84%EB%9E%B5-ch08.-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EC%84%A4%EA%B3%84-%ED%8C%A8%EB%9F%AC%EB%8B%A4%EC%9E%84/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"[알고리즘 문제 해결 전략] ch08. 알고리즘 설계 패러다임","name":"[알고리즘 문제 해결 전략] ch08. 알고리즘 설계 패러다임","description":"ch08. 동적 계획법","keywords":["Algorithm"],"articleBody":"8. 동적 계획법 8.1 도입 동적 계획법(dynamic programming) 은 최적화 문제를 연구하는 수학 이론에서 왔으며,\n우리가 전산학 전반에서 사용하는 동적(dynamic), 프로그래밍이란 단어와는 관련이 없다. 따라서, 바른 명명은 동적 프로그래밍이 아니라, 동적 계획법이다.\n8.1.1 중복되는 부분 문제 동적 계획법은 큰 의미에서 분할 정복과 같은 접근 방식을 의미한다.\n처음 주어진 문제를 더 작은 문제들로 나눈 뒤 각 조각의 답을 계산하고, 이 답들로부터 원래 문제에 대한 답을 계산해 내기 때문이다. 동적계획법은 ‘어떤 부분 문제’를 ‘두 개 이상의 문제’를 푸는데 사용될 수 있기 때문에, 이 문제의 답을 여러 번 계산하는 대신 한 번만 계산하고 계산 결과를 재활용 함으로써 속도의 향상을 꾀할 수 있다. 이를 위해, 각 문제의 답을 메모리에 저장할 필요가 있고, 이 메모리 저장 장소를 cache(캐시) 라고 한다. =\u003e 메모이제이션, 캐싱 두 번 이산 계산되는 부분 문제를 중복되는 부분 문제(overlapping subproblems) 라고 한다. 분할 정복: 단순한 재귀 호출을 통해, 문제를 분할해도 한 부분 문제를 한 번만 해결\n계산의 중복 횟수는 분할의 깊이가 깊어질수록 지수적으로 증가, 이를 해결하기 위해 고안된 알고리즘이 동적 계획법 ![DynamicProgramming | hongbeen’s blog.png](/images/before/DynamicProgramming | hongbeen’s blog.png)\n몇몇 부분 문제 들은 여러 번 계산하기 됨 캐시 배열을 만들어서, 각 배열에 저장되어 있는지 확인하고, 저장 되어 있다면 즉시 반환 메모이제이션(memoization): 함수의 결과를 저장하는 장소를 마련해 두고, 한 번 계산한 값을 저장해 뒀다 재활용하는 최적화 기법 메모이제이션을 사용하면 모든 부분 문제가 한 번씩만 계산된다고 보장할 수 있기 때문에 함수 호출 횟수가 엄청나게 감소한다. 동적 계획법: 이와 같이 두 번 이상 반복되는 계산되는 부분 문제들의 답을 미리 저장함으로써, 속도의 향상을 꾀하는 알고리즘 설계 기법 8.1.2 메모제이션 구현 패턴 항상 base case(기저 사례) 를 먼저 처리 cache 에 데이터가 저장되어 있으면 (답을 계산한 적이 있으면) 바로 반환 8.1.2 메모제이션의 시간 복잡도 분석 (주먹구구) 시간 복잡도: 존재하는 부분 문제의 수 x 한 부분 문제를 풀때 필요한 반복문의 수행횟수 상한을 간단히 계산할 수 있는 방법, 항상 정확하지는 않음 실제 수행 시간이 이 식 보다 더 간단할 수 있다. 8.1.3 동적 계획법 레시피 동적 계획법 알고리즘 만드는 첫 단계는 해당 문제를 재귀적으로 해결하는 완전 탐색 알고리즘을 만드는 것 부터 시작\n중복된 부분 문제를 한 번 만 계산하도록 메모제이션을 적용\n“원하는 답이 존재하는가?” 이 질문을 완전 탐색을 구할 때 흔히 가장 문제가 되는 것은, 원하는 답은 없는데 전체 답의 개수는 무지막지하게 많은 경우이다. 완전 탐색의 경우, 어떤 경로는 마지막 칸에 도달할지도 모른다고 생각하고, 수없이 많은 경로를 일일히 탐색하게 된다. 경로의 갯수가 n에 대해 지수적 증가하게 됨 8.2, 8.3 와일드카드, WILDCARD, 난이도: 중 비둘기 집 원리에 따라, 101 x 101 = 10201 번 이상 호출되었다면, 부분 문제가 존재할 수 밖에 없음. 101 x 101 배열에 모든 부분 문제의 답을 저장 할 수 있음 8.4 전통적 최적화 문제들 동적 계획법의 가장 일반적인 사용처는 최적화 문제 이다.\n최적화 문제: 여러 개의 가능한 답 중 가장 좋은 답(최적해) 를 찾는 문제\n최적화 문제에 특정 성질이 성립할 경우, 단순히 메모이제이션을 적용하는 것 보다 더 효율적으로 동적 계획법을 구현할 수 있다.\n예제) 삼각형 위의 최대 경로, TRIANGLEPATH, 난이도: 하\npath1(y, x, sum) = 현재 위치가 (y, x)이고, 지금까지 만난 수의 합이 sum 일 때, 이 경로를 맨 아래줄까지 연장해서 얻을 수 있는 최대 합을 반환 함수의 반환 값을 전체 경로의 최대치(path1)가 아니라, (y, x)에서 시작하는 부분 경로의 최대치로 바꾸면, 부분 문제들을 얻을 수 있다. path2(y, x) = (y, x)에서 시작해서 맨 아래줄까지 내려가는 부분 경로의 최대 합을 반환 8.4.1 최적 부분 구조 삼각형 위의 최대 경로 의 속도를 최적화 할 수 있는 sum이라는 정보가 (y, x) 에서 맨 아래줄까지 내려가는 문제를 해결하는 데 아무 상관이 없다 는 것 때문이다. 어떤 경로로 이 부분 문제에 도달 했건, 남은 부분 문제는 항상 최적으로 풀어도 상관 없다는 의미이다, 이 조건은 최적 부분 구조(optimal substruture) 라는 동적 계획법의 중요 요소 이다. 최적 부분 구조(optimal substruture) 는 어떤 문제와 분할 방식에 성립하는 조건이다. 각 부분 문제의 최적해만 있으면, 전체 문제의 최적해를 얻어 낼 수 있는 경우 지금까지의 선택과 상관 없이, 각 부분 문제를 최적으로 풀기만 하면 전체 문제의 최적해도 알 수 있다는 것 최단 경로 문제는 각 부분의 최적해가 전체의 최적해(최단 경로) 이기 때문에 최적 부분 구조를 갖는다. 8.4.2 최적화 문제, 동적 계획법 레시피 모든 답을 만들어 보고, 그 중 최적해의 점수를 반환하는 완전 탐색 알고리즘을 설계한다. 전체 답의 점수를 반환하는 것이 아니라, 남은 선택들에 해당하는 점수만을 반환하도록 부분 문제 정의를 바꾼다. 재귀 호출의 입력, 파라미터에 이전의 선택에 관한 정보가 있다면, 꼭 필요한 것만 남기고 줄인다. 문제에 최적 부분 구조가 성립할 경우, 이전 선택에 관련된 정보를 완전히 없앨 수 도 있다. 목표는 가능한 한 중복되는 부분 문제를 많이 만드는 것 입력의 종류가 줄어들면 줄어들 수 록, 더 많은 부분 문제가 중복되고, 메모이제이션을 최대한 활용할 수 있게 된다. 입력이 배열이거나 문자열인 경우, 적절한 변환을 통해 메모이제이션을 활용할 수 있도록 한다. 메모이제이션을 적용한다. 8.11 경우의 수와 확률 동적 계획법은 경우의 수를 세거나 확률을 계산하는 문제에도 흔하게 사용된다. 경우의 수를 새는 경우, 재귀적인 특징이 있기 때문이다. 8.11.1 타일링 방법의 수 세기, TILING2, 난이도: 하 2 x n 사각형을 채우는 모든 방법들은 맨 왼쪽 세로줄이 어떻게 채워져 있느냐로 나눌 수 있다. 이 두 가지 분류는 타일링 하는 방법을 모두 포함한다. 두 가지 분류에 모두 포함되는 타일링 방법은 없다. 결과적으로, 더 세지도 않고, 덜 세지도 않는다. tiling(n) = tiling(n-1) + tiling(n-2) // 타일 1개 사용한 경우 + 타일 2개 사용한 경우 8.11.2 경우의 수, 계산하기 레시피 모든 답을 직접 만들어서 세어보는 완전 탐색 알고리즘을 설계한다. 모든 경우는 이 선택지들에 포함됨 (덜 세지 않음) 어떤 경우도 두 개 이상의 선택지에 포함되지 않음 (더 세지 않음) 최적화 문제를 해결할 때 처럼, 이전 조각에서 결정한 요소들에 대한 입력, 파라미터를 없애거나 변형해서 줄인다. 재귀 함수는 앞으로 남아 있는 조각들을 고르는 경우의 수만 반환해야 한다. 메모이제이션을 적용한다. Reference 프로그래밍 대회에서 배우는 알고리즘 문제 해결 전략 (구종만, 인사이트) https://www.algospot.com/ ","wordCount":"898","inLanguage":"en","image":"https://2taezeat.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E","datePublished":"2024-01-05T11:30:03Z","dateModified":"2024-01-05T11:30:03Z","author":{"@type":"Person","name":"2taezeat"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://2taezeat.github.io/posts/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EB%AC%B8%EC%A0%9C-%ED%95%B4%EA%B2%B0-%EC%A0%84%EB%9E%B5/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EB%AC%B8%EC%A0%9C-%ED%95%B4%EA%B2%B0-%EC%A0%84%EB%9E%B5-ch08.-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EC%84%A4%EA%B3%84-%ED%8C%A8%EB%9F%AC%EB%8B%A4%EC%9E%84/"},"publisher":{"@type":"Organization","name":"2taezeat, blog","logo":{"@type":"ImageObject","url":"https://2taezeat.github.io/icon/favicon.ico"}}}</script></head><body id=top><header class=header><nav class=nav><div class=logo><a href=https://2taezeat.github.io/ accesskey=h title="2taezeat blog (Alt + H)"><img src=https://2taezeat.github.io/icon/apple-touch-icon.png alt aria-label=logo height=30>2taezeat blog</a><div class=logo-switches></div></div><ul id=menu><li><a href=https://2taezeat.github.io/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://2taezeat.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://2taezeat.github.io/searchs/ title=Search><span>Search</span></a></li><li><a href=https://github.com/2taezeat title=Github><span>Github</span>&nbsp;<svg fill="none" shape-rendering="geometricPrecision" stroke="currentcolor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2.5" viewBox="0 0 24 24" height="12" width="12"><path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"/><path d="M15 3h6v6"/><path d="M10 14 21 3"/></svg></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://2taezeat.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://2taezeat.github.io/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">[알고리즘 문제 해결 전략] ch08. 알고리즘 설계 패러다임</h1><div class=post-description>ch08. 동적 계획법</div><div class=post-meta><span title='2024-01-05 11:30:03 +0000 +0000'>2024-01-05</span>&nbsp;·&nbsp;5 min&nbsp;·&nbsp;898 words&nbsp;·&nbsp;2taezeat</div></header><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#8-동적-계획법>8. 동적 계획법</a><ul><li><a href=#81-도입>8.1 도입</a></li><li><a href=#811-중복되는-부분-문제>8.1.1 중복되는 부분 문제</a><ul><li><a href=#812-메모제이션-구현-패턴>8.1.2 메모제이션 구현 패턴</a></li><li><a href=#812-메모제이션의-시간-복잡도-분석>8.1.2 메모제이션의 시간 복잡도 분석</a></li><li><a href=#813-동적-계획법-레시피>8.1.3 동적 계획법 레시피</a></li></ul></li><li><a href=#82-83-와일드카드-wildcard-난이도-중>8.2, 8.3 와일드카드, WILDCARD, 난이도: 중</a></li><li><a href=#84-전통적-최적화-문제들>8.4 전통적 최적화 문제들</a><ul><li><a href=#841-최적-부분-구조>8.4.1 최적 부분 구조</a></li><li><a href=#842-최적화-문제-동적-계획법-레시피>8.4.2 최적화 문제, 동적 계획법 레시피</a></li></ul></li><li><a href=#811-경우의-수와-확률>8.11 경우의 수와 확률</a><ul><li><a href=#8111-타일링-방법의-수-세기-tiling2-난이도-하>8.11.1 타일링 방법의 수 세기, TILING2, 난이도: 하</a></li><li><a href=#8112-경우의-수-계산하기-레시피>8.11.2 경우의 수, 계산하기 레시피</a></li></ul></li></ul></li><li><a href=#reference>Reference</a></li></ul></nav></div></details></div><div class=post-content><h1 id=8-동적-계획법>8. 동적 계획법<a hidden class=anchor aria-hidden=true href=#8-동적-계획법>#</a></h1><h2 id=81-도입>8.1 도입<a hidden class=anchor aria-hidden=true href=#81-도입>#</a></h2><ul><li><p><strong>동적 계획법(dynamic programming)</strong> 은 최적화 문제를 연구하는 수학 이론에서 왔으며,</p><ul><li>우리가 전산학 전반에서 사용하는 동적(dynamic), 프로그래밍이란 단어와는 관련이 없다.</li></ul></li><li><p>따라서, 바른 명명은 동적 프로그래밍이 아니라, <strong>동적 계획법</strong>이다.</p></li></ul><h2 id=811-중복되는-부분-문제>8.1.1 중복되는 부분 문제<a hidden class=anchor aria-hidden=true href=#811-중복되는-부분-문제>#</a></h2><ul><li><p>동적 계획법은 큰 의미에서 <strong>분할 정복</strong>과 같은 접근 방식을 의미한다.</p><ul><li>처음 주어진 문제를 더 작은 문제들로 나눈 뒤 각 조각의 답을 계산하고, 이 답들로부터 원래 문제에 대한 답을 계산해 내기 때문이다.</li><li>동적계획법은 &lsquo;어떤 부분 문제&rsquo;를 &lsquo;두 개 이상의 문제&rsquo;를 푸는데 사용될 수 있기 때문에,<ul><li>이 문제의 <strong>답을 여러 번 계산하는 대신 한 번만 계산하고 계산 결과를 재활용</strong> 함으로써 속도의 향상을 꾀할 수 있다.</li></ul></li><li>이를 위해, 각 문제의 답을 메모리에 저장할 필요가 있고, 이 메모리 저장 장소를 <strong>cache(캐시)</strong> 라고 한다. => <strong>메모이제이션, 캐싱</strong></li><li><strong>두 번 이산 계산되는 부분 문제</strong>를 <strong>중복되는 부분 문제(overlapping subproblems)</strong> 라고 한다.</li></ul></li><li><p><strong>분할 정복</strong>: 단순한 재귀 호출을 통해, 문제를 분할해도 <strong>한 부분 문제를 한 번만</strong> 해결</p><ul><li>계산의 중복 횟수는 분할의 깊이가 깊어질수록 <strong>지수적으로 증가</strong>, 이를 해결하기 위해 고안된 알고리즘이 <strong>동적 계획법</strong></li></ul></li></ul><p><img loading=lazy src=/images/before/image-20240502094604917.png alt=image-20240502094604917.png width=680 height=auto></p><p><img loading=lazy src=/images/before/image-20240502094510502.png alt=image-20240502094510502.png width=680 height=auto></p><p>![DynamicProgramming | hongbeen&rsquo;s blog.png](/images/before/DynamicProgramming | hongbeen&rsquo;s blog.png)</p><ul><li>몇몇 부분 문제 들은 여러 번 계산하기 됨<ul><li><strong>캐시 배열</strong>을 만들어서, 각 배열에 저장되어 있는지 확인하고, 저장 되어 있다면 즉시 반환</li><li><strong>메모이제이션(memoization)</strong>: <strong>함수의 결과를 저장하는 장소를 마련해 두고, 한 번 계산한 값을 저장해 뒀다 재활용하는 최적화 기법</strong></li><li>메모이제이션을 사용하면 <strong>모든 부분 문제</strong>가 <strong>한 번씩만</strong> 계산된다고 <strong>보장</strong>할 수 있기 때문에 <strong>함수 호출 횟수가 엄청나게 감소</strong>한다.</li></ul></li><li><strong>동적 계획법:</strong> 이와 같이 <strong>두 번 이상 반복되는 계산되는 부분 문제들의 답을 미리 저장함</strong>으로써, 속도의 향상을 꾀하는 알고리즘 설계 기법</li></ul><p><img loading=lazy src=/images/before/Algorithm_Dynamic_Programming_001.png alt=Algorithm_Dynamic_Programming_001.png width=680 height=auto></p><h3 id=812-메모제이션-구현-패턴>8.1.2 메모제이션 구현 패턴<a hidden class=anchor aria-hidden=true href=#812-메모제이션-구현-패턴>#</a></h3><ul><li><strong>항상 base case(기저 사례)</strong> 를 먼저 처리</li><li>cache 에 데이터가 저장되어 있으면 <strong>(답을 계산한 적이 있으면) 바로 반환</strong></li></ul><h3 id=812-메모제이션의-시간-복잡도-분석>8.1.2 메모제이션의 시간 복잡도 분석<a hidden class=anchor aria-hidden=true href=#812-메모제이션의-시간-복잡도-분석>#</a></h3><ul><li>(주먹구구) 시간 복잡도: <code>존재하는 부분 문제의 수</code> x <code>한 부분 문제를 풀때 필요한 반복문의 수행횟수</code><ul><li>상한을 간단히 계산할 수 있는 방법, 항상 정확하지는 않음</li><li>실제 수행 시간이 <code>이 식</code> 보다 더 간단할 수 있다.</li></ul></li></ul><h3 id=813-동적-계획법-레시피>8.1.3 동적 계획법 레시피<a hidden class=anchor aria-hidden=true href=#813-동적-계획법-레시피>#</a></h3><ol><li><p>동적 계획법 알고리즘 만드는 첫 단계는 해당 문제를 재귀적으로 해결하는 <strong>완전 탐색 알고리즘</strong>을 만드는 것 부터 시작</p></li><li><p><strong>중복된 부분 문제를 한 번 만 계산하도록</strong> 메모제이션을 적용</p></li></ol><ul><li>&ldquo;원하는 답이 존재하는가?&rdquo; 이 질문을 완전 탐색을 구할 때 흔히 가장 문제가 되는 것은, 원하는 답은 없는데 전체 답의 개수는 무지막지하게 많은 경우이다.</li><li>완전 탐색의 경우, 어떤 경로는 마지막 칸에 도달할지도 모른다고 생각하고, 수없이 많은 경로를 일일히 탐색하게 된다. 경로의 갯수가 n에 대해 지수적 증가하게 됨</li></ul><h2 id=82-83-와일드카드-wildcard-난이도-중>8.2, 8.3 와일드카드, WILDCARD, 난이도: 중<a hidden class=anchor aria-hidden=true href=#82-83-와일드카드-wildcard-난이도-중>#</a></h2><ul><li>비둘기 집 원리에 따라, 101 x 101 = 10201 번 이상 호출되었다면, 부분 문제가 존재할 수 밖에 없음.</li><li>101 x 101 배열에 모든 부분 문제의 답을 저장 할 수 있음</li></ul><h2 id=84-전통적-최적화-문제들>8.4 전통적 최적화 문제들<a hidden class=anchor aria-hidden=true href=#84-전통적-최적화-문제들>#</a></h2><ul><li><p>동적 계획법의 가장 일반적인 사용처는 <strong>최적화 문제</strong> 이다.</p></li><li><p><strong>최적화 문제</strong>: 여러 개의 가능한 답 중 <strong>가장 좋은 답(최적해)</strong> 를 찾는 문제</p></li><li><p>최적화 문제에 특정 성질이 성립할 경우, 단순히 메모이제이션을 적용하는 것 보다 더 효율적으로 동적 계획법을 구현할 수 있다.</p></li><li><p><em>예제) 삼각형 위의 최대 경로, TRIANGLEPATH, 난이도: 하</em></p><ul><li><code>path1(y, x, sum) = 현재 위치가 (y, x)이고, 지금까지 만난 수의 합이 sum 일 때, 이 경로를 맨 아래줄까지 연장해서 얻을 수 있는 최대 합을 반환</code></li><li>함수의 반환 값을 <strong>전체 경로의 최대치</strong>(path1)가 아니라, (y, x)에서 시작하는 <strong>부분 경로의 최대치</strong>로 바꾸면, 부분 문제들을 얻을 수 있다.</li><li><code>path2(y, x) = (y, x)에서 시작해서 맨 아래줄까지 내려가는 부분 경로의 최대 합을 반환</code></li></ul></li></ul><h3 id=841-최적-부분-구조>8.4.1 최적 부분 구조<a hidden class=anchor aria-hidden=true href=#841-최적-부분-구조>#</a></h3><ul><li><em>삼각형 위의 최대 경로</em> 의 속도를 최적화 할 수 있는 <strong>sum</strong>이라는 정보가 <strong>(y, x)</strong> 에서 <strong>맨 아래줄까지 내려가는 문제를 해결하는 데 아무 상관이 없다</strong> 는 것 때문이다.</li><li>어떤 경로로 <strong>이 부분 문제에 도달 했건, 남은 부분 문제는 항상 최적으로 풀어도 상관 없다</strong>는 의미이다,<ul><li>이 조건은 <strong>최적 부분 구조(optimal substruture)</strong> 라는 동적 계획법의 중요 요소 이다.</li></ul></li><li><strong>최적 부분 구조(optimal substruture)</strong> 는 <strong>어떤 문제</strong>와 <strong>분할 방식</strong>에 성립하는 조건이다.<ul><li><strong>각 부분 문제의 최적해만 있으면, 전체 문제의 최적해를 얻어 낼 수 있는 경우</strong></li><li>지금까지의 선택과 상관 없이, <strong>각 부분 문제를 최적으로 풀기만</strong> 하면 <strong>전체 문제의 최적해</strong>도 알 수 있다는 것</li></ul></li><li>최단 경로 문제는 <strong>각 부분의 최적해</strong>가 <strong>전체의 최적해(최단 경로)</strong> 이기 때문에 <strong>최적 부분 구조</strong>를 갖는다.</li></ul><h3 id=842-최적화-문제-동적-계획법-레시피>8.4.2 최적화 문제, 동적 계획법 레시피<a hidden class=anchor aria-hidden=true href=#842-최적화-문제-동적-계획법-레시피>#</a></h3><ol><li>모든 답을 만들어 보고, 그 중 최적해의 점수를 반환하는 완전 탐색 알고리즘을 설계한다.</li><li>전체 답의 점수를 반환하는 것이 아니라, 남은 선택들에 해당하는 점수만을 반환하도록 부분 문제 정의를 바꾼다.</li><li>재귀 호출의 입력, 파라미터에 이전의 선택에 관한 정보가 있다면, 꼭 필요한 것만 남기고 줄인다.</li><li>문제에 최적 부분 구조가 성립할 경우, 이전 선택에 관련된 정보를 완전히 없앨 수 도 있다. 목표는 가능한 한 중복되는 부분 문제를 많이 만드는 것</li><li>입력의 종류가 줄어들면 줄어들 수 록, 더 많은 부분 문제가 중복되고, 메모이제이션을 최대한 활용할 수 있게 된다.</li><li>입력이 배열이거나 문자열인 경우, 적절한 변환을 통해 메모이제이션을 활용할 수 있도록 한다.</li><li>메모이제이션을 적용한다.</li></ol><h2 id=811-경우의-수와-확률>8.11 경우의 수와 확률<a hidden class=anchor aria-hidden=true href=#811-경우의-수와-확률>#</a></h2><ul><li>동적 계획법은 <strong>경우의 수</strong>를 세거나 <strong>확률</strong>을 계산하는 문제에도 흔하게 사용된다.<ul><li>경우의 수를 새는 경우, <strong>재귀적인 특징</strong>이 있기 때문이다.</li></ul></li></ul><h3 id=8111-타일링-방법의-수-세기-tiling2-난이도-하>8.11.1 타일링 방법의 수 세기, TILING2, 난이도: 하<a hidden class=anchor aria-hidden=true href=#8111-타일링-방법의-수-세기-tiling2-난이도-하>#</a></h3><ul><li>2 x n 사각형을 채우는 모든 방법들은 <strong>맨 왼쪽 세로줄</strong>이 어떻게 채워져 있느냐로 나눌 수 있다.<ul><li>이 두 가지 분류는 타일링 하는 방법을 모두 포함한다.</li><li>두 가지 분류에 모두 포함되는 타일링 방법은 없다.</li></ul></li><li>결과적으로, 더 세지도 않고, 덜 세지도 않는다.<ul><li><code>tiling(n) = tiling(n-1) + tiling(n-2)</code> // <code>타일 1개 사용한 경우 + 타일 2개 사용한 경우</code></li></ul></li></ul><h3 id=8112-경우의-수-계산하기-레시피>8.11.2 경우의 수, 계산하기 레시피<a hidden class=anchor aria-hidden=true href=#8112-경우의-수-계산하기-레시피>#</a></h3><ol><li>모든 답을 직접 만들어서 세어보는 완전 탐색 알고리즘을 설계한다.<ul><li>모든 경우는 이 선택지들에 포함됨 <strong>(덜 세지 않음)</strong></li><li>어떤 경우도 두 개 이상의 선택지에 포함되지 않음 <strong>(더 세지 않음)</strong></li></ul></li><li>최적화 문제를 해결할 때 처럼, 이전 조각에서 결정한 요소들에 대한 입력, 파라미터를 없애거나 변형해서 줄인다.</li><li>재귀 함수는 앞으로 남아 있는 조각들을 고르는 경우의 수만 반환해야 한다.</li><li>메모이제이션을 적용한다.</li></ol><h1 id=reference>Reference<a hidden class=anchor aria-hidden=true href=#reference>#</a></h1><ul><li>프로그래밍 대회에서 배우는 알고리즘 문제 해결 전략 (구종만, 인사이트)</li><li><a href=https://www.algospot.com/>https://www.algospot.com/</a></li></ul></div><footer class=post-footer><ul class=post-tags><li><a href=https://2taezeat.github.io/tags/algorithm/>Algorithm</a></li></ul><nav class=paginav><a class=prev href=https://2taezeat.github.io/posts/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EB%AC%B8%EC%A0%9C-%ED%95%B4%EA%B2%B0-%EC%A0%84%EB%9E%B5/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EB%AC%B8%EC%A0%9C-%ED%95%B4%EA%B2%B0-%EC%A0%84%EB%9E%B5-ch09.-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EC%84%A4%EA%B3%84-%ED%8C%A8%EB%9F%AC%EB%8B%A4%EC%9E%84/><span class=title>« Prev</span><br><span>[알고리즘 문제 해결 전략] ch09. 알고리즘 설계 패러다임</span>
</a><a class=next href=https://2taezeat.github.io/posts/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EB%AC%B8%EC%A0%9C-%ED%95%B4%EA%B2%B0-%EC%A0%84%EB%9E%B5/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EB%AC%B8%EC%A0%9C-%ED%95%B4%EA%B2%B0-%EC%A0%84%EB%9E%B5-ch07.-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EC%84%A4%EA%B3%84-%ED%8C%A8%EB%9F%AC%EB%8B%A4%EC%9E%84/><span class=title>Next »</span><br><span>[알고리즘 문제 해결 전략] ch07. 알고리즘 설계 패러다임</span></a></nav><ul class=share-buttons><li><a target=_blank rel="noopener noreferrer" aria-label="share [알고리즘 문제 해결 전략] ch08. 알고리즘 설계 패러다임 on x" href="https://x.com/intent/tweet/?text=%5b%ec%95%8c%ea%b3%a0%eb%a6%ac%ec%a6%98%20%eb%ac%b8%ec%a0%9c%20%ed%95%b4%ea%b2%b0%20%ec%a0%84%eb%9e%b5%5d%20ch08.%20%ec%95%8c%ea%b3%a0%eb%a6%ac%ec%a6%98%20%ec%84%a4%ea%b3%84%20%ed%8c%a8%eb%9f%ac%eb%8b%a4%ec%9e%84&amp;url=https%3a%2f%2f2taezeat.github.io%2fposts%2f%25EC%2595%258C%25EA%25B3%25A0%25EB%25A6%25AC%25EC%25A6%2598-%25EB%25AC%25B8%25EC%25A0%259C-%25ED%2595%25B4%25EA%25B2%25B0-%25EC%25A0%2584%25EB%259E%25B5%2f%25EC%2595%258C%25EA%25B3%25A0%25EB%25A6%25AC%25EC%25A6%2598-%25EB%25AC%25B8%25EC%25A0%259C-%25ED%2595%25B4%25EA%25B2%25B0-%25EC%25A0%2584%25EB%259E%25B5-ch08.-%25EC%2595%258C%25EA%25B3%25A0%25EB%25A6%25AC%25EC%25A6%2598-%25EC%2584%25A4%25EA%25B3%2584-%25ED%258C%25A8%25EB%259F%25AC%25EB%258B%25A4%25EC%259E%2584%2f&amp;hashtags=Algorithm"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446C483.971.0 512 28.03 512 62.554zM269.951 190.75 182.567 75.216H56L207.216 272.95 63.9 436.783h61.366L235.9 310.383l96.667 126.4H456L298.367 228.367l134-153.151H371.033zM127.633 110h36.468l219.38 290.065H349.5z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share [알고리즘 문제 해결 전략] ch08. 알고리즘 설계 패러다임 on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2f2taezeat.github.io%2fposts%2f%25EC%2595%258C%25EA%25B3%25A0%25EB%25A6%25AC%25EC%25A6%2598-%25EB%25AC%25B8%25EC%25A0%259C-%25ED%2595%25B4%25EA%25B2%25B0-%25EC%25A0%2584%25EB%259E%25B5%2f%25EC%2595%258C%25EA%25B3%25A0%25EB%25A6%25AC%25EC%25A6%2598-%25EB%25AC%25B8%25EC%25A0%259C-%25ED%2595%25B4%25EA%25B2%25B0-%25EC%25A0%2584%25EB%259E%25B5-ch08.-%25EC%2595%258C%25EA%25B3%25A0%25EB%25A6%25AC%25EC%25A6%2598-%25EC%2584%25A4%25EA%25B3%2584-%25ED%258C%25A8%25EB%259F%25AC%25EB%258B%25A4%25EC%259E%2584%2f&amp;title=%5b%ec%95%8c%ea%b3%a0%eb%a6%ac%ec%a6%98%20%eb%ac%b8%ec%a0%9c%20%ed%95%b4%ea%b2%b0%20%ec%a0%84%eb%9e%b5%5d%20ch08.%20%ec%95%8c%ea%b3%a0%eb%a6%ac%ec%a6%98%20%ec%84%a4%ea%b3%84%20%ed%8c%a8%eb%9f%ac%eb%8b%a4%ec%9e%84&amp;summary=%5b%ec%95%8c%ea%b3%a0%eb%a6%ac%ec%a6%98%20%eb%ac%b8%ec%a0%9c%20%ed%95%b4%ea%b2%b0%20%ec%a0%84%eb%9e%b5%5d%20ch08.%20%ec%95%8c%ea%b3%a0%eb%a6%ac%ec%a6%98%20%ec%84%a4%ea%b3%84%20%ed%8c%a8%eb%9f%ac%eb%8b%a4%ec%9e%84&amp;source=https%3a%2f%2f2taezeat.github.io%2fposts%2f%25EC%2595%258C%25EA%25B3%25A0%25EB%25A6%25AC%25EC%25A6%2598-%25EB%25AC%25B8%25EC%25A0%259C-%25ED%2595%25B4%25EA%25B2%25B0-%25EC%25A0%2584%25EB%259E%25B5%2f%25EC%2595%258C%25EA%25B3%25A0%25EB%25A6%25AC%25EC%25A6%2598-%25EB%25AC%25B8%25EC%25A0%259C-%25ED%2595%25B4%25EA%25B2%25B0-%25EC%25A0%2584%25EB%259E%25B5-ch08.-%25EC%2595%258C%25EA%25B3%25A0%25EB%25A6%25AC%25EC%25A6%2598-%25EC%2584%25A4%25EA%25B3%2584-%25ED%258C%25A8%25EB%259F%25AC%25EB%258B%25A4%25EC%259E%2584%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share [알고리즘 문제 해결 전략] ch08. 알고리즘 설계 패러다임 on reddit" href="https://reddit.com/submit?url=https%3a%2f%2f2taezeat.github.io%2fposts%2f%25EC%2595%258C%25EA%25B3%25A0%25EB%25A6%25AC%25EC%25A6%2598-%25EB%25AC%25B8%25EC%25A0%259C-%25ED%2595%25B4%25EA%25B2%25B0-%25EC%25A0%2584%25EB%259E%25B5%2f%25EC%2595%258C%25EA%25B3%25A0%25EB%25A6%25AC%25EC%25A6%2598-%25EB%25AC%25B8%25EC%25A0%259C-%25ED%2595%25B4%25EA%25B2%25B0-%25EC%25A0%2584%25EB%259E%25B5-ch08.-%25EC%2595%258C%25EA%25B3%25A0%25EB%25A6%25AC%25EC%25A6%2598-%25EC%2584%25A4%25EA%25B3%2584-%25ED%258C%25A8%25EB%259F%25AC%25EB%258B%25A4%25EC%259E%2584%2f&title=%5b%ec%95%8c%ea%b3%a0%eb%a6%ac%ec%a6%98%20%eb%ac%b8%ec%a0%9c%20%ed%95%b4%ea%b2%b0%20%ec%a0%84%eb%9e%b5%5d%20ch08.%20%ec%95%8c%ea%b3%a0%eb%a6%ac%ec%a6%98%20%ec%84%a4%ea%b3%84%20%ed%8c%a8%eb%9f%ac%eb%8b%a4%ec%9e%84"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share [알고리즘 문제 해결 전략] ch08. 알고리즘 설계 패러다임 on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2f2taezeat.github.io%2fposts%2f%25EC%2595%258C%25EA%25B3%25A0%25EB%25A6%25AC%25EC%25A6%2598-%25EB%25AC%25B8%25EC%25A0%259C-%25ED%2595%25B4%25EA%25B2%25B0-%25EC%25A0%2584%25EB%259E%25B5%2f%25EC%2595%258C%25EA%25B3%25A0%25EB%25A6%25AC%25EC%25A6%2598-%25EB%25AC%25B8%25EC%25A0%259C-%25ED%2595%25B4%25EA%25B2%25B0-%25EC%25A0%2584%25EB%259E%25B5-ch08.-%25EC%2595%258C%25EA%25B3%25A0%25EB%25A6%25AC%25EC%25A6%2598-%25EC%2584%25A4%25EA%25B3%2584-%25ED%258C%25A8%25EB%259F%25AC%25EB%258B%25A4%25EC%259E%2584%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share [알고리즘 문제 해결 전략] ch08. 알고리즘 설계 패러다임 on whatsapp" href="https://api.whatsapp.com/send?text=%5b%ec%95%8c%ea%b3%a0%eb%a6%ac%ec%a6%98%20%eb%ac%b8%ec%a0%9c%20%ed%95%b4%ea%b2%b0%20%ec%a0%84%eb%9e%b5%5d%20ch08.%20%ec%95%8c%ea%b3%a0%eb%a6%ac%ec%a6%98%20%ec%84%a4%ea%b3%84%20%ed%8c%a8%eb%9f%ac%eb%8b%a4%ec%9e%84%20-%20https%3a%2f%2f2taezeat.github.io%2fposts%2f%25EC%2595%258C%25EA%25B3%25A0%25EB%25A6%25AC%25EC%25A6%2598-%25EB%25AC%25B8%25EC%25A0%259C-%25ED%2595%25B4%25EA%25B2%25B0-%25EC%25A0%2584%25EB%259E%25B5%2f%25EC%2595%258C%25EA%25B3%25A0%25EB%25A6%25AC%25EC%25A6%2598-%25EB%25AC%25B8%25EC%25A0%259C-%25ED%2595%25B4%25EA%25B2%25B0-%25EC%25A0%2584%25EB%259E%25B5-ch08.-%25EC%2595%258C%25EA%25B3%25A0%25EB%25A6%25AC%25EC%25A6%2598-%25EC%2584%25A4%25EA%25B3%2584-%25ED%258C%25A8%25EB%259F%25AC%25EB%258B%25A4%25EC%259E%2584%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share [알고리즘 문제 해결 전략] ch08. 알고리즘 설계 패러다임 on telegram" href="https://telegram.me/share/url?text=%5b%ec%95%8c%ea%b3%a0%eb%a6%ac%ec%a6%98%20%eb%ac%b8%ec%a0%9c%20%ed%95%b4%ea%b2%b0%20%ec%a0%84%eb%9e%b5%5d%20ch08.%20%ec%95%8c%ea%b3%a0%eb%a6%ac%ec%a6%98%20%ec%84%a4%ea%b3%84%20%ed%8c%a8%eb%9f%ac%eb%8b%a4%ec%9e%84&amp;url=https%3a%2f%2f2taezeat.github.io%2fposts%2f%25EC%2595%258C%25EA%25B3%25A0%25EB%25A6%25AC%25EC%25A6%2598-%25EB%25AC%25B8%25EC%25A0%259C-%25ED%2595%25B4%25EA%25B2%25B0-%25EC%25A0%2584%25EB%259E%25B5%2f%25EC%2595%258C%25EA%25B3%25A0%25EB%25A6%25AC%25EC%25A6%2598-%25EB%25AC%25B8%25EC%25A0%259C-%25ED%2595%25B4%25EA%25B2%25B0-%25EC%25A0%2584%25EB%259E%25B5-ch08.-%25EC%2595%258C%25EA%25B3%25A0%25EB%25A6%25AC%25EC%25A6%2598-%25EC%2584%25A4%25EA%25B3%2584-%25ED%258C%25A8%25EB%259F%25AC%25EB%258B%25A4%25EC%259E%2584%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentcolor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share [알고리즘 문제 해결 전략] ch08. 알고리즘 설계 패러다임 on ycombinator" href="https://news.ycombinator.com/submitlink?t=%5b%ec%95%8c%ea%b3%a0%eb%a6%ac%ec%a6%98%20%eb%ac%b8%ec%a0%9c%20%ed%95%b4%ea%b2%b0%20%ec%a0%84%eb%9e%b5%5d%20ch08.%20%ec%95%8c%ea%b3%a0%eb%a6%ac%ec%a6%98%20%ec%84%a4%ea%b3%84%20%ed%8c%a8%eb%9f%ac%eb%8b%a4%ec%9e%84&u=https%3a%2f%2f2taezeat.github.io%2fposts%2f%25EC%2595%258C%25EA%25B3%25A0%25EB%25A6%25AC%25EC%25A6%2598-%25EB%25AC%25B8%25EC%25A0%259C-%25ED%2595%25B4%25EA%25B2%25B0-%25EC%25A0%2584%25EB%259E%25B5%2f%25EC%2595%258C%25EA%25B3%25A0%25EB%25A6%25AC%25EC%25A6%2598-%25EB%25AC%25B8%25EC%25A0%259C-%25ED%2595%25B4%25EA%25B2%25B0-%25EC%25A0%2584%25EB%259E%25B5-ch08.-%25EC%2595%258C%25EA%25B3%25A0%25EB%25A6%25AC%25EC%25A6%2598-%25EC%2584%25A4%25EA%25B3%2584-%25ED%258C%25A8%25EB%259F%25AC%25EB%258B%25A4%25EC%259E%2584%2f"><svg width="30" height="30" viewBox="0 0 512 512" fill="currentcolor" xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"><path d="M449.446.0C483.971.0 512 28.03 512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446zM183.8767 87.9921h-62.034L230.6673 292.4508V424.0079h50.6655V292.4508L390.1575 87.9921H328.1233L256 238.2489z"/></svg></a></li></ul></footer><script src=https://utteranc.es/client.js repo=2taezeat/blog_comment issue-term=pathname label=comment theme=github-light crossorigin=anonymous async></script></article></main><footer class=footer><span>&copy; 2024 <a href=https://2taezeat.github.io/>2taezeat, blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>