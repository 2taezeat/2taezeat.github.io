<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>[알고리즘 문제 해결 전략] ch17. 기초 자료 구조 | 2taezeat, blog</title>
<meta name=keywords content="Algorithm"><meta name=description content="ch17. 부분 합"><meta name=author content="2taezeat"><link rel=canonical href=https://2taezeat.github.io/posts/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EB%AC%B8%EC%A0%9C-%ED%95%B4%EA%B2%B0-%EC%A0%84%EB%9E%B5/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EB%AC%B8%EC%A0%9C-%ED%95%B4%EA%B2%B0-%EC%A0%84%EB%9E%B5-ch17.-%EA%B8%B0%EC%B4%88-%EC%9E%90%EB%A3%8C-%EA%B5%AC%EC%A1%B0/><meta name=google-site-verification content="YaEERzgrvu-ZwPg7gswZdTzRMufkHw3uIH7i8hVal1c"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.cc8105bf49785484525cafc7883272c26982bf06e1663dcfa3b55c3bb3f773b6.css integrity="sha256-zIEFv0l4VIRSXK/HiDJywmmCvwbhZj3Po7VcO7P3c7Y=" rel="preload stylesheet" as=style><link rel=icon href=https://2taezeat.github.io/icon/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://2taezeat.github.io/icon/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://2taezeat.github.io/icon/favicon-32x32.png><link rel=apple-touch-icon href=https://2taezeat.github.io/icon/apple-touch-icon.png><link rel=mask-icon href=https://2taezeat.github.io/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://2taezeat.github.io/posts/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EB%AC%B8%EC%A0%9C-%ED%95%B4%EA%B2%B0-%EC%A0%84%EB%9E%B5/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EB%AC%B8%EC%A0%9C-%ED%95%B4%EA%B2%B0-%EC%A0%84%EB%9E%B5-ch17.-%EA%B8%B0%EC%B4%88-%EC%9E%90%EB%A3%8C-%EA%B5%AC%EC%A1%B0/><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><meta property="og:title" content="[알고리즘 문제 해결 전략] ch17. 기초 자료 구조"><meta property="og:description" content="ch17. 부분 합"><meta property="og:type" content="article"><meta property="og:url" content="https://2taezeat.github.io/posts/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EB%AC%B8%EC%A0%9C-%ED%95%B4%EA%B2%B0-%EC%A0%84%EB%9E%B5/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EB%AC%B8%EC%A0%9C-%ED%95%B4%EA%B2%B0-%EC%A0%84%EB%9E%B5-ch17.-%EA%B8%B0%EC%B4%88-%EC%9E%90%EB%A3%8C-%EA%B5%AC%EC%A1%B0/"><meta property="og:image" content="https://2taezeat.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-01-12T11:30:03+00:00"><meta property="article:modified_time" content="2024-01-12T11:30:03+00:00"><meta property="og:site_name" content="2taezeat, blog"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://2taezeat.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="[알고리즘 문제 해결 전략] ch17. 기초 자료 구조"><meta name=twitter:description content="ch17. 부분 합"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://2taezeat.github.io/posts/"},{"@type":"ListItem","position":2,"name":"[알고리즘 문제 해결 전략] ch17. 기초 자료 구조","item":"https://2taezeat.github.io/posts/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EB%AC%B8%EC%A0%9C-%ED%95%B4%EA%B2%B0-%EC%A0%84%EB%9E%B5/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EB%AC%B8%EC%A0%9C-%ED%95%B4%EA%B2%B0-%EC%A0%84%EB%9E%B5-ch17.-%EA%B8%B0%EC%B4%88-%EC%9E%90%EB%A3%8C-%EA%B5%AC%EC%A1%B0/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"[알고리즘 문제 해결 전략] ch17. 기초 자료 구조","name":"[알고리즘 문제 해결 전략] ch17. 기초 자료 구조","description":"ch17. 부분 합","keywords":["Algorithm"],"articleBody":"17. 부분 합, 누적 합, 구간 합 17.1 도입 누적 합(Cumulative Sum, prefix sum): 배열의 각 위치에 대해 배열의 시작부터 현재 위치까지의 원소의 합을 미리 구해 둔 배열 O(N), 수열의 길이에 선형으로 증가 누적 합(Cumulative Sum)을 미리 구해 두면, list의 특정 구간의 합(range sum)을 O(1)에 구할 수 있다. cumulativeSum[-1] = 0이라 가정할 때, list[a]부터 list[b]까지의 합은 cumulativeSum[b] - cumulativeSum[a-1] 이다. 핵심: O(N) 시간으로 계산한 누적 합을 통해서, 구간 합을 O(1) 시간으로 빠르기 구하기 누적 합(Cumulative Sum) 은 첫 위치가 항상 A[0]으로 고정된, 구간 합(range sum) 이라고 할 수도 있다. 부분 합은 Partial Sum 이라 한다. 수열의 어느 부분의 합을 의미한다. 17.1.2 2차원으로의 확장 누적 합은 2차원 배열에서 A[y1, x1]에서 A[y2, x2]까지의 직사각형 구간의 합을 계산해야 할 때도 유용하다.\ncumulativeSum[y, x]는 (0, 0)을 왼쪽 위 칸, (y, x)를 오른쪽 아래 칸으로 갖는 직사각형 구간에 포함된 원소들의 합\n누적 합을 이용한 구간 합 구하기\n그림에서 굵은 선으로 표시된 구간의 합(range sum) sum(y1, x1, y2, x2) = cumulativeSum[y2, x2] - cumulativeSum[y2, x1 - 1] - cumulativeSum[y1 - 1, x2] + cumulativeSum[y1 - 1, x1 - 1] 17.1.3 예제: 합이 0에 가장 가까운 구간 0 에 가장 가깝다는 말: cumulativeSum[ ]의 두 값의 차이가 가장 적다는 말\n완전 탐색: O(N^2)\n누적 합 이용\n정렬: O(NlogN)\n얻은 누적 합을 이용해서, 인접한 원소들 확인하는 것: O(N)\n총 결과: O(NlogN)\n배열에서 가장 가까운 두 값을 찾기 위한 방법\n이 배열을 정렬한 뒤, 인접한 원소들끼리 확인 Ex) 9, 100, 101, 300, 308 =\u003e (100, 101) 17.2 누적 합(Cumulative Sum), 구간 합(range Sum) 코드 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 lst = [3, 5, 7, 9] N = len(lst) cumulativeSum = [0] for i in range(0, N): # 누적 합 구하기 cumulativeSum.append(cumulativeSum[i] + lst[i]) # [0, 3, 8, 15, 24] # 0 \u003c= leftIdx \u003c rightIdx \u003c N def calRangeSum(lIdx, rIdx): # leftIdx 부터 rightIdx 까지의 합 global cumulativeSum return cumulativeSum[rIdx + 1] - cumulativeSum[lIdx] print(calRangeSum(0, 0)) # 3 print(calRangeSum(0, 1)) # 8 print(calRangeSum(0, 3)) # 24 print(calRangeSum(2, 3)) # 12 print(calRangeSum(3, 3)) # 9 초기에, cumulativeSum = [0] 으로 초기화 해야, 이후 계산이 편해진다.\n‘cumulativeSum[-1] = 0이라 가정’ 에 해당 실제 PS에 누적 합 알고리즘을 쓸 때, 구간 인덱스가 0 or 1부터 인지 꼭 확인해야 한다.\n이 코드는 idx를 기준으로 계산하는 코드이다.\n0 \u003c= leftIdx \u003c rightIdx \u003c N 일반적인 구간 합 레퍼런스는 범위 정수를 기준으로 알려져 있다.\n이 경우에는 calRangeSum(left, right) = cumulativeSum[right - 1] - cumulativeSum[left] 이다. 슬라이딩 윈도우 (Sliding Window) 슬라이딩 윈도우는 고정된 크기의 범위(윈도우) 를 데이터를 순차적으로 이동시키면서, 일정한 구간의 데이터를 효율적으로 처리하는 알고리즘 기법입니다.\n이 방식은 특히 연속적인 구간에서 합계나 최대값, 최소값 등을 구하는 문제에서 자주 사용됩니다.\n핵심 아이디어 슬라이딩 윈도우는 전체 데이터를 처리하지 않고, 고정된 크기의 구간을 한 칸씩 이동하면서 그때그때 구간 내의 값을 업데이트하는 방식입니다.\n구간을 이동할 때, 이전 구간의 값을 활용하여 새로운 구간의 계산을 빠르게 처리할 수 있습니다.\n슬라이딩 윈도우의 활용 상황 연속된 구간의 합을 구하는 문제 최대/최소값을 구하는 문제 부분 배열/문자열의 패턴 매칭 문제 슬라이딩 윈도우의 기본 예시: 연속된 구간의 합을 구하는 문제 예를 들어, 배열에서 크기 k인 구간의 합을 구하는 경우를 생각해보세요. 배열이 [1, 3, 2, 6, 4, 5, 8]이고, k = 3이라면 크기 3인 구간의 합을 차례로 구하고 싶습니다.\n1. Naive 접근법 (비효율적) 모든 구간을 하나씩 새로 계산하는 방법은 다음과 같습니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 public class Main { public static void main(String[] args) { int[] arr = {1, 3, 2, 6, 4, 5, 8}; int k = 3; // 각 구간의 합을 계산 (구간의 시작 인덱스는 i) for (int i = 0; i \u003c= arr.length - k; i++) { int sum = 0; for (int j = i; j \u003c i + k; j++) { sum += arr[j]; } System.out.println(\"Sum of window starting at \" + i + \": \" + sum); } } } 여기서는 각 구간의 합을 구할 때마다 모든 원소를 다시 더하고 있습니다. 이 방법은 시간 복잡도가 O(n*k) 이므로 비효율적입니다. 2. 슬라이딩 윈도우를 이용한 효율적인 방법: 한 번 계산한 구간에서, 구간을 한 칸 오른쪽으로 이동할 때 맨 앞의 값을 빼고, 새로 추가되는 값을 더하는 방식으로 합을 계산하면, 중복 계산을 피할 수 있습니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 fun main() { val arr = arrayOf(1, 3, 2, 6, 4, 5, 8) val k = 3 // 초기 구간의 합 계산 var sum = 0 for (i in 0 until k) { sum += arr[i] } println(\"Initial sum: $sum\") // 슬라이딩 윈도우로 구간을 한 칸씩 이동하면서 합을 업데이트 for (i in 1..arr.size - k) { sum = sum - arr[i - 1] + arr[i + k - 1] println(\"Sum of window starting at $i: $sum\") } } Initial sum: 6 Sum of window starting at 1: 11 Sum of window starting at 2: 12 Sum of window starting at 3: 15 Sum of window starting at 4: 17 슬라이딩 윈도우 활용법: 초기 윈도우 구간을 설정한 후, 구간이 이동할 때마다 이전 구간에서 제외되는 값을 빼고 새롭게 추가되는 값을 더하는 방식으로 계산을 빠르게 업데이트합니다. 이렇게 하면 시간 복잡도가 O(n) 으로 줄어들어, 더 큰 데이터를 효율적으로 처리할 수 있습니다. 활용 예시 1: 최대 구간 합 배열에서 연속된 k개의 요소 중 최대 구간 합을 구하는 문제를 슬라이딩 윈도우로 해결할 수 있습니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 fun main() { val arr = arrayOf(1, 3, 2, 6, 4, 5, 8) val k = 3 // 초기 구간의 합 계산 var maxSum = 0 for (i in 0 until k) { maxSum += arr[i] } var currentSum = maxSum // 슬라이딩 윈도우로 구간을 한 칸씩 이동하면서 최대 구간 합 계산 for (i in 1..arr.size - k) { currentSum = currentSum - arr[i - 1] + arr[i + k - 1] if (currentSum \u003e maxSum) { maxSum = currentSum } } println(\"Maximum sum of any window: $maxSum\") } 활용 예시 2: 문자열에서 부분 문자열의 패턴 매칭 슬라이딩 윈도우는 문자열에서도 유용하게 쓰입니다. 예를 들어, 주어진 문자열에서 특정 길이의 부분 문자열이 패턴에 맞는지 확인하는 문제를 슬라이딩 윈도우로 해결할 수 있습니다.\n슬라이딩 윈도우의 장점: 효율성: 슬라이딩 윈도우는 불필요한 반복 계산을 줄여, 처리 속도를 크게 향상시킵니다. 시간 복잡도: 많은 문제에서 슬라이딩 윈도우 기법을 사용하면, 전체 배열이나 문자열을 매번 새로 계산하는 대신, O(n) 복잡도로 문제를 해결할 수 있습니다. 시간 복잡도 분석 초기 구간 계산:\n슬라이딩 윈도우 기법에서는 먼저 첫 번째 구간에 대한 합을 계산합니다. 이 작업은 구간의 크기 k에 대해 O(k) 의 시간이 소요됩니다. 1 2 3 4 5 // 초기 구간의 합 계산 (O(k)) int sum = 0; for (int i = 0; i \u003c k; i++) { sum += arr[i]; } 구간 이동 및 업데이트:\n이후, 윈도우를 한 칸씩 이동하면서, 이전 구간의 맨 앞 값을 빼고, 새로운 값을 더하는 방식으로 구간 합을 업데이트합니다. 이 작업은 한 번의 이동당 O(1) 의 시간이 소요됩니다. 1 2 3 4 // 슬라이딩 윈도우로 구간을 한 칸씩 이동하면서 합을 업데이트 (O(n - k)) for (int i = 1; i \u003c= arr.length - k; i++) { sum = sum - arr[i - 1] + arr[i + k - 1]; } 전체 배열을 처리:\n슬라이딩 윈도우는 배열을 한 번 순회하는 동안 고정된 크기의 구간을 이동하면서 계산을 수행합니다. 배열 전체의 크기가 n이라면, 전체 시간 복잡도는 O(n) 이 됩니다. 최종 시간 복잡도: 초기 구간 계산: O(k) (구간의 크기 k만큼의 합을 처음에 계산) 구간 이동 및 업데이트: O(n - k) (나머지 n - k개의 구간을 계산) 전체 시간 복잡도: O(n) 즉, 슬라이딩 윈도우는 배열 전체를 한 번 순회하면서 각 구간을 효율적으로 계산하기 때문에, O(n) 의 시간 복잡도로 문제를 해결할 수 있습니다.\nReference 프로그래밍 대회에서 배우는 알고리즘 문제 해결 전략 (구종만, 인사이트) https://www.algospot.com/ ","wordCount":"1263","inLanguage":"en","image":"https://2taezeat.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E","datePublished":"2024-01-12T11:30:03Z","dateModified":"2024-01-12T11:30:03Z","author":{"@type":"Person","name":"2taezeat"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://2taezeat.github.io/posts/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EB%AC%B8%EC%A0%9C-%ED%95%B4%EA%B2%B0-%EC%A0%84%EB%9E%B5/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EB%AC%B8%EC%A0%9C-%ED%95%B4%EA%B2%B0-%EC%A0%84%EB%9E%B5-ch17.-%EA%B8%B0%EC%B4%88-%EC%9E%90%EB%A3%8C-%EA%B5%AC%EC%A1%B0/"},"publisher":{"@type":"Organization","name":"2taezeat, blog","logo":{"@type":"ImageObject","url":"https://2taezeat.github.io/icon/favicon.ico"}}}</script></head><body id=top><header class=header><nav class=nav><div class=logo><a href=https://2taezeat.github.io/ accesskey=h title="2taezeat blog (Alt + H)"><img src=https://2taezeat.github.io/icon/apple-touch-icon.png alt aria-label=logo height=30>2taezeat blog</a><div class=logo-switches></div></div><ul id=menu><li><a href=https://2taezeat.github.io/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://2taezeat.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://2taezeat.github.io/searchs/ title=Search><span>Search</span></a></li><li><a href=https://github.com/2taezeat title=Github><span>Github</span>&nbsp;<svg fill="none" shape-rendering="geometricPrecision" stroke="currentcolor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2.5" viewBox="0 0 24 24" height="12" width="12"><path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"/><path d="M15 3h6v6"/><path d="M10 14 21 3"/></svg></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://2taezeat.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://2taezeat.github.io/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">[알고리즘 문제 해결 전략] ch17. 기초 자료 구조</h1><div class=post-description>ch17. 부분 합</div><div class=post-meta><span title='2024-01-12 11:30:03 +0000 +0000'>2024-01-12</span>&nbsp;·&nbsp;6 min&nbsp;·&nbsp;1263 words&nbsp;·&nbsp;2taezeat</div></header><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#17-부분-합-누적-합-구간-합>17. 부분 합, 누적 합, 구간 합</a><ul><li><a href=#171-도입>17.1 도입</a><ul><li><a href=#1712-2차원으로의-확장>17.1.2 2차원으로의 확장</a></li><li><a href=#1713-예제-합이-0에-가장-가까운-구간>17.1.3 예제: 합이 0에 가장 가까운 구간</a></li></ul></li><li><a href=#172-누적-합cumulative-sum-구간-합range-sum-코드>17.2 누적 합(Cumulative Sum), 구간 합(range Sum) 코드</a></li></ul></li><li><a href=#슬라이딩-윈도우-sliding-window>슬라이딩 윈도우 (Sliding Window)</a><ul><li><ul><li><a href=#핵심-아이디어><strong>핵심 아이디어</strong></a></li><li><a href=#슬라이딩-윈도우의-활용-상황><strong>슬라이딩 윈도우의 활용 상황</strong></a></li><li><a href=#슬라이딩-윈도우의-기본-예시-연속된-구간의-합을-구하는-문제><strong>슬라이딩 윈도우의 기본 예시</strong>: 연속된 구간의 합을 구하는 문제</a><ul><li><a href=#1-naive-접근법-비효율적>1. <strong>Naive 접근법 (비효율적)</strong></a></li><li><a href=#2-슬라이딩-윈도우를-이용한-효율적인-방법>2. <strong>슬라이딩 윈도우를 이용한 효율적인 방법</strong>:</a></li></ul></li><li><a href=#슬라이딩-윈도우-활용법><strong>슬라이딩 윈도우 활용법</strong>:</a></li><li><a href=#활용-예시-1-최대-구간-합><strong>활용 예시 1: 최대 구간 합</strong></a></li><li><a href=#활용-예시-2-문자열에서-부분-문자열의-패턴-매칭><strong>활용 예시 2: 문자열에서 부분 문자열의 패턴 매칭</strong></a></li><li><a href=#슬라이딩-윈도우의-장점><strong>슬라이딩 윈도우의 장점</strong>:</a></li><li><a href=#시간-복잡도-분석>시간 복잡도 분석</a></li><li><a href=#최종-시간-복잡도>최종 시간 복잡도:</a></li></ul></li></ul></li><li><a href=#reference>Reference</a></li></ul></nav></div></details></div><div class=post-content><h1 id=17-부분-합-누적-합-구간-합>17. 부분 합, 누적 합, 구간 합<a hidden class=anchor aria-hidden=true href=#17-부분-합-누적-합-구간-합>#</a></h1><h2 id=171-도입>17.1 도입<a hidden class=anchor aria-hidden=true href=#171-도입>#</a></h2><ul><li><strong>누적 합(Cumulative Sum, prefix sum)</strong>: 배열의 각 위치에 대해 <strong>배열의 시작부터 현재 위치까지의 원소의 합</strong>을 <strong>미리 구해 둔 배열</strong><ul><li>O(N), 수열의 길이에 선형으로 증가</li></ul></li><li><strong>누적 합(Cumulative Sum)을 미리 구해 두면, list의 특정 <code>구간의 합(range sum)</code>을 O(1)에 구할 수 있다.</strong><ul><li>cumulativeSum[-1] = 0이라 가정할 때, <code>list[a]부터 list[b]까지의 합</code>은 <code>cumulativeSum[b] - cumulativeSum[a-1]</code> 이다.</li></ul></li><li><strong>핵심: O(N) 시간으로 계산한 누적 합을 통해서, 구간 합을 O(1) 시간으로 빠르기 구하기</strong></li><li><strong>누적 합(Cumulative Sum)</strong> 은 첫 위치가 항상 <code>A[0]</code>으로 고정된, <strong><code>구간 합(range sum)</code></strong> 이라고 할 수도 있다.</li><li>부분 합은 <strong>Partial Sum</strong> 이라 한다. 수열의 어느 부분의 합을 의미한다.</li></ul><h3 id=1712-2차원으로의-확장>17.1.2 2차원으로의 확장<a hidden class=anchor aria-hidden=true href=#1712-2차원으로의-확장>#</a></h3><ul><li><p>누적 합은 2차원 배열에서 A[y1, x1]에서 A[y2, x2]까지의 직사각형 구간의 합을 계산해야 할 때도 유용하다.</p></li><li><p>cumulativeSum[y, x]는 (0, 0)을 왼쪽 위 칸, (y, x)를 오른쪽 아래 칸으로 갖는 직사각형 구간에 포함된 원소들의 합</p><p><img loading=lazy src=/images/before/image-20240327204330937.png alt=image-20240327204330937.png width=680 height=auto></p></li><li><p><strong>누적 합</strong>을 이용한 <strong>구간 합</strong> 구하기</p><ul><li>그림에서 굵은 선으로 표시된 <strong>구간의 합(range sum)</strong></li><li><code>sum(y1, x1, y2, x2)</code> = <code>cumulativeSum[y2, x2] - cumulativeSum[y2, x1 - 1] - cumulativeSum[y1 - 1, x2] + cumulativeSum[y1 - 1, x1 - 1]</code></li></ul></li></ul><h3 id=1713-예제-합이-0에-가장-가까운-구간>17.1.3 예제: 합이 0에 가장 가까운 구간<a hidden class=anchor aria-hidden=true href=#1713-예제-합이-0에-가장-가까운-구간>#</a></h3><ul><li><p>0 에 가장 가깝다는 말: cumulativeSum[ ]의 두 값의 차이가 가장 적다는 말</p><ul><li><p>완전 탐색: O(N^2)</p></li><li><p>누적 합 이용</p><ul><li><p>정렬: O(NlogN)</p></li><li><p>얻은 누적 합을 이용해서, 인접한 원소들 확인하는 것: O(N)</p></li><li><p>총 결과: O(NlogN)</p></li></ul></li></ul></li><li><p>배열에서 <strong>가장 가까운 두 값</strong>을 찾기 위한 방법</p><ul><li>이 배열을 <strong>정렬한 뒤,</strong> <strong>인접한 원소들끼리</strong> 확인</li><li>Ex) <code>9, 100, 101, 300, 308</code> => (100, 101)</li></ul></li></ul><h2 id=172-누적-합cumulative-sum-구간-합range-sum-코드>17.2 누적 합(Cumulative Sum), 구간 합(range Sum) 코드<a hidden class=anchor aria-hidden=true href=#172-누적-합cumulative-sum-구간-합range-sum-코드>#</a></h2><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=n>lst</span> <span class=o>=</span> <span class=p>[</span><span class=mi>3</span><span class=p>,</span> <span class=mi>5</span><span class=p>,</span> <span class=mi>7</span><span class=p>,</span> <span class=mi>9</span><span class=p>]</span>
</span></span><span class=line><span class=cl><span class=n>N</span> <span class=o>=</span> <span class=nb>len</span><span class=p>(</span><span class=n>lst</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>cumulativeSum</span> <span class=o>=</span> <span class=p>[</span><span class=mi>0</span><span class=p>]</span> 
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>for</span> <span class=n>i</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=mi>0</span><span class=p>,</span> <span class=n>N</span><span class=p>):</span>  <span class=c1># 누적 합 구하기</span>
</span></span><span class=line><span class=cl>    <span class=n>cumulativeSum</span><span class=o>.</span><span class=n>append</span><span class=p>(</span><span class=n>cumulativeSum</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>+</span> <span class=n>lst</span><span class=p>[</span><span class=n>i</span><span class=p>])</span>  <span class=c1># [0, 3, 8, 15, 24]</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 0 &lt;= leftIdx &lt; rightIdx &lt; N</span>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>calRangeSum</span><span class=p>(</span><span class=n>lIdx</span><span class=p>,</span> <span class=n>rIdx</span><span class=p>):</span> <span class=c1># leftIdx 부터 rightIdx 까지의 합</span>
</span></span><span class=line><span class=cl>    <span class=k>global</span> <span class=n>cumulativeSum</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>cumulativeSum</span><span class=p>[</span><span class=n>rIdx</span> <span class=o>+</span> <span class=mi>1</span><span class=p>]</span> <span class=o>-</span> <span class=n>cumulativeSum</span><span class=p>[</span><span class=n>lIdx</span><span class=p>]</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=n>calRangeSum</span><span class=p>(</span><span class=mi>0</span><span class=p>,</span> <span class=mi>0</span><span class=p>))</span> <span class=c1># 3</span>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=n>calRangeSum</span><span class=p>(</span><span class=mi>0</span><span class=p>,</span> <span class=mi>1</span><span class=p>))</span> <span class=c1># 8</span>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=n>calRangeSum</span><span class=p>(</span><span class=mi>0</span><span class=p>,</span> <span class=mi>3</span><span class=p>))</span> <span class=c1># 24</span>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=n>calRangeSum</span><span class=p>(</span><span class=mi>2</span><span class=p>,</span> <span class=mi>3</span><span class=p>))</span> <span class=c1># 12</span>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=n>calRangeSum</span><span class=p>(</span><span class=mi>3</span><span class=p>,</span> <span class=mi>3</span><span class=p>))</span> <span class=c1># 9</span>
</span></span></code></pre></td></tr></table></div></div><ul><li><p>초기에, <code>cumulativeSum = [0]</code> 으로 초기화 해야, 이후 계산이 편해진다.</p><ul><li><em>&lsquo;cumulativeSum[-1] = 0이라 가정&rsquo;</em> 에 해당</li></ul></li><li><p><strong>실제 PS에 누적 합 알고리즘을 쓸 때, 구간 인덱스가 0 or 1부터 인지 꼭 확인해야 한다.</strong></p></li><li><p>이 코드는 <code>idx</code>를 기준으로 계산하는 코드이다.</p><ul><li><code>0 &lt;= leftIdx &lt; rightIdx &lt; N</code></li></ul></li><li><p>일반적인 <strong>구간 합 레퍼런스</strong>는 <code>범위 정수</code>를 기준으로 알려져 있다.</p><ul><li>이 경우에는 <code>calRangeSum(left, right) = cumulativeSum[right - 1] - cumulativeSum[left]</code> 이다.</li></ul></li></ul><h1 id=슬라이딩-윈도우-sliding-window>슬라이딩 윈도우 (Sliding Window)<a hidden class=anchor aria-hidden=true href=#슬라이딩-윈도우-sliding-window>#</a></h1><p>슬라이딩 윈도우는 <strong>고정된 크기의 범위(윈도우)</strong> 를 데이터를 순차적으로 이동시키면서, 일정한 구간의 데이터를 효율적으로 처리하는 알고리즘 기법입니다.</p><p>이 방식은 특히 <strong>연속적인 구간</strong>에서 합계나 최대값, 최소값 등을 구하는 문제에서 자주 사용됩니다.</p><h3 id=핵심-아이디어><strong>핵심 아이디어</strong><a hidden class=anchor aria-hidden=true href=#핵심-아이디어>#</a></h3><p>슬라이딩 윈도우는 전체 데이터를 처리하지 않고, 고정된 크기의 구간을 <strong>한 칸씩 이동</strong>하면서 그때그때 구간 내의 값을 업데이트하는 방식입니다.</p><p>구간을 이동할 때, <strong>이전 구간의 값</strong>을 활용하여 새로운 구간의 계산을 빠르게 처리할 수 있습니다.</p><h3 id=슬라이딩-윈도우의-활용-상황><strong>슬라이딩 윈도우의 활용 상황</strong><a hidden class=anchor aria-hidden=true href=#슬라이딩-윈도우의-활용-상황>#</a></h3><ol><li><strong>연속된 구간의 합을 구하는 문제</strong></li><li><strong>최대/최소값을 구하는 문제</strong></li><li><strong>부분 배열/문자열의 패턴 매칭 문제</strong></li></ol><hr><h3 id=슬라이딩-윈도우의-기본-예시-연속된-구간의-합을-구하는-문제><strong>슬라이딩 윈도우의 기본 예시</strong>: 연속된 구간의 합을 구하는 문제<a hidden class=anchor aria-hidden=true href=#슬라이딩-윈도우의-기본-예시-연속된-구간의-합을-구하는-문제>#</a></h3><p>예를 들어, 배열에서 크기 <code>k</code>인 구간의 합을 구하는 경우를 생각해보세요. 배열이 <code>[1, 3, 2, 6, 4, 5, 8]</code>이고, <code>k = 3</code>이라면 크기 3인 구간의 합을 차례로 구하고 싶습니다.</p><h4 id=1-naive-접근법-비효율적>1. <strong>Naive 접근법 (비효율적)</strong><a hidden class=anchor aria-hidden=true href=#1-naive-접근법-비효율적>#</a></h4><p>모든 구간을 하나씩 새로 계산하는 방법은 다음과 같습니다.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>public</span><span class=w> </span><span class=kd>class</span> <span class=nc>Main</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>public</span><span class=w> </span><span class=kd>static</span><span class=w> </span><span class=kt>void</span><span class=w> </span><span class=nf>main</span><span class=p>(</span><span class=n>String</span><span class=o>[]</span><span class=w> </span><span class=n>args</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=kt>int</span><span class=o>[]</span><span class=w> </span><span class=n>arr</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=p>{</span><span class=n>1</span><span class=p>,</span><span class=w> </span><span class=n>3</span><span class=p>,</span><span class=w> </span><span class=n>2</span><span class=p>,</span><span class=w> </span><span class=n>6</span><span class=p>,</span><span class=w> </span><span class=n>4</span><span class=p>,</span><span class=w> </span><span class=n>5</span><span class=p>,</span><span class=w> </span><span class=n>8</span><span class=p>};</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=kt>int</span><span class=w> </span><span class=n>k</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>3</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=c1>// 각 구간의 합을 계산 (구간의 시작 인덱스는 i)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>for</span><span class=w> </span><span class=p>(</span><span class=kt>int</span><span class=w> </span><span class=n>i</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>0</span><span class=p>;</span><span class=w> </span><span class=n>i</span><span class=w> </span><span class=o>&lt;=</span><span class=w> </span><span class=n>arr</span><span class=p>.</span><span class=na>length</span><span class=w> </span><span class=o>-</span><span class=w> </span><span class=n>k</span><span class=p>;</span><span class=w> </span><span class=n>i</span><span class=o>++</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=kt>int</span><span class=w> </span><span class=n>sum</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>0</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=k>for</span><span class=w> </span><span class=p>(</span><span class=kt>int</span><span class=w> </span><span class=n>j</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>i</span><span class=p>;</span><span class=w> </span><span class=n>j</span><span class=w> </span><span class=o>&lt;</span><span class=w> </span><span class=n>i</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=n>k</span><span class=p>;</span><span class=w> </span><span class=n>j</span><span class=o>++</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=n>sum</span><span class=w> </span><span class=o>+=</span><span class=w> </span><span class=n>arr</span><span class=o>[</span><span class=n>j</span><span class=o>]</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=n>System</span><span class=p>.</span><span class=na>out</span><span class=p>.</span><span class=na>println</span><span class=p>(</span><span class=s>&#34;Sum of window starting at &#34;</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=n>i</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=s>&#34;: &#34;</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=n>sum</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><ul><li>여기서는 각 구간의 합을 구할 때마다 <strong>모든 원소</strong>를 다시 더하고 있습니다. 이 방법은 시간 복잡도가 <strong>O(n*k)</strong> 이므로 비효율적입니다.</li></ul><h4 id=2-슬라이딩-윈도우를-이용한-효율적인-방법>2. <strong>슬라이딩 윈도우를 이용한 효율적인 방법</strong>:<a hidden class=anchor aria-hidden=true href=#2-슬라이딩-윈도우를-이용한-효율적인-방법>#</a></h4><p>한 번 계산한 구간에서, <strong>구간을 한 칸 오른쪽으로 이동</strong>할 때 <strong>맨 앞의 값을 빼고, 새로 추가되는 값을 더하는 방식</strong>으로 합을 계산하면, 중복 계산을 피할 수 있습니다.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-kotlin data-lang=kotlin><span class=line><span class=cl><span class=k>fun</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>val</span> <span class=py>arr</span> <span class=p>=</span> <span class=n>arrayOf</span><span class=p>(</span><span class=m>1</span><span class=p>,</span> <span class=m>3</span><span class=p>,</span> <span class=m>2</span><span class=p>,</span> <span class=m>6</span><span class=p>,</span> <span class=m>4</span><span class=p>,</span> <span class=m>5</span><span class=p>,</span> <span class=m>8</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>val</span> <span class=py>k</span> <span class=p>=</span> <span class=m>3</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// 초기 구간의 합 계산
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>var</span> <span class=py>sum</span> <span class=p>=</span> <span class=m>0</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=p>(</span><span class=n>i</span> <span class=k>in</span> <span class=m>0</span> <span class=n>until</span> <span class=n>k</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>sum</span> <span class=o>+=</span> <span class=n>arr</span><span class=p>[</span><span class=n>i</span><span class=p>]</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=n>println</span><span class=p>(</span><span class=s2>&#34;Initial sum: </span><span class=si>$sum</span><span class=s2>&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// 슬라이딩 윈도우로 구간을 한 칸씩 이동하면서 합을 업데이트
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>for</span> <span class=p>(</span><span class=n>i</span> <span class=k>in</span> <span class=m>1.</span><span class=p>.</span><span class=n>arr</span><span class=p>.</span><span class=n>size</span> <span class=p>-</span> <span class=n>k</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>sum</span> <span class=p>=</span> <span class=n>sum</span> <span class=p>-</span> <span class=n>arr</span><span class=p>[</span><span class=n>i</span> <span class=p>-</span> <span class=m>1</span><span class=p>]</span> <span class=p>+</span> <span class=n>arr</span><span class=p>[</span><span class=n>i</span> <span class=p>+</span> <span class=n>k</span> <span class=p>-</span> <span class=m>1</span><span class=p>]</span>
</span></span><span class=line><span class=cl>        <span class=n>println</span><span class=p>(</span><span class=s2>&#34;Sum of window starting at </span><span class=si>$i</span><span class=s2>: </span><span class=si>$sum</span><span class=s2>&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>Initial</span> <span class=n>sum</span><span class=p>:</span> <span class=m>6</span>
</span></span><span class=line><span class=cl><span class=n>Sum</span> <span class=n>of</span> <span class=n>window</span> <span class=n>starting</span> <span class=n>at</span> <span class=m>1</span><span class=p>:</span> <span class=m>11</span>
</span></span><span class=line><span class=cl><span class=n>Sum</span> <span class=n>of</span> <span class=n>window</span> <span class=n>starting</span> <span class=n>at</span> <span class=m>2</span><span class=p>:</span> <span class=m>12</span>
</span></span><span class=line><span class=cl><span class=n>Sum</span> <span class=n>of</span> <span class=n>window</span> <span class=n>starting</span> <span class=n>at</span> <span class=m>3</span><span class=p>:</span> <span class=m>15</span>
</span></span><span class=line><span class=cl><span class=n>Sum</span> <span class=n>of</span> <span class=n>window</span> <span class=n>starting</span> <span class=n>at</span> <span class=m>4</span><span class=p>:</span> <span class=m>17</span>
</span></span></code></pre></td></tr></table></div></div><h3 id=슬라이딩-윈도우-활용법><strong>슬라이딩 윈도우 활용법</strong>:<a hidden class=anchor aria-hidden=true href=#슬라이딩-윈도우-활용법>#</a></h3><ul><li><strong>초기 윈도우 구간</strong>을 설정한 후, 구간이 이동할 때마다 <strong>이전 구간에서 제외되는 값</strong>을 빼고 <strong>새롭게 추가되는 값</strong>을 더하는 방식으로 계산을 빠르게 업데이트합니다.</li><li>이렇게 하면 시간 복잡도가 <strong>O(n)</strong> 으로 줄어들어, 더 큰 데이터를 효율적으로 처리할 수 있습니다.</li></ul><hr><h3 id=활용-예시-1-최대-구간-합><strong>활용 예시 1: 최대 구간 합</strong><a hidden class=anchor aria-hidden=true href=#활용-예시-1-최대-구간-합>#</a></h3><p>배열에서 연속된 <code>k</code>개의 요소 중 <strong>최대 구간 합</strong>을 구하는 문제를 슬라이딩 윈도우로 해결할 수 있습니다.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-kotlin data-lang=kotlin><span class=line><span class=cl><span class=k>fun</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>val</span> <span class=py>arr</span> <span class=p>=</span> <span class=n>arrayOf</span><span class=p>(</span><span class=m>1</span><span class=p>,</span> <span class=m>3</span><span class=p>,</span> <span class=m>2</span><span class=p>,</span> <span class=m>6</span><span class=p>,</span> <span class=m>4</span><span class=p>,</span> <span class=m>5</span><span class=p>,</span> <span class=m>8</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>val</span> <span class=py>k</span> <span class=p>=</span> <span class=m>3</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// 초기 구간의 합 계산
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>var</span> <span class=py>maxSum</span> <span class=p>=</span> <span class=m>0</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=p>(</span><span class=n>i</span> <span class=k>in</span> <span class=m>0</span> <span class=n>until</span> <span class=n>k</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>maxSum</span> <span class=o>+=</span> <span class=n>arr</span><span class=p>[</span><span class=n>i</span><span class=p>]</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>var</span> <span class=py>currentSum</span> <span class=p>=</span> <span class=n>maxSum</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// 슬라이딩 윈도우로 구간을 한 칸씩 이동하면서 최대 구간 합 계산
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>for</span> <span class=p>(</span><span class=n>i</span> <span class=k>in</span> <span class=m>1.</span><span class=p>.</span><span class=n>arr</span><span class=p>.</span><span class=n>size</span> <span class=p>-</span> <span class=n>k</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>currentSum</span> <span class=p>=</span> <span class=n>currentSum</span> <span class=p>-</span> <span class=n>arr</span><span class=p>[</span><span class=n>i</span> <span class=p>-</span> <span class=m>1</span><span class=p>]</span> <span class=p>+</span> <span class=n>arr</span><span class=p>[</span><span class=n>i</span> <span class=p>+</span> <span class=n>k</span> <span class=p>-</span> <span class=m>1</span><span class=p>]</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=n>currentSum</span> <span class=p>&gt;</span> <span class=n>maxSum</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=n>maxSum</span> <span class=p>=</span> <span class=n>currentSum</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>println</span><span class=p>(</span><span class=s2>&#34;Maximum sum of any window: </span><span class=si>$maxSum</span><span class=s2>&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><h3 id=활용-예시-2-문자열에서-부분-문자열의-패턴-매칭><strong>활용 예시 2: 문자열에서 부분 문자열의 패턴 매칭</strong><a hidden class=anchor aria-hidden=true href=#활용-예시-2-문자열에서-부분-문자열의-패턴-매칭>#</a></h3><p>슬라이딩 윈도우는 문자열에서도 유용하게 쓰입니다. 예를 들어, 주어진 문자열에서 특정 길이의 부분 문자열이 패턴에 맞는지 확인하는 문제를 슬라이딩 윈도우로 해결할 수 있습니다.</p><hr><h3 id=슬라이딩-윈도우의-장점><strong>슬라이딩 윈도우의 장점</strong>:<a hidden class=anchor aria-hidden=true href=#슬라이딩-윈도우의-장점>#</a></h3><ol><li><strong>효율성</strong>: 슬라이딩 윈도우는 불필요한 반복 계산을 줄여, 처리 속도를 크게 향상시킵니다.</li><li><strong>시간 복잡도</strong>: 많은 문제에서 슬라이딩 윈도우 기법을 사용하면, 전체 배열이나 문자열을 매번 새로 계산하는 대신, <strong>O(n)</strong> 복잡도로 문제를 해결할 수 있습니다.</li></ol><h3 id=시간-복잡도-분석>시간 복잡도 분석<a hidden class=anchor aria-hidden=true href=#시간-복잡도-분석>#</a></h3><ol><li><p><strong>초기 구간 계산</strong>:</p><ul><li>슬라이딩 윈도우 기법에서는 먼저 <strong>첫 번째 구간</strong>에 대한 합을 계산합니다. 이 작업은 구간의 크기 <code>k</code>에 대해 <strong>O(k)</strong> 의 시간이 소요됩니다.</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=c1>// 초기 구간의 합 계산 (O(k))</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kt>int</span><span class=w> </span><span class=n>sum</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>0</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>for</span><span class=w> </span><span class=p>(</span><span class=kt>int</span><span class=w> </span><span class=n>i</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>0</span><span class=p>;</span><span class=w> </span><span class=n>i</span><span class=w> </span><span class=o>&lt;</span><span class=w> </span><span class=n>k</span><span class=p>;</span><span class=w> </span><span class=n>i</span><span class=o>++</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>sum</span><span class=w> </span><span class=o>+=</span><span class=w> </span><span class=n>arr</span><span class=o>[</span><span class=n>i</span><span class=o>]</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div></li><li><p><strong>구간 이동 및 업데이트</strong>:</p><ul><li>이후, 윈도우를 <strong>한 칸씩 이동</strong>하면서, 이전 구간의 맨 앞 값을 빼고, 새로운 값을 더하는 방식으로 구간 합을 업데이트합니다. 이 작업은 한 번의 이동당 <strong>O(1)</strong> 의 시간이 소요됩니다.</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=c1>// 슬라이딩 윈도우로 구간을 한 칸씩 이동하면서 합을 업데이트 (O(n - k))</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>for</span><span class=w> </span><span class=p>(</span><span class=kt>int</span><span class=w> </span><span class=n>i</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>1</span><span class=p>;</span><span class=w> </span><span class=n>i</span><span class=w> </span><span class=o>&lt;=</span><span class=w> </span><span class=n>arr</span><span class=p>.</span><span class=na>length</span><span class=w> </span><span class=o>-</span><span class=w> </span><span class=n>k</span><span class=p>;</span><span class=w> </span><span class=n>i</span><span class=o>++</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>sum</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>sum</span><span class=w> </span><span class=o>-</span><span class=w> </span><span class=n>arr</span><span class=o>[</span><span class=n>i</span><span class=w> </span><span class=o>-</span><span class=w> </span><span class=n>1</span><span class=o>]</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=n>arr</span><span class=o>[</span><span class=n>i</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=n>k</span><span class=w> </span><span class=o>-</span><span class=w> </span><span class=n>1</span><span class=o>]</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div></li><li><p><strong>전체 배열을 처리</strong>:</p><ul><li>슬라이딩 윈도우는 배열을 한 번 순회하는 동안 고정된 크기의 구간을 이동하면서 계산을 수행합니다. 배열 전체의 크기가 <code>n</code>이라면, <strong>전체 시간 복잡도는 O(n)</strong> 이 됩니다.</li></ul></li></ol><h3 id=최종-시간-복잡도>최종 시간 복잡도:<a hidden class=anchor aria-hidden=true href=#최종-시간-복잡도>#</a></h3><ul><li><strong>초기 구간 계산</strong>: <code>O(k)</code> (구간의 크기 <code>k</code>만큼의 합을 처음에 계산)</li><li><strong>구간 이동 및 업데이트</strong>: <code>O(n - k)</code> (나머지 <code>n - k</code>개의 구간을 계산)</li><li><strong>전체 시간 복잡도</strong>: <strong>O(n)</strong></li></ul><p>즉, 슬라이딩 윈도우는 배열 전체를 한 번 순회하면서 각 구간을 효율적으로 계산하기 때문에, <strong>O(n)</strong> 의 시간 복잡도로 문제를 해결할 수 있습니다.</p><h1 id=reference>Reference<a hidden class=anchor aria-hidden=true href=#reference>#</a></h1><ul><li>프로그래밍 대회에서 배우는 알고리즘 문제 해결 전략 (구종만, 인사이트)</li><li><a href=https://www.algospot.com/>https://www.algospot.com/</a></li></ul></div><footer class=post-footer><ul class=post-tags><li><a href=https://2taezeat.github.io/tags/algorithm/>Algorithm</a></li></ul><nav class=paginav><a class=prev href=https://2taezeat.github.io/posts/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EB%AC%B8%EC%A0%9C-%ED%95%B4%EA%B2%B0-%EC%A0%84%EB%9E%B5/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EB%AC%B8%EC%A0%9C-%ED%95%B4%EA%B2%B0-%EC%A0%84%EB%9E%B5-ch18.-%EA%B8%B0%EC%B4%88-%EC%9E%90%EB%A3%8C-%EA%B5%AC%EC%A1%B0/><span class=title>« Prev</span><br><span>[알고리즘 문제 해결 전략] ch18. 기초 자료 구조</span>
</a><a class=next href=https://2taezeat.github.io/posts/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EB%AC%B8%EC%A0%9C-%ED%95%B4%EA%B2%B0-%EC%A0%84%EB%9E%B5/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EB%AC%B8%EC%A0%9C-%ED%95%B4%EA%B2%B0-%EC%A0%84%EB%9E%B5-ch16.-%EA%B8%B0%EC%B4%88-%EC%9E%90%EB%A3%8C-%EA%B5%AC%EC%A1%B0/><span class=title>Next »</span><br><span>[알고리즘 문제 해결 전략] ch16. 기초 자료 구조</span></a></nav><ul class=share-buttons><li><a target=_blank rel="noopener noreferrer" aria-label="share [알고리즘 문제 해결 전략] ch17. 기초 자료 구조 on x" href="https://x.com/intent/tweet/?text=%5b%ec%95%8c%ea%b3%a0%eb%a6%ac%ec%a6%98%20%eb%ac%b8%ec%a0%9c%20%ed%95%b4%ea%b2%b0%20%ec%a0%84%eb%9e%b5%5d%20ch17.%20%ea%b8%b0%ec%b4%88%20%ec%9e%90%eb%a3%8c%20%ea%b5%ac%ec%a1%b0&amp;url=https%3a%2f%2f2taezeat.github.io%2fposts%2f%25EC%2595%258C%25EA%25B3%25A0%25EB%25A6%25AC%25EC%25A6%2598-%25EB%25AC%25B8%25EC%25A0%259C-%25ED%2595%25B4%25EA%25B2%25B0-%25EC%25A0%2584%25EB%259E%25B5%2f%25EC%2595%258C%25EA%25B3%25A0%25EB%25A6%25AC%25EC%25A6%2598-%25EB%25AC%25B8%25EC%25A0%259C-%25ED%2595%25B4%25EA%25B2%25B0-%25EC%25A0%2584%25EB%259E%25B5-ch17.-%25EA%25B8%25B0%25EC%25B4%2588-%25EC%259E%2590%25EB%25A3%258C-%25EA%25B5%25AC%25EC%25A1%25B0%2f&amp;hashtags=Algorithm"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446C483.971.0 512 28.03 512 62.554zM269.951 190.75 182.567 75.216H56L207.216 272.95 63.9 436.783h61.366L235.9 310.383l96.667 126.4H456L298.367 228.367l134-153.151H371.033zM127.633 110h36.468l219.38 290.065H349.5z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share [알고리즘 문제 해결 전략] ch17. 기초 자료 구조 on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2f2taezeat.github.io%2fposts%2f%25EC%2595%258C%25EA%25B3%25A0%25EB%25A6%25AC%25EC%25A6%2598-%25EB%25AC%25B8%25EC%25A0%259C-%25ED%2595%25B4%25EA%25B2%25B0-%25EC%25A0%2584%25EB%259E%25B5%2f%25EC%2595%258C%25EA%25B3%25A0%25EB%25A6%25AC%25EC%25A6%2598-%25EB%25AC%25B8%25EC%25A0%259C-%25ED%2595%25B4%25EA%25B2%25B0-%25EC%25A0%2584%25EB%259E%25B5-ch17.-%25EA%25B8%25B0%25EC%25B4%2588-%25EC%259E%2590%25EB%25A3%258C-%25EA%25B5%25AC%25EC%25A1%25B0%2f&amp;title=%5b%ec%95%8c%ea%b3%a0%eb%a6%ac%ec%a6%98%20%eb%ac%b8%ec%a0%9c%20%ed%95%b4%ea%b2%b0%20%ec%a0%84%eb%9e%b5%5d%20ch17.%20%ea%b8%b0%ec%b4%88%20%ec%9e%90%eb%a3%8c%20%ea%b5%ac%ec%a1%b0&amp;summary=%5b%ec%95%8c%ea%b3%a0%eb%a6%ac%ec%a6%98%20%eb%ac%b8%ec%a0%9c%20%ed%95%b4%ea%b2%b0%20%ec%a0%84%eb%9e%b5%5d%20ch17.%20%ea%b8%b0%ec%b4%88%20%ec%9e%90%eb%a3%8c%20%ea%b5%ac%ec%a1%b0&amp;source=https%3a%2f%2f2taezeat.github.io%2fposts%2f%25EC%2595%258C%25EA%25B3%25A0%25EB%25A6%25AC%25EC%25A6%2598-%25EB%25AC%25B8%25EC%25A0%259C-%25ED%2595%25B4%25EA%25B2%25B0-%25EC%25A0%2584%25EB%259E%25B5%2f%25EC%2595%258C%25EA%25B3%25A0%25EB%25A6%25AC%25EC%25A6%2598-%25EB%25AC%25B8%25EC%25A0%259C-%25ED%2595%25B4%25EA%25B2%25B0-%25EC%25A0%2584%25EB%259E%25B5-ch17.-%25EA%25B8%25B0%25EC%25B4%2588-%25EC%259E%2590%25EB%25A3%258C-%25EA%25B5%25AC%25EC%25A1%25B0%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share [알고리즘 문제 해결 전략] ch17. 기초 자료 구조 on reddit" href="https://reddit.com/submit?url=https%3a%2f%2f2taezeat.github.io%2fposts%2f%25EC%2595%258C%25EA%25B3%25A0%25EB%25A6%25AC%25EC%25A6%2598-%25EB%25AC%25B8%25EC%25A0%259C-%25ED%2595%25B4%25EA%25B2%25B0-%25EC%25A0%2584%25EB%259E%25B5%2f%25EC%2595%258C%25EA%25B3%25A0%25EB%25A6%25AC%25EC%25A6%2598-%25EB%25AC%25B8%25EC%25A0%259C-%25ED%2595%25B4%25EA%25B2%25B0-%25EC%25A0%2584%25EB%259E%25B5-ch17.-%25EA%25B8%25B0%25EC%25B4%2588-%25EC%259E%2590%25EB%25A3%258C-%25EA%25B5%25AC%25EC%25A1%25B0%2f&title=%5b%ec%95%8c%ea%b3%a0%eb%a6%ac%ec%a6%98%20%eb%ac%b8%ec%a0%9c%20%ed%95%b4%ea%b2%b0%20%ec%a0%84%eb%9e%b5%5d%20ch17.%20%ea%b8%b0%ec%b4%88%20%ec%9e%90%eb%a3%8c%20%ea%b5%ac%ec%a1%b0"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share [알고리즘 문제 해결 전략] ch17. 기초 자료 구조 on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2f2taezeat.github.io%2fposts%2f%25EC%2595%258C%25EA%25B3%25A0%25EB%25A6%25AC%25EC%25A6%2598-%25EB%25AC%25B8%25EC%25A0%259C-%25ED%2595%25B4%25EA%25B2%25B0-%25EC%25A0%2584%25EB%259E%25B5%2f%25EC%2595%258C%25EA%25B3%25A0%25EB%25A6%25AC%25EC%25A6%2598-%25EB%25AC%25B8%25EC%25A0%259C-%25ED%2595%25B4%25EA%25B2%25B0-%25EC%25A0%2584%25EB%259E%25B5-ch17.-%25EA%25B8%25B0%25EC%25B4%2588-%25EC%259E%2590%25EB%25A3%258C-%25EA%25B5%25AC%25EC%25A1%25B0%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share [알고리즘 문제 해결 전략] ch17. 기초 자료 구조 on whatsapp" href="https://api.whatsapp.com/send?text=%5b%ec%95%8c%ea%b3%a0%eb%a6%ac%ec%a6%98%20%eb%ac%b8%ec%a0%9c%20%ed%95%b4%ea%b2%b0%20%ec%a0%84%eb%9e%b5%5d%20ch17.%20%ea%b8%b0%ec%b4%88%20%ec%9e%90%eb%a3%8c%20%ea%b5%ac%ec%a1%b0%20-%20https%3a%2f%2f2taezeat.github.io%2fposts%2f%25EC%2595%258C%25EA%25B3%25A0%25EB%25A6%25AC%25EC%25A6%2598-%25EB%25AC%25B8%25EC%25A0%259C-%25ED%2595%25B4%25EA%25B2%25B0-%25EC%25A0%2584%25EB%259E%25B5%2f%25EC%2595%258C%25EA%25B3%25A0%25EB%25A6%25AC%25EC%25A6%2598-%25EB%25AC%25B8%25EC%25A0%259C-%25ED%2595%25B4%25EA%25B2%25B0-%25EC%25A0%2584%25EB%259E%25B5-ch17.-%25EA%25B8%25B0%25EC%25B4%2588-%25EC%259E%2590%25EB%25A3%258C-%25EA%25B5%25AC%25EC%25A1%25B0%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share [알고리즘 문제 해결 전략] ch17. 기초 자료 구조 on telegram" href="https://telegram.me/share/url?text=%5b%ec%95%8c%ea%b3%a0%eb%a6%ac%ec%a6%98%20%eb%ac%b8%ec%a0%9c%20%ed%95%b4%ea%b2%b0%20%ec%a0%84%eb%9e%b5%5d%20ch17.%20%ea%b8%b0%ec%b4%88%20%ec%9e%90%eb%a3%8c%20%ea%b5%ac%ec%a1%b0&amp;url=https%3a%2f%2f2taezeat.github.io%2fposts%2f%25EC%2595%258C%25EA%25B3%25A0%25EB%25A6%25AC%25EC%25A6%2598-%25EB%25AC%25B8%25EC%25A0%259C-%25ED%2595%25B4%25EA%25B2%25B0-%25EC%25A0%2584%25EB%259E%25B5%2f%25EC%2595%258C%25EA%25B3%25A0%25EB%25A6%25AC%25EC%25A6%2598-%25EB%25AC%25B8%25EC%25A0%259C-%25ED%2595%25B4%25EA%25B2%25B0-%25EC%25A0%2584%25EB%259E%25B5-ch17.-%25EA%25B8%25B0%25EC%25B4%2588-%25EC%259E%2590%25EB%25A3%258C-%25EA%25B5%25AC%25EC%25A1%25B0%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentcolor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share [알고리즘 문제 해결 전략] ch17. 기초 자료 구조 on ycombinator" href="https://news.ycombinator.com/submitlink?t=%5b%ec%95%8c%ea%b3%a0%eb%a6%ac%ec%a6%98%20%eb%ac%b8%ec%a0%9c%20%ed%95%b4%ea%b2%b0%20%ec%a0%84%eb%9e%b5%5d%20ch17.%20%ea%b8%b0%ec%b4%88%20%ec%9e%90%eb%a3%8c%20%ea%b5%ac%ec%a1%b0&u=https%3a%2f%2f2taezeat.github.io%2fposts%2f%25EC%2595%258C%25EA%25B3%25A0%25EB%25A6%25AC%25EC%25A6%2598-%25EB%25AC%25B8%25EC%25A0%259C-%25ED%2595%25B4%25EA%25B2%25B0-%25EC%25A0%2584%25EB%259E%25B5%2f%25EC%2595%258C%25EA%25B3%25A0%25EB%25A6%25AC%25EC%25A6%2598-%25EB%25AC%25B8%25EC%25A0%259C-%25ED%2595%25B4%25EA%25B2%25B0-%25EC%25A0%2584%25EB%259E%25B5-ch17.-%25EA%25B8%25B0%25EC%25B4%2588-%25EC%259E%2590%25EB%25A3%258C-%25EA%25B5%25AC%25EC%25A1%25B0%2f"><svg width="30" height="30" viewBox="0 0 512 512" fill="currentcolor" xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"><path d="M449.446.0C483.971.0 512 28.03 512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446zM183.8767 87.9921h-62.034L230.6673 292.4508V424.0079h50.6655V292.4508L390.1575 87.9921H328.1233L256 238.2489z"/></svg></a></li></ul></footer><script src=https://utteranc.es/client.js repo=2taezeat/blog_comment issue-term=pathname label=comment theme=github-light crossorigin=anonymous async></script></article></main><footer class=footer><span>&copy; 2024 <a href=https://2taezeat.github.io/>2taezeat, blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>