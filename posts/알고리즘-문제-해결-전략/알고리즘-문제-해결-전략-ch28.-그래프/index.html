<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>[알고리즘 문제 해결 전략] ch28. 그래프 | 2taezeat, blog</title>
<meta name=keywords content="Algorithm"><meta name=description content="ch28. 그래프의 깊이 우선 탐색 (DFS)"><meta name=author content="2taezeat"><link rel=canonical href=https://2taezeat.github.io/posts/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EB%AC%B8%EC%A0%9C-%ED%95%B4%EA%B2%B0-%EC%A0%84%EB%9E%B5/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EB%AC%B8%EC%A0%9C-%ED%95%B4%EA%B2%B0-%EC%A0%84%EB%9E%B5-ch28.-%EA%B7%B8%EB%9E%98%ED%94%84/><meta name=google-site-verification content="YaEERzgrvu-ZwPg7gswZdTzRMufkHw3uIH7i8hVal1c"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.cc8105bf49785484525cafc7883272c26982bf06e1663dcfa3b55c3bb3f773b6.css integrity="sha256-zIEFv0l4VIRSXK/HiDJywmmCvwbhZj3Po7VcO7P3c7Y=" rel="preload stylesheet" as=style><link rel=icon href=https://2taezeat.github.io/icon/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://2taezeat.github.io/icon/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://2taezeat.github.io/icon/favicon-32x32.png><link rel=apple-touch-icon href=https://2taezeat.github.io/icon/apple-touch-icon.png><link rel=mask-icon href=https://2taezeat.github.io/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://2taezeat.github.io/posts/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EB%AC%B8%EC%A0%9C-%ED%95%B4%EA%B2%B0-%EC%A0%84%EB%9E%B5/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EB%AC%B8%EC%A0%9C-%ED%95%B4%EA%B2%B0-%EC%A0%84%EB%9E%B5-ch28.-%EA%B7%B8%EB%9E%98%ED%94%84/><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><meta property="og:title" content="[알고리즘 문제 해결 전략] ch28. 그래프"><meta property="og:description" content="ch28. 그래프의 깊이 우선 탐색 (DFS)"><meta property="og:type" content="article"><meta property="og:url" content="https://2taezeat.github.io/posts/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EB%AC%B8%EC%A0%9C-%ED%95%B4%EA%B2%B0-%EC%A0%84%EB%9E%B5/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EB%AC%B8%EC%A0%9C-%ED%95%B4%EA%B2%B0-%EC%A0%84%EB%9E%B5-ch28.-%EA%B7%B8%EB%9E%98%ED%94%84/"><meta property="og:image" content="https://2taezeat.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-01-23T11:30:03+00:00"><meta property="article:modified_time" content="2024-01-23T11:30:03+00:00"><meta property="og:site_name" content="2taezeat, blog"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://2taezeat.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="[알고리즘 문제 해결 전략] ch28. 그래프"><meta name=twitter:description content="ch28. 그래프의 깊이 우선 탐색 (DFS)"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://2taezeat.github.io/posts/"},{"@type":"ListItem","position":2,"name":"[알고리즘 문제 해결 전략] ch28. 그래프","item":"https://2taezeat.github.io/posts/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EB%AC%B8%EC%A0%9C-%ED%95%B4%EA%B2%B0-%EC%A0%84%EB%9E%B5/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EB%AC%B8%EC%A0%9C-%ED%95%B4%EA%B2%B0-%EC%A0%84%EB%9E%B5-ch28.-%EA%B7%B8%EB%9E%98%ED%94%84/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"[알고리즘 문제 해결 전략] ch28. 그래프","name":"[알고리즘 문제 해결 전략] ch28. 그래프","description":"ch28. 그래프의 깊이 우선 탐색 (DFS)","keywords":["Algorithm"],"articleBody":"28. 그래프의 깊이 우선 탐색 28.1 도입 탐색(search) 알고리즘: 트리의 순회와 같이 그래프의 모든 정점들을 특정헌 순서에 따라 방문하는 알고리즘들 정점들을 정해진 순서대로 둘러보기 위한 알고리즘, 순회 알고리즘 탐색 과정에서 얻는 정보가 아주 중요 탐색 과정에서 어떤 간선이 사용되었는지, 또 어떤 순서로 정점들이 방문되었는지를 통해 그래프의 구조를 알 수 있다. 28.1.1 깊이 우선 탐색(depth-first search) 깊이 우선 탐색(depth-first search, DFS) 는 그래프의 모든 정점을 발견하는 가장 단순하고 고전적인 방법\n깊이 우선 탐색은 그래프의 시작 노드에서 출발하여 탐색할 한 쪽 분기를 정하여 최대 깊이까지 탐색을 마친 후, 다른 쪽 분기로 이동하여 다시 탐색을 수행하는 알고리즘.\n현재 정점과 인접한 간선들을 하나씩 검사하다가, 아직 방문하지 않은 정점으로 향하는 간선이 있다면 그 간선을 무조건 따라간다.\n이 과정에서 더이상 갈 곳이 없는 막힌 정점에 도달하면 포기하고, 마지막에 따라왔던 간선을 따라 뒤로 돌아간다.\n탐색의 각 과정에서 가능한 한 그래프 안으로 ‘깊이’ 들어가려고 시도하며, 막힌 정점에 도달하지 않는 한 뒤로 돌아가지 않는다.\n더 따라갈 간선이 없을 경우 이전으로 돌아간다.\n지금까지 방문한 정점들을 모두 저장(기록) 해야 한다.\n재귀 호출을 이용하면 이와 같은 일을 간단히 할 수 있게 된다.\n‘기본’ 적인 재귀, dfs 코드\n얼마든지 문제에 따라 변형 할 수 있어야 한다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 N = 10 visited = [False for _ in range(N)] graph = [[] for _ in range(N)] result = [] # 방문 순서 def dfs(node): visited[node] = True nxtLst = graph[node] for nxt in nxtLst: if not visited[nxt]: dfs(nxt) # 더 이상 방문할 정점이 없으니, 재귀 호출을 종료하고 이전 정점으로 돌아간다. result.append(node) # 여기서 result는 전역 변수이고, mutable (list) 이다. def dfsAll(): for startNode in range(N): # 모든 정점을 순회하면서, 아직 방문한 적이 없으면 방문한다. if not visited[startNode]: dfs(startNode) dfsAll() ‘기본’ 적인 반복문, dfs 코드 1 2 3 4 5 6 7 8 9 10 11 12 13 vi = set() path = [] def dfsLoop(startNode): stack = [startNode] while stack: nxt = stack.pop() if nxt not in vi: vi.add(nxt) path.append(nxt) for w in graph[nxt]: stack.append(w) 그래프에서는 모든 정점들이 간선을 통해 연결되어 있다는 보장이 없기 때문에, dfs() 만으로는 모든 정점을 순서대로 발견한다는 목적에 부합하지 않는다.\ndfsAll()로 모든 그래프 조각을 발견(탐색)한다.\n깊이 우선 탐색은 그래프 전체의 구조를 파악하기 위해 사용,\n그래프의 구조상 한 번에 모든 정점을 다 볼 수 없는 경우에도 모든 정점을 다 방문할 필요가 있다. =\u003e dfsAll() 28.1.2 깊이 우선 탐색의 시간 복잡도 인접 리스트의 경우\ndfs()는 한 정점마다 수행되므로, 정확히 V번 호출\n모든 정점(V)에 대해 dfs()를 수행하고 나면 모든 간선(E)을 정확히 한 번(방향 그래프의 경우) 혹은 두 번(무향 그래프) 확인함\n따라서 깊이 우선 탐색의 시간 복잡도는 O(V+E)\n인접 행렬을 사용하는 경우에도 dfs()의 호출 횟수는 V번\n하지만, 인접 행렬을 사용할 때는 dfs() 내부에서 다른 모든 정점을 순회하며 두 정점 사이에 간선이 있는가를 확인해야 함 한 번의 dfs() 실행에 O(V)의 시간이 든다 따라서 인접 행렬의 경우 전체 시간 복잡도는 O(V^2) 이다. 28.1.3 위상 정렬 위상 정렬은 의존성이 있는 작업들이 주어질 때, 이들을 어떤 순서로 수행해야 하는지 계산해 준다.\n위상 정렬의 결과는 항상 같지 않다. 구현 방법에 따라 달라진다. 각 작업들을 정점으로 표현하고, 작업 간의 의존 관계를 간선으로 표현한 방향 그래프를 의존성 그래프(dependency graph) 라고 한다.\n의존성 그래프는 그래프에 사이클이 없다. 이 그래프는 사이클이 없는 방향 그래프(DAG) 가 된다. 의존성 그래프의 정점들을 일렬로 늘어놓고, 왼쪽에서부터 하나씩 수행한다고 하자\n이때 모든 의존성이 만족되려면 모든 간선이 왼쪽에서 오른쪽으로 가야 한다. 이렇게 DAG의 정점을 배열하는 문제를 위상 정렬(topological sort) 이라고 한다. 위상 정렬을 구현하는 방법은 dfsAll()을 수행하며 dfs()가 종료할 때마다 현재 정점의 번호를 기록하는 것\ndfsAll() 이 종료한 뒤 기록된 순서를 뒺비으면 위상 정렬 결과를 얻을 수 있다. dfs()가 늦게 종료한 정점일 수록 정렬 결과의 앞에 온다. dfs가 아닌 queue 를 이용한 위상 정렬\n입력 차수, 진입 차수 (In-degree): 방향 그래프에서 한 정점으로 들어오는 간선의 수 출력 차수, 진출 차수 (Out-degree): 방향 그래프에서 한 정점에서 나가는 간선의 수 차수 (degree): 한 정점에서 인접한 간선의 수 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 graph = [[] for _ in range(N)] # 인접 리스트 result = [] indegree = [0] * N # 진입 차수 리스트 q = deque() for i in range(M): S, E = map(int, input().split()) graph[S].append(E) indegree[E] += 1 # 진입 차수 데이터 저장 for i in range(N): if indegree[i] == 0: q.append(i) # 진입 차수 리스트의 값이 0인 노드를 큐에 삽입 while q: # 큐가 빌때 까지, 위상 정렬 수행 now = q.popleft() result.append(now) for nxt in graph[now]: indegree[nxt] -= 1 if indegree[nxt] == 0: q.append(nxt) print(result) 28.2, 28.3 고대어 사전, DICTIONARY, 난이도: 하 각 알파벳을 정점으로 표현, 한 알파벳이 다른 알파벳 앞에 와야 할 때 두 정점을 방향 간선으로 연결 우리가 원하는 알파벳 순서는 이 그래프를 위상 정렬 한 결과 인접한 단어들만 검사하더라도 그래프의 위상 정렬 결과는 모든 단어 쌍을 검사했을 때와 같다. 단어 A, B, C가 순서대로 등장한다면, (A, C)는 검사하지 않고, (A, B), (B, C)쌍 만 검사해도 된다. 그래프가 DAG면 빈 리스트 반환 / 아니면, 위상 정렬 결과 반환 28.7 이론적 배경과 응용 28.7.1 깊이 우선 탐색과 간선의 분류 DFS를 수행하면, 그 과정에서 그래프의 모든 간선을 한 번씩 만나게 된다.\n일부 간선은 처음 발견한 정점으로 따라가고, 나머지는 무시하게 된다.\n그러나 이 간선들을 무시하지 않고 이들에 대한 정보를 수집하면 그래프의 구조에 대해 많은 것을 알 수 있다. 탐색이 따라가는 간선들만 모아 보면 트리 형태를 띠게 된다.\n이런 트리를 주어진 그래프의 DFS 스패닝 트리(DFS Spanning Tree) 라고 부른다. DFS 스패닝 트리를 생성하면, 그래프 중 모든 간선을 네 가지 중 하나로 분류 할 수 있다. 간선 분류\n트리 간선(tree edge): 스패닝 트리에 포함된 간선\n순방향 간선(forward edge): 스패닝 트리의 선조에서 자손으로 연겨되지만 트리 간선이 아닌 간선\n역방향 간선(back edge): 스패닝 트리의 자손에서 선조로 연결되는 간선\n교차 간선(cross edge): 1.2.3번 3가지 를 제외한 나머지 간선들,\n교차 간선은 트리에서 선조와 자손 관계가 아닌 정점들 간에 연결된 간선들을 의미 그래프의 간선을 항상 4가지 중 하나로 분류해야 하는 것은 아니다.\n깊이 우선 탐색이 어느 순서대로 정점을 방문하느냐(실제 구현 방법)에 따라 서로 다른 트리가 생성될 수 있다.\n무향 그래프 간선의 분류\n무향 그래프는 교차 간선, 순방향, 역방향 간선의 구분이 있을 수 없다. 28.7.2 사이클 존재 여부 확인 간선 구분 의 사용 예시, 방향 그래프에 사이클이 존재하는지 여부를 판정 ‘사이클의 존재 여부’는 ‘역방향 간선 존재 여부’ 와 동치 사이클에 포함된 정점 중 dfs 에서 처음 만나는 정점을 u라고 할 때, dfs(u)는 u에서 갈 수 있는 정점들을 모두 방문한 후에야 종료한다. 따라서, dfs는 사이클에서 u 이전에 있는 정점을 dfs(u)가 종료하기 전에 방문하게 되는데, 이 정점에서 u로가는 정점은 항상 역방향 간선이 된다. 28.7.3 간선 구분하는 방법 정점이 방문할 때 이 정점이 방문되었다는 사실 뿐만 아니라, 이 정점이 몇 번째로 발견되었는지도 동시에 기록\n탐색 과정에서 각 정점을 몇 번째로 발견했는지를 배열 discovered[] 에 저장\n(u, v)가 순방향 간선 이려면, v는 u의 자손, 따라서 v는 u보다 더 늦게 발견되어야 한다. (u, v)가 역방향 간선 이려면 v는 u의 선조, 따라서 v는 u보다 일찍 발견되어야 한다. (u, v)가 교차 간선 이려면, dfs(v)가 종류한 후 dfs(u)가 호출되어야 한다. 따라서 v는 u보다 일찍 발견되어야 한다. 이처럼 발견 순서 정보를 이용하면 해당 간선이 순방향 간선인지를 알아낼 수 있다.\n반면 v가 u보다 먼저 방문되었다면 v가 u의 부모인지 아닌지를 구분할 방법이 없다.\n이때 구분하는 한 가지 방법은 dfs(v)가 종료햇는지를 확인하는 것\ndfs(v)가 아직 종료하지 않았다면 v는 u의 선조 및 (u, v)는 역뱡향 간선\n아니면 교차 간선\n간선을 구분하는 깊이 우선 탐색 알고리즘 python 구현\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 N = 10 discovered = [-1 for _ in range(N)] # i번 정점의 발견 순서 finished = [False for _ in range(N)] # dfs가 종료했으면 True 아니면 False graph = [[] for _ in range(N)] result = dict() counter = 0 # 지금까지 발견한 정점의 수 def dfsForEdgesType(node): global counter counter += 1 discovered[node] = counter # 발견 순서 기록 nxtLst = graph[node] for nxt in nxtLst: if discovered[nxt] == -1: result[node] = \"tree edge\" dfsForEdgesType(nxt) elif discovered[node] \u003c discovered[node]: result[node] = \"forward edge\" elif not finished[nxt]: result[node] = \"backward edge\" else: result[node] = \"cross edge\" finished[node] = True 28.7.3 예제: 절단점 찾기 알고리즘 그래프의 절단점(cut vertex) 를 찾는 문제 - DFS를 이용해서 풀 수 있는 응용 문제 중 하나\n무향 그래프의 절단점: 인접한 간선들을 모두 지웠을 때 해당 컴포넌트가 두 개 이상으로 나뉘어지는 정점을 말한다.\n1, 3, 5번이 절단점이 된다. 어떤 정점이 절단점인지 확인하는 간단한 방법은 해당 정점을 그래프에서 삭제한 뒤, 컴포넌트의 개수가 이전보다 늘어났는지를 확인하는 것\n모든 정점의 절단점 여부를 확인하려면, 깊이 우선 탐색을 V번 수행\n그러나 탐색 과정에서 얻는 정보를 잘 이용하면 한 번의 깊이 우선 탐색만으로 그래프의 모든 절단점을 찾을 수 있다.\n​\n임의의 정점에서 DFS를 수행해 DFS 스패닝 트리를 얻는다.\n어떤 정점 u 가 절단점인지 알 수 있는 방법\n그래프가 쪼개지지 않는 유일한 경우는 그림 처럼 u의 선조와 자손들이 전부 역뱡향 간선으로 연결되어 있을 때 뿐이다. 이것을 확인하는 방법은 DFS를 수행하는 dfs2()가 각 정점을 루트로 하는 서브트레엇 역뱡향 간선을 통해 갈 수 있는 정점의 최소 깊이를 반환하도록 하는 것 만약 u의 자손들이 모두 역방향 간선을 통해 u의 선조로 올라갈 수 있다면 u는 절단점이 아니다. u가 스패닝 트리의 루트라서 선조가 없다면 어떻게 될까?\nu는 무조건 절단점이라고 생각하기 쉽지만, 간과하기 쉬운 예외가 있다. 바로 자손이 하나도 없거나 하나밖에 없는 경우다. 이 경우 u가 없어져도 그래프는 쪼개지지 않는다. 따라서 u가 루트인 경우 둘 이상의 자손을 가질 때만 절단점이 된다. 실제로 이 알고리즘을 구현할 때는 각 정점의 깊이를 비굔하는 대신, 각 정점의 발견 순서를 비교하는 형태로 코드를 작성해 간단히 구현할 수 있다.\n알고 싶은 것은 해당 서브트리가 u의 조상 중 하나와 연결되어 있는지인데, u의 조상들은 항상 u보다 먼저 발견된다. 따라서, 깊이 우선 탐색 함수가 해당 정점을 루트로 하는 서브트리에서 역방향 간선을 통해 닿는 정점들의 최소 발견 순서를 반환하면 된다. 무향 그래프에서 절단점을 찾는 알고리즘 python 구현\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 N = 10 discovered = [-1 for _ in range(N)] # i번 정점의 발견 순서 finished = [False for _ in range(N)] # dfs가 종료했으면 True 아니면 False isCutVertex = [False for _ in range(N)] # True면 절단점 graph = [[] for _ in range(N)] result = dict() counter = 0 # 지금까지 발견한 정점의 수 # node를 루트로 하는 서브트리에 있는 절단점들을 찾는다 # 반환 값은 해당 서브트리에서 역방향 간선으로 갈 수 있는 정점 중, 가장 일찍 발견된 정점의 발견 시점 # 처음 호출 할때는 isRoot = True 로 둔다. def findCutVertex(node, isRoot): global counter counter += 1 discovered[node] = counter ret = discovered[node] children = 0 nxtLst = graph[node] for nxt in nxtLst: if discovered[nxt] == -1: children += 1 # 루트인 경우의 절단점 판정을 위해 자손 서브트리의 개수를 샌다. subTreeMaxNode = findCutVertex(nxt, False) # 서브 트리에서 갈 수 있는 가장 높은 정점의 번호 ret = min(ret, subTreeMaxNode) if not isRoot and subTreeMaxNode \u003e= discovered[node]: # 그 노드가 자기 자신의 이하에 있다면 현재 위치는 절단점이다. isCutVertex[node] = True else: ret = min(ret, discovered[nxt]) if isRoot: isCutVertex[node] = (children \u003e= 2) # 루트인 경우 절단점 판정은 서브트리의 개수 return ret 무향 그래프에서 절단점을 포함하지 않는 서브 그래프를 이중 결합 컴포넌트(biconnected component) 라고 부른다.\nReference 프로그래밍 대회에서 배우는 알고리즘 문제 해결 전략 (구종만, 인사이트) https://www.algospot.com/ ","wordCount":"1823","inLanguage":"en","image":"https://2taezeat.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E","datePublished":"2024-01-23T11:30:03Z","dateModified":"2024-01-23T11:30:03Z","author":{"@type":"Person","name":"2taezeat"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://2taezeat.github.io/posts/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EB%AC%B8%EC%A0%9C-%ED%95%B4%EA%B2%B0-%EC%A0%84%EB%9E%B5/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EB%AC%B8%EC%A0%9C-%ED%95%B4%EA%B2%B0-%EC%A0%84%EB%9E%B5-ch28.-%EA%B7%B8%EB%9E%98%ED%94%84/"},"publisher":{"@type":"Organization","name":"2taezeat, blog","logo":{"@type":"ImageObject","url":"https://2taezeat.github.io/icon/favicon.ico"}}}</script></head><body id=top><header class=header><nav class=nav><div class=logo><a href=https://2taezeat.github.io/ accesskey=h title="2taezeat blog (Alt + H)"><img src=https://2taezeat.github.io/icon/apple-touch-icon.png alt aria-label=logo height=30>2taezeat blog</a><div class=logo-switches></div></div><ul id=menu><li><a href=https://2taezeat.github.io/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://2taezeat.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://2taezeat.github.io/searchs/ title=Search><span>Search</span></a></li><li><a href=https://github.com/2taezeat title=Github><span>Github</span>&nbsp;<svg fill="none" shape-rendering="geometricPrecision" stroke="currentcolor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2.5" viewBox="0 0 24 24" height="12" width="12"><path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"/><path d="M15 3h6v6"/><path d="M10 14 21 3"/></svg></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://2taezeat.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://2taezeat.github.io/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">[알고리즘 문제 해결 전략] ch28. 그래프</h1><div class=post-description>ch28. 그래프의 깊이 우선 탐색 (DFS)</div><div class=post-meta><span title='2024-01-23 11:30:03 +0000 +0000'>2024-01-23</span>&nbsp;·&nbsp;9 min&nbsp;·&nbsp;1823 words&nbsp;·&nbsp;2taezeat</div></header><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#28-그래프의-깊이-우선-탐색>28. 그래프의 깊이 우선 탐색</a><ul><li><a href=#281-도입>28.1 도입</a><ul><li><a href=#2811-깊이-우선-탐색depth-first-search>28.1.1 깊이 우선 탐색(depth-first search)</a></li><li><a href=#2812-깊이-우선-탐색의-시간-복잡도>28.1.2 깊이 우선 탐색의 시간 복잡도</a></li><li><a href=#2813-위상-정렬>28.1.3 위상 정렬</a></li></ul></li><li><a href=#282-283--고대어-사전-dictionary-난이도-하>28.2, 28.3 고대어 사전, DICTIONARY, 난이도: 하</a></li><li><a href=#287-이론적-배경과-응용>28.7 이론적 배경과 응용</a><ul><li><a href=#2871-깊이-우선-탐색과-간선의-분류>28.7.1 깊이 우선 탐색과 간선의 분류</a></li><li><a href=#2872-사이클-존재-여부-확인>28.7.2 사이클 존재 여부 확인</a></li><li><a href=#2873-간선-구분하는-방법>28.7.3 <code>간선 구분</code>하는 방법</a></li><li><a href=#2873-예제-절단점-찾기-알고리즘>28.7.3 예제: 절단점 찾기 알고리즘</a></li></ul></li></ul></li><li><a href=#reference>Reference</a></li></ul></nav></div></details></div><div class=post-content><h1 id=28-그래프의-깊이-우선-탐색>28. 그래프의 깊이 우선 탐색<a hidden class=anchor aria-hidden=true href=#28-그래프의-깊이-우선-탐색>#</a></h1><h2 id=281-도입>28.1 도입<a hidden class=anchor aria-hidden=true href=#281-도입>#</a></h2><ul><li>탐색(search) 알고리즘: 트리의 순회와 같이 그래프의 모든 정점들을 특정헌 순서에 따라 방문하는 알고리즘들<ul><li>정점들을 정해진 순서대로 둘러보기 위한 알고리즘, 순회 알고리즘</li></ul></li><li>탐색 <strong>과정에서 얻는 정보</strong>가 아주 중요<ul><li>탐색 과정에서 <strong>어떤 간선이 사용</strong>되었는지, 또 <strong>어떤 순서로 정점들이 방문</strong>되었는지를 통해 그래프의 구조를 알 수 있다.</li></ul></li></ul><h3 id=2811-깊이-우선-탐색depth-first-search>28.1.1 깊이 우선 탐색(depth-first search)<a hidden class=anchor aria-hidden=true href=#2811-깊이-우선-탐색depth-first-search>#</a></h3><ul><li><p><strong>깊이 우선 탐색(depth-first search, DFS)</strong> 는 그래프의 모든 정점을 발견하는 가장 단순하고 고전적인 방법</p><ul><li><p>깊이 우선 탐색은 그래프의 시작 노드에서 출발하여 탐색할 <strong>한 쪽 분기를 정하여 최대 깊이까지 탐색</strong>을 마친 후, <strong>다른 쪽 분기로 이동</strong>하여 다시 탐색을 수행하는 알고리즘.</p></li><li><p>현재 정점과 인접한 간선들을 하나씩 검사하다가, 아직 방문하지 않은 정점으로 향하는 간선이 있다면 그 간선을 무조건 따라간다.</p></li><li><p>이 과정에서 더이상 갈 곳이 없는 막힌 정점에 도달하면 포기하고, 마지막에 따라왔던 간선을 따라 뒤로 돌아간다.</p></li><li><p>탐색의 각 과정에서 가능한 한 그래프 안으로 &lsquo;깊이&rsquo; 들어가려고 시도하며, 막힌 정점에 도달하지 않는 한 뒤로 돌아가지 않는다.</p></li><li><p>더 따라갈 간선이 없을 경우 <strong>이전으로 돌아간다.</strong></p></li><li><p>지금까지 <strong>방문한 정점</strong>들을 모두 <strong>저장(기록)</strong> 해야 한다.</p></li><li><p>재귀 호출을 이용하면 이와 같은 일을 간단히 할 수 있게 된다.</p><p><img loading=lazy src=/images/before/image-20240422163839145.png alt=image-20240422163839145.png width=680 height=auto></p></li></ul></li><li><p><strong>&lsquo;기본&rsquo;</strong> 적인 재귀, dfs 코드</p></li><li><p>얼마든지 문제에 따라 변형 할 수 있어야 한다.</p></li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=n>N</span> <span class=o>=</span> <span class=mi>10</span>
</span></span><span class=line><span class=cl><span class=n>visited</span> <span class=o>=</span> <span class=p>[</span><span class=kc>False</span> <span class=k>for</span> <span class=n>_</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=n>N</span><span class=p>)]</span>
</span></span><span class=line><span class=cl><span class=n>graph</span> <span class=o>=</span> <span class=p>[[]</span> <span class=k>for</span> <span class=n>_</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=n>N</span><span class=p>)]</span>
</span></span><span class=line><span class=cl><span class=n>result</span> <span class=o>=</span> <span class=p>[]</span> <span class=c1># 방문 순서</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>dfs</span><span class=p>(</span><span class=n>node</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=n>visited</span><span class=p>[</span><span class=n>node</span><span class=p>]</span> <span class=o>=</span> <span class=kc>True</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>nxtLst</span> <span class=o>=</span> <span class=n>graph</span><span class=p>[</span><span class=n>node</span><span class=p>]</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=n>nxt</span> <span class=ow>in</span> <span class=n>nxtLst</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=ow>not</span> <span class=n>visited</span><span class=p>[</span><span class=n>nxt</span><span class=p>]:</span>
</span></span><span class=line><span class=cl>            <span class=n>dfs</span><span class=p>(</span><span class=n>nxt</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1># 더 이상 방문할 정점이 없으니, 재귀 호출을 종료하고 이전 정점으로 돌아간다.</span>
</span></span><span class=line><span class=cl>    <span class=n>result</span><span class=o>.</span><span class=n>append</span><span class=p>(</span><span class=n>node</span><span class=p>)</span> <span class=c1># 여기서 result는 전역 변수이고, mutable (list) 이다.</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>dfsAll</span><span class=p>():</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=n>startNode</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=n>N</span><span class=p>):</span> <span class=c1># 모든 정점을 순회하면서, 아직 방문한 적이 없으면 방문한다.</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=ow>not</span> <span class=n>visited</span><span class=p>[</span><span class=n>startNode</span><span class=p>]:</span>
</span></span><span class=line><span class=cl>            <span class=n>dfs</span><span class=p>(</span><span class=n>startNode</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>dfsAll</span><span class=p>()</span>
</span></span></code></pre></td></tr></table></div></div><ul><li><strong>&lsquo;기본&rsquo;</strong> 적인 반복문, dfs 코드</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=n>vi</span> <span class=o>=</span> <span class=nb>set</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=n>path</span> <span class=o>=</span> <span class=p>[]</span>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>dfsLoop</span><span class=p>(</span><span class=n>startNode</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=n>stack</span> <span class=o>=</span> <span class=p>[</span><span class=n>startNode</span><span class=p>]</span>
</span></span><span class=line><span class=cl>    <span class=k>while</span> <span class=n>stack</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=n>nxt</span> <span class=o>=</span> <span class=n>stack</span><span class=o>.</span><span class=n>pop</span><span class=p>()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=n>nxt</span> <span class=ow>not</span> <span class=ow>in</span> <span class=n>vi</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=n>vi</span><span class=o>.</span><span class=n>add</span><span class=p>(</span><span class=n>nxt</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=n>path</span><span class=o>.</span><span class=n>append</span><span class=p>(</span><span class=n>nxt</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            
</span></span><span class=line><span class=cl>            <span class=k>for</span> <span class=n>w</span> <span class=ow>in</span> <span class=n>graph</span><span class=p>[</span><span class=n>nxt</span><span class=p>]:</span>
</span></span><span class=line><span class=cl>                <span class=n>stack</span><span class=o>.</span><span class=n>append</span><span class=p>(</span><span class=n>w</span><span class=p>)</span>
</span></span></code></pre></td></tr></table></div></div><ul><li><p>그래프에서는 모든 정점들이 간선을 통해 연결되어 있다는 보장이 없기 때문에, <code>dfs()</code> 만으로는 모든 정점을 순서대로 발견한다는 목적에 부합하지 않는다.</p><ul><li><p><code>dfsAll()</code>로 모든 그래프 조각을 발견(탐색)한다.</p><p><img loading=lazy src=/images/before/image-20240422163920221.png alt=image-20240422163920221.png width=680 height=auto></p></li></ul></li><li><p>깊이 우선 탐색은 그래프 전체의 구조를 파악하기 위해 사용,</p><ul><li>그래프의 구조상 한 번에 모든 정점을 다 볼 수 없는 경우에도 모든 정점을 다 방문할 필요가 있다. => <code>dfsAll()</code></li></ul></li></ul><h3 id=2812-깊이-우선-탐색의-시간-복잡도>28.1.2 깊이 우선 탐색의 시간 복잡도<a hidden class=anchor aria-hidden=true href=#2812-깊이-우선-탐색의-시간-복잡도>#</a></h3><ul><li><p><strong>인접 리스트</strong>의 경우</p><ul><li><p><code>dfs()</code>는 한 정점마다 수행되므로, 정확히 <strong>V번 호출</strong></p></li><li><p>모든 정점(V)에 대해 <code>dfs()</code>를 수행하고 나면 모든 간선(E)을 <strong>정확히 한 번(방향 그래프의 경우) 혹은 두 번(무향 그래프)</strong> 확인함</p></li><li><p>따라서 깊이 우선 탐색의 시간 복잡도는 <strong>O(V+E)</strong></p></li></ul></li><li><p><strong>인접 행렬</strong>을 사용하는 경우에도 dfs()의 호출 횟수는 V번</p><ul><li>하지만, 인접 행렬을 사용할 때는 dfs() 내부에서 <strong>다른 모든 정점을 순회하며 두 정점 사이에 간선</strong>이 있는가를 확인해야 함</li><li>한 번의 <code>dfs()</code> 실행에 O(V)의 시간이 든다</li><li>따라서 인접 행렬의 경우 전체 시간 복잡도는 <strong>O(V^2)</strong> 이다.</li></ul></li></ul><h3 id=2813-위상-정렬>28.1.3 위상 정렬<a hidden class=anchor aria-hidden=true href=#2813-위상-정렬>#</a></h3><p><img loading=lazy src=/images/before/image-20240422163948203.png alt=image-20240422163948203.png width=680 height=auto></p><p><img loading=lazy src=/images/before/image-20240422164008876.png alt=image-20240422164008876.png width=680 height=auto></p><p><img loading=lazy src=/images/before/image-20240422165340695.png alt=image-20240422165340695.png width=680 height=auto></p><ul><li><p>위상 정렬은 <strong>의존성</strong>이 있는 작업들이 주어질 때, 이들을 어떤 순서로 수행해야 하는지 계산해 준다.</p><ul><li>위상 정렬의 결과는 항상 같지 않다. 구현 방법에 따라 달라진다.</li></ul></li><li><p>각 작업들을 정점으로 표현하고, 작업 간의 의존 관계를 간선으로 표현한 방향 그래프를 <strong>의존성 그래프(dependency graph)</strong> 라고 한다.</p><ul><li>의존성 그래프는 그래프에 사이클이 없다.</li><li>이 그래프는 <strong>사이클이 없는 방향 그래프(DAG)</strong> 가 된다.</li></ul></li><li><p>의존성 그래프의 정점들을 일렬로 늘어놓고, 왼쪽에서부터 하나씩 수행한다고 하자</p><ul><li>이때 모든 <strong>의존성</strong>이 만족되려면 모든 간선이 왼쪽에서 오른쪽으로 가야 한다.</li><li>이렇게 DAG의 정점을 배열하는 문제를 <strong>위상 정렬(topological sort)</strong> 이라고 한다.</li></ul></li><li><p><strong>위상 정렬</strong>을 구현하는 방법은 <code>dfsAll()</code>을 수행하며 <code>dfs()</code>가 종료할 때마다 현재 정점의 번호를 기록하는 것</p><ul><li><code>dfsAll()</code> 이 종료한 뒤 기록된 순서를 뒺비으면 위상 정렬 결과를 얻을 수 있다.</li><li><code>dfs()</code>가 늦게 종료한 정점일 수록 정렬 결과의 앞에 온다.</li></ul></li><li><p><strong>dfs</strong>가 아닌 <strong>queue</strong> 를 이용한 <strong>위상 정렬</strong></p><ul><li><strong>입력 차수, 진입 차수 (In-degree)</strong>: 방향 그래프에서 한 정점으로 들어오는 간선의 수</li><li><strong>출력 차수, 진출 차수 (Out-degree)</strong>: 방향 그래프에서 한 정점에서 나가는 간선의 수</li><li>차수 (degree): 한 정점에서 인접한 간선의 수</li></ul></li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=n>graph</span> <span class=o>=</span> <span class=p>[[]</span> <span class=k>for</span> <span class=n>_</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=n>N</span><span class=p>)]</span>  <span class=c1># 인접 리스트</span>
</span></span><span class=line><span class=cl><span class=n>result</span> <span class=o>=</span> <span class=p>[]</span>
</span></span><span class=line><span class=cl><span class=n>indegree</span> <span class=o>=</span> <span class=p>[</span><span class=mi>0</span><span class=p>]</span> <span class=o>*</span> <span class=n>N</span>  <span class=c1># 진입 차수 리스트</span>
</span></span><span class=line><span class=cl><span class=n>q</span> <span class=o>=</span> <span class=n>deque</span><span class=p>()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>for</span> <span class=n>i</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=n>M</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=n>S</span><span class=p>,</span> <span class=n>E</span> <span class=o>=</span> <span class=nb>map</span><span class=p>(</span><span class=nb>int</span><span class=p>,</span> <span class=nb>input</span><span class=p>()</span><span class=o>.</span><span class=n>split</span><span class=p>())</span>
</span></span><span class=line><span class=cl>    <span class=n>graph</span><span class=p>[</span><span class=n>S</span><span class=p>]</span><span class=o>.</span><span class=n>append</span><span class=p>(</span><span class=n>E</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>indegree</span><span class=p>[</span><span class=n>E</span><span class=p>]</span> <span class=o>+=</span> <span class=mi>1</span>  <span class=c1># 진입 차수 데이터 저장</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>for</span> <span class=n>i</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=n>N</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=n>indegree</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>==</span> <span class=mi>0</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=n>q</span><span class=o>.</span><span class=n>append</span><span class=p>(</span><span class=n>i</span><span class=p>)</span>  <span class=c1># 진입 차수 리스트의 값이 0인 노드를 큐에 삽입</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>while</span> <span class=n>q</span><span class=p>:</span>  <span class=c1># 큐가 빌때 까지, 위상 정렬 수행</span>
</span></span><span class=line><span class=cl>    <span class=n>now</span> <span class=o>=</span> <span class=n>q</span><span class=o>.</span><span class=n>popleft</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=n>result</span><span class=o>.</span><span class=n>append</span><span class=p>(</span><span class=n>now</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=n>nxt</span> <span class=ow>in</span> <span class=n>graph</span><span class=p>[</span><span class=n>now</span><span class=p>]:</span>
</span></span><span class=line><span class=cl>        <span class=n>indegree</span><span class=p>[</span><span class=n>nxt</span><span class=p>]</span> <span class=o>-=</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=n>indegree</span><span class=p>[</span><span class=n>nxt</span><span class=p>]</span> <span class=o>==</span> <span class=mi>0</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=n>q</span><span class=o>.</span><span class=n>append</span><span class=p>(</span><span class=n>nxt</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=n>result</span><span class=p>)</span>
</span></span></code></pre></td></tr></table></div></div><h2 id=282-283--고대어-사전-dictionary-난이도-하>28.2, 28.3 고대어 사전, DICTIONARY, 난이도: 하<a hidden class=anchor aria-hidden=true href=#282-283--고대어-사전-dictionary-난이도-하>#</a></h2><ul><li>각 알파벳을 정점으로 표현, 한 알파벳이 다른 알파벳 앞에 와야 할 때 두 정점을 방향 간선으로 연결<ul><li>우리가 원하는 알파벳 순서는 이 그래프를 <strong>위상 정렬</strong> 한 결과</li></ul></li><li><strong>인접한 단어</strong>들만 검사하더라도 그래프의 위상 정렬 결과는 <strong>모든 단어 쌍을 검사</strong>했을 때와 같다.<ul><li>단어 A, B, C가 순서대로 등장한다면, (A, C)는 검사하지 않고, (A, B), (B, C)쌍 만 검사해도 된다.</li></ul></li><li>그래프가 DAG면 빈 리스트 반환 / 아니면, 위상 정렬 결과 반환</li></ul><h2 id=287-이론적-배경과-응용>28.7 이론적 배경과 응용<a hidden class=anchor aria-hidden=true href=#287-이론적-배경과-응용>#</a></h2><h3 id=2871-깊이-우선-탐색과-간선의-분류>28.7.1 깊이 우선 탐색과 간선의 분류<a hidden class=anchor aria-hidden=true href=#2871-깊이-우선-탐색과-간선의-분류>#</a></h3><p><img loading=lazy src=/images/before/image-20240422164107076.png alt=image-20240422164107076.png width=680 height=auto></p><ul><li><p>DFS를 수행하면, 그 과정에서 그래프의 모든 간선을 한 번씩 만나게 된다.</p></li><li><p>일부 간선은 처음 발견한 정점으로 따라가고, 나머지는 무시하게 된다.</p><ul><li>그러나 이 간선들을 무시하지 않고 이들에 대한 정보를 수집하면 그래프의 구조에 대해 많은 것을 알 수 있다.</li></ul></li><li><p>탐색이 따라가는 간선들만 모아 보면 <strong>트리</strong> 형태를 띠게 된다.</p><ul><li>이런 트리를 주어진 그래프의 <strong><code>DFS 스패닝 트리(DFS Spanning Tree)</code></strong> 라고 부른다.</li></ul></li><li><p><strong>DFS 스패닝 트리</strong>를 생성하면, 그래프 중 모든 간선을 네 가지 중 하나로 분류 할 수 있다. <strong><code>간선 분류</code></strong></p><ol><li><p><strong>트리 간선(tree edge)</strong>: 스패닝 트리에 포함된 간선</p></li><li><p><strong>순방향 간선(forward edge)</strong>: 스패닝 트리의 선조에서 자손으로 연겨되지만 트리 간선이 아닌 간선</p></li><li><p><strong>역방향 간선(back edge)</strong>: 스패닝 트리의 자손에서 선조로 연결되는 간선</p></li><li><p><strong>교차 간선(cross edge)</strong>: 1.2.3번 3가지 를 제외한 나머지 간선들,</p><ul><li>교차 간선은 트리에서 선조와 자손 관계가 아닌 정점들 간에 연결된 간선들을 의미</li></ul></li></ol></li><li><p>그래프의 간선을 항상 4가지 중 하나로 분류해야 하는 것은 아니다.</p><p><img loading=lazy src=/images/before/image-20240422165320434.png alt=image-20240422165320434.png width=680 height=auto></p></li><li><p>깊이 우선 탐색이 어느 순서대로 정점을 방문하느냐(실제 구현 방법)에 따라 <strong>서로 다른 트리</strong>가 생성될 수 있다.</p></li><li><p><strong>무향 그래프</strong> 간선의 분류</p><ul><li><strong>무향 그래프</strong>는 교차 간선, 순방향, 역방향 간선의 구분이 있을 수 없다.</li></ul></li></ul><h3 id=2872-사이클-존재-여부-확인>28.7.2 사이클 존재 여부 확인<a hidden class=anchor aria-hidden=true href=#2872-사이클-존재-여부-확인>#</a></h3><ul><li><strong><code>간선 구분</code></strong> 의 사용 예시, 방향 그래프에 <strong>사이클</strong>이 존재하는지 여부를 판정</li><li>&lsquo;<strong>사이클</strong>의 존재 여부&rsquo;는 &lsquo;<strong>역방향 간선</strong> 존재 여부&rsquo; 와 <strong>동치</strong><ul><li>사이클에 포함된 정점 중 dfs 에서 처음 만나는 정점을 u라고 할 때,</li><li>dfs(u)는 u에서 갈 수 있는 정점들을 모두 방문한 후에야 종료한다.</li><li>따라서, dfs는 <strong>사이클</strong>에서 u 이전에 있는 정점을 dfs(u)가 종료하기 전에 방문하게 되는데,</li><li>이 정점에서 u로가는 정점은 항상 <strong>역방향</strong> 간선이 된다.</li></ul></li></ul><h3 id=2873-간선-구분하는-방법>28.7.3 <code>간선 구분</code>하는 방법<a hidden class=anchor aria-hidden=true href=#2873-간선-구분하는-방법>#</a></h3><ul><li><p>정점이 방문할 때 이 정점이 방문되었다는 사실 뿐만 아니라, 이 정점이 몇 번째로 발견되었는지도 동시에 기록</p></li><li><p>탐색 과정에서 각 정점을 몇 번째로 발견했는지를 <code>배열 discovered[]</code> 에 저장</p><ul><li>(u, v)가 <strong>순방향 간선</strong> 이려면, v는 u의 자손, 따라서 v는 u보다 더 늦게 발견되어야 한다.</li><li>(u, v)가 <strong>역방향 간선</strong> 이려면 v는 u의 선조, 따라서 v는 u보다 일찍 발견되어야 한다.</li><li>(u, v)가 <strong>교차 간선</strong> 이려면, dfs(v)가 종류한 후 dfs(u)가 호출되어야 한다. 따라서 v는 u보다 일찍 발견되어야 한다.</li></ul></li><li><p>이처럼 <strong>발견 순서 정보</strong>를 이용하면 해당 간선이 순방향 간선인지를 알아낼 수 있다.</p></li><li><p>반면 v가 u보다 먼저 방문되었다면 v가 u의 부모인지 아닌지를 구분할 방법이 없다.</p><ul><li><p>이때 구분하는 한 가지 방법은 dfs(v)가 종료햇는지를 확인하는 것</p></li><li><p>dfs(v)가 아직 종료하지 않았다면 v는 u의 선조 및 (u, v)는 <strong>역뱡향 간선</strong></p></li><li><p>아니면 <strong>교차 간선</strong></p></li></ul></li><li><p><strong>간선을 구분</strong>하는 깊이 우선 탐색 알고리즘 python 구현</p></li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=n>N</span> <span class=o>=</span> <span class=mi>10</span>
</span></span><span class=line><span class=cl><span class=n>discovered</span> <span class=o>=</span> <span class=p>[</span><span class=o>-</span><span class=mi>1</span> <span class=k>for</span> <span class=n>_</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=n>N</span><span class=p>)]</span>  <span class=c1># i번 정점의 발견 순서</span>
</span></span><span class=line><span class=cl><span class=n>finished</span> <span class=o>=</span> <span class=p>[</span><span class=kc>False</span> <span class=k>for</span> <span class=n>_</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=n>N</span><span class=p>)]</span>  <span class=c1># dfs가 종료했으면 True 아니면 False</span>
</span></span><span class=line><span class=cl><span class=n>graph</span> <span class=o>=</span> <span class=p>[[]</span> <span class=k>for</span> <span class=n>_</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=n>N</span><span class=p>)]</span>
</span></span><span class=line><span class=cl><span class=n>result</span> <span class=o>=</span> <span class=nb>dict</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=n>counter</span> <span class=o>=</span> <span class=mi>0</span>  <span class=c1># 지금까지 발견한 정점의 수</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>dfsForEdgesType</span><span class=p>(</span><span class=n>node</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=k>global</span> <span class=n>counter</span>
</span></span><span class=line><span class=cl>    <span class=n>counter</span> <span class=o>+=</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>    <span class=n>discovered</span><span class=p>[</span><span class=n>node</span><span class=p>]</span> <span class=o>=</span> <span class=n>counter</span>  <span class=c1># 발견 순서 기록</span>
</span></span><span class=line><span class=cl>    <span class=n>nxtLst</span> <span class=o>=</span> <span class=n>graph</span><span class=p>[</span><span class=n>node</span><span class=p>]</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=n>nxt</span> <span class=ow>in</span> <span class=n>nxtLst</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=n>discovered</span><span class=p>[</span><span class=n>nxt</span><span class=p>]</span> <span class=o>==</span> <span class=o>-</span><span class=mi>1</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=n>result</span><span class=p>[</span><span class=n>node</span><span class=p>]</span> <span class=o>=</span> <span class=s2>&#34;tree edge&#34;</span>
</span></span><span class=line><span class=cl>            <span class=n>dfsForEdgesType</span><span class=p>(</span><span class=n>nxt</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=k>elif</span> <span class=n>discovered</span><span class=p>[</span><span class=n>node</span><span class=p>]</span> <span class=o>&lt;</span> <span class=n>discovered</span><span class=p>[</span><span class=n>node</span><span class=p>]:</span>  <span class=n>result</span><span class=p>[</span><span class=n>node</span><span class=p>]</span> <span class=o>=</span> <span class=s2>&#34;forward edge&#34;</span>
</span></span><span class=line><span class=cl>        <span class=k>elif</span> <span class=ow>not</span> <span class=n>finished</span><span class=p>[</span><span class=n>nxt</span><span class=p>]:</span> <span class=n>result</span><span class=p>[</span><span class=n>node</span><span class=p>]</span> <span class=o>=</span> <span class=s2>&#34;backward edge&#34;</span>
</span></span><span class=line><span class=cl>        <span class=k>else</span><span class=p>:</span> <span class=n>result</span><span class=p>[</span><span class=n>node</span><span class=p>]</span> <span class=o>=</span> <span class=s2>&#34;cross edge&#34;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>finished</span><span class=p>[</span><span class=n>node</span><span class=p>]</span> <span class=o>=</span> <span class=kc>True</span>
</span></span></code></pre></td></tr></table></div></div><h3 id=2873-예제-절단점-찾기-알고리즘>28.7.3 예제: 절단점 찾기 알고리즘<a hidden class=anchor aria-hidden=true href=#2873-예제-절단점-찾기-알고리즘>#</a></h3><p><img loading=lazy src=/images/before/image-20240422164146626.png alt=image-20240422164146626.png width=680 height=auto></p><ul><li><p><strong>그래프의 절단점(cut vertex)</strong> 를 찾는 문제 - DFS를 이용해서 풀 수 있는 응용 문제 중 하나</p></li><li><p>무향 그래프의 절단점: 인접한 간선들을 모두 지웠을 때 해당 컴포넌트가 두 개 이상으로 나뉘어지는 정점을 말한다.</p><ul><li>1, 3, 5번이 절단점이 된다.</li></ul></li><li><p>어떤 정점이 절단점인지 확인하는 간단한 방법은 해당 정점을 그래프에서 삭제한 뒤, 컴포넌트의 개수가 이전보다 늘어났는지를 확인하는 것</p></li><li><p>모든 정점의 절단점 여부를 확인하려면, 깊이 우선 탐색을 V번 수행</p><ul><li><p>그러나 탐색 과정에서 얻는 정보를 잘 이용하면 <strong>한 번의 깊이 우선 탐색만으로</strong> 그래프의 모든 절단점을 찾을 수 있다.</p><p><img loading=lazy src=/images/before/image-20240422164220993.png alt=image-20240422164220993.png width=680 height=auto></p></li></ul></li></ul><p>​</p><ul><li><p>임의의 정점에서 DFS를 수행해 DFS 스패닝 트리를 얻는다.</p></li><li><p>어떤 정점 u 가 절단점인지 알 수 있는 방법</p><ul><li>그래프가 쪼개지지 않는 유일한 경우는 그림 처럼 u의 선조와 자손들이 전부 <strong>역뱡향 간선</strong>으로 연결되어 있을 때 뿐이다.</li><li>이것을 확인하는 방법은 DFS를 수행하는 dfs2()가 각 정점을 루트로 하는 서브트레엇 역뱡향 간선을 통해 갈 수 있는 정점의 최소 깊이를 반환하도록 하는 것</li><li>만약 u의 자손들이 모두 역방향 간선을 통해 u의 선조로 올라갈 수 있다면 u는 절단점이 아니다.</li></ul></li><li><p>u가 스패닝 트리의 루트라서 선조가 없다면 어떻게 될까?</p><ul><li>u는 무조건 절단점이라고 생각하기 쉽지만, 간과하기 쉬운 예외가 있다.</li><li>바로 자손이 하나도 없거나 하나밖에 없는 경우다.</li><li>이 경우 u가 없어져도 그래프는 쪼개지지 않는다.</li><li>따라서 u가 루트인 경우 둘 이상의 자손을 가질 때만 절단점이 된다.</li></ul></li><li><p>실제로 이 알고리즘을 구현할 때는 각 정점의 깊이를 비굔하는 대신, 각 정점의 발견 순서를 비교하는 형태로 코드를 작성해 간단히 구현할 수 있다.</p><ul><li>알고 싶은 것은 해당 서브트리가 u의 조상 중 하나와 연결되어 있는지인데, u의 조상들은 항상 u보다 먼저 발견된다.</li><li>따라서, 깊이 우선 탐색 함수가 해당 정점을 루트로 하는 서브트리에서 <strong>역방향 간선</strong>을 통해 닿는 정점들의 <strong>최소 발견 순서</strong>를 반환하면 된다.</li></ul></li><li><p>무향 그래프에서 <strong>절단점</strong>을 찾는 알고리즘 python 구현</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=n>N</span> <span class=o>=</span> <span class=mi>10</span>
</span></span><span class=line><span class=cl><span class=n>discovered</span> <span class=o>=</span> <span class=p>[</span><span class=o>-</span><span class=mi>1</span> <span class=k>for</span> <span class=n>_</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=n>N</span><span class=p>)]</span>  <span class=c1># i번 정점의 발견 순서</span>
</span></span><span class=line><span class=cl><span class=n>finished</span> <span class=o>=</span> <span class=p>[</span><span class=kc>False</span> <span class=k>for</span> <span class=n>_</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=n>N</span><span class=p>)]</span>  <span class=c1># dfs가 종료했으면 True 아니면 False</span>
</span></span><span class=line><span class=cl><span class=n>isCutVertex</span> <span class=o>=</span> <span class=p>[</span><span class=kc>False</span> <span class=k>for</span> <span class=n>_</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=n>N</span><span class=p>)]</span>  <span class=c1># True면 절단점</span>
</span></span><span class=line><span class=cl><span class=n>graph</span> <span class=o>=</span> <span class=p>[[]</span> <span class=k>for</span> <span class=n>_</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=n>N</span><span class=p>)]</span>
</span></span><span class=line><span class=cl><span class=n>result</span> <span class=o>=</span> <span class=nb>dict</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=n>counter</span> <span class=o>=</span> <span class=mi>0</span>  <span class=c1># 지금까지 발견한 정점의 수</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># node를 루트로 하는 서브트리에 있는 절단점들을 찾는다</span>
</span></span><span class=line><span class=cl><span class=c1># 반환 값은 해당 서브트리에서 역방향 간선으로 갈 수 있는 정점 중, 가장 일찍 발견된 정점의 발견 시점</span>
</span></span><span class=line><span class=cl><span class=c1># 처음 호출 할때는 isRoot = True 로 둔다.</span>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>findCutVertex</span><span class=p>(</span><span class=n>node</span><span class=p>,</span> <span class=n>isRoot</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=k>global</span> <span class=n>counter</span>
</span></span><span class=line><span class=cl>    <span class=n>counter</span> <span class=o>+=</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>    <span class=n>discovered</span><span class=p>[</span><span class=n>node</span><span class=p>]</span> <span class=o>=</span> <span class=n>counter</span>
</span></span><span class=line><span class=cl>    <span class=n>ret</span> <span class=o>=</span> <span class=n>discovered</span><span class=p>[</span><span class=n>node</span><span class=p>]</span>
</span></span><span class=line><span class=cl>    <span class=n>children</span> <span class=o>=</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>    <span class=n>nxtLst</span> <span class=o>=</span> <span class=n>graph</span><span class=p>[</span><span class=n>node</span><span class=p>]</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=n>nxt</span> <span class=ow>in</span> <span class=n>nxtLst</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=n>discovered</span><span class=p>[</span><span class=n>nxt</span><span class=p>]</span> <span class=o>==</span> <span class=o>-</span><span class=mi>1</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=n>children</span> <span class=o>+=</span> <span class=mi>1</span>  <span class=c1># 루트인 경우의 절단점 판정을 위해 자손 서브트리의 개수를 샌다.</span>
</span></span><span class=line><span class=cl>            <span class=n>subTreeMaxNode</span> <span class=o>=</span> <span class=n>findCutVertex</span><span class=p>(</span><span class=n>nxt</span><span class=p>,</span> <span class=kc>False</span><span class=p>)</span>  <span class=c1># 서브 트리에서 갈 수 있는 가장 높은 정점의 번호</span>
</span></span><span class=line><span class=cl>            <span class=n>ret</span> <span class=o>=</span> <span class=nb>min</span><span class=p>(</span><span class=n>ret</span><span class=p>,</span> <span class=n>subTreeMaxNode</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=ow>not</span> <span class=n>isRoot</span> <span class=ow>and</span> <span class=n>subTreeMaxNode</span> <span class=o>&gt;=</span> <span class=n>discovered</span><span class=p>[</span><span class=n>node</span><span class=p>]:</span>  <span class=c1># 그 노드가 자기 자신의 이하에 있다면 현재 위치는 절단점이다.</span>
</span></span><span class=line><span class=cl>                <span class=n>isCutVertex</span><span class=p>[</span><span class=n>node</span><span class=p>]</span> <span class=o>=</span> <span class=kc>True</span>
</span></span><span class=line><span class=cl>        <span class=k>else</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=n>ret</span> <span class=o>=</span> <span class=nb>min</span><span class=p>(</span><span class=n>ret</span><span class=p>,</span> <span class=n>discovered</span><span class=p>[</span><span class=n>nxt</span><span class=p>])</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=n>isRoot</span><span class=p>:</span> <span class=n>isCutVertex</span><span class=p>[</span><span class=n>node</span><span class=p>]</span> <span class=o>=</span> <span class=p>(</span><span class=n>children</span> <span class=o>&gt;=</span> <span class=mi>2</span><span class=p>)</span>  <span class=c1># 루트인 경우 절단점 판정은 서브트리의 개수</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>ret</span>
</span></span></code></pre></td></tr></table></div></div></li><li><p>무향 그래프에서 절단점을 포함하지 않는 서브 그래프를 <code>이중 결합 컴포넌트(biconnected component)</code> 라고 부른다.</p></li></ul><h1 id=reference>Reference<a hidden class=anchor aria-hidden=true href=#reference>#</a></h1><ul><li>프로그래밍 대회에서 배우는 알고리즘 문제 해결 전략 (구종만, 인사이트)</li><li><a href=https://www.algospot.com/>https://www.algospot.com/</a></li></ul></div><footer class=post-footer><ul class=post-tags><li><a href=https://2taezeat.github.io/tags/algorithm/>Algorithm</a></li></ul><nav class=paginav><a class=prev href=https://2taezeat.github.io/posts/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EB%AC%B8%EC%A0%9C-%ED%95%B4%EA%B2%B0-%EC%A0%84%EB%9E%B5/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EB%AC%B8%EC%A0%9C-%ED%95%B4%EA%B2%B0-%EC%A0%84%EB%9E%B5-ch29.-%EA%B7%B8%EB%9E%98%ED%94%84/><span class=title>« Prev</span><br><span>[알고리즘 문제 해결 전략] ch29. 그래프</span>
</a><a class=next href=https://2taezeat.github.io/posts/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EB%AC%B8%EC%A0%9C-%ED%95%B4%EA%B2%B0-%EC%A0%84%EB%9E%B5/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EB%AC%B8%EC%A0%9C-%ED%95%B4%EA%B2%B0-%EC%A0%84%EB%9E%B5-ch27.-%EA%B7%B8%EB%9E%98%ED%94%84/><span class=title>Next »</span><br><span>[알고리즘 문제 해결 전략] ch27. 그래프</span></a></nav><ul class=share-buttons><li><a target=_blank rel="noopener noreferrer" aria-label="share [알고리즘 문제 해결 전략] ch28. 그래프 on x" href="https://x.com/intent/tweet/?text=%5b%ec%95%8c%ea%b3%a0%eb%a6%ac%ec%a6%98%20%eb%ac%b8%ec%a0%9c%20%ed%95%b4%ea%b2%b0%20%ec%a0%84%eb%9e%b5%5d%20ch28.%20%ea%b7%b8%eb%9e%98%ed%94%84&amp;url=https%3a%2f%2f2taezeat.github.io%2fposts%2f%25EC%2595%258C%25EA%25B3%25A0%25EB%25A6%25AC%25EC%25A6%2598-%25EB%25AC%25B8%25EC%25A0%259C-%25ED%2595%25B4%25EA%25B2%25B0-%25EC%25A0%2584%25EB%259E%25B5%2f%25EC%2595%258C%25EA%25B3%25A0%25EB%25A6%25AC%25EC%25A6%2598-%25EB%25AC%25B8%25EC%25A0%259C-%25ED%2595%25B4%25EA%25B2%25B0-%25EC%25A0%2584%25EB%259E%25B5-ch28.-%25EA%25B7%25B8%25EB%259E%2598%25ED%2594%2584%2f&amp;hashtags=Algorithm"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446C483.971.0 512 28.03 512 62.554zM269.951 190.75 182.567 75.216H56L207.216 272.95 63.9 436.783h61.366L235.9 310.383l96.667 126.4H456L298.367 228.367l134-153.151H371.033zM127.633 110h36.468l219.38 290.065H349.5z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share [알고리즘 문제 해결 전략] ch28. 그래프 on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2f2taezeat.github.io%2fposts%2f%25EC%2595%258C%25EA%25B3%25A0%25EB%25A6%25AC%25EC%25A6%2598-%25EB%25AC%25B8%25EC%25A0%259C-%25ED%2595%25B4%25EA%25B2%25B0-%25EC%25A0%2584%25EB%259E%25B5%2f%25EC%2595%258C%25EA%25B3%25A0%25EB%25A6%25AC%25EC%25A6%2598-%25EB%25AC%25B8%25EC%25A0%259C-%25ED%2595%25B4%25EA%25B2%25B0-%25EC%25A0%2584%25EB%259E%25B5-ch28.-%25EA%25B7%25B8%25EB%259E%2598%25ED%2594%2584%2f&amp;title=%5b%ec%95%8c%ea%b3%a0%eb%a6%ac%ec%a6%98%20%eb%ac%b8%ec%a0%9c%20%ed%95%b4%ea%b2%b0%20%ec%a0%84%eb%9e%b5%5d%20ch28.%20%ea%b7%b8%eb%9e%98%ed%94%84&amp;summary=%5b%ec%95%8c%ea%b3%a0%eb%a6%ac%ec%a6%98%20%eb%ac%b8%ec%a0%9c%20%ed%95%b4%ea%b2%b0%20%ec%a0%84%eb%9e%b5%5d%20ch28.%20%ea%b7%b8%eb%9e%98%ed%94%84&amp;source=https%3a%2f%2f2taezeat.github.io%2fposts%2f%25EC%2595%258C%25EA%25B3%25A0%25EB%25A6%25AC%25EC%25A6%2598-%25EB%25AC%25B8%25EC%25A0%259C-%25ED%2595%25B4%25EA%25B2%25B0-%25EC%25A0%2584%25EB%259E%25B5%2f%25EC%2595%258C%25EA%25B3%25A0%25EB%25A6%25AC%25EC%25A6%2598-%25EB%25AC%25B8%25EC%25A0%259C-%25ED%2595%25B4%25EA%25B2%25B0-%25EC%25A0%2584%25EB%259E%25B5-ch28.-%25EA%25B7%25B8%25EB%259E%2598%25ED%2594%2584%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share [알고리즘 문제 해결 전략] ch28. 그래프 on reddit" href="https://reddit.com/submit?url=https%3a%2f%2f2taezeat.github.io%2fposts%2f%25EC%2595%258C%25EA%25B3%25A0%25EB%25A6%25AC%25EC%25A6%2598-%25EB%25AC%25B8%25EC%25A0%259C-%25ED%2595%25B4%25EA%25B2%25B0-%25EC%25A0%2584%25EB%259E%25B5%2f%25EC%2595%258C%25EA%25B3%25A0%25EB%25A6%25AC%25EC%25A6%2598-%25EB%25AC%25B8%25EC%25A0%259C-%25ED%2595%25B4%25EA%25B2%25B0-%25EC%25A0%2584%25EB%259E%25B5-ch28.-%25EA%25B7%25B8%25EB%259E%2598%25ED%2594%2584%2f&title=%5b%ec%95%8c%ea%b3%a0%eb%a6%ac%ec%a6%98%20%eb%ac%b8%ec%a0%9c%20%ed%95%b4%ea%b2%b0%20%ec%a0%84%eb%9e%b5%5d%20ch28.%20%ea%b7%b8%eb%9e%98%ed%94%84"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share [알고리즘 문제 해결 전략] ch28. 그래프 on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2f2taezeat.github.io%2fposts%2f%25EC%2595%258C%25EA%25B3%25A0%25EB%25A6%25AC%25EC%25A6%2598-%25EB%25AC%25B8%25EC%25A0%259C-%25ED%2595%25B4%25EA%25B2%25B0-%25EC%25A0%2584%25EB%259E%25B5%2f%25EC%2595%258C%25EA%25B3%25A0%25EB%25A6%25AC%25EC%25A6%2598-%25EB%25AC%25B8%25EC%25A0%259C-%25ED%2595%25B4%25EA%25B2%25B0-%25EC%25A0%2584%25EB%259E%25B5-ch28.-%25EA%25B7%25B8%25EB%259E%2598%25ED%2594%2584%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share [알고리즘 문제 해결 전략] ch28. 그래프 on whatsapp" href="https://api.whatsapp.com/send?text=%5b%ec%95%8c%ea%b3%a0%eb%a6%ac%ec%a6%98%20%eb%ac%b8%ec%a0%9c%20%ed%95%b4%ea%b2%b0%20%ec%a0%84%eb%9e%b5%5d%20ch28.%20%ea%b7%b8%eb%9e%98%ed%94%84%20-%20https%3a%2f%2f2taezeat.github.io%2fposts%2f%25EC%2595%258C%25EA%25B3%25A0%25EB%25A6%25AC%25EC%25A6%2598-%25EB%25AC%25B8%25EC%25A0%259C-%25ED%2595%25B4%25EA%25B2%25B0-%25EC%25A0%2584%25EB%259E%25B5%2f%25EC%2595%258C%25EA%25B3%25A0%25EB%25A6%25AC%25EC%25A6%2598-%25EB%25AC%25B8%25EC%25A0%259C-%25ED%2595%25B4%25EA%25B2%25B0-%25EC%25A0%2584%25EB%259E%25B5-ch28.-%25EA%25B7%25B8%25EB%259E%2598%25ED%2594%2584%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share [알고리즘 문제 해결 전략] ch28. 그래프 on telegram" href="https://telegram.me/share/url?text=%5b%ec%95%8c%ea%b3%a0%eb%a6%ac%ec%a6%98%20%eb%ac%b8%ec%a0%9c%20%ed%95%b4%ea%b2%b0%20%ec%a0%84%eb%9e%b5%5d%20ch28.%20%ea%b7%b8%eb%9e%98%ed%94%84&amp;url=https%3a%2f%2f2taezeat.github.io%2fposts%2f%25EC%2595%258C%25EA%25B3%25A0%25EB%25A6%25AC%25EC%25A6%2598-%25EB%25AC%25B8%25EC%25A0%259C-%25ED%2595%25B4%25EA%25B2%25B0-%25EC%25A0%2584%25EB%259E%25B5%2f%25EC%2595%258C%25EA%25B3%25A0%25EB%25A6%25AC%25EC%25A6%2598-%25EB%25AC%25B8%25EC%25A0%259C-%25ED%2595%25B4%25EA%25B2%25B0-%25EC%25A0%2584%25EB%259E%25B5-ch28.-%25EA%25B7%25B8%25EB%259E%2598%25ED%2594%2584%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentcolor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share [알고리즘 문제 해결 전략] ch28. 그래프 on ycombinator" href="https://news.ycombinator.com/submitlink?t=%5b%ec%95%8c%ea%b3%a0%eb%a6%ac%ec%a6%98%20%eb%ac%b8%ec%a0%9c%20%ed%95%b4%ea%b2%b0%20%ec%a0%84%eb%9e%b5%5d%20ch28.%20%ea%b7%b8%eb%9e%98%ed%94%84&u=https%3a%2f%2f2taezeat.github.io%2fposts%2f%25EC%2595%258C%25EA%25B3%25A0%25EB%25A6%25AC%25EC%25A6%2598-%25EB%25AC%25B8%25EC%25A0%259C-%25ED%2595%25B4%25EA%25B2%25B0-%25EC%25A0%2584%25EB%259E%25B5%2f%25EC%2595%258C%25EA%25B3%25A0%25EB%25A6%25AC%25EC%25A6%2598-%25EB%25AC%25B8%25EC%25A0%259C-%25ED%2595%25B4%25EA%25B2%25B0-%25EC%25A0%2584%25EB%259E%25B5-ch28.-%25EA%25B7%25B8%25EB%259E%2598%25ED%2594%2584%2f"><svg width="30" height="30" viewBox="0 0 512 512" fill="currentcolor" xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"><path d="M449.446.0C483.971.0 512 28.03 512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446zM183.8767 87.9921h-62.034L230.6673 292.4508V424.0079h50.6655V292.4508L390.1575 87.9921H328.1233L256 238.2489z"/></svg></a></li></ul></footer><script src=https://utteranc.es/client.js repo=2taezeat/blog_comment issue-term=pathname label=comment theme=github-light crossorigin=anonymous async></script></article></main><footer class=footer><span>&copy; 2024 <a href=https://2taezeat.github.io/>2taezeat, blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>