<!doctype html><html lang=en dir=auto><head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>알고리즘 문제 해결 전략, 그래프 (ch27) | 2taezeat, blog</title>
<meta name=keywords content><meta name=description content="&lsquo;프로그래밍 대회에서 배우는 알고리즘 문제 해결 전략&rsquo;을 읽고, 정리한다."><meta name=author content="2taezeat"><link rel=canonical href=http://localhost:1313/posts/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EB%AC%B8%EC%A0%9C-%ED%95%B4%EA%B2%B0-%EC%A0%84%EB%9E%B5/2024-01-22-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EB%AC%B8%EC%A0%9C-%ED%95%B4%EA%B2%B0-%EC%A0%84%EB%9E%B5-%EA%B7%B8%EB%9E%98%ED%94%84-ch27/><meta name=google-site-verification content="YaEERzgrvu-ZwPg7gswZdTzRMufkHw3uIH7i8hVal1c"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.9bc633d66da2093ac93d30e5b21470b6655a1e928ddc297458ca9dfb4f00c07d.css integrity="sha256-m8Yz1m2iCTrJPTDlshRwtmVaHpKN3Cl0WMqd+08AwH0=" rel="preload stylesheet" as=style><link rel=icon href=http://localhost:1313/icon/favicon.ico><link rel=icon type=image/png sizes=16x16 href=http://localhost:1313/icon/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=http://localhost:1313/icon/favicon-32x32.png><link rel=apple-touch-icon href=http://localhost:1313/icon/apple-touch-icon.png><link rel=mask-icon href=http://localhost:1313/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=http://localhost:1313/posts/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EB%AC%B8%EC%A0%9C-%ED%95%B4%EA%B2%B0-%EC%A0%84%EB%9E%B5/2024-01-22-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EB%AC%B8%EC%A0%9C-%ED%95%B4%EA%B2%B0-%EC%A0%84%EB%9E%B5-%EA%B7%B8%EB%9E%98%ED%94%84-ch27/><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><meta property="og:title" content="알고리즘 문제 해결 전략, 그래프 (ch27)"><meta property="og:description" content="&lsquo;프로그래밍 대회에서 배우는 알고리즘 문제 해결 전략&rsquo;을 읽고, 정리한다."><meta property="og:type" content="article"><meta property="og:url" content="http://localhost:1313/posts/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EB%AC%B8%EC%A0%9C-%ED%95%B4%EA%B2%B0-%EC%A0%84%EB%9E%B5/2024-01-22-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EB%AC%B8%EC%A0%9C-%ED%95%B4%EA%B2%B0-%EC%A0%84%EB%9E%B5-%EA%B7%B8%EB%9E%98%ED%94%84-ch27/"><meta property="og:image" content="http://localhost:1313/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-01-22T01:01:46+09:00"><meta property="article:modified_time" content="2024-01-22T01:01:46+09:00"><meta property="og:site_name" content="2taezeat, blog"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="http://localhost:1313/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="알고리즘 문제 해결 전략, 그래프 (ch27)"><meta name=twitter:description content="&lsquo;프로그래밍 대회에서 배우는 알고리즘 문제 해결 전략&rsquo;을 읽고, 정리한다."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"http://localhost:1313/posts/"},{"@type":"ListItem","position":2,"name":"알고리즘 문제 해결 전략, 그래프 (ch27)","item":"http://localhost:1313/posts/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EB%AC%B8%EC%A0%9C-%ED%95%B4%EA%B2%B0-%EC%A0%84%EB%9E%B5/2024-01-22-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EB%AC%B8%EC%A0%9C-%ED%95%B4%EA%B2%B0-%EC%A0%84%EB%9E%B5-%EA%B7%B8%EB%9E%98%ED%94%84-ch27/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"알고리즘 문제 해결 전략, 그래프 (ch27)","name":"알고리즘 문제 해결 전략, 그래프 (ch27)","description":"\u0026lsquo;프로그래밍 대회에서 배우는 알고리즘 문제 해결 전략\u0026rsquo;을 읽고, 정리한다.\n","keywords":[],"articleBody":"‘프로그래밍 대회에서 배우는 알고리즘 문제 해결 전략’을 읽고, 정리한다.\n07장. 그래프 정리\nch27. 그래프의 표현과 정의 27. 그래프의 표현과 정의 27.1 도입 그래프(graph)는 현실 세계의 사물이나 추상적인 개념 간의 연결 관계를 표현한다. 트리에 있었던 부모 자식 관계에 관한 제약이 없기 때문에 그래프는 트리보다 다양한 구조를 표현할 수 있다. 트리도 그래프 중 하나 27.1.1 그래프의 정의 그래프 G(V, E)는 어떤 자료나 개념을 표현하는 정점(vertex, node)의 집합 V와 이들을 연결하는 간선(edge)들의 집합 E로 구성된 자료구조 이다. 그래프는 정점들과 간선들로 정의되며, 정점의 위치 정보나 간선의 순서 등은 그래프의 정의에 포함되지 않는다. 아래 그래프들은 모두 같은 그래프를 표현한다. 27.1.2 그래프의 종류 방향 그래프(directed graph) or 유향 그래프\n방향 그래프에서는 각 간선이 방향이라는 새로운 속성을 갖는다. u -\u003e v 와 v-\u003e u 는 서로 다른 간선이다. 무향 그래프\n간선에 방향이 없는 그래프 가중치 그래프(weighted graph)\n각 각선에 가중치(weight)라고 불리는 실수 속성을 부여 다중 그래프(multigraph)\n두 정점 사이에 두 개 이상의 간선이 있을 수 있는 그래프 단순 그래프\n두 정점 사이에 최대 한 개의 간선만 있는 그래프 트리 or 루트 없는 트리(unrooted tree)\n부모 자식 관계가 없을 뿐, 간선 들의 연결 관계만 보면 트리와 같은 무향 그래프를 말한다. 간선들의 연결 관계가 트리와 같다는 말은, 간선을 통해 두 정점을 잇는 방법이 딱 하나밖에 없다는 의미 이분 그래프(bipartite graph)\n그래프의 정점들을 겹치지 않는 두 개의 그룹으로 나눠서 서로 다른 그룹에 속한 정점들 간에만 간선이 존재하도록 만들 수 있는 그래프 Ex) 남성과 여성 사이클 없는 방향 그래프(directed acyclic graph, DAG)\n방향 그래프인데, **한 점에서 출발해 자기 자신으로 돌아오는 경로(사이클)**가 존재하지 않는 경우\n간선의 방향을 무시할 경우 DAG에는 사이클이 존재할 수도 있다.\n27.1.3 그래프의 경로 경로(path): 끝과 끝이 서로 연결된 간선들을 순서대로 나열 한 것 주로, 거쳐 가는 정점의 번호만을 간단히 써서 표기함 (1, 2), (2, 4), (4, 5) === 1 -\u003e 4 -\u003e 5 방향 그래프의 경우 앞 간선의 끝점이 뒷 간선의 시작점과 만나야 한다 경로 중 한 정점을 최대 한 번만지나는 경로를 **단순 경로(simple path)**라고 한다. 현대 그래프 이론에서는 ‘경로’ 라고 하면 대부분은 ‘단순 경로‘를 의미한다. 한 정점을 두 번 이상 지날 수 있는 경로를 이야기 할 대는 별도로 이 사실을 명시한다. 시작한 점에서 끝나는 경로를 사이클 라고 한다. 사이클(cycle): 시작점과 끝나는 점이 같은 경로 27.2 그래프의 사용 예 현실 세계의 수 많은 문제를 풀기 위해 그래프가 사용된다. 철도망의 안전성 분석 소셜 네트워크 분석 인터넷 전송 속도 계산 한 붓 그리기 주어진 그래프의 모든 간선을 한 번씩만 지나는 경로: 오일러 경로(Eulerian path) 외환 거래 27.3 암시적 그래프 구조들 현실 세계에서 그래프 같은 형태를 갖는 구조가 아니라도 그래프를 통해서 표현하면 쉽게 해결 할 수 있는 문제\n이 같은 그래프 구조를 암시적 그래프(implicit graph) 라고 한다. Ex) 2차원 board에서 미로 최단 경로 찾기 할 일 목록 정리\n위상 정렬(topological sorting), DFS를 응용 15-퍼즐\n게임판 덮기\n회의실 배정\n만족성 문제(satisfiability problem) 모든 사람이 두 선택지 중 하나를 선택해야 하는 문제: 2-SAT 문제 27.4 그래프의 표현 방법 많은 경우 그래프는 트리에 비해 정적인 용도로 사용된다. 보다 정적이라는 말은 새로운 정점이나 간선을 추가, 삭제 하는 일이 자주 일어나지 않는다는 의미 따라서 대부분의 그래프는 구조의 변경이 어렵더라도 좀 더 간단하고 메모리를 적게 차지하는 방법으로 구현된다. 그래프의 정점(node)들을 객체의 인스턴스로 표현하는 대신(트리 방식), 각 정점에 0부터 시작하는 번호를 붙이고, 배열에 각 정점의 정보를 저장하는 것 그래프의 표현 방식은 간선(edge)의 정보를 어떤 식으로 저장하는냐에 따라 크게 2가지로 나눈다. 이 두 가지 방법은 표현 방법은 메모리나 시간 사용 특성이 굉장히 다르다. 27.4.1 인접 리스트 (adjacency list) 표현 그래프의 각 정점 마다 해당 정점에서 나가는 간선의 목록을 저장해서 그래프를 표현\n각 정점(node)마다 하나의 연결 리스트를 갖는 방식으로 구현\n노드 중심\nadjacent[i]: 정점 i와 간선을 통해 연결된 정점들의 번호를 저장하는 연결 리스트\n실제로는 이 리스트에 정보를 추가, 삭제 할 일이 많지 않기 때문에 동적 배열을 사용해도 좋다 무방향 그래프(Undirected Graph)에서 (a, b) 간선은 두 번 저장된다.\n한 번은 a 정점에 인접한 간선을 저장하고 다른 한 번은 b에 인접한 간선을 저장한다. 정점의 수: N, 간선의 수: E인 무방향 그래프의 경우 N개의 리스트, N개의 배열, 2E개의 노드가 필요 0: 1 1: 2 2: 0, 3 3: 2 4: 6 5: 4 6: 5 장점\nO(V+E) 크기의 메모리 공간을 사용 어떤 노드에 인접한 노드들을 쉽게 찾을 수 있다. 단점\n간선 (u, v)가 존재하는 확인하기 위해서는 연결 리스트 (adjacent[i])를 처음 부터 읽어가면서 각 원소를 일일이 확인해야 한다 간선의 존재 여부와 정점의 차수: 정점 i의 리스트에 있는 노드의 수 즉, 정점 차수만큼의 시간이 필요 27.4.2 인접 행렬(adjacency matrix) 표현 인접 리스트 표현의 큰 단점은 두 정점이 주어질 때 이 정점이 연결되어 있는 지를 알기 위해서는 연결 리스트를 일일이 뒤져야 한다는 것\n이와 같은 연산의 속도를 높이기 위해 고안된 그래프 표현 방식이 인접 행렬이다.\n그래프의 인접 행렬은 이름에서 유추할 수 있듯이 |V|x|V| 크기의 행렬 (2차원 배열)을 이용해 간선의 정보를 저장한다.\nadjacent[i][j]: 정점 i에서 정점 j로 가는 간선이 있는지를 나타내는 boolean 값 변수\n가중치 그래프를 인접 행렬로 표현하려면 각 간선의 정보를 boolean 이 아니라, 정수, 실수(가중치 값)로 두면 된다.\n두 정점 사이에 간선이 없는 경우 -1 or inf 로 지정한다. 무방향 그래프를 인접 행렬로 표현한다면 이 행렬은 **대칭 행렬(Symmetric Matrix)**이 된다.\n물론 방향 그래프는 대칭 행렬이 안 될 수도 있다 1 2 3 4 if (간선 (i, j)가 그래프에 존재): matrix[i][j] = 1; else matrix[i][j] = 0; 장점\n정점의 번호 u, v가 주어졌을 때, 두 정점을 잇는 간선이 있는지를 한 번의 배열 접근만으로 확인 가능 정점의 차수 는 O(V) 안에 알 수 있다: 인접 배열의 i번 째 행 또는 열을 모두 더한다. 단점\n실제의 간선의 개수와 관계없이 항상 O(V^2) 크기의 메모리 공간을 사용 어떤 노드에 인접한 노드들을 찾기 위해서는 모든 노드를 전부 순회해야 한다. 그래프에 존재하는 모든 간선의 수는 O(V^2) 안에 알 수 있다. : 인접 행렬 전체를 조사한다. 27.4.3 인접 행렬 vs 인접 리스트 서로 완전히 정반대의 특성을 가져서, 한 방식의 단점이 바로 다른 방식의 장점이다. 따라서, 알고리즘, 그래프의 종류에 따라서 2가지 중 적절히 선택해야 한다. 간선의 수가 V^2 에 비해 훨씬 적은 그래프를 희소 그래프(sparse graph) 라고 한다. 인접 리스트를 사용하는 것이 유리 반대로, 간선의 수가 거의 V^2에 비례하는 그래프를 밀집 그래프(dense graph) 라고 한다. 인접 행렬을 사용하는 것이 유리 27.4.4 에지 리스트(Edge List) 간선, edge를 중심으로 그래프를 표현 에지 리스트는 리스트에 출발 노드, 도착 노드를 저장하여 Edge를 표현 또는 출발 노드, 도착 노드, 가중치를 저장 MST, 벨만-포드, 크루스칼에 주로 사용 노드 중심 알고리즘에는 잘 사용하지 않음. edgeLst = [ (1,2,8), (1,3,3), (3,4,13), (2,4,4), (2,5,15), (4,5,2) ] # 출발, 도착, 가중치 27.4.5 암시적 그래프 표현 그래프를 이용해 푸는 문제라고 해서, 항상 그래프를 직접 메모리에 표현해야 하는 것은 아니다.\n암시적 그래프로 표현 가능\n2차원 board에서 미로 최단 경로 찾기 각 빈칸을 정수 일렬번호를 갖는 정점으로 표현하는 대신, **빈 칸의 위치 (y, x)**로 표현 할 수 있다 주어진 입력을 그래프로 변환하는 번거로운 과정을 거칠 필요 없이 BFS 가능 15-퍼즐 모든 상태(16!===20조) 를 그래프로 표현하는 것은 실용적인 방법이 아니다. 암시적 그래프 표현이 항상 더 좋은 것은 아니다.\n그래프 사용 알고리즘과 변환 과정이 합쳐지게 되면 더 복잡해 질 수 도 있다.\n번거롭더라도 입력을 미리 그래프 표현으로 바꿔 두는 것이 전체 코드를 더 간결하게 할 수 있다.\nReference 프로그래밍 대회에서 배우는 알고리즘 문제 해결 전략 (구종만, 인사이트) https://www.algospot.com/ ","wordCount":"1119","inLanguage":"en","image":"http://localhost:1313/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E","datePublished":"2024-01-22T01:01:46+09:00","dateModified":"2024-01-22T01:01:46+09:00","author":{"@type":"Person","name":"2taezeat"},"mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:1313/posts/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EB%AC%B8%EC%A0%9C-%ED%95%B4%EA%B2%B0-%EC%A0%84%EB%9E%B5/2024-01-22-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EB%AC%B8%EC%A0%9C-%ED%95%B4%EA%B2%B0-%EC%A0%84%EB%9E%B5-%EA%B7%B8%EB%9E%98%ED%94%84-ch27/"},"publisher":{"@type":"Organization","name":"2taezeat, blog","logo":{"@type":"ImageObject","url":"http://localhost:1313/icon/favicon.ico"}}}</script></head><body id=top><header class=header><nav class=nav><div class=logo><a href=http://localhost:1313/ accesskey=h title="2taezeat blog (Alt + H)"><img src=http://localhost:1313/icon/apple-touch-icon.png alt aria-label=logo height=30>2taezeat blog</a><div class=logo-switches></div></div><ul id=menu><li><a href=http://localhost:1313/tags/ title=Tags><span>Tags</span></a></li><li><a href=http://localhost:1313/archives/ title=Archives><span>Archives</span></a></li><li><a href=http://localhost:1313/searchs/ title=Search><span>Search</span></a></li><li><a href=https://github.com/2taezeat title=Github><span>Github</span>&nbsp;<svg fill="none" shape-rendering="geometricPrecision" stroke="currentcolor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2.5" viewBox="0 0 24 24" height="12" width="12"><path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"/><path d="M15 3h6v6"/><path d="M10 14 21 3"/></svg></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=http://localhost:1313/>Home</a>&nbsp;»&nbsp;<a href=http://localhost:1313/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">알고리즘 문제 해결 전략, 그래프 (ch27)</h1><div class=post-meta><span title='2024-01-22 01:01:46 +0900 KST'>2024-01-22</span>&nbsp;·&nbsp;6 min&nbsp;·&nbsp;1119 words&nbsp;·&nbsp;2taezeat</div></header><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#27-그래프의-표현과-정의>27. 그래프의 표현과 정의</a><ul><li><a href=#271-도입>27.1 도입</a><ul><li><a href=#2711-그래프의-정의>27.1.1 그래프의 정의</a></li><li><a href=#2712-그래프의-종류>27.1.2 그래프의 종류</a></li><li><a href=#2713-그래프의-경로>27.1.3 그래프의 경로</a></li></ul></li><li><a href=#272-그래프의-사용-예>27.2 그래프의 사용 예</a></li><li><a href=#273-암시적-그래프-구조들>27.3 암시적 그래프 구조들</a></li><li><a href=#274-그래프의-표현-방법>27.4 그래프의 표현 방법</a><ul><li><a href=#2741-인접-리스트-adjacency-list-표현>27.4.1 <strong>인접 리스트 (adjacency list)</strong> 표현</a></li><li><a href=#2742-인접-행렬adjacency-matrix-표현>27.4.2 <strong>인접 행렬(adjacency matrix)</strong> 표현</a></li><li><a href=#2743-인접-행렬-vs-인접-리스트>27.4.3 인접 행렬 vs 인접 리스트</a></li><li><a href=#2744-에지-리스트edge-list>27.4.4 에지 리스트(Edge List)</a></li><li><a href=#2745-암시적-그래프-표현>27.4.5 암시적 그래프 표현</a></li></ul></li></ul></li><li><a href=#reference>Reference</a></li></ul></nav></div></details></div><div class=post-content><p><strong>&lsquo;프로그래밍 대회에서 배우는 알고리즘 문제 해결 전략&rsquo;을 읽고, 정리한다.</strong></p><hr><p>07장. <strong>그래프</strong> 정리</p><ul><li>ch27. 그래프의 표현과 정의</li></ul><h1 id=27-그래프의-표현과-정의>27. 그래프의 표현과 정의<a hidden class=anchor aria-hidden=true href=#27-그래프의-표현과-정의>#</a></h1><h2 id=271-도입>27.1 도입<a hidden class=anchor aria-hidden=true href=#271-도입>#</a></h2><ul><li>그래프(graph)는 현실 세계의 사물이나 추상적인 개념 간의 <strong>연결 관계</strong>를 표현한다.<ul><li><strong>트리</strong>에 있었던 <strong>부모 자식 관계</strong>에 관한 제약이 없기 때문에 그래프는 트리보다 다양한 구조를 표현할 수 있다.</li><li>트리도 그래프 중 하나</li></ul></li></ul><h3 id=2711-그래프의-정의>27.1.1 그래프의 정의<a hidden class=anchor aria-hidden=true href=#2711-그래프의-정의>#</a></h3><ul><li>그래프 G(V, E)는 어떤 자료나 개념을 표현하는 정점(vertex, node)의 집합 V와 이들을 연결하는 간선(edge)들의 집합 E로 구성된 자료구조 이다.</li><li>그래프는 정점들과 간선들로 정의되며, 정점의 위치 정보나 간선의 순서 등은 그래프의 정의에 포함되지 않는다.<ul><li>아래 그래프들은 모두 같은 그래프를 표현한다.</li></ul></li></ul><h3 id=2712-그래프의-종류>27.1.2 그래프의 종류<a hidden class=anchor aria-hidden=true href=#2712-그래프의-종류>#</a></h3><ul><li><p><strong>방향 그래프(directed graph) or 유향 그래프</strong></p><ul><li>방향 그래프에서는 각 간선이 <strong>방향</strong>이라는 새로운 속성을 갖는다.</li><li><code>u -> v</code> 와 <code>v-> u</code> 는 서로 다른 간선이다.</li></ul></li><li><p><strong>무향 그래프</strong></p><ul><li>간선에 방향이 없는 그래프</li></ul></li><li><p><strong>가중치 그래프(weighted graph)</strong></p><ul><li>각 각선에 가중치(weight)라고 불리는 실수 속성을 부여</li></ul></li><li><p><strong>다중 그래프(multigraph)</strong></p><ul><li>두 정점 사이에 두 개 이상의 간선이 있을 수 있는 그래프</li></ul></li><li><p><strong>단순 그래프</strong></p><ul><li>두 정점 사이에 최대 한 개의 간선만 있는 그래프</li></ul></li><li><p><strong>트리 or 루트 없는 트리(unrooted tree)</strong></p><ul><li>부모 자식 관계가 없을 뿐, 간선 들의 연결 관계만 보면 트리와 같은 무향 그래프를 말한다.</li><li>간선들의 연결 관계가 트리와 같다는 말은, 간선을 통해 두 정점을 잇는 방법이 <strong>딱 하나밖</strong>에 없다는 의미</li></ul></li><li><p><strong>이분 그래프(bipartite graph)</strong></p><ul><li>그래프의 정점들을 겹치지 않는 두 개의 그룹으로 나눠서 서로 다른 그룹에 속한 정점들 간에만 간선이 존재하도록 만들 수 있는 그래프</li><li>Ex) 남성과 여성</li></ul></li><li><p><strong>사이클 없는 방향 그래프(directed acyclic graph, DAG)</strong></p><ul><li><p>방향 그래프인데, **한 점에서 출발해 자기 자신으로 돌아오는 경로(사이클)**가 존재하지 않는 경우</p></li><li><p>간선의 방향을 무시할 경우 DAG에는 사이클이 존재할 수도 있다.</p></li></ul></li></ul><h3 id=2713-그래프의-경로>27.1.3 그래프의 경로<a hidden class=anchor aria-hidden=true href=#2713-그래프의-경로>#</a></h3><ul><li><strong>경로(path)</strong>: 끝과 끝이 서로 연결된 <strong>간선</strong>들을 <strong>순서</strong>대로 <strong>나열</strong> 한 것<ul><li>주로, 거쳐 가는 정점의 번호만을 간단히 써서 표기함</li><li><code>(1, 2), (2, 4), (4, 5) === 1 -> 4 -> 5</code></li></ul></li><li>방향 그래프의 경우 앞 간선의 끝점이 뒷 간선의 시작점과 만나야 한다</li><li>경로 중 한 정점을 <strong>최대 한 번만</strong>지나는 경로를 **단순 경로(simple path)**라고 한다.</li><li>현대 그래프 이론에서는 &lsquo;경로&rsquo; 라고 하면 대부분은 &lsquo;<strong>단순 경로</strong>&lsquo;를 의미한다.<ul><li>한 정점을 두 번 이상 지날 수 있는 경로를 이야기 할 대는 별도로 이 사실을 명시한다.</li></ul></li><li>시작한 점에서 끝나는 경로를 <strong>사이클</strong> 라고 한다.<ul><li><strong>사이클(cycle):</strong> 시작점과 끝나는 점이 같은 경로</li></ul></li></ul><h2 id=272-그래프의-사용-예>27.2 그래프의 사용 예<a hidden class=anchor aria-hidden=true href=#272-그래프의-사용-예>#</a></h2><ul><li>현실 세계의 수 많은 문제를 풀기 위해 그래프가 사용된다.</li><li>철도망의 안전성 분석</li><li>소셜 네트워크 분석</li><li>인터넷 전송 속도 계산</li><li>한 붓 그리기<ul><li>주어진 그래프의 모든 간선을 한 번씩만 지나는 경로: <strong>오일러 경로(Eulerian path)</strong></li></ul></li><li>외환 거래</li></ul><h2 id=273-암시적-그래프-구조들>27.3 암시적 그래프 구조들<a hidden class=anchor aria-hidden=true href=#273-암시적-그래프-구조들>#</a></h2><ul><li><p>현실 세계에서 그래프 같은 형태를 갖는 구조가 아니라도 그래프를 통해서 표현하면 쉽게 해결 할 수 있는 문제</p><ul><li>이 같은 그래프 구조를 <strong>암시적 그래프(implicit graph)</strong> 라고 한다.</li><li>Ex) 2차원 board에서 미로 최단 경로 찾기</li></ul></li><li><p>할 일 목록 정리</p><ul><li>위상 정렬(topological sorting), DFS를 응용</li></ul></li><li><p>15-퍼즐</p></li><li><p>게임판 덮기</p></li><li><p>회의실 배정</p><ul><li>만족성 문제(satisfiability problem)</li><li>모든 사람이 두 선택지 중 하나를 선택해야 하는 문제: 2-SAT 문제</li></ul></li></ul><h2 id=274-그래프의-표현-방법>27.4 그래프의 표현 방법<a hidden class=anchor aria-hidden=true href=#274-그래프의-표현-방법>#</a></h2><ul><li>많은 경우 그래프는 트리에 비해 <strong>정적</strong>인 용도로 사용된다.<ul><li>보다 <strong>정적</strong>이라는 말은 새로운 정점이나 간선을 추가, 삭제 하는 일이 자주 일어나지 않는다는 의미</li><li>따라서 대부분의 그래프는 구조의 변경이 어렵더라도 좀 더 간단하고 메모리를 적게 차지하는 방법으로 구현된다.</li></ul></li><li>그래프의 정점(node)들을 객체의 인스턴스로 표현하는 대신(트리 방식), 각 정점에 0부터 시작하는 <strong>번호</strong>를 붙이고, <strong>배열</strong>에 각 정점의 정보를 저장하는 것</li><li>그래프의 표현 방식은 간선(edge)의 정보를 어떤 식으로 저장하는냐에 따라 크게 2가지로 나눈다.<ul><li>이 두 가지 방법은 표현 방법은 메모리나 시간 사용 특성이 굉장히 다르다.</li></ul></li></ul><h3 id=2741-인접-리스트-adjacency-list-표현>27.4.1 <strong>인접 리스트 (adjacency list)</strong> 표현<a hidden class=anchor aria-hidden=true href=#2741-인접-리스트-adjacency-list-표현>#</a></h3><ul><li><p>그래프의 각 정점 마다 해당 정점에서 나가는 간선의 목록을 저장해서 그래프를 표현</p></li><li><p>각 정점(node)마다 하나의 <strong>연결 리스트</strong>를 갖는 방식으로 구현</p></li><li><p>노드 중심</p></li><li><p><code>adjacent[i]: 정점 i와 간선을 통해 연결된 정점들의 번호를 저장하는 연결 리스트</code></p><ul><li>실제로는 이 리스트에 정보를 추가, 삭제 할 일이 많지 않기 때문에 <strong>동적 배열</strong>을 사용해도 좋다</li></ul></li><li><p>무방향 그래프(Undirected Graph)에서 (a, b) 간선은 두 번 저장된다.</p><ol><li>한 번은 a 정점에 인접한 간선을 저장하고 다른 한 번은 b에 인접한 간선을 저장한다.</li><li>정점의 수: N, 간선의 수: E인 무방향 그래프의 경우</li><li>N개의 리스트, N개의 배열, 2E개의 노드가 필요</li></ol></li><li><pre tabindex=0><code>0: 1
1: 2
2: 0, 3
3: 2
4: 6
5: 4
6: 5
</code></pre></li><li><p>장점</p><ul><li>O(V+E) 크기의 메모리 공간을 사용</li><li>어떤 노드에 인접한 노드들을 쉽게 찾을 수 있다.</li></ul></li><li><p>단점</p><ul><li>간선 (u, v)가 존재하는 확인하기 위해서는 연결 리스트 (adjacent[i])를 처음 부터 읽어가면서 각 원소를 일일이 확인해야 한다</li><li>간선의 존재 여부와 정점의 차수: 정점 i의 리스트에 있는 노드의 수 즉, 정점 차수만큼의 시간이 필요</li></ul></li></ul><h3 id=2742-인접-행렬adjacency-matrix-표현>27.4.2 <strong>인접 행렬(adjacency matrix)</strong> 표현<a hidden class=anchor aria-hidden=true href=#2742-인접-행렬adjacency-matrix-표현>#</a></h3><ul><li><p><strong>인접 리스트</strong> 표현의 큰 단점은 두 정점이 주어질 때 이 정점이 연결되어 있는 지를 알기 위해서는 연결 리스트를 일일이 뒤져야 한다는 것</p></li><li><p>이와 같은 연산의 속도를 높이기 위해 고안된 그래프 표현 방식이 인접 행렬이다.</p></li><li><p>그래프의 인접 행렬은 이름에서 유추할 수 있듯이 |V|x|V| 크기의 행렬 (2차원 배열)을 이용해 간선의 정보를 저장한다.</p></li><li><p><code>adjacent[i][j]: 정점 i에서 정점 j로 가는 간선이 있는지를 나타내는 boolean 값 변수</code></p></li><li><p><strong>가중치 그래프</strong>를 인접 행렬로 표현하려면 각 간선의 정보를 boolean 이 아니라, 정수, 실수(가중치 값)로 두면 된다.</p><ul><li>두 정점 사이에 간선이 없는 경우 -1 or inf 로 지정한다.</li></ul></li><li><p>무방향 그래프를 인접 행렬로 표현한다면 이 행렬은 **대칭 행렬(Symmetric Matrix)**이 된다.</p><ul><li>물론 방향 그래프는 대칭 행렬이 안 될 수도 있다</li></ul></li><li><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>if</span> <span class=p>(</span><span class=n>간선</span> <span class=p>(</span><span class=n>i</span><span class=p>,</span> <span class=n>j</span><span class=p>)</span><span class=n>가</span> <span class=n>그래프에</span> <span class=n>존재</span><span class=p>):</span>
</span></span><span class=line><span class=cl>	<span class=n>matrix</span><span class=p>[</span><span class=n>i</span><span class=p>][</span><span class=n>j</span><span class=p>]</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>else</span>
</span></span><span class=line><span class=cl>	<span class=n>matrix</span><span class=p>[</span><span class=n>i</span><span class=p>][</span><span class=n>j</span><span class=p>]</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span></code></pre></td></tr></table></div></div></li><li><p>장점</p><ul><li>정점의 번호 u, v가 주어졌을 때, 두 정점을 잇는 간선이 있는지를 <strong>한 번의 배열 접근만</strong>으로 확인 가능</li><li>정점의 차수 는 O(V) 안에 알 수 있다: 인접 배열의 i번 째 행 또는 열을 모두 더한다.</li></ul></li><li><p>단점</p><ul><li>실제의 간선의 개수와 관계없이 항상 O(V^2) 크기의 메모리 공간을 사용</li><li>어떤 노드에 인접한 노드들을 찾기 위해서는 모든 노드를 전부 순회해야 한다.</li><li>그래프에 존재하는 모든 간선의 수는 O(V^2) 안에 알 수 있다. : 인접 행렬 전체를 조사한다.</li></ul></li></ul><h3 id=2743-인접-행렬-vs-인접-리스트>27.4.3 인접 행렬 vs 인접 리스트<a hidden class=anchor aria-hidden=true href=#2743-인접-행렬-vs-인접-리스트>#</a></h3><ul><li>서로 완전히 정반대의 특성을 가져서, 한 방식의 단점이 바로 다른 방식의 장점이다.</li><li>따라서, 알고리즘, 그래프의 종류에 따라서 <strong>2가지 중 적절히</strong> 선택해야 한다.</li><li>간선의 수가 V^2 에 비해 훨씬 적은 그래프를 <strong>희소 그래프(sparse graph)</strong> 라고 한다.<ul><li><strong>인접 리스트</strong>를 사용하는 것이 유리</li></ul></li><li>반대로, 간선의 수가 거의 V^2에 비례하는 그래프를 <strong>밀집 그래프(dense graph)</strong> 라고 한다.<ul><li>인접 행렬을 사용하는 것이 유리</li></ul></li></ul><h3 id=2744-에지-리스트edge-list>27.4.4 에지 리스트(Edge List)<a hidden class=anchor aria-hidden=true href=#2744-에지-리스트edge-list>#</a></h3><ul><li>간선, edge를 중심으로 그래프를 표현</li><li>에지 리스트는 리스트에 <code>출발 노드, 도착 노드</code>를 저장하여 Edge를 표현</li><li>또는 <code>출발 노드, 도착 노드, 가중치</code>를 저장</li><li><strong>MST, 벨만-포드, 크루스칼</strong>에 주로 사용</li><li><strong>노드 중심 알고리즘</strong>에는 잘 사용하지 않음.</li><li><code>edgeLst = [ (1,2,8), (1,3,3), (3,4,13), (2,4,4), (2,5,15), (4,5,2) ] # 출발, 도착, 가중치</code></li></ul><h3 id=2745-암시적-그래프-표현>27.4.5 암시적 그래프 표현<a hidden class=anchor aria-hidden=true href=#2745-암시적-그래프-표현>#</a></h3><ul><li><p>그래프를 이용해 푸는 문제라고 해서, 항상 그래프를 <strong>직접 메모리에 표현</strong>해야 <strong>하는 것은 아니다.</strong></p></li><li><p>암시적 그래프로 표현 가능</p><ul><li>2차원 board에서 미로 최단 경로 찾기<ul><li>각 빈칸을 정수 일렬번호를 갖는 정점으로 표현하는 대신, **<code>빈 칸의 위치 (y, x)</code>**로 표현 할 수 있다</li><li>주어진 입력을 그래프로 변환하는 번거로운 과정을 거칠 필요 없이 BFS 가능</li></ul></li><li>15-퍼즐<ul><li>모든 상태(16!===20조) 를 그래프로 표현하는 것은 실용적인 방법이 아니다.</li></ul></li></ul></li><li><p><strong>암시적 그래프 표현</strong>이 항상 더 좋은 것은 아니다.</p><ul><li><p>그래프 사용 알고리즘과 변환 과정이 합쳐지게 되면 더 복잡해 질 수 도 있다.</p></li><li><p>번거롭더라도 입력을 미리 그래프 표현으로 바꿔 두는 것이 전체 코드를 더 간결하게 할 수 있다.</p></li></ul></li></ul><h1 id=reference>Reference<a hidden class=anchor aria-hidden=true href=#reference>#</a></h1><ul><li>프로그래밍 대회에서 배우는 알고리즘 문제 해결 전략 (구종만, 인사이트)</li><li><a href=https://www.algospot.com/>https://www.algospot.com/</a></li></ul></div><footer class=post-footer><ul class=post-tags></ul><nav class=paginav><a class=prev href=http://localhost:1313/posts/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EB%AC%B8%EC%A0%9C-%ED%95%B4%EA%B2%B0-%EC%A0%84%EB%9E%B5/2024-01-23-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EB%AC%B8%EC%A0%9C-%ED%95%B4%EA%B2%B0-%EC%A0%84%EB%9E%B5-%EA%B7%B8%EB%9E%98%ED%94%84-ch28/><span class=title>« Prev</span><br><span>알고리즘 문제 해결 전략, 그래프 (ch28)</span>
</a><a class=next href=http://localhost:1313/posts/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EB%AC%B8%EC%A0%9C-%ED%95%B4%EA%B2%B0-%EC%A0%84%EB%9E%B5/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EB%AC%B8%EC%A0%9C-%ED%95%B4%EA%B2%B0-%EC%A0%84%EB%9E%B5-%ED%8A%B8%EB%A6%AC-ch26/><span class=title>Next »</span><br><span>알고리즘 문제 해결 전략, 트리 (ch26)</span></a></nav><ul class=share-buttons><li><a target=_blank rel="noopener noreferrer" aria-label="share 알고리즘 문제 해결 전략, 그래프 (ch27) on x" href="https://x.com/intent/tweet/?text=%ec%95%8c%ea%b3%a0%eb%a6%ac%ec%a6%98%20%eb%ac%b8%ec%a0%9c%20%ed%95%b4%ea%b2%b0%20%ec%a0%84%eb%9e%b5%2c%20%ea%b7%b8%eb%9e%98%ed%94%84%20%28ch27%29&amp;url=http%3a%2f%2flocalhost%3a1313%2fposts%2f%25EC%2595%258C%25EA%25B3%25A0%25EB%25A6%25AC%25EC%25A6%2598-%25EB%25AC%25B8%25EC%25A0%259C-%25ED%2595%25B4%25EA%25B2%25B0-%25EC%25A0%2584%25EB%259E%25B5%2f2024-01-22-%25EC%2595%258C%25EA%25B3%25A0%25EB%25A6%25AC%25EC%25A6%2598-%25EB%25AC%25B8%25EC%25A0%259C-%25ED%2595%25B4%25EA%25B2%25B0-%25EC%25A0%2584%25EB%259E%25B5-%25EA%25B7%25B8%25EB%259E%2598%25ED%2594%2584-ch27%2f&amp;hashtags="><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446C483.971.0 512 28.03 512 62.554zM269.951 190.75 182.567 75.216H56L207.216 272.95 63.9 436.783h61.366L235.9 310.383l96.667 126.4H456L298.367 228.367l134-153.151H371.033zM127.633 110h36.468l219.38 290.065H349.5z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share 알고리즘 문제 해결 전략, 그래프 (ch27) on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=http%3a%2f%2flocalhost%3a1313%2fposts%2f%25EC%2595%258C%25EA%25B3%25A0%25EB%25A6%25AC%25EC%25A6%2598-%25EB%25AC%25B8%25EC%25A0%259C-%25ED%2595%25B4%25EA%25B2%25B0-%25EC%25A0%2584%25EB%259E%25B5%2f2024-01-22-%25EC%2595%258C%25EA%25B3%25A0%25EB%25A6%25AC%25EC%25A6%2598-%25EB%25AC%25B8%25EC%25A0%259C-%25ED%2595%25B4%25EA%25B2%25B0-%25EC%25A0%2584%25EB%259E%25B5-%25EA%25B7%25B8%25EB%259E%2598%25ED%2594%2584-ch27%2f&amp;title=%ec%95%8c%ea%b3%a0%eb%a6%ac%ec%a6%98%20%eb%ac%b8%ec%a0%9c%20%ed%95%b4%ea%b2%b0%20%ec%a0%84%eb%9e%b5%2c%20%ea%b7%b8%eb%9e%98%ed%94%84%20%28ch27%29&amp;summary=%ec%95%8c%ea%b3%a0%eb%a6%ac%ec%a6%98%20%eb%ac%b8%ec%a0%9c%20%ed%95%b4%ea%b2%b0%20%ec%a0%84%eb%9e%b5%2c%20%ea%b7%b8%eb%9e%98%ed%94%84%20%28ch27%29&amp;source=http%3a%2f%2flocalhost%3a1313%2fposts%2f%25EC%2595%258C%25EA%25B3%25A0%25EB%25A6%25AC%25EC%25A6%2598-%25EB%25AC%25B8%25EC%25A0%259C-%25ED%2595%25B4%25EA%25B2%25B0-%25EC%25A0%2584%25EB%259E%25B5%2f2024-01-22-%25EC%2595%258C%25EA%25B3%25A0%25EB%25A6%25AC%25EC%25A6%2598-%25EB%25AC%25B8%25EC%25A0%259C-%25ED%2595%25B4%25EA%25B2%25B0-%25EC%25A0%2584%25EB%259E%25B5-%25EA%25B7%25B8%25EB%259E%2598%25ED%2594%2584-ch27%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share 알고리즘 문제 해결 전략, 그래프 (ch27) on reddit" href="https://reddit.com/submit?url=http%3a%2f%2flocalhost%3a1313%2fposts%2f%25EC%2595%258C%25EA%25B3%25A0%25EB%25A6%25AC%25EC%25A6%2598-%25EB%25AC%25B8%25EC%25A0%259C-%25ED%2595%25B4%25EA%25B2%25B0-%25EC%25A0%2584%25EB%259E%25B5%2f2024-01-22-%25EC%2595%258C%25EA%25B3%25A0%25EB%25A6%25AC%25EC%25A6%2598-%25EB%25AC%25B8%25EC%25A0%259C-%25ED%2595%25B4%25EA%25B2%25B0-%25EC%25A0%2584%25EB%259E%25B5-%25EA%25B7%25B8%25EB%259E%2598%25ED%2594%2584-ch27%2f&title=%ec%95%8c%ea%b3%a0%eb%a6%ac%ec%a6%98%20%eb%ac%b8%ec%a0%9c%20%ed%95%b4%ea%b2%b0%20%ec%a0%84%eb%9e%b5%2c%20%ea%b7%b8%eb%9e%98%ed%94%84%20%28ch27%29"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share 알고리즘 문제 해결 전략, 그래프 (ch27) on facebook" href="https://facebook.com/sharer/sharer.php?u=http%3a%2f%2flocalhost%3a1313%2fposts%2f%25EC%2595%258C%25EA%25B3%25A0%25EB%25A6%25AC%25EC%25A6%2598-%25EB%25AC%25B8%25EC%25A0%259C-%25ED%2595%25B4%25EA%25B2%25B0-%25EC%25A0%2584%25EB%259E%25B5%2f2024-01-22-%25EC%2595%258C%25EA%25B3%25A0%25EB%25A6%25AC%25EC%25A6%2598-%25EB%25AC%25B8%25EC%25A0%259C-%25ED%2595%25B4%25EA%25B2%25B0-%25EC%25A0%2584%25EB%259E%25B5-%25EA%25B7%25B8%25EB%259E%2598%25ED%2594%2584-ch27%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share 알고리즘 문제 해결 전략, 그래프 (ch27) on whatsapp" href="https://api.whatsapp.com/send?text=%ec%95%8c%ea%b3%a0%eb%a6%ac%ec%a6%98%20%eb%ac%b8%ec%a0%9c%20%ed%95%b4%ea%b2%b0%20%ec%a0%84%eb%9e%b5%2c%20%ea%b7%b8%eb%9e%98%ed%94%84%20%28ch27%29%20-%20http%3a%2f%2flocalhost%3a1313%2fposts%2f%25EC%2595%258C%25EA%25B3%25A0%25EB%25A6%25AC%25EC%25A6%2598-%25EB%25AC%25B8%25EC%25A0%259C-%25ED%2595%25B4%25EA%25B2%25B0-%25EC%25A0%2584%25EB%259E%25B5%2f2024-01-22-%25EC%2595%258C%25EA%25B3%25A0%25EB%25A6%25AC%25EC%25A6%2598-%25EB%25AC%25B8%25EC%25A0%259C-%25ED%2595%25B4%25EA%25B2%25B0-%25EC%25A0%2584%25EB%259E%25B5-%25EA%25B7%25B8%25EB%259E%2598%25ED%2594%2584-ch27%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share 알고리즘 문제 해결 전략, 그래프 (ch27) on telegram" href="https://telegram.me/share/url?text=%ec%95%8c%ea%b3%a0%eb%a6%ac%ec%a6%98%20%eb%ac%b8%ec%a0%9c%20%ed%95%b4%ea%b2%b0%20%ec%a0%84%eb%9e%b5%2c%20%ea%b7%b8%eb%9e%98%ed%94%84%20%28ch27%29&amp;url=http%3a%2f%2flocalhost%3a1313%2fposts%2f%25EC%2595%258C%25EA%25B3%25A0%25EB%25A6%25AC%25EC%25A6%2598-%25EB%25AC%25B8%25EC%25A0%259C-%25ED%2595%25B4%25EA%25B2%25B0-%25EC%25A0%2584%25EB%259E%25B5%2f2024-01-22-%25EC%2595%258C%25EA%25B3%25A0%25EB%25A6%25AC%25EC%25A6%2598-%25EB%25AC%25B8%25EC%25A0%259C-%25ED%2595%25B4%25EA%25B2%25B0-%25EC%25A0%2584%25EB%259E%25B5-%25EA%25B7%25B8%25EB%259E%2598%25ED%2594%2584-ch27%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentcolor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share 알고리즘 문제 해결 전략, 그래프 (ch27) on ycombinator" href="https://news.ycombinator.com/submitlink?t=%ec%95%8c%ea%b3%a0%eb%a6%ac%ec%a6%98%20%eb%ac%b8%ec%a0%9c%20%ed%95%b4%ea%b2%b0%20%ec%a0%84%eb%9e%b5%2c%20%ea%b7%b8%eb%9e%98%ed%94%84%20%28ch27%29&u=http%3a%2f%2flocalhost%3a1313%2fposts%2f%25EC%2595%258C%25EA%25B3%25A0%25EB%25A6%25AC%25EC%25A6%2598-%25EB%25AC%25B8%25EC%25A0%259C-%25ED%2595%25B4%25EA%25B2%25B0-%25EC%25A0%2584%25EB%259E%25B5%2f2024-01-22-%25EC%2595%258C%25EA%25B3%25A0%25EB%25A6%25AC%25EC%25A6%2598-%25EB%25AC%25B8%25EC%25A0%259C-%25ED%2595%25B4%25EA%25B2%25B0-%25EC%25A0%2584%25EB%259E%25B5-%25EA%25B7%25B8%25EB%259E%2598%25ED%2594%2584-ch27%2f"><svg width="30" height="30" viewBox="0 0 512 512" fill="currentcolor" xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"><path d="M449.446.0C483.971.0 512 28.03 512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446zM183.8767 87.9921h-62.034L230.6673 292.4508V424.0079h50.6655V292.4508L390.1575 87.9921H328.1233L256 238.2489z"/></svg></a></li></ul></footer><script src=https://utteranc.es/client.js repo=2taezeat/blog_comment issue-term=pathname label=comment theme=github-light crossorigin=anonymous async></script></article></main><footer class=footer><span>&copy; 2024 <a href=http://localhost:1313/>2taezeat, blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>