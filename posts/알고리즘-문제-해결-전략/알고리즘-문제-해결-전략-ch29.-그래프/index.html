<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>[알고리즘 문제 해결 전략] ch29. 그래프 | 2taezeat, blog</title>
<meta name=keywords content="Algorithm"><meta name=description content="ch29. 그래프의 너비 우선 탐색 (BFS)"><meta name=author content="2taezeat"><link rel=canonical href=https://2taezeat.github.io/posts/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EB%AC%B8%EC%A0%9C-%ED%95%B4%EA%B2%B0-%EC%A0%84%EB%9E%B5/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EB%AC%B8%EC%A0%9C-%ED%95%B4%EA%B2%B0-%EC%A0%84%EB%9E%B5-ch29.-%EA%B7%B8%EB%9E%98%ED%94%84/><meta name=google-site-verification content="YaEERzgrvu-ZwPg7gswZdTzRMufkHw3uIH7i8hVal1c"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.ac5f9f91bda1d016954cea3021c7b0474ce8732b88eebfb20282c242585dcd7c.css integrity="sha256-rF+fkb2h0BaVTOowIcewR0zocyuI7r+yAoLCQlhdzXw=" rel="preload stylesheet" as=style><link rel=icon href=https://2taezeat.github.io/icon/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://2taezeat.github.io/icon/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://2taezeat.github.io/icon/favicon-32x32.png><link rel=apple-touch-icon href=https://2taezeat.github.io/icon/apple-touch-icon.png><link rel=mask-icon href=https://2taezeat.github.io/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://2taezeat.github.io/posts/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EB%AC%B8%EC%A0%9C-%ED%95%B4%EA%B2%B0-%EC%A0%84%EB%9E%B5/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EB%AC%B8%EC%A0%9C-%ED%95%B4%EA%B2%B0-%EC%A0%84%EB%9E%B5-ch29.-%EA%B7%B8%EB%9E%98%ED%94%84/><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><meta property="og:title" content="[알고리즘 문제 해결 전략] ch29. 그래프"><meta property="og:description" content="ch29. 그래프의 너비 우선 탐색 (BFS)"><meta property="og:type" content="article"><meta property="og:url" content="https://2taezeat.github.io/posts/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EB%AC%B8%EC%A0%9C-%ED%95%B4%EA%B2%B0-%EC%A0%84%EB%9E%B5/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EB%AC%B8%EC%A0%9C-%ED%95%B4%EA%B2%B0-%EC%A0%84%EB%9E%B5-ch29.-%EA%B7%B8%EB%9E%98%ED%94%84/"><meta property="og:image" content="https://2taezeat.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-01-24T11:30:03+00:00"><meta property="article:modified_time" content="2024-01-24T11:30:03+00:00"><meta property="og:site_name" content="2taezeat, blog"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://2taezeat.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="[알고리즘 문제 해결 전략] ch29. 그래프"><meta name=twitter:description content="ch29. 그래프의 너비 우선 탐색 (BFS)"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://2taezeat.github.io/posts/"},{"@type":"ListItem","position":2,"name":"[알고리즘 문제 해결 전략] ch29. 그래프","item":"https://2taezeat.github.io/posts/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EB%AC%B8%EC%A0%9C-%ED%95%B4%EA%B2%B0-%EC%A0%84%EB%9E%B5/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EB%AC%B8%EC%A0%9C-%ED%95%B4%EA%B2%B0-%EC%A0%84%EB%9E%B5-ch29.-%EA%B7%B8%EB%9E%98%ED%94%84/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"[알고리즘 문제 해결 전략] ch29. 그래프","name":"[알고리즘 문제 해결 전략] ch29. 그래프","description":"ch29. 그래프의 너비 우선 탐색 (BFS)","keywords":["Algorithm"],"articleBody":"29. 그래프의 너비 우선 탐색 29.1 도입 28.1.1 너비 우선 탐색(Breadth First Search) 너비 우선 탐색은 시작점에서 가까운 정점(Node)부터 순서대로 방문하는 탐색 알고리즘\n시작 노드에서 출발해 시작 노드를 기준으로 가까운 노드를 먼저 방문하면서 탐색하는 알고리즘\n각 정점을 방문할 때 마다 모든 인접 정점들을 검사\n이 중 처음 보는 정점을 발견하면, 이 정점을 방문 예정이라고 기록, 큐에 저장\n너비 우선 탐색의 방문 순서는 정점을 먼저 꺼내는지에 의해 결정\n이를 구현하는 방법은 목록에 먼저 넣은 정점을 항상 먼저 꺼내는 것\n정점 목록을 큐(queue) 를 사용하면 너비 우선 탐색의 조건을 만족시킬 수 있다.\n그래서 큐(queue) 를 쓰는 거다 그래프의 너비 우선 탐색 python 구현\nDFS의 visited[]가 각 정점의 방문 여부를 저장했던 것에 비해, BFS에서 discovered[]는 각 정점의 발견 여부를 저장한다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 discovered = [False for _ in range(N)] result = [] def bfs(startNode): q = deque([ [startNode] ]) discovered[startNode] = True while q: node = q.popleft() result.append(node) for nxt in graph[node]: if not discovered[nxt]: q.append(nxt) discovered[nxt] = True DFS와 달리 BFS에서는 발견(discover) 과 방문(visit) 이 같지 않다.\n모든 정점은 다음 3개의 상태를 순서대로 거쳐 간다.\n아직 발견되지 않은 상태 (visited = False) 발견되었지만 아직 방문되지 않은 상태 (in queue) 방문된 상태 (discoverd = True) BFS에서 새 정점을 발견하는데 사용했던 간선들을 모은 트리를 BFS 스패닝 트리(BFS Spanning Tree) 라고 한다.\n29.1.2 너비 우선 탐색의 시간 복잡도 DFS와 다를 게 없다. 모든 정점을 한 번씩 방문하며, 정점을 방문할 때마다 인접한 모든 간선을 검사한다 인접 리스트 인 경우: O(V+E) 인접 행렬 인 경우: O(V^2) 29.1.3 너비 우선 탐색과 최단 거리 그래프의 구조에 관한 다양한 문제를 푸는 데 사용되는 DFS와 달리, BFS는 대게 딱 하나의 용도로 사용된다. 바로 그래프의 최단 경로 문제를 풀 때 사용 BFS를 간단하게 변경해 모든 정점에 대해 시작점으로 부터의 거리 distance[]를 계산할 수 있기 때문이다. 시작점 부터 v까지의 최단 거리 distance[v]는 distance[u] + 1이다. 간선 (u, v)를 처음 발견해 큐에 넣었다고 가정할 때 시작점으로부터 다른 모든 정점까지의 최단 경로를 BFS 스패닝 트리 위에서 찾을 수 있다. 시작점으로 부터의 최단 경로는 ‘BFS 스패닝 트리에서 루트로 가는 경로’ 29.1.4 모든 점의 발견 그래프 전체 구조에 관한 정보를 얻기 위해 사용되는 DFS와 달리, BFS는 대게 시작점으로부터 다른 정점들까지의 거리를 구하기 위해 사용된다. 따라서, DFS 처럼 모든 정점을 검사하면서 수행하는 작업 BFS는 잘하지 않는다. 29.2, 29.3 Sorting Game, SORTGAME, 난이도: 중 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 dic = defaultdict(lambda: -1) # { \"1023\": 1, ... } def bfs(first, n, distance): q = deque() distance[first] = 0 dic[first] = 0 q.append(first) while q: here = q.popleft() cost = distance[here] for i in range(1, n): left = 0 for j in range(n - i, 0, -1): right = left + i A, B, C = here[0:left], here[left:right + 1][::-1], here[right + 1:] rev = A + B + C left += 1 if distance[rev] == -1: distance[rev] = cost + 1 dic[rev] = cost + 1 q.append(rev) def makeDic(): for n in range(1, 9): distance = defaultdict(lambda: -1) first = \"012345678\"[:n] bfs(first, n, distance) makeDic() for _ in range(int(input())): N = int(input()) L = list(map(int, input().split())) sorted_score = sorted(L) target = [sorted_score.index(s) for s in L] stringTarget = ''.join(str(s) for s in target) answer = dic[stringTarget] print(answer) 문제를 읽고, 그래프로 접근, 바꾸기 {3, 4, 1, 2} === {9, 100, 5, 6} 상대적 크기가 같음 모든 상태를 미리 BFS를 통해 계산 29.4, 29.5 어린이날, CHILDRENDAY, 난이도: 상 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 # 1. c \u003e= n + m # 2. c mod n = m # 3. d에 포함된 digit들로만 구성 # 흰색: 0 ~ n # 회색: n ~ 2n-1 def bfs(): q = deque([(0, 0)]) while q: currentNode, tmpResult = q.popleft() if currentNode - n == m: # 회색이면서, 현재 노드 값이 m일때 return tmpResult for dn in d: cal = currentNode * 10 + dn if cal \u003e= n: # 회색 nxtNode = (cal % n) + n else: # 흰색 nxtNode = (cal % n) if not discovered[nxtNode]: discovered[nxtNode] = True q.append([nxtNode, tmpResult * 10 + dn]) return -1 # 그래프를 만들고, 0 to m으로 가는 최단 경로를 찾는다. for _ in range(int(input())): d, n, m = input().split() n = int(n) m = int(m) d = sorted(map(int, list(d))) discovered = [False] * (2 * n) answer = bfs() if answer == -1: print(\"IMPOSSIBLE\") else: print(answer) 여러 개의 조건이 있는 문제 일부 조건을 없앤 더 단순한 문제를 푼 후, 조건을 하나하나 추가 mod 연산, 법칙 사전순으로 가장 최단 경로 =\u003e 임의의 순서 대신 번호가 증가하는 순서(오름 차순)으로 검사 조건 강제 29.6 (기본 BFS 말고) 최단 경로 전략 게임판의 상태를 그래프로 표현: 상태 공간(state space)\n15-퍼즐 문제는 그래프상의 최단 경로 문제로 변경 상태 공간을 전체 탐색하지 않고, 답을 찾는 데로 BFS를 종료하기 때문에 시간 복잡도를 다르게 계산해야 한다. 너브 우선 탐색이 방문하는 정점의 개수에 가장 직접적인 영향을 주는 요소는 최단 거리 d 이다. 방문하는 정점의 개수에 영향을 미치는 다른 요소는 탐색의 분기 수(branching factor) b 이다. 방문하는 정점의 수: O(b^d) 지수적으로 증가 29.6.1 양방향 탐색(bidirectional search) 시작 정점에서 시작하는 정방향 탐색과, 목표 정점에서 시작해 거꾸로 올라오는 역방향 탐색을 동시에 하면서, 이 둘이 가운데서 만나면 종료 정방향과 역방향 탐색에서 방문할 정점들을 모두 같은 큐에 넣음 최단 거리를 저장할 때는 정방향은 양수, 역방향은 음수로 저장 (구분하기 위해) 인접한 상태를 검사했는데, 서로 부호가 다르면, 가운데서 만났다는 의미 목표 상태에서 역방향으로 움직이기 쉬워야 가능 함 29.6.2 점점 깊어지는 탐색 양방향 탐색에서도 방문하는 정점 수는 최단 거리에 따라 지수적으로 증가, O(b^d/2)\n따라서, 규모가 큰 탐색 문제를 풀 때는 DFS를 기반으로 한 방법을 사용해야 함\nDFS는 방문할 정점의 목록을 유지하는 BFS와 달리 정점을 발견하는 즉시 방문 큐가 너무 많은 메모리를 차지하는 일이 발생하지 않음 그러나 최단 경로를 찾기 불가능\nDFS는 목표 상태를 찾아도 지금까지 찾은 경로가 최단 경로인지 확신할 수 없다. 각 정점을 방문하지 않으면 한 상태를 두 번 방문할 수 도 있고, 사이클에 빠져 탐색이 종료하지 않을 수 있다. IDS(Iteratively Deepening Search, 점점 깊어지는 탐색)이 이 문제를 해결하기 위해 고안됨\n임의의 깊이 제한 limit 보다 짧은 경로가 존재하는 DFS로 확인\n답을 찾으면 성공이니 반환 찾지 못하면, limit 을 늘려서 다시 시도 IDS는 조합 탐색(가지치기) 와 관계가 깊다.\n깊이 제한을 늘려가면서 DFS를 반복하면 한 정점을 두 번 이상 방문하는 낭비가 생겨난다. 방문하는 상태의 수 O(b^d) IDS는 큐를 사용하지 않기 때문에, 메모리는 스택만 사용함 최대 메모리 사용량은 탐색의 깊이에 비례하게 된다. O(d) 29.6.3 탐색 방법 선택하기 최단 경로 찾는 경우, BFS를 우선 고려 메모리 사용량, 탐색의 깊이 한계 확인 양방향 탐색 고려, 목표 상태에서 역방향으로 움직이기 쉬워야 함 IDS 고려 29.6.4 상태 객체의 구현 상태에 대한, 여러 연산을 가능한 한 효율적으로 구현 가능한 한 적은 메모리 사용 비트마스크 기법 일대일 대응 함수 현재 상태가 몇 번째인지 계산하는 일대일 함수를 작성하면, 현재 상태를 정수로 표현 가능 29.7, 29.8 하노이의 탑, HANOI4B, 난이도: 중 start state —–bfs for find 최단 경로—-\u003e end state 시작과 끝 상태가 유일하게 정해져 있음, 그래프가 양방향 그래프 이기 때문에 양방향 탐색ㅇ글 적용하기 용이하다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 def plus(x): if x \u003e 0: return x + 1 elif x \u003c 0: return x - 1 def judgeSign(x, y): if x * y \u003c 0: return True return False def changeStr(ori, i, j, iNum, jNum): lo = list(ori) lo[i] = \"0\" if jNum == 0: lo[j] = str(iNum) else: lo[j + 1] = str(iNum) return \"\".join(lo) def bfsWithBidir(): # 양방향 탐색 q = deque([(start, 1), (end, -1)]) while q: current, count = q.popleft() topIdx = [[(i * n), 0] for i in range(4)] for i in range(4, 0, -1): for j in range(1, n + 1): cIdx = i * n - j v = current[i * n - j] if v != \"0\": topIdx[i - 1][0] = cIdx topIdx[i - 1][1] = int(v) break for i in range(0, 4): idx, iNum = topIdx[i] if iNum == 0: continue for j in range(0, 4): if (i == j): continue jNum = topIdx[j][1] if (jNum == 0 or iNum \u003c jNum): # 옮길 수 있는 경우, 가능한 경우 change = changeStr(current, idx, topIdx[j][0], iNum, jNum) if (visited[change] == 0): # 방문하지 않은 경우 nc = plus(count) q.append((change, nc)) visited[change] = nc elif judgeSign(visited[change], visited[current]): # nxt Node가 방문되었고, 출발 방향이 다를때 =\u003e 중간에서 만난 경우 return abs(visited[change]) + abs(visited[current]) - 1 for _ in range(int(input())): n = int(input()) start = [\"0\"] * n * 4 end = [\"0\"] * n * 4 for i in range(4): t1 = list(map(int, input().split())) for j in range(t1[0]): start[i * n + j] = str(t1[j + 1]) for i in range(4): t1 = list(map(int, input().split())) for j in range(t1[0]): end[i * n + j] = str(t1[j + 1]) start = \"\".join(start) end = \"\".join(end) if start == end: print(0) continue visited = defaultdict(lambda: 0) visited[start] = 1 visited[end] = -1 answer = bfsWithBidir() print(answer) Reference 프로그래밍 대회에서 배우는 알고리즘 문제 해결 전략 (구종만, 인사이트) https://www.algospot.com/ ","wordCount":"1577","inLanguage":"en","image":"https://2taezeat.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E","datePublished":"2024-01-24T11:30:03Z","dateModified":"2024-01-24T11:30:03Z","author":{"@type":"Person","name":"2taezeat"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://2taezeat.github.io/posts/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EB%AC%B8%EC%A0%9C-%ED%95%B4%EA%B2%B0-%EC%A0%84%EB%9E%B5/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EB%AC%B8%EC%A0%9C-%ED%95%B4%EA%B2%B0-%EC%A0%84%EB%9E%B5-ch29.-%EA%B7%B8%EB%9E%98%ED%94%84/"},"publisher":{"@type":"Organization","name":"2taezeat, blog","logo":{"@type":"ImageObject","url":"https://2taezeat.github.io/icon/favicon.ico"}}}</script></head><body id=top><header class=header><nav class=nav><div class=logo><a href=https://2taezeat.github.io/ accesskey=h title="2taezeat blog (Alt + H)"><img src=https://2taezeat.github.io/icon/apple-touch-icon.png alt aria-label=logo height=30>2taezeat blog</a><div class=logo-switches></div></div><ul id=menu><li><a href=https://2taezeat.github.io/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://2taezeat.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://2taezeat.github.io/searchs/ title=Search><span>Search</span></a></li><li><a href=https://github.com/2taezeat title=Github><span>Github</span>&nbsp;<svg fill="none" shape-rendering="geometricPrecision" stroke="currentcolor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2.5" viewBox="0 0 24 24" height="12" width="12"><path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"/><path d="M15 3h6v6"/><path d="M10 14 21 3"/></svg></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://2taezeat.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://2taezeat.github.io/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">[알고리즘 문제 해결 전략] ch29. 그래프</h1><div class=post-description>ch29. 그래프의 너비 우선 탐색 (BFS)</div><div class=post-meta><span title='2024-01-24 11:30:03 +0000 +0000'>2024-01-24</span>&nbsp;·&nbsp;8 min&nbsp;·&nbsp;1577 words&nbsp;·&nbsp;2taezeat</div></header><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#29-그래프의-너비-우선-탐색>29. 그래프의 너비 우선 탐색</a><ul><li><a href=#291-도입>29.1 도입</a><ul><li><a href=#2811-너비-우선-탐색breadth-first-search>28.1.1 너비 우선 탐색(Breadth First Search)</a></li><li><a href=#2912-너비-우선-탐색의-시간-복잡도>29.1.2 너비 우선 탐색의 시간 복잡도</a></li><li><a href=#2913-너비-우선-탐색과-최단-거리>29.1.3 너비 우선 탐색과 최단 거리</a></li><li><a href=#2914-모든-점의-발견>29.1.4 모든 점의 발견</a></li></ul></li><li><a href=#292-293-sorting-game-sortgame-난이도-중>29.2, 29.3 Sorting Game, SORTGAME, 난이도: 중</a></li><li><a href=#294-295-어린이날-childrenday-난이도-상>29.4, 29.5 어린이날, CHILDRENDAY, 난이도: 상</a></li><li><a href=#296-기본-bfs-말고-최단-경로-전략>29.6 (기본 BFS 말고) 최단 경로 전략</a><ul><li><a href=#2961-양방향-탐색bidirectional-search>29.6.1 <strong>양방향 탐색(bidirectional search)</strong></a></li><li><a href=#2962-점점-깊어지는-탐색>29.6.2 점점 깊어지는 탐색</a></li><li><a href=#2963-탐색-방법-선택하기>29.6.3 탐색 방법 선택하기</a></li><li><a href=#2964-상태-객체의-구현>29.6.4 상태 객체의 구현</a></li></ul></li><li><a href=#297-298-하노이의-탑-hanoi4b-난이도-중>29.7, 29.8 하노이의 탑, HANOI4B, 난이도: 중</a></li></ul></li><li><a href=#reference>Reference</a></li></ul></nav></div></details></div><div class=post-content><h1 id=29-그래프의-너비-우선-탐색>29. 그래프의 너비 우선 탐색<a hidden class=anchor aria-hidden=true href=#29-그래프의-너비-우선-탐색>#</a></h1><h2 id=291-도입>29.1 도입<a hidden class=anchor aria-hidden=true href=#291-도입>#</a></h2><h3 id=2811-너비-우선-탐색breadth-first-search>28.1.1 너비 우선 탐색(Breadth First Search)<a hidden class=anchor aria-hidden=true href=#2811-너비-우선-탐색breadth-first-search>#</a></h3><ul><li><p>너비 우선 탐색은 <strong>시작점에서 가까운 정점(Node)부터 순서대로 방문</strong>하는 탐색 알고리즘</p></li><li><p>시작 노드에서 출발해 시작 노드를 기준으로 가까운 노드를 먼저 방문하면서 탐색하는 알고리즘</p></li><li><p>각 정점을 방문할 때 마다 모든 인접 정점들을 검사</p><ul><li><p>이 중 처음 보는 정점을 발견하면, 이 정점을 방문 예정이라고 기록, 큐에 저장</p></li><li><p>너비 우선 탐색의 <strong>방문 순서</strong>는 정점을 <strong>먼저 꺼내는지</strong>에 의해 결정</p></li><li><p>이를 구현하는 방법은 목록에 먼저 넣은 정점을 항상 먼저 꺼내는 것</p></li><li><p>정점 목록을 <strong>큐(queue)</strong> 를 사용하면 너비 우선 탐색의 조건을 만족시킬 수 있다.</p><ul><li>그래서 <strong>큐(queue)</strong> 를 쓰는 거다</li></ul></li></ul></li></ul><p><img loading=lazy src=/images/before/image-20240423200312484.png alt=image-20240423200312484.png width=680 height=auto></p><ul><li><p>그래프의 너비 우선 탐색 python 구현</p><ul><li><strong>DFS</strong>의 <code>visited[]</code>가 각 정점의 <strong>방문 여부</strong>를 저장했던 것에 비해,</li><li><strong>BFS</strong>에서 <code>discovered[]</code>는 각 정점의 <strong>발견 여부</strong>를 저장한다.</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=n>discovered</span> <span class=o>=</span> <span class=p>[</span><span class=kc>False</span> <span class=k>for</span> <span class=n>_</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=n>N</span><span class=p>)]</span>
</span></span><span class=line><span class=cl><span class=n>result</span> <span class=o>=</span> <span class=p>[]</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>bfs</span><span class=p>(</span><span class=n>startNode</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=n>q</span> <span class=o>=</span> <span class=n>deque</span><span class=p>([</span> <span class=p>[</span><span class=n>startNode</span><span class=p>]</span> <span class=p>])</span>
</span></span><span class=line><span class=cl>    <span class=n>discovered</span><span class=p>[</span><span class=n>startNode</span><span class=p>]</span> <span class=o>=</span> <span class=kc>True</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>while</span> <span class=n>q</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=n>node</span> <span class=o>=</span> <span class=n>q</span><span class=o>.</span><span class=n>popleft</span><span class=p>()</span>
</span></span><span class=line><span class=cl>        <span class=n>result</span><span class=o>.</span><span class=n>append</span><span class=p>(</span><span class=n>node</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=n>nxt</span> <span class=ow>in</span> <span class=n>graph</span><span class=p>[</span><span class=n>node</span><span class=p>]:</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=ow>not</span> <span class=n>discovered</span><span class=p>[</span><span class=n>nxt</span><span class=p>]:</span>
</span></span><span class=line><span class=cl>              <span class=n>q</span><span class=o>.</span><span class=n>append</span><span class=p>(</span><span class=n>nxt</span><span class=p>)</span>
</span></span><span class=line><span class=cl>              <span class=n>discovered</span><span class=p>[</span><span class=n>nxt</span><span class=p>]</span> <span class=o>=</span> <span class=kc>True</span>
</span></span></code></pre></td></tr></table></div></div></li><li><p>DFS와 달리 BFS에서는 <strong>발견(discover)</strong> 과 <strong>방문(visit)</strong> 이 같지 않다.</p></li><li><p>모든 정점은 다음 3개의 상태를 순서대로 거쳐 간다.</p><ol><li>아직 <strong>발견</strong>되지 않은 상태 (visited = False)</li><li><strong>발견</strong>되었지만 아직 <strong>방문</strong>되지 않은 상태 (in queue)</li><li>방문된 상태 (discoverd = True)</li></ol></li><li><p>BFS에서 새 정점을 <strong>발견</strong>하는데 사용했던 간선들을 모은 트리를 <code>BFS 스패닝 트리(BFS Spanning Tree)</code> 라고 한다.</p></li></ul><h3 id=2912-너비-우선-탐색의-시간-복잡도>29.1.2 너비 우선 탐색의 시간 복잡도<a hidden class=anchor aria-hidden=true href=#2912-너비-우선-탐색의-시간-복잡도>#</a></h3><ul><li>DFS와 다를 게 없다.</li><li>모든 정점을 한 번씩 방문하며, 정점을 방문할 때마다 인접한 모든 간선을 검사한다</li><li><strong>인접 리스트</strong> 인 경우: O(V+E)</li><li><strong>인접 행렬</strong> 인 경우: O(V^2)</li></ul><h3 id=2913-너비-우선-탐색과-최단-거리>29.1.3 너비 우선 탐색과 최단 거리<a hidden class=anchor aria-hidden=true href=#2913-너비-우선-탐색과-최단-거리>#</a></h3><ul><li>그래프의 구조에 관한 다양한 문제를 푸는 데 사용되는 DFS와 달리, BFS는 <strong>대게 딱 하나의 용도</strong>로 사용된다.<ul><li>바로 그래프의 <strong>최단 경로 문제</strong>를 풀 때 사용</li></ul></li><li>BFS를 간단하게 변경해 모든 정점에 대해 시작점으로 부터의 거리 distance[]를 계산할 수 있기 때문이다.</li><li><strong>시작점 부터 v까지의 최단 거리</strong> <code>distance[v]</code>는 <code>distance[u] + 1</code>이다.<ul><li>간선 (u, v)를 처음 발견해 큐에 넣었다고 가정할 때</li></ul></li><li>시작점으로부터 다른 모든 정점까지의 <strong>최단 경로</strong>를 <strong>BFS 스패닝 트리</strong> 위에서 찾을 수 있다.</li><li>시작점으로 부터의 최단 경로는 <strong>&lsquo;BFS 스패닝 트리에서 루트로 가는 경로&rsquo;</strong></li></ul><h3 id=2914-모든-점의-발견>29.1.4 모든 점의 발견<a hidden class=anchor aria-hidden=true href=#2914-모든-점의-발견>#</a></h3><ul><li><strong>그래프 전체 구조에 관한 정보</strong>를 얻기 위해 사용되는 DFS와 달리,</li><li>BFS는 대게 시작점으로부터 다른 정점들까지의 <strong>거리</strong>를 구하기 위해 사용된다.</li><li>따라서, DFS 처럼 모든 정점을 검사하면서 수행하는 작업 BFS는 잘하지 않는다.</li></ul><h2 id=292-293-sorting-game-sortgame-난이도-중>29.2, 29.3 Sorting Game, SORTGAME, 난이도: 중<a hidden class=anchor aria-hidden=true href=#292-293-sorting-game-sortgame-난이도-중>#</a></h2><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=lnt>38
</span><span class=lnt>39
</span><span class=lnt>40
</span><span class=lnt>41
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=n>dic</span> <span class=o>=</span> <span class=n>defaultdict</span><span class=p>(</span><span class=k>lambda</span><span class=p>:</span> <span class=o>-</span><span class=mi>1</span><span class=p>)</span>  <span class=c1># { &#34;1023&#34;: 1, ... }</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>bfs</span><span class=p>(</span><span class=n>first</span><span class=p>,</span> <span class=n>n</span><span class=p>,</span> <span class=n>distance</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=n>q</span> <span class=o>=</span> <span class=n>deque</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=n>distance</span><span class=p>[</span><span class=n>first</span><span class=p>]</span> <span class=o>=</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>    <span class=n>dic</span><span class=p>[</span><span class=n>first</span><span class=p>]</span> <span class=o>=</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>    <span class=n>q</span><span class=o>.</span><span class=n>append</span><span class=p>(</span><span class=n>first</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>while</span> <span class=n>q</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=n>here</span> <span class=o>=</span> <span class=n>q</span><span class=o>.</span><span class=n>popleft</span><span class=p>()</span>
</span></span><span class=line><span class=cl>        <span class=n>cost</span> <span class=o>=</span> <span class=n>distance</span><span class=p>[</span><span class=n>here</span><span class=p>]</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=n>i</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=mi>1</span><span class=p>,</span> <span class=n>n</span><span class=p>):</span>
</span></span><span class=line><span class=cl>            <span class=n>left</span> <span class=o>=</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>            <span class=k>for</span> <span class=n>j</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=n>n</span> <span class=o>-</span> <span class=n>i</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=o>-</span><span class=mi>1</span><span class=p>):</span>
</span></span><span class=line><span class=cl>                <span class=n>right</span> <span class=o>=</span> <span class=n>left</span> <span class=o>+</span> <span class=n>i</span>
</span></span><span class=line><span class=cl>                <span class=n>A</span><span class=p>,</span> <span class=n>B</span><span class=p>,</span> <span class=n>C</span> <span class=o>=</span> <span class=n>here</span><span class=p>[</span><span class=mi>0</span><span class=p>:</span><span class=n>left</span><span class=p>],</span> <span class=n>here</span><span class=p>[</span><span class=n>left</span><span class=p>:</span><span class=n>right</span> <span class=o>+</span> <span class=mi>1</span><span class=p>][::</span><span class=o>-</span><span class=mi>1</span><span class=p>],</span> <span class=n>here</span><span class=p>[</span><span class=n>right</span> <span class=o>+</span> <span class=mi>1</span><span class=p>:]</span>
</span></span><span class=line><span class=cl>                <span class=n>rev</span> <span class=o>=</span> <span class=n>A</span> <span class=o>+</span> <span class=n>B</span> <span class=o>+</span> <span class=n>C</span>
</span></span><span class=line><span class=cl>                <span class=n>left</span> <span class=o>+=</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>                <span class=k>if</span> <span class=n>distance</span><span class=p>[</span><span class=n>rev</span><span class=p>]</span> <span class=o>==</span> <span class=o>-</span><span class=mi>1</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                    <span class=n>distance</span><span class=p>[</span><span class=n>rev</span><span class=p>]</span> <span class=o>=</span> <span class=n>cost</span> <span class=o>+</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>                    <span class=n>dic</span><span class=p>[</span><span class=n>rev</span><span class=p>]</span> <span class=o>=</span> <span class=n>cost</span> <span class=o>+</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>                    <span class=n>q</span><span class=o>.</span><span class=n>append</span><span class=p>(</span><span class=n>rev</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>makeDic</span><span class=p>():</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=n>n</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=mi>1</span><span class=p>,</span> <span class=mi>9</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=n>distance</span> <span class=o>=</span> <span class=n>defaultdict</span><span class=p>(</span><span class=k>lambda</span><span class=p>:</span> <span class=o>-</span><span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=n>first</span> <span class=o>=</span> <span class=s2>&#34;012345678&#34;</span><span class=p>[:</span><span class=n>n</span><span class=p>]</span>
</span></span><span class=line><span class=cl>        <span class=n>bfs</span><span class=p>(</span><span class=n>first</span><span class=p>,</span> <span class=n>n</span><span class=p>,</span> <span class=n>distance</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>makeDic</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=k>for</span> <span class=n>_</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=nb>int</span><span class=p>(</span><span class=nb>input</span><span class=p>())):</span>
</span></span><span class=line><span class=cl>    <span class=n>N</span> <span class=o>=</span> <span class=nb>int</span><span class=p>(</span><span class=nb>input</span><span class=p>())</span>
</span></span><span class=line><span class=cl>    <span class=n>L</span> <span class=o>=</span> <span class=nb>list</span><span class=p>(</span><span class=nb>map</span><span class=p>(</span><span class=nb>int</span><span class=p>,</span> <span class=nb>input</span><span class=p>()</span><span class=o>.</span><span class=n>split</span><span class=p>()))</span>
</span></span><span class=line><span class=cl>    <span class=n>sorted_score</span> <span class=o>=</span> <span class=nb>sorted</span><span class=p>(</span><span class=n>L</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>target</span> <span class=o>=</span> <span class=p>[</span><span class=n>sorted_score</span><span class=o>.</span><span class=n>index</span><span class=p>(</span><span class=n>s</span><span class=p>)</span> <span class=k>for</span> <span class=n>s</span> <span class=ow>in</span> <span class=n>L</span><span class=p>]</span>
</span></span><span class=line><span class=cl>    <span class=n>stringTarget</span> <span class=o>=</span> <span class=s1>&#39;&#39;</span><span class=o>.</span><span class=n>join</span><span class=p>(</span><span class=nb>str</span><span class=p>(</span><span class=n>s</span><span class=p>)</span> <span class=k>for</span> <span class=n>s</span> <span class=ow>in</span> <span class=n>target</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>answer</span> <span class=o>=</span> <span class=n>dic</span><span class=p>[</span><span class=n>stringTarget</span><span class=p>]</span>
</span></span><span class=line><span class=cl>    <span class=nb>print</span><span class=p>(</span><span class=n>answer</span><span class=p>)</span>
</span></span></code></pre></td></tr></table></div></div><ul><li>문제를 읽고, <strong>그래프로 접근, 바꾸기</strong></li><li><code>{3, 4, 1, 2} === {9, 100, 5, 6}</code> 상대적 크기가 같음</li><li>모든 상태를 미리 BFS를 통해 계산</li></ul><h2 id=294-295-어린이날-childrenday-난이도-상>29.4, 29.5 어린이날, CHILDRENDAY, 난이도: 상<a hidden class=anchor aria-hidden=true href=#294-295-어린이날-childrenday-난이도-상>#</a></h2><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=lnt>38
</span><span class=lnt>39
</span><span class=lnt>40
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=c1># 1. c &gt;= n + m</span>
</span></span><span class=line><span class=cl><span class=c1># 2. c mod n = m</span>
</span></span><span class=line><span class=cl><span class=c1># 3. d에 포함된 digit들로만 구성</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 흰색: 0 ~ n</span>
</span></span><span class=line><span class=cl><span class=c1># 회색: n ~ 2n-1</span>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>bfs</span><span class=p>():</span>
</span></span><span class=line><span class=cl>    <span class=n>q</span> <span class=o>=</span> <span class=n>deque</span><span class=p>([(</span><span class=mi>0</span><span class=p>,</span> <span class=mi>0</span><span class=p>)])</span>
</span></span><span class=line><span class=cl>    <span class=k>while</span> <span class=n>q</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=n>currentNode</span><span class=p>,</span> <span class=n>tmpResult</span> <span class=o>=</span> <span class=n>q</span><span class=o>.</span><span class=n>popleft</span><span class=p>()</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=n>currentNode</span> <span class=o>-</span> <span class=n>n</span> <span class=o>==</span> <span class=n>m</span><span class=p>:</span>  <span class=c1># 회색이면서, 현재 노드 값이 m일때</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=n>tmpResult</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=n>dn</span> <span class=ow>in</span> <span class=n>d</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=n>cal</span> <span class=o>=</span> <span class=n>currentNode</span> <span class=o>*</span> <span class=mi>10</span> <span class=o>+</span> <span class=n>dn</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=n>cal</span> <span class=o>&gt;=</span> <span class=n>n</span><span class=p>:</span>  <span class=c1># 회색</span>
</span></span><span class=line><span class=cl>                <span class=n>nxtNode</span> <span class=o>=</span> <span class=p>(</span><span class=n>cal</span> <span class=o>%</span> <span class=n>n</span><span class=p>)</span> <span class=o>+</span> <span class=n>n</span>
</span></span><span class=line><span class=cl>            <span class=k>else</span><span class=p>:</span>  <span class=c1># 흰색</span>
</span></span><span class=line><span class=cl>                <span class=n>nxtNode</span> <span class=o>=</span> <span class=p>(</span><span class=n>cal</span> <span class=o>%</span> <span class=n>n</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=ow>not</span> <span class=n>discovered</span><span class=p>[</span><span class=n>nxtNode</span><span class=p>]:</span>
</span></span><span class=line><span class=cl>                <span class=n>discovered</span><span class=p>[</span><span class=n>nxtNode</span><span class=p>]</span> <span class=o>=</span> <span class=kc>True</span>
</span></span><span class=line><span class=cl>                <span class=n>q</span><span class=o>.</span><span class=n>append</span><span class=p>([</span><span class=n>nxtNode</span><span class=p>,</span> <span class=n>tmpResult</span> <span class=o>*</span> <span class=mi>10</span> <span class=o>+</span> <span class=n>dn</span><span class=p>])</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=o>-</span><span class=mi>1</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 그래프를 만들고, 0 to m으로 가는 최단 경로를 찾는다.</span>
</span></span><span class=line><span class=cl><span class=k>for</span> <span class=n>_</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=nb>int</span><span class=p>(</span><span class=nb>input</span><span class=p>())):</span>
</span></span><span class=line><span class=cl>    <span class=n>d</span><span class=p>,</span> <span class=n>n</span><span class=p>,</span> <span class=n>m</span> <span class=o>=</span> <span class=nb>input</span><span class=p>()</span><span class=o>.</span><span class=n>split</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=n>n</span> <span class=o>=</span> <span class=nb>int</span><span class=p>(</span><span class=n>n</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>m</span> <span class=o>=</span> <span class=nb>int</span><span class=p>(</span><span class=n>m</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>d</span> <span class=o>=</span> <span class=nb>sorted</span><span class=p>(</span><span class=nb>map</span><span class=p>(</span><span class=nb>int</span><span class=p>,</span> <span class=nb>list</span><span class=p>(</span><span class=n>d</span><span class=p>)))</span>
</span></span><span class=line><span class=cl>    <span class=n>discovered</span> <span class=o>=</span> <span class=p>[</span><span class=kc>False</span><span class=p>]</span> <span class=o>*</span> <span class=p>(</span><span class=mi>2</span> <span class=o>*</span> <span class=n>n</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>answer</span> <span class=o>=</span> <span class=n>bfs</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=n>answer</span> <span class=o>==</span> <span class=o>-</span><span class=mi>1</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=nb>print</span><span class=p>(</span><span class=s2>&#34;IMPOSSIBLE&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>else</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=nb>print</span><span class=p>(</span><span class=n>answer</span><span class=p>)</span>
</span></span></code></pre></td></tr></table></div></div><ul><li><strong>여러 개의 조건이 있는</strong> 문제<ul><li>일부 조건을 없앤 더 <strong>단순한 문제를 푼 후, 조건을 하나하나 추가</strong></li></ul></li><li>mod 연산, 법칙</li><li>사전순으로 가장 최단 경로 => 임의의 순서 대신 번호가 증가하는 순서(오름 차순)으로 검사<ul><li>조건 강제</li></ul></li></ul><p><img loading=lazy src=/images/before/image-20240423200343027.png alt=image-20240423200343027.png width=680 height=auto></p><p><img loading=lazy src=/images/before/image-20240423200356957.png alt=image-20240423200356957.png width=680 height=auto></p><h2 id=296-기본-bfs-말고-최단-경로-전략>29.6 (기본 BFS 말고) 최단 경로 전략<a hidden class=anchor aria-hidden=true href=#296-기본-bfs-말고-최단-경로-전략>#</a></h2><ul><li><p>게임판의 상태를 그래프로 표현: <strong>상태 공간(state space)</strong></p><ul><li>15-퍼즐 문제는 그래프상의 최단 경로 문제로 변경</li><li>상태 공간을 전체 탐색하지 않고, 답을 찾는 데로 BFS를 종료하기 때문에 시간 복잡도를 다르게 계산해야 한다.</li><li>너브 우선 탐색이 방문하는 정점의 개수에 가장 직접적인 영향을 주는 요소는 <strong>최단 거리 d</strong> 이다.</li><li>방문하는 정점의 개수에 영향을 미치는 다른 요소는 <strong>탐색의 분기 수(branching factor) b</strong> 이다.</li><li>방문하는 정점의 수: <strong>O(b^d)</strong> 지수적으로 증가</li></ul></li></ul><h3 id=2961-양방향-탐색bidirectional-search>29.6.1 <strong>양방향 탐색(bidirectional search)</strong><a hidden class=anchor aria-hidden=true href=#2961-양방향-탐색bidirectional-search>#</a></h3><ul><li>시작 정점에서 시작하는 정방향 탐색과, 목표 정점에서 시작해 거꾸로 올라오는 역방향 탐색을 동시에 하면서, 이 둘이 가운데서 만나면 종료<ul><li>정방향과 역방향 탐색에서 방문할 정점들을 모두 같은 큐에 넣음</li><li>최단 거리를 저장할 때는 정방향은 양수, 역방향은 음수로 저장 (구분하기 위해)</li><li>인접한 상태를 검사했는데, 서로 부호가 다르면, 가운데서 만났다는 의미</li><li>목표 상태에서 역방향으로 움직이기 쉬워야 가능 함</li></ul></li></ul><p><img loading=lazy src=/images/before/image-20240423200415002.png alt=image-20240423200415002.png width=680 height=auto></p><h3 id=2962-점점-깊어지는-탐색>29.6.2 점점 깊어지는 탐색<a hidden class=anchor aria-hidden=true href=#2962-점점-깊어지는-탐색>#</a></h3><ul><li><p><strong>양방향 탐색</strong>에서도 방문하는 정점 수는 최단 거리에 따라 지수적으로 증가, O(b^d/2)</p></li><li><p>따라서, 규모가 큰 탐색 문제를 풀 때는 DFS를 기반으로 한 방법을 사용해야 함</p><ul><li>DFS는 방문할 정점의 목록을 유지하는 BFS와 달리 정점을 <strong>발견하는 즉시 방문</strong></li><li>큐가 너무 많은 메모리를 차지하는 일이 발생하지 않음</li></ul></li><li><p>그러나 최단 경로를 찾기 불가능</p><ul><li>DFS는 목표 상태를 찾아도 지금까지 찾은 경로가 최단 경로인지 확신할 수 없다.</li><li>각 정점을 방문하지 않으면 한 상태를 두 번 방문할 수 도 있고, 사이클에 빠져 탐색이 종료하지 않을 수 있다.</li></ul></li><li><p><code>IDS(Iteratively Deepening Search, 점점 깊어지는 탐색)</code>이 이 문제를 해결하기 위해 고안됨</p></li><li><p>임의의 깊이 제한 limit 보다 짧은 경로가 존재하는 DFS로 확인</p><ul><li>답을 찾으면 성공이니 반환</li><li>찾지 못하면, limit 을 늘려서 다시 시도</li></ul></li><li><p>IDS는 <strong>조합 탐색(가지치기)</strong> 와 관계가 깊다.</p><ul><li>깊이 제한을 늘려가면서 DFS를 반복하면 한 정점을 두 번 이상 방문하는 낭비가 생겨난다.</li><li>방문하는 상태의 수 <strong>O(b^d)</strong></li><li>IDS는 큐를 사용하지 않기 때문에, <strong>메모리는 스택만 사용함</strong></li><li>최대 메모리 사용량은 <strong>탐색의 깊이</strong>에 비례하게 된다. <strong>O(d)</strong></li></ul></li></ul><p><img loading=lazy src=/images/before/image-20240423200432896.png alt=image-20240423200432896.png width=680 height=auto></p><p><img loading=lazy src=/images/before/image-20240423200443251.png alt=image-20240423200443251.png width=680 height=auto></p><h3 id=2963-탐색-방법-선택하기>29.6.3 탐색 방법 선택하기<a hidden class=anchor aria-hidden=true href=#2963-탐색-방법-선택하기>#</a></h3><ol><li>최단 경로 찾는 경우, BFS를 우선 고려<ul><li>메모리 사용량, 탐색의 깊이 한계 확인</li></ul></li><li>양방향 탐색 고려, 목표 상태에서 역방향으로 움직이기 쉬워야 함</li><li>IDS 고려</li></ol><p><img loading=lazy src=/images/before/image-20240423200513520.png alt=image-20240423200513520.png width=680 height=auto></p><h3 id=2964-상태-객체의-구현>29.6.4 상태 객체의 구현<a hidden class=anchor aria-hidden=true href=#2964-상태-객체의-구현>#</a></h3><ol><li>상태에 대한, 여러 연산을 가능한 한 효율적으로 구현</li><li>가능한 한 적은 메모리 사용<ul><li><strong>비트마스크</strong> 기법</li><li><strong>일대일 대응</strong> 함수<ul><li>현재 상태가 몇 번째인지 계산하는 <strong>일대일 함수</strong>를 작성하면, 현재 상태를 정수로 표현 가능</li></ul></li></ul></li></ol><h2 id=297-298-하노이의-탑-hanoi4b-난이도-중>29.7, 29.8 하노이의 탑, HANOI4B, 난이도: 중<a hidden class=anchor aria-hidden=true href=#297-298-하노이의-탑-hanoi4b-난이도-중>#</a></h2><ul><li><strong>start state &mdash;&ndash;bfs for find 최단 경로&mdash;-> end state</strong></li><li>시작과 끝 상태가 유일하게 정해져 있음, 그래프가 양방향 그래프 이기 때문에 양방향 탐색ㅇ글 적용하기 용이하다.</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=lnt>38
</span><span class=lnt>39
</span><span class=lnt>40
</span><span class=lnt>41
</span><span class=lnt>42
</span><span class=lnt>43
</span><span class=lnt>44
</span><span class=lnt>45
</span><span class=lnt>46
</span><span class=lnt>47
</span><span class=lnt>48
</span><span class=lnt>49
</span><span class=lnt>50
</span><span class=lnt>51
</span><span class=lnt>52
</span><span class=lnt>53
</span><span class=lnt>54
</span><span class=lnt>55
</span><span class=lnt>56
</span><span class=lnt>57
</span><span class=lnt>58
</span><span class=lnt>59
</span><span class=lnt>60
</span><span class=lnt>61
</span><span class=lnt>62
</span><span class=lnt>63
</span><span class=lnt>64
</span><span class=lnt>65
</span><span class=lnt>66
</span><span class=lnt>67
</span><span class=lnt>68
</span><span class=lnt>69
</span><span class=lnt>70
</span><span class=lnt>71
</span><span class=lnt>72
</span><span class=lnt>73
</span><span class=lnt>74
</span><span class=lnt>75
</span><span class=lnt>76
</span><span class=lnt>77
</span><span class=lnt>78
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>def</span> <span class=nf>plus</span><span class=p>(</span><span class=n>x</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=n>x</span> <span class=o>&gt;</span> <span class=mi>0</span><span class=p>:</span> <span class=k>return</span> <span class=n>x</span> <span class=o>+</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>    <span class=k>elif</span> <span class=n>x</span> <span class=o>&lt;</span> <span class=mi>0</span><span class=p>:</span> <span class=k>return</span> <span class=n>x</span> <span class=o>-</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>judgeSign</span><span class=p>(</span><span class=n>x</span><span class=p>,</span> <span class=n>y</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=n>x</span> <span class=o>*</span> <span class=n>y</span> <span class=o>&lt;</span> <span class=mi>0</span><span class=p>:</span> <span class=k>return</span> <span class=kc>True</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=kc>False</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>changeStr</span><span class=p>(</span><span class=n>ori</span><span class=p>,</span> <span class=n>i</span><span class=p>,</span> <span class=n>j</span><span class=p>,</span> <span class=n>iNum</span><span class=p>,</span> <span class=n>jNum</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=n>lo</span> <span class=o>=</span> <span class=nb>list</span><span class=p>(</span><span class=n>ori</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>lo</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>=</span> <span class=s2>&#34;0&#34;</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=n>jNum</span> <span class=o>==</span> <span class=mi>0</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=n>lo</span><span class=p>[</span><span class=n>j</span><span class=p>]</span> <span class=o>=</span> <span class=nb>str</span><span class=p>(</span><span class=n>iNum</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>else</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=n>lo</span><span class=p>[</span><span class=n>j</span> <span class=o>+</span> <span class=mi>1</span><span class=p>]</span> <span class=o>=</span> <span class=nb>str</span><span class=p>(</span><span class=n>iNum</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=s2>&#34;&#34;</span><span class=o>.</span><span class=n>join</span><span class=p>(</span><span class=n>lo</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>bfsWithBidir</span><span class=p>():</span>  <span class=c1># 양방향 탐색</span>
</span></span><span class=line><span class=cl>    <span class=n>q</span> <span class=o>=</span> <span class=n>deque</span><span class=p>([(</span><span class=n>start</span><span class=p>,</span> <span class=mi>1</span><span class=p>),</span> <span class=p>(</span><span class=n>end</span><span class=p>,</span> <span class=o>-</span><span class=mi>1</span><span class=p>)])</span>
</span></span><span class=line><span class=cl>    <span class=k>while</span> <span class=n>q</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=n>current</span><span class=p>,</span> <span class=n>count</span> <span class=o>=</span> <span class=n>q</span><span class=o>.</span><span class=n>popleft</span><span class=p>()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=n>topIdx</span> <span class=o>=</span> <span class=p>[[(</span><span class=n>i</span> <span class=o>*</span> <span class=n>n</span><span class=p>),</span> <span class=mi>0</span><span class=p>]</span> <span class=k>for</span> <span class=n>i</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=mi>4</span><span class=p>)]</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=n>i</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=mi>4</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=o>-</span><span class=mi>1</span><span class=p>):</span>
</span></span><span class=line><span class=cl>            <span class=k>for</span> <span class=n>j</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=mi>1</span><span class=p>,</span> <span class=n>n</span> <span class=o>+</span> <span class=mi>1</span><span class=p>):</span>
</span></span><span class=line><span class=cl>                <span class=n>cIdx</span> <span class=o>=</span> <span class=n>i</span> <span class=o>*</span> <span class=n>n</span> <span class=o>-</span> <span class=n>j</span>
</span></span><span class=line><span class=cl>                <span class=n>v</span> <span class=o>=</span> <span class=n>current</span><span class=p>[</span><span class=n>i</span> <span class=o>*</span> <span class=n>n</span> <span class=o>-</span> <span class=n>j</span><span class=p>]</span>
</span></span><span class=line><span class=cl>                <span class=k>if</span> <span class=n>v</span> <span class=o>!=</span> <span class=s2>&#34;0&#34;</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                    <span class=n>topIdx</span><span class=p>[</span><span class=n>i</span> <span class=o>-</span> <span class=mi>1</span><span class=p>][</span><span class=mi>0</span><span class=p>]</span> <span class=o>=</span> <span class=n>cIdx</span>
</span></span><span class=line><span class=cl>                    <span class=n>topIdx</span><span class=p>[</span><span class=n>i</span> <span class=o>-</span> <span class=mi>1</span><span class=p>][</span><span class=mi>1</span><span class=p>]</span> <span class=o>=</span> <span class=nb>int</span><span class=p>(</span><span class=n>v</span><span class=p>)</span>
</span></span><span class=line><span class=cl>                    <span class=k>break</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=n>i</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=mi>0</span><span class=p>,</span> <span class=mi>4</span><span class=p>):</span>
</span></span><span class=line><span class=cl>            <span class=n>idx</span><span class=p>,</span> <span class=n>iNum</span> <span class=o>=</span> <span class=n>topIdx</span><span class=p>[</span><span class=n>i</span><span class=p>]</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=n>iNum</span> <span class=o>==</span> <span class=mi>0</span><span class=p>:</span> <span class=k>continue</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>            <span class=k>for</span> <span class=n>j</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=mi>0</span><span class=p>,</span> <span class=mi>4</span><span class=p>):</span>
</span></span><span class=line><span class=cl>                <span class=k>if</span> <span class=p>(</span><span class=n>i</span> <span class=o>==</span> <span class=n>j</span><span class=p>):</span> <span class=k>continue</span>
</span></span><span class=line><span class=cl>                <span class=n>jNum</span> <span class=o>=</span> <span class=n>topIdx</span><span class=p>[</span><span class=n>j</span><span class=p>][</span><span class=mi>1</span><span class=p>]</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>                <span class=k>if</span> <span class=p>(</span><span class=n>jNum</span> <span class=o>==</span> <span class=mi>0</span> <span class=ow>or</span> <span class=n>iNum</span> <span class=o>&lt;</span> <span class=n>jNum</span><span class=p>):</span>  <span class=c1># 옮길 수 있는 경우, 가능한 경우</span>
</span></span><span class=line><span class=cl>                    <span class=n>change</span> <span class=o>=</span> <span class=n>changeStr</span><span class=p>(</span><span class=n>current</span><span class=p>,</span> <span class=n>idx</span><span class=p>,</span> <span class=n>topIdx</span><span class=p>[</span><span class=n>j</span><span class=p>][</span><span class=mi>0</span><span class=p>],</span> <span class=n>iNum</span><span class=p>,</span> <span class=n>jNum</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>                    <span class=k>if</span> <span class=p>(</span><span class=n>visited</span><span class=p>[</span><span class=n>change</span><span class=p>]</span> <span class=o>==</span> <span class=mi>0</span><span class=p>):</span>  <span class=c1># 방문하지 않은 경우</span>
</span></span><span class=line><span class=cl>                        <span class=n>nc</span> <span class=o>=</span> <span class=n>plus</span><span class=p>(</span><span class=n>count</span><span class=p>)</span>
</span></span><span class=line><span class=cl>                        <span class=n>q</span><span class=o>.</span><span class=n>append</span><span class=p>((</span><span class=n>change</span><span class=p>,</span> <span class=n>nc</span><span class=p>))</span>
</span></span><span class=line><span class=cl>                        <span class=n>visited</span><span class=p>[</span><span class=n>change</span><span class=p>]</span> <span class=o>=</span> <span class=n>nc</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>                    <span class=k>elif</span> <span class=n>judgeSign</span><span class=p>(</span><span class=n>visited</span><span class=p>[</span><span class=n>change</span><span class=p>],</span> <span class=n>visited</span><span class=p>[</span><span class=n>current</span><span class=p>]):</span>  <span class=c1># nxt Node가 방문되었고, 출발 방향이 다를때 =&gt; 중간에서 만난 경우</span>
</span></span><span class=line><span class=cl>                        <span class=k>return</span> <span class=nb>abs</span><span class=p>(</span><span class=n>visited</span><span class=p>[</span><span class=n>change</span><span class=p>])</span> <span class=o>+</span> <span class=nb>abs</span><span class=p>(</span><span class=n>visited</span><span class=p>[</span><span class=n>current</span><span class=p>])</span> <span class=o>-</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>for</span> <span class=n>_</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=nb>int</span><span class=p>(</span><span class=nb>input</span><span class=p>())):</span>
</span></span><span class=line><span class=cl>    <span class=n>n</span> <span class=o>=</span> <span class=nb>int</span><span class=p>(</span><span class=nb>input</span><span class=p>())</span>
</span></span><span class=line><span class=cl>    <span class=n>start</span> <span class=o>=</span> <span class=p>[</span><span class=s2>&#34;0&#34;</span><span class=p>]</span> <span class=o>*</span> <span class=n>n</span> <span class=o>*</span> <span class=mi>4</span>
</span></span><span class=line><span class=cl>    <span class=n>end</span> <span class=o>=</span> <span class=p>[</span><span class=s2>&#34;0&#34;</span><span class=p>]</span> <span class=o>*</span> <span class=n>n</span> <span class=o>*</span> <span class=mi>4</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=n>i</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=mi>4</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=n>t1</span> <span class=o>=</span> <span class=nb>list</span><span class=p>(</span><span class=nb>map</span><span class=p>(</span><span class=nb>int</span><span class=p>,</span> <span class=nb>input</span><span class=p>()</span><span class=o>.</span><span class=n>split</span><span class=p>()))</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=n>j</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=n>t1</span><span class=p>[</span><span class=mi>0</span><span class=p>]):</span>
</span></span><span class=line><span class=cl>            <span class=n>start</span><span class=p>[</span><span class=n>i</span> <span class=o>*</span> <span class=n>n</span> <span class=o>+</span> <span class=n>j</span><span class=p>]</span> <span class=o>=</span> <span class=nb>str</span><span class=p>(</span><span class=n>t1</span><span class=p>[</span><span class=n>j</span> <span class=o>+</span> <span class=mi>1</span><span class=p>])</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=n>i</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=mi>4</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=n>t1</span> <span class=o>=</span> <span class=nb>list</span><span class=p>(</span><span class=nb>map</span><span class=p>(</span><span class=nb>int</span><span class=p>,</span> <span class=nb>input</span><span class=p>()</span><span class=o>.</span><span class=n>split</span><span class=p>()))</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=n>j</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=n>t1</span><span class=p>[</span><span class=mi>0</span><span class=p>]):</span>
</span></span><span class=line><span class=cl>            <span class=n>end</span><span class=p>[</span><span class=n>i</span> <span class=o>*</span> <span class=n>n</span> <span class=o>+</span> <span class=n>j</span><span class=p>]</span> <span class=o>=</span> <span class=nb>str</span><span class=p>(</span><span class=n>t1</span><span class=p>[</span><span class=n>j</span> <span class=o>+</span> <span class=mi>1</span><span class=p>])</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>start</span> <span class=o>=</span> <span class=s2>&#34;&#34;</span><span class=o>.</span><span class=n>join</span><span class=p>(</span><span class=n>start</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>end</span> <span class=o>=</span> <span class=s2>&#34;&#34;</span><span class=o>.</span><span class=n>join</span><span class=p>(</span><span class=n>end</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=n>start</span> <span class=o>==</span> <span class=n>end</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=nb>print</span><span class=p>(</span><span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=k>continue</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>visited</span> <span class=o>=</span> <span class=n>defaultdict</span><span class=p>(</span><span class=k>lambda</span><span class=p>:</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>visited</span><span class=p>[</span><span class=n>start</span><span class=p>]</span> <span class=o>=</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>    <span class=n>visited</span><span class=p>[</span><span class=n>end</span><span class=p>]</span> <span class=o>=</span> <span class=o>-</span><span class=mi>1</span>
</span></span><span class=line><span class=cl>    <span class=n>answer</span> <span class=o>=</span> <span class=n>bfsWithBidir</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=nb>print</span><span class=p>(</span><span class=n>answer</span><span class=p>)</span>
</span></span></code></pre></td></tr></table></div></div><h1 id=reference>Reference<a hidden class=anchor aria-hidden=true href=#reference>#</a></h1><ul><li>프로그래밍 대회에서 배우는 알고리즘 문제 해결 전략 (구종만, 인사이트)</li><li><a href=https://www.algospot.com/>https://www.algospot.com/</a></li></ul></div><footer class=post-footer><ul class=post-tags><li><a href=https://2taezeat.github.io/tags/algorithm/>Algorithm</a></li></ul><nav class=paginav><a class=prev href=https://2taezeat.github.io/posts/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EB%AC%B8%EC%A0%9C-%ED%95%B4%EA%B2%B0-%EC%A0%84%EB%9E%B5/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EB%AC%B8%EC%A0%9C-%ED%95%B4%EA%B2%B0-%EC%A0%84%EB%9E%B5-ch30.-%EA%B7%B8%EB%9E%98%ED%94%84/><span class=title>« Prev</span><br><span>[알고리즘 문제 해결 전략] ch30. 그래프</span>
</a><a class=next href=https://2taezeat.github.io/posts/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EB%AC%B8%EC%A0%9C-%ED%95%B4%EA%B2%B0-%EC%A0%84%EB%9E%B5/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EB%AC%B8%EC%A0%9C-%ED%95%B4%EA%B2%B0-%EC%A0%84%EB%9E%B5-ch28.-%EA%B7%B8%EB%9E%98%ED%94%84/><span class=title>Next »</span><br><span>[알고리즘 문제 해결 전략] ch28. 그래프</span></a></nav><ul class=share-buttons><li><a target=_blank rel="noopener noreferrer" aria-label="share [알고리즘 문제 해결 전략] ch29. 그래프 on x" href="https://x.com/intent/tweet/?text=%5b%ec%95%8c%ea%b3%a0%eb%a6%ac%ec%a6%98%20%eb%ac%b8%ec%a0%9c%20%ed%95%b4%ea%b2%b0%20%ec%a0%84%eb%9e%b5%5d%20ch29.%20%ea%b7%b8%eb%9e%98%ed%94%84&amp;url=https%3a%2f%2f2taezeat.github.io%2fposts%2f%25EC%2595%258C%25EA%25B3%25A0%25EB%25A6%25AC%25EC%25A6%2598-%25EB%25AC%25B8%25EC%25A0%259C-%25ED%2595%25B4%25EA%25B2%25B0-%25EC%25A0%2584%25EB%259E%25B5%2f%25EC%2595%258C%25EA%25B3%25A0%25EB%25A6%25AC%25EC%25A6%2598-%25EB%25AC%25B8%25EC%25A0%259C-%25ED%2595%25B4%25EA%25B2%25B0-%25EC%25A0%2584%25EB%259E%25B5-ch29.-%25EA%25B7%25B8%25EB%259E%2598%25ED%2594%2584%2f&amp;hashtags=Algorithm"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446C483.971.0 512 28.03 512 62.554zM269.951 190.75 182.567 75.216H56L207.216 272.95 63.9 436.783h61.366L235.9 310.383l96.667 126.4H456L298.367 228.367l134-153.151H371.033zM127.633 110h36.468l219.38 290.065H349.5z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share [알고리즘 문제 해결 전략] ch29. 그래프 on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2f2taezeat.github.io%2fposts%2f%25EC%2595%258C%25EA%25B3%25A0%25EB%25A6%25AC%25EC%25A6%2598-%25EB%25AC%25B8%25EC%25A0%259C-%25ED%2595%25B4%25EA%25B2%25B0-%25EC%25A0%2584%25EB%259E%25B5%2f%25EC%2595%258C%25EA%25B3%25A0%25EB%25A6%25AC%25EC%25A6%2598-%25EB%25AC%25B8%25EC%25A0%259C-%25ED%2595%25B4%25EA%25B2%25B0-%25EC%25A0%2584%25EB%259E%25B5-ch29.-%25EA%25B7%25B8%25EB%259E%2598%25ED%2594%2584%2f&amp;title=%5b%ec%95%8c%ea%b3%a0%eb%a6%ac%ec%a6%98%20%eb%ac%b8%ec%a0%9c%20%ed%95%b4%ea%b2%b0%20%ec%a0%84%eb%9e%b5%5d%20ch29.%20%ea%b7%b8%eb%9e%98%ed%94%84&amp;summary=%5b%ec%95%8c%ea%b3%a0%eb%a6%ac%ec%a6%98%20%eb%ac%b8%ec%a0%9c%20%ed%95%b4%ea%b2%b0%20%ec%a0%84%eb%9e%b5%5d%20ch29.%20%ea%b7%b8%eb%9e%98%ed%94%84&amp;source=https%3a%2f%2f2taezeat.github.io%2fposts%2f%25EC%2595%258C%25EA%25B3%25A0%25EB%25A6%25AC%25EC%25A6%2598-%25EB%25AC%25B8%25EC%25A0%259C-%25ED%2595%25B4%25EA%25B2%25B0-%25EC%25A0%2584%25EB%259E%25B5%2f%25EC%2595%258C%25EA%25B3%25A0%25EB%25A6%25AC%25EC%25A6%2598-%25EB%25AC%25B8%25EC%25A0%259C-%25ED%2595%25B4%25EA%25B2%25B0-%25EC%25A0%2584%25EB%259E%25B5-ch29.-%25EA%25B7%25B8%25EB%259E%2598%25ED%2594%2584%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share [알고리즘 문제 해결 전략] ch29. 그래프 on reddit" href="https://reddit.com/submit?url=https%3a%2f%2f2taezeat.github.io%2fposts%2f%25EC%2595%258C%25EA%25B3%25A0%25EB%25A6%25AC%25EC%25A6%2598-%25EB%25AC%25B8%25EC%25A0%259C-%25ED%2595%25B4%25EA%25B2%25B0-%25EC%25A0%2584%25EB%259E%25B5%2f%25EC%2595%258C%25EA%25B3%25A0%25EB%25A6%25AC%25EC%25A6%2598-%25EB%25AC%25B8%25EC%25A0%259C-%25ED%2595%25B4%25EA%25B2%25B0-%25EC%25A0%2584%25EB%259E%25B5-ch29.-%25EA%25B7%25B8%25EB%259E%2598%25ED%2594%2584%2f&title=%5b%ec%95%8c%ea%b3%a0%eb%a6%ac%ec%a6%98%20%eb%ac%b8%ec%a0%9c%20%ed%95%b4%ea%b2%b0%20%ec%a0%84%eb%9e%b5%5d%20ch29.%20%ea%b7%b8%eb%9e%98%ed%94%84"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share [알고리즘 문제 해결 전략] ch29. 그래프 on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2f2taezeat.github.io%2fposts%2f%25EC%2595%258C%25EA%25B3%25A0%25EB%25A6%25AC%25EC%25A6%2598-%25EB%25AC%25B8%25EC%25A0%259C-%25ED%2595%25B4%25EA%25B2%25B0-%25EC%25A0%2584%25EB%259E%25B5%2f%25EC%2595%258C%25EA%25B3%25A0%25EB%25A6%25AC%25EC%25A6%2598-%25EB%25AC%25B8%25EC%25A0%259C-%25ED%2595%25B4%25EA%25B2%25B0-%25EC%25A0%2584%25EB%259E%25B5-ch29.-%25EA%25B7%25B8%25EB%259E%2598%25ED%2594%2584%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share [알고리즘 문제 해결 전략] ch29. 그래프 on whatsapp" href="https://api.whatsapp.com/send?text=%5b%ec%95%8c%ea%b3%a0%eb%a6%ac%ec%a6%98%20%eb%ac%b8%ec%a0%9c%20%ed%95%b4%ea%b2%b0%20%ec%a0%84%eb%9e%b5%5d%20ch29.%20%ea%b7%b8%eb%9e%98%ed%94%84%20-%20https%3a%2f%2f2taezeat.github.io%2fposts%2f%25EC%2595%258C%25EA%25B3%25A0%25EB%25A6%25AC%25EC%25A6%2598-%25EB%25AC%25B8%25EC%25A0%259C-%25ED%2595%25B4%25EA%25B2%25B0-%25EC%25A0%2584%25EB%259E%25B5%2f%25EC%2595%258C%25EA%25B3%25A0%25EB%25A6%25AC%25EC%25A6%2598-%25EB%25AC%25B8%25EC%25A0%259C-%25ED%2595%25B4%25EA%25B2%25B0-%25EC%25A0%2584%25EB%259E%25B5-ch29.-%25EA%25B7%25B8%25EB%259E%2598%25ED%2594%2584%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share [알고리즘 문제 해결 전략] ch29. 그래프 on telegram" href="https://telegram.me/share/url?text=%5b%ec%95%8c%ea%b3%a0%eb%a6%ac%ec%a6%98%20%eb%ac%b8%ec%a0%9c%20%ed%95%b4%ea%b2%b0%20%ec%a0%84%eb%9e%b5%5d%20ch29.%20%ea%b7%b8%eb%9e%98%ed%94%84&amp;url=https%3a%2f%2f2taezeat.github.io%2fposts%2f%25EC%2595%258C%25EA%25B3%25A0%25EB%25A6%25AC%25EC%25A6%2598-%25EB%25AC%25B8%25EC%25A0%259C-%25ED%2595%25B4%25EA%25B2%25B0-%25EC%25A0%2584%25EB%259E%25B5%2f%25EC%2595%258C%25EA%25B3%25A0%25EB%25A6%25AC%25EC%25A6%2598-%25EB%25AC%25B8%25EC%25A0%259C-%25ED%2595%25B4%25EA%25B2%25B0-%25EC%25A0%2584%25EB%259E%25B5-ch29.-%25EA%25B7%25B8%25EB%259E%2598%25ED%2594%2584%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentcolor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share [알고리즘 문제 해결 전략] ch29. 그래프 on ycombinator" href="https://news.ycombinator.com/submitlink?t=%5b%ec%95%8c%ea%b3%a0%eb%a6%ac%ec%a6%98%20%eb%ac%b8%ec%a0%9c%20%ed%95%b4%ea%b2%b0%20%ec%a0%84%eb%9e%b5%5d%20ch29.%20%ea%b7%b8%eb%9e%98%ed%94%84&u=https%3a%2f%2f2taezeat.github.io%2fposts%2f%25EC%2595%258C%25EA%25B3%25A0%25EB%25A6%25AC%25EC%25A6%2598-%25EB%25AC%25B8%25EC%25A0%259C-%25ED%2595%25B4%25EA%25B2%25B0-%25EC%25A0%2584%25EB%259E%25B5%2f%25EC%2595%258C%25EA%25B3%25A0%25EB%25A6%25AC%25EC%25A6%2598-%25EB%25AC%25B8%25EC%25A0%259C-%25ED%2595%25B4%25EA%25B2%25B0-%25EC%25A0%2584%25EB%259E%25B5-ch29.-%25EA%25B7%25B8%25EB%259E%2598%25ED%2594%2584%2f"><svg width="30" height="30" viewBox="0 0 512 512" fill="currentcolor" xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"><path d="M449.446.0C483.971.0 512 28.03 512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446zM183.8767 87.9921h-62.034L230.6673 292.4508V424.0079h50.6655V292.4508L390.1575 87.9921H328.1233L256 238.2489z"/></svg></a></li></ul></footer><script src=https://utteranc.es/client.js repo=2taezeat/blog_comment issue-term=pathname label=comment theme=github-light crossorigin=anonymous async></script></article></main><footer class=footer><span>&copy; 2024 <a href=https://2taezeat.github.io/>2taezeat, blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>