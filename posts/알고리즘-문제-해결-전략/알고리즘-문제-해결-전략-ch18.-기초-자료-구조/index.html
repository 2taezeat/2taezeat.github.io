<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>[알고리즘 문제 해결 전략] ch18. 기초 자료 구조 | 2taezeat, blog</title>
<meta name=keywords content="Algorithm"><meta name=description content="ch18. 선형 자료 구조 (동적 배열, 연결 리스트)"><meta name=author content="2taezeat"><link rel=canonical href=https://2taezeat.github.io/posts/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EB%AC%B8%EC%A0%9C-%ED%95%B4%EA%B2%B0-%EC%A0%84%EB%9E%B5/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EB%AC%B8%EC%A0%9C-%ED%95%B4%EA%B2%B0-%EC%A0%84%EB%9E%B5-ch18.-%EA%B8%B0%EC%B4%88-%EC%9E%90%EB%A3%8C-%EA%B5%AC%EC%A1%B0/><meta name=google-site-verification content="YaEERzgrvu-ZwPg7gswZdTzRMufkHw3uIH7i8hVal1c"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.fcb4dca47a3205209ed5ad677bea9ef840216e00cc778e31a6e3943bf8f843e1.css integrity="sha256-/LTcpHoyBSCe1a1ne+qe+EAhbgDMd44xpuOUO/j4Q+E=" rel="preload stylesheet" as=style><link rel=icon href=https://2taezeat.github.io/icon/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://2taezeat.github.io/icon/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://2taezeat.github.io/icon/favicon-32x32.png><link rel=apple-touch-icon href=https://2taezeat.github.io/icon/apple-touch-icon.png><link rel=mask-icon href=https://2taezeat.github.io/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://2taezeat.github.io/posts/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EB%AC%B8%EC%A0%9C-%ED%95%B4%EA%B2%B0-%EC%A0%84%EB%9E%B5/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EB%AC%B8%EC%A0%9C-%ED%95%B4%EA%B2%B0-%EC%A0%84%EB%9E%B5-ch18.-%EA%B8%B0%EC%B4%88-%EC%9E%90%EB%A3%8C-%EA%B5%AC%EC%A1%B0/><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><meta property="og:title" content="[알고리즘 문제 해결 전략] ch18. 기초 자료 구조"><meta property="og:description" content="ch18. 선형 자료 구조 (동적 배열, 연결 리스트)"><meta property="og:type" content="article"><meta property="og:url" content="https://2taezeat.github.io/posts/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EB%AC%B8%EC%A0%9C-%ED%95%B4%EA%B2%B0-%EC%A0%84%EB%9E%B5/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EB%AC%B8%EC%A0%9C-%ED%95%B4%EA%B2%B0-%EC%A0%84%EB%9E%B5-ch18.-%EA%B8%B0%EC%B4%88-%EC%9E%90%EB%A3%8C-%EA%B5%AC%EC%A1%B0/"><meta property="og:image" content="https://2taezeat.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-01-13T11:30:03+00:00"><meta property="article:modified_time" content="2024-01-13T11:30:03+00:00"><meta property="og:site_name" content="2taezeat, blog"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://2taezeat.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="[알고리즘 문제 해결 전략] ch18. 기초 자료 구조"><meta name=twitter:description content="ch18. 선형 자료 구조 (동적 배열, 연결 리스트)"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://2taezeat.github.io/posts/"},{"@type":"ListItem","position":2,"name":"[알고리즘 문제 해결 전략] ch18. 기초 자료 구조","item":"https://2taezeat.github.io/posts/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EB%AC%B8%EC%A0%9C-%ED%95%B4%EA%B2%B0-%EC%A0%84%EB%9E%B5/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EB%AC%B8%EC%A0%9C-%ED%95%B4%EA%B2%B0-%EC%A0%84%EB%9E%B5-ch18.-%EA%B8%B0%EC%B4%88-%EC%9E%90%EB%A3%8C-%EA%B5%AC%EC%A1%B0/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"[알고리즘 문제 해결 전략] ch18. 기초 자료 구조","name":"[알고리즘 문제 해결 전략] ch18. 기초 자료 구조","description":"ch18. 선형 자료 구조 (동적 배열, 연결 리스트)","keywords":["Algorithm"],"articleBody":"18. 선형 자료 구조 18.1 도입 일렬로 늘어선 같은 종류의 자료 여러 개를 저장하기 위한 가장 기초적인 자료구조는 배열(Array) 이다.\n동적 배열, 연결 리스트는 배열과 비슷하지만, 배열에서 비효율적이거나 할 수 없는 작업들을 효율적으로 작업한다.\n18.2 동적 배열 배열(일반 배열, 정적 배열) 의 문제는 배열을 선언할 때, 배열의 크기를 지정해야 하며, 그 이상의 자료를 집어넣을 수 없다는 점이다.\n이 문제를 해결 하기 위해, 자료의 개수가 변함에 따라 크기가 변경되는 동적 배열(dynamic array)이 고안되었다.\n동적 배열은 또 다른 종류의 배열이 아니다.\n동적 배열은 일반 배열처럼 언어 차원에서 지원되는 기능이 아니다.\n동적 배열은 일반 배열을 이용해 만들어 낸 별도의 자료 구조 이다.\n동적 배열은 대개 언어 문법이 아니라 언어의 표준 라이브러리에 포함되어 있다.\n내부적으로는 일반 배열로 구현되기 때문에, 동적 배열은 일반 배열이 갖는 특성을 그대로 물려 받는다.\n요즘에는 일반적인 배열을 제공하지 않고 동적 배열만을 제공하는 언어들도 있다. 동적 타입을 갖는 언어, 대표적으로 Python 이 동적 배열 기능도 내부적으로는 항상 일반 배열로 구현된다. 18.2.1 일반 배열의 특성 일반 배열은, 동적 배열과 비교하면 정적 배열로 볼 수 있다. 원소들은 메모리의 연속된 위치에 저장된다. 캐시의 효율성을 높여준다, 공간 지역성 주어진 위치의 원소를 반환하거나 변경하는 동작을 O(1) 에 할 수 있다. 배열에 원소를 삽입, 삭제 O(N), 원소를 삽입, 삭제하고 기존 원소를 모두 이동(데이터 복사)시켜줘야 한다. 정확한 수행 시간은 삽입, 삭제의 위치에 따라 달라지지만, 평균적으로 선형 시간 임의 접근(random access) 가 O(1) 에 가능하다. 순차 접근과 달리 인덱스에 해당하는 데이터에 접근할 수 있다. 18.2.2 동적 배열의 특성 일반 배열의 특성을 그대로 물려 받음 컴파일 시점에 크기를 지정해야 하는 일반 배열의 배열의 크기를 변경하는 resize() 연산이 가능 O(N) 시간이 걸림 주어진 원소를 배열의 맨 끝에 추가함으로써, 크기를 1 늘리는 append() 연산을 지원한다. O(1) 시간이 걸림 18.2.3 동적 배열의 연산 동적 배열의 연산을 하기 위해서는 동적으로 할당받은 배열(dynamically allocated array)을 사용한다. 동적으로 할당받은 배열은 new 등의 연산으로 고정된 길이의 배열 동적 배열의 크기가 바뀌어야 할 때는 단순하게 새 배열을 동적으로 할당받은 뒤 기존 원소들을 복사하고, 새 배열을 참조하도록 바꿔치기 한다 새 배열을 할당받고 기존 자료를 복사하는 데는 배열의 크기에 비례하는 시간이 걸린다. 따라서, resize() 연산은 O(N) 1 2 val size: Int; // 현재 배열의 크기 val arrayPointer: ElemntType // (동적으로 할당 받은) 실제 배열을 가리키는 포인터 메모리를 할당받을 때 배열의 크기가 커질 때를 대비해서 여유분의 메모리를 미리 할당받으면, append()를 O(1)에 구현할 수 있다.\n배열이 이미 할당한 메모리에 꽉 찼을 때, 더 큰 메모리를 할당받아 배열의 원소를 그 쪽으로 전부 옮긴다. 배열의 용량(capacity): 할당 받은 메모리의 크기\n배열의 크기(size): 실제 원수의 수\n여유분의 메모리(capacity)가 있지만, 실제로 동적 배열을 사용하는 프로그램에서는 배열의 크기가 5이라고 인식\n만약 현재 배열의 크기가 용량보다 작다면 append() 연산은 size를 1 증가 하고, 그 위치에 새 값을 할당하는 것으로 O(1) 에 구현 가능\n1 2 // append(newValue)의 일부 array[size++] = newValue 미리 할당해 둔 메모리가 꽉 찼을 때 append()는 어떻게 되는가?\n재할당: 더 큰 새 배열을 동적으로 할당받고, 새 배열에 기존 배열의 내용을 모두 복사한 다음 배열에 대한 포인터를 바꿔치기 한다. 미리 정해좋은 M이라는 크기만큼 배열의 용량을 늘려준다고 할 때, 시간 복잡도는 O(N+M), 선형 시간, 매우 가끔 일어남 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 // 배열 용량이 꽉 찼으면 재할당받는다. if (size == capacity) { int newCapacity = capacity + M; // 정해진 값 M 만큼의 새로운 배열을 새로 할당한다. int* newArray = new int[newCapacity]; for (int i = 0 ; i \u003c size ; ++i) // 기존 배열의 원소들을 복사한다. newArray[i] = array[i]; if (array) delete [] array; // 기존 배열을 삭제한 뒤 , 새로운 배열로 바꿔치기 한다. array = newArray; capacity = newCapacity; } // size의 값을 1 늘리고, 새로운 값(newValue)를 추가한다. array[size++] = newValue; 18.2.4 동적 배열의 재할당 전략 재할당에 걸리는 시간 복잡도 계산\n연산을 아주 여러 번 반복해서 수행한 뒤 각 수행 시간의 평균을 내자. // 분할 상환 분석(amortized analysis) 각 재할당 과정에서 선형 시간이 걸리더라도, 그것이 아주 가끔 일어난다면 전체 평균은 여전히 상수 시간일 수 도 있다. 텅 빈 배열로 시작해서, N번 append 연산을 할 때, 재할당의 수 K = O(N/M) 이다.\nM은 상수이므로 N이 아주 커지면, K = O(N) 재할당마다 복사하는 원소의 수는 M, 2M, 3M … KM개로 증가 전체 복사하는 원소의 수는 (K+1)KM * 1/2 = O(K^2) = O(N^2) N번의 append 연산에 드는 시간이 O(N^2) 이면, 한 번의 append 연산에 드는 시간은 평균적으로, O(N^2) / N = O(N) 이다.\n결과적으로 상수 시간에 append를 구현할 수 없게 된다. 상수 시간 [ O(1) ] 에 append를 구현하는 비결\n재할당을 할 때마다 정해진 개수의 여유분을 확보하는 것이 아니라, 현재 가진 원소의 개수에 비례해서 여유분을 확보하는 것이다.\n예를 들어, 배열 용량이 부족할 때마다 용량을 두 배로 늘리는 방법, 1,2,4 …\n배열의 용량이 꽉 찼을 때 이것을 어떻게 증가, 또는 반대로 감소시키느냐의 전략은 동적 배열의 효율성에 큰 영향을 미친다.\n18.2.5 표준 라이브러리의 동적 배열 구현 현대에 사용되는 대부분의 언어들은 동적 배열을 표준 라이브러리에서 제공한다. C언어만 제외 C++: vector, Java: ArrayList , Kotlin: MutableList, Python: List 이들은 내부적으로 배열(Array, 일반 정적 배열) 를 사용하기 때문에, 이들은 배열과 거의 다를 것 없는 속도를 제공한다. 최종 크기가 얼마인지 알 수 있다면, 동적 배열의 용량을 미리 늘려둠으로써 재할당에 드는 비용을 줄이기 Java의 ArrayList에서 ensureCapacity() 를 호출 하면 된다. 18.3 연결 리스트 배열과 달리, 메모리에 원소들이 물리적으로 흩어져 있고, 각 원소들이 이전과 다음 원소를 가리키는 포인터를 가지고 있다.\n데이터를 감싼 노드를 포인터로 연결해서 공간 효율성을 극대화 시킨 자료 구조\n삽입과 삭제를 상수 시간에 할 수 있게 해준다.\n이와 같은 연결 리스트를 정확히는 양방향 연결 리스트(doubly linked list) 라고 한다.\n1 data class Node\u003cT\u003e(var element: T, var next: Node\u003cT\u003e? = null) 1 2 3 4 5 class LinkedList\u003cT\u003e { private var head: Node\u003cT\u003e? = null private var tail: Node\u003cT\u003e? = null private var size = 0 } 원소와 포인터들의 집합들을 리스트의 노드(node)라고 부른다. 대게 연결 리스트는 head, tail에 대한 포인터만을 가진 클래스로 구현된다. 18.3.1 연결 리스트 특성 특정 위치의 값을 찾기(탐색) 가 쉽지 않다. i번째 노드를 찾 데 드는 시간은 리스트의 길이에 선형 비례 한다. O(N) 연결 리스트의 머리부터 하나씩 포인터를 따라가며 다음 노드를 찾을 수 밖에 없다. 삽입, 삭제 노드들의 순서가 포인터에 의해 정의되기 때문에, 삽입, 삭제는 간단하다. O(1) 다른 노드들은 그대로 두고, 삽입/삭제 노드와 이전/이후 노드의 포인터만을 바꾸면 된다. 18.3.2 표준 라이브러리의 연결 리스트 구현 동적 배열과 같이, 대부분의 프로그래밍 언어에서 연결 리스트를 표준 라이브러리에서 제공한다. C++ STL의 list, Java: LinkedList 18.3.3 연결 리스트 응용 연산들 splicing: 잘라 붙이기 연산\n다른 리스트를 통째로 삽입 하는 것을 상수 시간에 할 수 있다. 잘라 붙이기 연산을 구현하면 연결 리스트의 크기를 O(1)에 알기 불가능해진다. 연결 리스트의 크기를 알 수 있는 방법이 없어서, 원소의 개수를 리스트 객체에서 유지하면서 새 원소를 삽입하거나 삭제할 때마다 갱신해줘야 한다. 하지만, 잘라 붙이기 연산을 할 때는 몇 개의 원소가 추가 되는지 알기 없기 때문이다. 이 때문에 잘라 붙이기 연산을 지원하는 연결 리스트 구현은 많지 않다. Java의 LinkedList의 구현은 잘라 붙이기 연산을 포기하는 대신, 리스트의 크기를 구하는 연산을 상수 시간에 지원한다. 삭제했던 원소 돌려놓기: 한 번 삭제했던 원소를 제자리에 쉽게 돌려 놓을 수 있다.\nnode의 포인터들은 원래 자기가 들어가 있던 위치를 알고 있기 때문에, recoverNode() 처럼 node에 대해서만 알고 있어도 원래 리스트에 쉽게 다시 삽입할 수 있다.\n이 방법은 이전, 이후 노드 또한 삭제된 상태에서 수행되면 리스트를 망가뜨리기 때문에, 항상 삭제한 순서의 반대로 복구가 이루어질 때만 사용할 수 있다.\n이 연산은 프로그램의 되돌리기(undo) 연산을 지원하는 데 유용하게 쓸 수 있다.\n사용자 인터페이스(UI)에 되돌리기 연산이 자주 사용 양뱡향 연결 리스트로 문제의 현재 상태를 표현하면 되돌리기 연산을 통해 문제의 상태를 되돌리는 작업을 효율적으로 할 수 있다: 조합 탐색 에 유용하다.\n1 2 3 4 5 6 7 8 9 10 11 // node 이전/이후 노드의 포인터를 바꿔서 node를 리스트에서 삭제한다 void deleteNode(listNode* node){ node-\u003eprev-\u003enext = node-\u003enext; node-\u003enext-\u003eprev = node-\u003eprev; } // node 이전/이후 노드의 포인터를 바꿔서 자기 자신을 다시 리스트에 삽입 void recoverNode(listNode* node){ node-\u003eprev-\u003enext = node; node-\u003enext-\u003eprev = node; } 18.4 동적 배열과 연결 리스트 비교 삽입, 삭제가 많다 =\u003e 연결 리스트\n원소 접근이 많다 =\u003e 동적 배열\n배열의 끝에서만 삽입, 삭제가 많다 =\u003e 동적 배열\n작업 동적 배열 연결 리스트 이전 원소/다음 원소 찾기 O(1) O(1) 맨 뒤에 원소 추가/삭제하기 O(1) O(1) 맨 뒤 이외의 위치에 원소 추가/삭제하기 O(N) O(1) 임의의 위치의 원소 찾기 O(1) O(N) 크기 구하기 O(1) O(N) or O(1), 잘라 붙이기 연산 유무에 따라 Reference 프로그래밍 대회에서 배우는 알고리즘 문제 해결 전략 (구종만, 인사이트) https://www.algospot.com/ ","wordCount":"1317","inLanguage":"en","image":"https://2taezeat.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E","datePublished":"2024-01-13T11:30:03Z","dateModified":"2024-01-13T11:30:03Z","author":{"@type":"Person","name":"2taezeat"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://2taezeat.github.io/posts/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EB%AC%B8%EC%A0%9C-%ED%95%B4%EA%B2%B0-%EC%A0%84%EB%9E%B5/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EB%AC%B8%EC%A0%9C-%ED%95%B4%EA%B2%B0-%EC%A0%84%EB%9E%B5-ch18.-%EA%B8%B0%EC%B4%88-%EC%9E%90%EB%A3%8C-%EA%B5%AC%EC%A1%B0/"},"publisher":{"@type":"Organization","name":"2taezeat, blog","logo":{"@type":"ImageObject","url":"https://2taezeat.github.io/icon/favicon.ico"}}}</script></head><body id=top><header class=header><nav class=nav><div class=logo><a href=https://2taezeat.github.io/ accesskey=h title="2taezeat blog (Alt + H)"><img src=https://2taezeat.github.io/icon/apple-touch-icon.png alt aria-label=logo height=30>2taezeat blog</a><div class=logo-switches></div></div><ul id=menu><li><a href=https://2taezeat.github.io/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://2taezeat.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://2taezeat.github.io/searchs/ title=Search><span>Search</span></a></li><li><a href=https://github.com/2taezeat title=Github><span>Github</span>&nbsp;<svg fill="none" shape-rendering="geometricPrecision" stroke="currentcolor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2.5" viewBox="0 0 24 24" height="12" width="12"><path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"/><path d="M15 3h6v6"/><path d="M10 14 21 3"/></svg></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://2taezeat.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://2taezeat.github.io/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">[알고리즘 문제 해결 전략] ch18. 기초 자료 구조</h1><div class=post-description>ch18. 선형 자료 구조 (동적 배열, 연결 리스트)</div><div class=post-meta><span title='2024-01-13 11:30:03 +0000 +0000'>2024-01-13</span>&nbsp;·&nbsp;7 min&nbsp;·&nbsp;1317 words&nbsp;·&nbsp;2taezeat</div></header><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#18-선형-자료-구조>18. 선형 자료 구조</a><ul><li><a href=#181-도입>18.1 도입</a></li><li><a href=#182-동적-배열>18.2 동적 배열</a><ul><li><a href=#1821-일반-배열의-특성>18.2.1 일반 배열의 특성</a></li><li><a href=#1822-동적-배열의-특성>18.2.2 동적 배열의 특성</a></li><li><a href=#1823-동적-배열의-연산>18.2.3 동적 배열의 연산</a></li><li><a href=#1824-동적-배열의-재할당-전략>18.2.4 동적 배열의 재할당 전략</a></li><li><a href=#1825-표준-라이브러리의-동적-배열-구현>18.2.5 표준 라이브러리의 동적 배열 구현</a></li></ul></li><li><a href=#183-연결-리스트>18.3 연결 리스트</a><ul><li><a href=#1831-연결-리스트-특성>18.3.1 연결 리스트 특성</a></li><li><a href=#1832-표준-라이브러리의-연결-리스트-구현>18.3.2 표준 라이브러리의 연결 리스트 구현</a></li><li><a href=#1833-연결-리스트-응용-연산들>18.3.3 연결 리스트 응용 연산들</a></li></ul></li><li><a href=#184-동적-배열과-연결-리스트-비교>18.4 동적 배열과 연결 리스트 비교</a></li></ul></li><li><a href=#reference>Reference</a></li></ul></nav></div></details></div><div class=post-content><h1 id=18-선형-자료-구조>18. 선형 자료 구조<a hidden class=anchor aria-hidden=true href=#18-선형-자료-구조>#</a></h1><h2 id=181-도입>18.1 도입<a hidden class=anchor aria-hidden=true href=#181-도입>#</a></h2><ul><li><p>일렬로 늘어선 같은 종류의 자료 여러 개를 저장하기 위한 가장 기초적인 자료구조는 <code>배열(Array)</code> 이다.</p></li><li><p><code>동적 배열, 연결 리스트</code>는 <code>배열</code>과 비슷하지만, 배열에서 비효율적이거나 할 수 없는 작업들을 효율적으로 작업한다.</p></li></ul><h2 id=182-동적-배열>18.2 동적 배열<a hidden class=anchor aria-hidden=true href=#182-동적-배열>#</a></h2><ul><li><p><strong>배열(일반 배열, 정적 배열)</strong> 의 문제는 배열을 선언할 때, 배열의 크기를 지정해야 하며, <strong>그 이상의 자료를 집어넣을 수 없다는 점</strong>이다.</p></li><li><p>이 문제를 해결 하기 위해, 자료의 개수가 변함에 따라 크기가 변경되는 <code>동적 배열(dynamic array)</code>이 고안되었다.</p></li><li><p>동적 배열은 또 다른 종류의 배열이 아니다.</p></li><li><p>동적 배열은 일반 배열처럼 언어 차원에서 지원되는 기능이 아니다.</p></li><li><p>동적 배열은 일반 배열을 이용해 만들어 낸 <strong>별도의 자료 구조</strong> 이다.</p></li><li><p>동적 배열은 대개 언어 문법이 아니라 <strong>언어의 표준 라이브러리</strong>에 포함되어 있다.</p></li><li><p>내부적으로는 <strong>일반 배열</strong>로 구현되기 때문에, <strong>동적 배열은 일반 배열이 갖는 특성을 그대로 물려 받는다.</strong></p></li></ul><blockquote><ul><li>요즘에는 일반적인 배열을 제공하지 않고 <strong>동적 배열만</strong>을 제공하는 언어들도 있다.<ul><li>동적 타입을 갖는 언어, 대표적으로 Python</li></ul></li><li>이 동적 배열 기능도 내부적으로는 항상 <strong>일반 배열</strong>로 구현된다.</li></ul></blockquote><h3 id=1821-일반-배열의-특성>18.2.1 일반 배열의 특성<a hidden class=anchor aria-hidden=true href=#1821-일반-배열의-특성>#</a></h3><ul><li>일반 배열은, 동적 배열과 비교하면 <strong>정적 배열</strong>로 볼 수 있다.</li><li>원소들은 <strong>메모리의 연속된 위치</strong>에 저장된다.<ul><li><strong>캐시의 효율성을 높여준다, 공간 지역성</strong></li></ul></li><li>주어진 위치의 원소를 <strong>반환</strong>하거나 <strong>변경</strong>하는 동작을 <strong>O(1)</strong> 에 할 수 있다.</li><li>배열에 원소를 <strong>삽입, 삭제</strong><ul><li>O(N), 원소를 삽입, 삭제하고 기존 원소를 모두 이동(데이터 복사)시켜줘야 한다.</li><li>정확한 수행 시간은 삽입, 삭제의 위치에 따라 달라지지만, 평균적으로 선형 시간</li></ul></li><li><strong>임의 접근(random access)</strong> 가 <strong>O(1)</strong> 에 가능하다.<ul><li><strong>순차 접근</strong>과 달리 <strong>인덱스</strong>에 해당하는 데이터에 접근할 수 있다.</li></ul></li></ul><h3 id=1822-동적-배열의-특성>18.2.2 동적 배열의 특성<a hidden class=anchor aria-hidden=true href=#1822-동적-배열의-특성>#</a></h3><ul><li>일반 배열의 특성을 그대로 물려 받음</li><li>컴파일 시점에 크기를 지정해야 하는 일반 배열의</li><li>배열의 크기를 변경하는 <code>resize()</code> 연산이 가능<ul><li>O(N) 시간이 걸림</li></ul></li><li>주어진 원소를 배열의 맨 끝에 추가함으로써, 크기를 1 늘리는 <code>append()</code> 연산을 지원한다.<ul><li>O(1) 시간이 걸림</li></ul></li></ul><h3 id=1823-동적-배열의-연산>18.2.3 동적 배열의 연산<a hidden class=anchor aria-hidden=true href=#1823-동적-배열의-연산>#</a></h3><ul><li>동적 배열의 연산을 하기 위해서는 <code>동적으로 할당받은 배열(dynamically allocated array)</code>을 사용한다.<ul><li><code>동적으로 할당받은 배열</code>은 <code>new</code> 등의 연산으로 고정된 길이의 배열</li></ul></li><li>동적 배열의 크기가 바뀌어야 할 때는 단순하게 새 배열을 동적으로 할당받은 뒤 기존 원소들을 복사하고, 새 배열을 참조하도록 바꿔치기 한다</li><li>새 배열을 할당받고 <strong>기존 자료를 복사</strong>하는 데는 배열의 크기에 비례하는 시간이 걸린다.<ul><li>따라서, <strong>resize()</strong> 연산은 O(N)</li></ul></li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-kotlin data-lang=kotlin><span class=line><span class=cl><span class=k>val</span> <span class=py>size</span><span class=p>:</span> <span class=n>Int</span><span class=p>;</span> <span class=c1>// 현재 배열의 크기
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>val</span> <span class=py>arrayPointer</span><span class=p>:</span> <span class=n>ElemntType</span> <span class=c1>// (동적으로 할당 받은) 실제 배열을 가리키는 포인터
</span></span></span></code></pre></td></tr></table></div></div><ul><li><p>메모리를 할당받을 때 배열의 크기가 커질 때를 대비해서 <strong>여유분의 메모리를 미리 할당</strong>받으면, <code>append()</code>를 O(1)에 구현할 수 있다.</p><ul><li>배열이 이미 할당한 메모리에 꽉 찼을 때, 더 큰 메모리를 할당받아 배열의 원소를 그 쪽으로 전부 옮긴다.</li></ul></li><li><p><strong>배열의 용량(capacity):</strong> 할당 받은 메모리의 크기</p></li><li><p><strong>배열의 크기(size)</strong>: 실제 원수의 수</p></li><li><p>여유분의 메모리(capacity)가 있지만, 실제로 동적 배열을 사용하는 프로그램에서는 배열의 크기가 5이라고 인식</p></li><li><p>만약 현재 배열의 크기가 용량보다 작다면 <code>append()</code> 연산은 size를 1 증가 하고, 그 위치에 새 값을 할당하는 것으로 <strong>O(1)</strong> 에 구현 가능</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-kotlin data-lang=kotlin><span class=line><span class=cl><span class=c1>// append(newValue)의 일부
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>array</span><span class=p>[</span><span class=n>size</span><span class=o>++</span><span class=p>]</span> <span class=p>=</span> <span class=n>newValue</span>
</span></span></code></pre></td></tr></table></div></div></li><li><p>미리 할당해 둔 메모리가 꽉 찼을 때 <code>append()</code>는 어떻게 되는가?</p><ul><li><strong>재할당</strong>: 더 큰 <strong>새 배열을 동적으로 할당</strong>받고, 새 배열에 <strong>기존 배열의 내용을 모두 복사</strong>한 다음 <strong>배열에 대한 포인터를 바꿔치기</strong> 한다.</li><li>미리 정해좋은 M이라는 크기만큼 배열의 용량을 늘려준다고 할 때, <strong>시간 복잡도는 O(N+M), 선형 시간, 매우 가끔 일어남</strong></li></ul></li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=c1>// 배열 용량이 꽉 찼으면 재할당받는다.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>if</span> <span class=p>(</span><span class=n>size</span> <span class=o>==</span> <span class=n>capacity</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>newCapacity</span> <span class=o>=</span> <span class=n>capacity</span> <span class=o>+</span> <span class=n>M</span><span class=p>;</span> <span class=c1>// 정해진 값 M 만큼의 새로운 배열을 새로 할당한다.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>int</span><span class=o>*</span> <span class=n>newArray</span> <span class=o>=</span> <span class=k>new</span> <span class=kt>int</span><span class=p>[</span><span class=n>newCapacity</span><span class=p>];</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span> <span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>size</span> <span class=p>;</span> <span class=o>++</span><span class=n>i</span><span class=p>)</span>  <span class=c1>// 기존 배열의 원소들을 복사한다.
</span></span></span><span class=line><span class=cl><span class=c1></span>    	<span class=n>newArray</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>=</span> <span class=n>array</span><span class=p>[</span><span class=n>i</span><span class=p>];</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>array</span><span class=p>)</span> <span class=k>delete</span> <span class=p>[]</span> <span class=n>array</span><span class=p>;</span>  <span class=c1>// 기존 배열을 삭제한 뒤 , 새로운 배열로 바꿔치기 한다.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>array</span> <span class=o>=</span> <span class=n>newArray</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>capacity</span> <span class=o>=</span> <span class=n>newCapacity</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// size의 값을 1 늘리고, 새로운 값(newValue)를 추가한다.    
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>array</span><span class=p>[</span><span class=n>size</span><span class=o>++</span><span class=p>]</span> <span class=o>=</span> <span class=n>newValue</span><span class=p>;</span>
</span></span></code></pre></td></tr></table></div></div><h3 id=1824-동적-배열의-재할당-전략>18.2.4 동적 배열의 재할당 전략<a hidden class=anchor aria-hidden=true href=#1824-동적-배열의-재할당-전략>#</a></h3><ul><li><p><strong>재할당</strong>에 걸리는 시간 복잡도 계산</p><ul><li>연산을 아주 여러 번 반복해서 수행한 뒤 각 수행 시간의 평균을 내자. // <code>분할 상환 분석(amortized analysis)</code></li><li>각 재할당 과정에서 선형 시간이 걸리더라도, 그것이 아주 가끔 일어난다면 전체 평균은 여전히 상수 시간일 수 도 있다.</li></ul></li><li><p>텅 빈 배열로 시작해서, N번 append 연산을 할 때, 재할당의 수 K = O(N/M) 이다.</p><ul><li>M은 상수이므로 N이 아주 커지면, K = O(N)</li><li>재할당마다 복사하는 원소의 수는 M, 2M, 3M &mldr; KM개로 증가</li><li><strong>전체 복사하는 원소의 수</strong>는 (K+1)KM * 1/2 = O(K^2) = <strong>O(N^2)</strong></li></ul></li><li><p>N번의 <code>append</code> 연산에 드는 시간이 O(N^2) 이면, <strong>한 번의 <code>append</code> 연산</strong>에 드는 시간은 <strong>평균적으로, O(N^2) / N = O(N)</strong> 이다.</p><ul><li>결과적으로 상수 시간에 <code>append</code>를 구현할 수 없게 된다.</li></ul></li><li><p>상수 시간 [ <strong>O(1)</strong> ] 에 <code>append</code>를 구현하는 비결</p><ul><li><p><strong>재할당</strong>을 할 때마다 정해진 개수의 여유분을 확보하는 것이 아니라, <strong>현재 가진 원소의 개수에 비례해서 여유분을 확보</strong>하는 것이다.</p></li><li><p>예를 들어, 배열 용량이 부족할 때마다 용량을 두 배로 늘리는 방법, 1,2,4 &mldr;</p></li></ul></li><li><p>배열의 용량이 꽉 찼을 때 이것을 어떻게 증가, 또는 반대로 감소시키느냐의 전략은 동적 배열의 효율성에 큰 영향을 미친다.</p></li></ul><h3 id=1825-표준-라이브러리의-동적-배열-구현>18.2.5 표준 라이브러리의 동적 배열 구현<a hidden class=anchor aria-hidden=true href=#1825-표준-라이브러리의-동적-배열-구현>#</a></h3><ul><li>현대에 사용되는 대부분의 언어들은 <strong>동적 배열</strong>을 <strong>표준 라이브러리에서 제공</strong>한다. C언어만 제외<ul><li><code>C++: vector</code>, <code>Java: ArrayList</code> , <code>Kotlin: MutableList</code>, <code>Python: List</code></li></ul></li><li>이들은 내부적으로 <strong>배열(Array, 일반 정적 배열)</strong> 를 사용하기 때문에, 이들은 배열과 거의 다를 것 없는 속도를 제공한다.</li><li>최종 크기가 얼마인지 알 수 있다면, 동적 배열의 용량을 미리 늘려둠으로써 재할당에 드는 비용을 줄이기<ul><li>Java의 ArrayList에서 <code>ensureCapacity()</code> 를 호출 하면 된다.</li></ul></li></ul><h2 id=183-연결-리스트>18.3 연결 리스트<a hidden class=anchor aria-hidden=true href=#183-연결-리스트>#</a></h2><ul><li><p>배열과 달리, <strong>메모리에 원소들이 물리적으로 흩어져 있고</strong>, 각 원소들이 이전과 다음 원소를 가리키는 <strong>포인터</strong>를 가지고 있다.</p></li><li><p>데이터를 감싼 <strong>노드</strong>를 <strong>포인터로 연결</strong>해서 공간 효율성을 극대화 시킨 자료 구조</p></li><li><p><strong>삽입과 삭제</strong>를 <strong>상수 시간</strong>에 할 수 있게 해준다.</p></li><li><p>이와 같은 연결 리스트를 정확히는 <code>양방향 연결 리스트(doubly linked list)</code> 라고 한다.</p></li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-kotlin data-lang=kotlin><span class=line><span class=cl><span class=k>data</span> <span class=k>class</span> <span class=nc>Node</span><span class=p>&lt;</span><span class=n>T</span><span class=p>&gt;(</span><span class=k>var</span> <span class=py>element</span><span class=p>:</span> <span class=n>T</span><span class=p>,</span> <span class=k>var</span> <span class=py>next</span><span class=p>:</span> <span class=n>Node</span><span class=p>&lt;</span><span class=n>T</span><span class=p>&gt;?</span> <span class=p>=</span> <span class=k>null</span><span class=p>)</span> 
</span></span></code></pre></td></tr></table></div></div><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-kotlin data-lang=kotlin><span class=line><span class=cl><span class=k>class</span> <span class=nc>LinkedList</span><span class=p>&lt;</span><span class=n>T</span><span class=p>&gt;</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>private</span> <span class=k>var</span> <span class=py>head</span><span class=p>:</span> <span class=n>Node</span><span class=p>&lt;</span><span class=n>T</span><span class=p>&gt;?</span> <span class=p>=</span> <span class=k>null</span>
</span></span><span class=line><span class=cl>    <span class=k>private</span> <span class=k>var</span> <span class=py>tail</span><span class=p>:</span> <span class=n>Node</span><span class=p>&lt;</span><span class=n>T</span><span class=p>&gt;?</span> <span class=p>=</span> <span class=k>null</span>
</span></span><span class=line><span class=cl>	<span class=k>private</span> <span class=k>var</span> <span class=py>size</span> <span class=p>=</span> <span class=m>0</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><ul><li>원소와 포인터들의 집합들을 리스트의 노드(node)라고 부른다.</li><li>대게 연결 리스트는 head, tail에 대한 포인터만을 가진 클래스로 구현된다.</li></ul><h3 id=1831-연결-리스트-특성>18.3.1 연결 리스트 특성<a hidden class=anchor aria-hidden=true href=#1831-연결-리스트-특성>#</a></h3><ul><li>특정 위치의 값을 <strong>찾기(탐색)</strong> 가 쉽지 않다.<ul><li>i번째 노드를 찾 데 드는 시간은 리스트의 길이에 <strong>선형 비례 한다. O(N)</strong></li><li>연결 리스트의 머리부터 <strong>하나씩 포인터를 따라가며 다음 노드를 찾을 수 밖에 없다.</strong></li></ul></li><li>삽입, 삭제<ul><li>노드들의 순서가 포인터에 의해 정의되기 때문에, 삽입, 삭제는 간단하다. <strong>O(1)</strong></li><li>다른 노드들은 그대로 두고, 삽입/삭제 노드와 이전/이후 노드의 <strong>포인터만</strong>을 바꾸면 된다.</li></ul></li></ul><h3 id=1832-표준-라이브러리의-연결-리스트-구현>18.3.2 표준 라이브러리의 연결 리스트 구현<a hidden class=anchor aria-hidden=true href=#1832-표준-라이브러리의-연결-리스트-구현>#</a></h3><ul><li>동적 배열과 같이, 대부분의 프로그래밍 언어에서 <strong>연결 리스트를 표준 라이브러리</strong>에서 제공한다.<ul><li><code>C++ STL의 list</code>, <code>Java: LinkedList</code></li></ul></li></ul><h3 id=1833-연결-리스트-응용-연산들>18.3.3 연결 리스트 응용 연산들<a hidden class=anchor aria-hidden=true href=#1833-연결-리스트-응용-연산들>#</a></h3><ul><li><p><strong>splicing</strong>: 잘라 붙이기 연산</p><ul><li>다른 리스트를 통째로 삽입 하는 것을 상수 시간에 할 수 있다.</li><li>잘라 붙이기 연산을 구현하면 연결 리스트의 크기를 <strong>O(1)에 알기 불가능</strong>해진다.</li><li>연결 리스트의 크기를 알 수 있는 방법이 없어서, 원소의 개수를 리스트 객체에서 유지하면서 새 원소를 삽입하거나 삭제할 때마다 갱신해줘야 한다.</li><li>하지만, 잘라 붙이기 연산을 할 때는 몇 개의 원소가 추가 되는지 알기 없기 때문이다.</li><li>이 때문에 잘라 붙이기 연산을 지원하는 연결 리스트 구현은 많지 않다.<ul><li>Java의 LinkedList의 구현은 잘라 붙이기 연산을 포기하는 대신, 리스트의 크기를 구하는 연산을 상수 시간에 지원한다.</li></ul></li></ul></li><li><p><strong>삭제했던 원소 돌려놓기</strong>: 한 번 삭제했던 원소를 제자리에 쉽게 돌려 놓을 수 있다.</p><ul><li><p><strong>node의 포인터들</strong>은 원래 자기가 들어가 있던 위치를 알고 있기 때문에, recoverNode() 처럼 node에 대해서만 알고 있어도 원래 리스트에 쉽게 다시 삽입할 수 있다.</p></li><li><p>이 방법은 이전, 이후 노드 또한 삭제된 상태에서 수행되면 리스트를 망가뜨리기 때문에, <strong>항상 삭제한 순서의 반대로 복구가 이루어질 때만 사용할 수 있다.</strong></p></li><li><p>이 연산은 프로그램의 <strong><code>되돌리기(undo)</code></strong> 연산을 지원하는 데 유용하게 쓸 수 있다.</p><ul><li>사용자 인터페이스(UI)에 되돌리기 연산이 자주 사용</li></ul></li><li><p>양뱡향 연결 리스트로 문제의 현재 상태를 표현하면 되돌리기 연산을 통해 문제의 상태를 되돌리는 작업을 효율적으로 할 수 있다: <strong>조합 탐색</strong> 에 유용하다.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=c1>// node 이전/이후 노드의 포인터를 바꿔서 node를 리스트에서 삭제한다
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>void</span> <span class=nf>deleteNode</span><span class=p>(</span><span class=n>listNode</span><span class=o>*</span> <span class=n>node</span><span class=p>){</span>
</span></span><span class=line><span class=cl>	<span class=n>node</span><span class=o>-&gt;</span><span class=n>prev</span><span class=o>-&gt;</span><span class=n>next</span> <span class=o>=</span> <span class=n>node</span><span class=o>-&gt;</span><span class=n>next</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>node</span><span class=o>-&gt;</span><span class=n>next</span><span class=o>-&gt;</span><span class=n>prev</span> <span class=o>=</span> <span class=n>node</span><span class=o>-&gt;</span><span class=n>prev</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// node 이전/이후 노드의 포인터를 바꿔서 자기 자신을 다시 리스트에 삽입
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>void</span> <span class=nf>recoverNode</span><span class=p>(</span><span class=n>listNode</span><span class=o>*</span> <span class=n>node</span><span class=p>){</span>
</span></span><span class=line><span class=cl>	<span class=n>node</span><span class=o>-&gt;</span><span class=n>prev</span><span class=o>-&gt;</span><span class=n>next</span> <span class=o>=</span> <span class=n>node</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>node</span><span class=o>-&gt;</span><span class=n>next</span><span class=o>-&gt;</span><span class=n>prev</span> <span class=o>=</span> <span class=n>node</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>    
</span></span></code></pre></td></tr></table></div></div></li></ul></li></ul><h2 id=184-동적-배열과-연결-리스트-비교>18.4 동적 배열과 연결 리스트 비교<a hidden class=anchor aria-hidden=true href=#184-동적-배열과-연결-리스트-비교>#</a></h2><ul><li><p>삽입, 삭제가 많다 => 연결 리스트</p></li><li><p>원소 접근이 많다 => 동적 배열</p></li><li><p>배열의 끝에서만 삽입, 삭제가 많다 => 동적 배열</p><table><thead><tr><th>작업</th><th>동적 배열</th><th>연결 리스트</th></tr></thead><tbody><tr><td>이전 원소/다음 원소 찾기</td><td>O(1)</td><td>O(1)</td></tr><tr><td>맨 뒤에 원소 추가/삭제하기</td><td>O(1)</td><td>O(1)</td></tr><tr><td>맨 뒤 이외의 위치에 원소 추가/삭제하기</td><td>O(N)</td><td>O(1)</td></tr><tr><td>임의의 위치의 원소 찾기</td><td>O(1)</td><td>O(N)</td></tr><tr><td>크기 구하기</td><td>O(1)</td><td>O(N) or O(1), 잘라 붙이기 연산 유무에 따라</td></tr></tbody></table></li></ul><h1 id=reference>Reference<a hidden class=anchor aria-hidden=true href=#reference>#</a></h1><ul><li>프로그래밍 대회에서 배우는 알고리즘 문제 해결 전략 (구종만, 인사이트)</li><li><a href=https://www.algospot.com/>https://www.algospot.com/</a></li></ul></div><footer class=post-footer><ul class=post-tags><li><a href=https://2taezeat.github.io/tags/algorithm/>Algorithm</a></li></ul><nav class=paginav><a class=prev href=https://2taezeat.github.io/posts/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EB%AC%B8%EC%A0%9C-%ED%95%B4%EA%B2%B0-%EC%A0%84%EB%9E%B5/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EB%AC%B8%EC%A0%9C-%ED%95%B4%EA%B2%B0-%EC%A0%84%EB%9E%B5-ch19.-%EA%B8%B0%EC%B4%88-%EC%9E%90%EB%A3%8C-%EA%B5%AC%EC%A1%B0/><span class=title>« Prev</span><br><span>[알고리즘 문제 해결 전략] ch19. 기초 자료 구조</span>
</a><a class=next href=https://2taezeat.github.io/posts/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EB%AC%B8%EC%A0%9C-%ED%95%B4%EA%B2%B0-%EC%A0%84%EB%9E%B5/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EB%AC%B8%EC%A0%9C-%ED%95%B4%EA%B2%B0-%EC%A0%84%EB%9E%B5-ch17.-%EA%B8%B0%EC%B4%88-%EC%9E%90%EB%A3%8C-%EA%B5%AC%EC%A1%B0/><span class=title>Next »</span><br><span>[알고리즘 문제 해결 전략] ch17. 기초 자료 구조</span></a></nav><ul class=share-buttons><li><a target=_blank rel="noopener noreferrer" aria-label="share [알고리즘 문제 해결 전략] ch18. 기초 자료 구조 on x" href="https://x.com/intent/tweet/?text=%5b%ec%95%8c%ea%b3%a0%eb%a6%ac%ec%a6%98%20%eb%ac%b8%ec%a0%9c%20%ed%95%b4%ea%b2%b0%20%ec%a0%84%eb%9e%b5%5d%20ch18.%20%ea%b8%b0%ec%b4%88%20%ec%9e%90%eb%a3%8c%20%ea%b5%ac%ec%a1%b0&amp;url=https%3a%2f%2f2taezeat.github.io%2fposts%2f%25EC%2595%258C%25EA%25B3%25A0%25EB%25A6%25AC%25EC%25A6%2598-%25EB%25AC%25B8%25EC%25A0%259C-%25ED%2595%25B4%25EA%25B2%25B0-%25EC%25A0%2584%25EB%259E%25B5%2f%25EC%2595%258C%25EA%25B3%25A0%25EB%25A6%25AC%25EC%25A6%2598-%25EB%25AC%25B8%25EC%25A0%259C-%25ED%2595%25B4%25EA%25B2%25B0-%25EC%25A0%2584%25EB%259E%25B5-ch18.-%25EA%25B8%25B0%25EC%25B4%2588-%25EC%259E%2590%25EB%25A3%258C-%25EA%25B5%25AC%25EC%25A1%25B0%2f&amp;hashtags=Algorithm"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446C483.971.0 512 28.03 512 62.554zM269.951 190.75 182.567 75.216H56L207.216 272.95 63.9 436.783h61.366L235.9 310.383l96.667 126.4H456L298.367 228.367l134-153.151H371.033zM127.633 110h36.468l219.38 290.065H349.5z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share [알고리즘 문제 해결 전략] ch18. 기초 자료 구조 on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2f2taezeat.github.io%2fposts%2f%25EC%2595%258C%25EA%25B3%25A0%25EB%25A6%25AC%25EC%25A6%2598-%25EB%25AC%25B8%25EC%25A0%259C-%25ED%2595%25B4%25EA%25B2%25B0-%25EC%25A0%2584%25EB%259E%25B5%2f%25EC%2595%258C%25EA%25B3%25A0%25EB%25A6%25AC%25EC%25A6%2598-%25EB%25AC%25B8%25EC%25A0%259C-%25ED%2595%25B4%25EA%25B2%25B0-%25EC%25A0%2584%25EB%259E%25B5-ch18.-%25EA%25B8%25B0%25EC%25B4%2588-%25EC%259E%2590%25EB%25A3%258C-%25EA%25B5%25AC%25EC%25A1%25B0%2f&amp;title=%5b%ec%95%8c%ea%b3%a0%eb%a6%ac%ec%a6%98%20%eb%ac%b8%ec%a0%9c%20%ed%95%b4%ea%b2%b0%20%ec%a0%84%eb%9e%b5%5d%20ch18.%20%ea%b8%b0%ec%b4%88%20%ec%9e%90%eb%a3%8c%20%ea%b5%ac%ec%a1%b0&amp;summary=%5b%ec%95%8c%ea%b3%a0%eb%a6%ac%ec%a6%98%20%eb%ac%b8%ec%a0%9c%20%ed%95%b4%ea%b2%b0%20%ec%a0%84%eb%9e%b5%5d%20ch18.%20%ea%b8%b0%ec%b4%88%20%ec%9e%90%eb%a3%8c%20%ea%b5%ac%ec%a1%b0&amp;source=https%3a%2f%2f2taezeat.github.io%2fposts%2f%25EC%2595%258C%25EA%25B3%25A0%25EB%25A6%25AC%25EC%25A6%2598-%25EB%25AC%25B8%25EC%25A0%259C-%25ED%2595%25B4%25EA%25B2%25B0-%25EC%25A0%2584%25EB%259E%25B5%2f%25EC%2595%258C%25EA%25B3%25A0%25EB%25A6%25AC%25EC%25A6%2598-%25EB%25AC%25B8%25EC%25A0%259C-%25ED%2595%25B4%25EA%25B2%25B0-%25EC%25A0%2584%25EB%259E%25B5-ch18.-%25EA%25B8%25B0%25EC%25B4%2588-%25EC%259E%2590%25EB%25A3%258C-%25EA%25B5%25AC%25EC%25A1%25B0%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share [알고리즘 문제 해결 전략] ch18. 기초 자료 구조 on reddit" href="https://reddit.com/submit?url=https%3a%2f%2f2taezeat.github.io%2fposts%2f%25EC%2595%258C%25EA%25B3%25A0%25EB%25A6%25AC%25EC%25A6%2598-%25EB%25AC%25B8%25EC%25A0%259C-%25ED%2595%25B4%25EA%25B2%25B0-%25EC%25A0%2584%25EB%259E%25B5%2f%25EC%2595%258C%25EA%25B3%25A0%25EB%25A6%25AC%25EC%25A6%2598-%25EB%25AC%25B8%25EC%25A0%259C-%25ED%2595%25B4%25EA%25B2%25B0-%25EC%25A0%2584%25EB%259E%25B5-ch18.-%25EA%25B8%25B0%25EC%25B4%2588-%25EC%259E%2590%25EB%25A3%258C-%25EA%25B5%25AC%25EC%25A1%25B0%2f&title=%5b%ec%95%8c%ea%b3%a0%eb%a6%ac%ec%a6%98%20%eb%ac%b8%ec%a0%9c%20%ed%95%b4%ea%b2%b0%20%ec%a0%84%eb%9e%b5%5d%20ch18.%20%ea%b8%b0%ec%b4%88%20%ec%9e%90%eb%a3%8c%20%ea%b5%ac%ec%a1%b0"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share [알고리즘 문제 해결 전략] ch18. 기초 자료 구조 on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2f2taezeat.github.io%2fposts%2f%25EC%2595%258C%25EA%25B3%25A0%25EB%25A6%25AC%25EC%25A6%2598-%25EB%25AC%25B8%25EC%25A0%259C-%25ED%2595%25B4%25EA%25B2%25B0-%25EC%25A0%2584%25EB%259E%25B5%2f%25EC%2595%258C%25EA%25B3%25A0%25EB%25A6%25AC%25EC%25A6%2598-%25EB%25AC%25B8%25EC%25A0%259C-%25ED%2595%25B4%25EA%25B2%25B0-%25EC%25A0%2584%25EB%259E%25B5-ch18.-%25EA%25B8%25B0%25EC%25B4%2588-%25EC%259E%2590%25EB%25A3%258C-%25EA%25B5%25AC%25EC%25A1%25B0%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share [알고리즘 문제 해결 전략] ch18. 기초 자료 구조 on whatsapp" href="https://api.whatsapp.com/send?text=%5b%ec%95%8c%ea%b3%a0%eb%a6%ac%ec%a6%98%20%eb%ac%b8%ec%a0%9c%20%ed%95%b4%ea%b2%b0%20%ec%a0%84%eb%9e%b5%5d%20ch18.%20%ea%b8%b0%ec%b4%88%20%ec%9e%90%eb%a3%8c%20%ea%b5%ac%ec%a1%b0%20-%20https%3a%2f%2f2taezeat.github.io%2fposts%2f%25EC%2595%258C%25EA%25B3%25A0%25EB%25A6%25AC%25EC%25A6%2598-%25EB%25AC%25B8%25EC%25A0%259C-%25ED%2595%25B4%25EA%25B2%25B0-%25EC%25A0%2584%25EB%259E%25B5%2f%25EC%2595%258C%25EA%25B3%25A0%25EB%25A6%25AC%25EC%25A6%2598-%25EB%25AC%25B8%25EC%25A0%259C-%25ED%2595%25B4%25EA%25B2%25B0-%25EC%25A0%2584%25EB%259E%25B5-ch18.-%25EA%25B8%25B0%25EC%25B4%2588-%25EC%259E%2590%25EB%25A3%258C-%25EA%25B5%25AC%25EC%25A1%25B0%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share [알고리즘 문제 해결 전략] ch18. 기초 자료 구조 on telegram" href="https://telegram.me/share/url?text=%5b%ec%95%8c%ea%b3%a0%eb%a6%ac%ec%a6%98%20%eb%ac%b8%ec%a0%9c%20%ed%95%b4%ea%b2%b0%20%ec%a0%84%eb%9e%b5%5d%20ch18.%20%ea%b8%b0%ec%b4%88%20%ec%9e%90%eb%a3%8c%20%ea%b5%ac%ec%a1%b0&amp;url=https%3a%2f%2f2taezeat.github.io%2fposts%2f%25EC%2595%258C%25EA%25B3%25A0%25EB%25A6%25AC%25EC%25A6%2598-%25EB%25AC%25B8%25EC%25A0%259C-%25ED%2595%25B4%25EA%25B2%25B0-%25EC%25A0%2584%25EB%259E%25B5%2f%25EC%2595%258C%25EA%25B3%25A0%25EB%25A6%25AC%25EC%25A6%2598-%25EB%25AC%25B8%25EC%25A0%259C-%25ED%2595%25B4%25EA%25B2%25B0-%25EC%25A0%2584%25EB%259E%25B5-ch18.-%25EA%25B8%25B0%25EC%25B4%2588-%25EC%259E%2590%25EB%25A3%258C-%25EA%25B5%25AC%25EC%25A1%25B0%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentcolor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share [알고리즘 문제 해결 전략] ch18. 기초 자료 구조 on ycombinator" href="https://news.ycombinator.com/submitlink?t=%5b%ec%95%8c%ea%b3%a0%eb%a6%ac%ec%a6%98%20%eb%ac%b8%ec%a0%9c%20%ed%95%b4%ea%b2%b0%20%ec%a0%84%eb%9e%b5%5d%20ch18.%20%ea%b8%b0%ec%b4%88%20%ec%9e%90%eb%a3%8c%20%ea%b5%ac%ec%a1%b0&u=https%3a%2f%2f2taezeat.github.io%2fposts%2f%25EC%2595%258C%25EA%25B3%25A0%25EB%25A6%25AC%25EC%25A6%2598-%25EB%25AC%25B8%25EC%25A0%259C-%25ED%2595%25B4%25EA%25B2%25B0-%25EC%25A0%2584%25EB%259E%25B5%2f%25EC%2595%258C%25EA%25B3%25A0%25EB%25A6%25AC%25EC%25A6%2598-%25EB%25AC%25B8%25EC%25A0%259C-%25ED%2595%25B4%25EA%25B2%25B0-%25EC%25A0%2584%25EB%259E%25B5-ch18.-%25EA%25B8%25B0%25EC%25B4%2588-%25EC%259E%2590%25EB%25A3%258C-%25EA%25B5%25AC%25EC%25A1%25B0%2f"><svg width="30" height="30" viewBox="0 0 512 512" fill="currentcolor" xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"><path d="M449.446.0C483.971.0 512 28.03 512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446zM183.8767 87.9921h-62.034L230.6673 292.4508V424.0079h50.6655V292.4508L390.1575 87.9921H328.1233L256 238.2489z"/></svg></a></li></ul></footer><script src=https://utteranc.es/client.js repo=2taezeat/blog_comment issue-term=pathname label=comment theme=github-light crossorigin=anonymous async></script></article></main><footer class=footer><span>&copy; 2024 <a href=https://2taezeat.github.io/>2taezeat, blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>