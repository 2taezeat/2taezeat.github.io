<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Kotlin 정리 (3) | 2taezeat, blog</title>
<meta name=keywords content="Kotlin"><meta name=description content="Kotlin 정리 (3)"><meta name=author content="2taezeat"><link rel=canonical href=https://2taezeat.github.io/posts/dev/kotlin-%EC%A0%95%EB%A6%AC-3/><meta name=google-site-verification content="YaEERzgrvu-ZwPg7gswZdTzRMufkHw3uIH7i8hVal1c"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.cc8105bf49785484525cafc7883272c26982bf06e1663dcfa3b55c3bb3f773b6.css integrity="sha256-zIEFv0l4VIRSXK/HiDJywmmCvwbhZj3Po7VcO7P3c7Y=" rel="preload stylesheet" as=style><link rel=icon href=https://2taezeat.github.io/icon/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://2taezeat.github.io/icon/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://2taezeat.github.io/icon/favicon-32x32.png><link rel=apple-touch-icon href=https://2taezeat.github.io/icon/apple-touch-icon.png><link rel=mask-icon href=https://2taezeat.github.io/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://2taezeat.github.io/posts/dev/kotlin-%EC%A0%95%EB%A6%AC-3/><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><meta property="og:title" content="Kotlin 정리 (3)"><meta property="og:description" content="Kotlin 정리 (3)"><meta property="og:type" content="article"><meta property="og:url" content="https://2taezeat.github.io/posts/dev/kotlin-%EC%A0%95%EB%A6%AC-3/"><meta property="og:image" content="https://2taezeat.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-12-06T11:30:03+00:00"><meta property="article:modified_time" content="2023-12-06T11:30:03+00:00"><meta property="og:site_name" content="2taezeat, blog"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://2taezeat.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="Kotlin 정리 (3)"><meta name=twitter:description content="Kotlin 정리 (3)"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://2taezeat.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Kotlin 정리 (3)","item":"https://2taezeat.github.io/posts/dev/kotlin-%EC%A0%95%EB%A6%AC-3/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Kotlin 정리 (3)","name":"Kotlin 정리 (3)","description":"Kotlin 정리 (3)","keywords":["Kotlin"],"articleBody":"코틀린 Reflection 설명 Reflection은 프로그램 실행 중에 코드의 구조 (클래스, 함수, 프로퍼티 등)를 분석하고 조작할 수 있는 기능입니다.\n코틀린에서는 kotlin-reflect 라이브러리를 통해 Reflection을 사용할 수 있습니다.\nReflection의 주요 기능:\n클래스 정보 조회: 클래스 이름, 상위 클래스, 인터페이스, 생성자, 메서드, 프로퍼티 등 클래스의 구조 정보를 가져올 수 있습니다. 함수 호출: 함수 객체를 가져와 동적으로 함수를 호출하고 결과를 얻을 수 있습니다. 프로퍼티 접근: 프로퍼티 객체를 가져와 값을 읽거나 변경할 수 있습니다. 생성자 호출: 생성자 객체를 가져와 동적으로 객체를 생성할 수 있습니다. 코틀린 Reflection 사용 방법:\n의존성 추가: build.gradle 파일에 kotlin-reflect 라이브러리 의존성을 추가합니다. 클래스 참조 가져오기: ::class 연산자를 사용하여 KClass 객체를 가져옵니다. 1 val personClass = Person::class 클래스 정보 조회: KClass 객체의 메서드를 사용하여 클래스 정보를 조회합니다. 1 2 val constructors = personClass.constructors val properties = personClass.memberProperties 함수 호출: KFunction 객체의 call() 또는 callBy() 메서드를 사용하여 함수를 호출합니다. 1 2 val getNameFunction = personClass.members.find { it.name == \"getName\" } as KFunction\u003c*\u003e val name = getNameFunction.call(personInstance) 프로퍼티 접근: KProperty 객체의 getter 또는 setter를 사용하여 프로퍼티 값을 읽거나 변경합니다. 1 2 val nameProperty = personClass.memberProperties.find { it.name == \"name\" } as KMutableProperty1\u003cPerson, String\u003e nameProperty.set(personInstance, \"Alice\") Reflection 사용 시 주의 사항:\n성능 저하: Reflection은 일반적인 메서드 호출이나 프로퍼티 접근보다 성능이 떨어질 수 있습니다.\n유지보수 어려움: Reflection을 사용하면 컴파일 시점에 타입 검사가 이루어지지 않으므로, 런타임 오류 발생 가능성이 높아지고 코드의 유지보수가 어려워질 수 있습니다.\n보안 문제: Reflection을 통해 private 멤버에 접근할 수 있으므로, 보안에 유의해야 합니다.\nReflection 사용 예시:\nJSON 파싱 라이브러리: Gson, Moshi 등의 JSON 파싱 라이브러리는 Reflection을 사용하여 JSON 데이터를 객체로 변환합니다. 의존성 주입 프레임워크: Dagger, Hilt 등의 의존성 주입 프레임워크는 Reflection을 사용하여 의존성을 주입합니다. 테스트 프레임워크: Mockito 등의 테스트 프레임워크는 Reflection을 사용하여 Mock 객체를 생성하고 메서드 호출을 가로챕니다. Kotlin 1.9에서 Enum.entries 설명 Kotlin 1.9.0부터 Enum 클래스에 entries 프로퍼티가 추가되었습니다.\n이는 기존의 values() 함수의 대안으로, 더 안전하고 효율적인 방식으로 Enum 상수 목록을 가져올 수 있도록 합니다.\nEnum.entries의 장점:\n불변성 (Immutability): entries는 Enum 상수 목록의 복사본을 반환하지 않고, 원본 목록에 대한 참조를 반환합니다. 따라서 실수로 목록을 수정하여 예기치 않은 결과를 초래하는 것을 방지합니다.\n성능 향상: values() 함수는 매번 호출될 때마다 새로운 배열(Array) 을 생성하여 반환하는 반면,\nentries는 한 번만 생성된 목록을 반환하므로 메모리 사용량을 줄이고 성능을 향상시킵니다. List 인터페이스 지원: entries는 List 인터페이스를 구현하므로, filter, map, forEach 등 다양한 List 관련 함수를 활용할 수 있습니다.\nvalues()는 모든 호출 마다 Mutable Array 복사본을 생성해서 반환하기 때문에, API 본질적 설계 버그입니다.\n이는 values()이 반환한 Array 값을 악의적인 의도로 변경하거나 배열을 조작하려는 개발자의 실수로 이어질 수 있습니다.\n코틀린 코드 컴파일 및 빌드 코틀린 컴파일러는 자바 컴파일러가 자바 소스코드를 컴파일할 때와 마찬가지로 코틀린 소스코드(.kt)를 분석해서 .class 파일을 만들어낸다. 만들어진 .class 파일은 개발 중인 애플리케이션의 유형에 맞는 표준 패키징 과정을 거쳐 실행될 수 있다. Java 코드와 Kotlin 코드의 빌드 과정은 다음과 같은 순서로 이루어진다. 코틀린 컴파일러가 코틀린 코드를 컴파일해 .class 파일을 생성한다. 이 과정에서 코틀린 코드가 참조하는 Java 코드가 함께 로딩되어 사용된다. Java 컴파일러가 Java 코드를 컴파일해 .class 파일을 생성한다. 이때 이미 코틀린이 컴파일한 .class 파일의 경로를 클래스 패스에 추가해 컴파일한다. 코틀린 컴파일러로 컴파일한 코드는 코틀린 런타임 라이브러리(kotlin runtime library)에 의존한다. 코틀린 런타임 라이브러리 : 코틀린 자체 표준 라이브러리 클래스 + 코틀린에서 자바 API의 기능을 확장한 내용 코틀린으로 컴파일한 애플리케이션을 배포할때는 코틀린 런타임 라이브러리도 함께 배포해야 한다. 프로젝트를 컴파일하기 위해 메이븐(Maven)과 그레이(Gradle), 앤트(Ant) 등의 빌드 시스템을 사용 빌드 시스템은 모두 코틀린과 자바가 코드베이스에 함께 들어있는 혼합 언어 프로젝트를 지원할 수 있다 메이븐(Maven)과 그레이(Gradle)들은 애플리케이션을 패키지할 때 알아서 코틀린 런타임 라이브러리을 포함시켜준다. Map Kotlin의 Map 인터페이스는 구현 방법에 따라 다르며, 그 자체는 특정 자료구조(예: 해시 테이블)에 의존하지 않습니다.\n**Map**은 단지 키-값 쌍을 관리하는 기능을 정의한 인터페이스일 뿐, 이를 어떻게 구현할지는 구체적인 구현체에 따라 달라집니다.\n1. Map은 인터페이스 **Map**은 키-값 쌍을 관리하는 추상적인 개념을 정의한 인터페이스입니다. Map 인터페이스를 구현하는 여러 클래스들이 존재하며, 이 클래스들이 각기 다른 방식으로 내부 동작을 처리합니다. 예를 들어, Map 인터페이스를 구현한 클래스 중에는 해시 테이블 기반의 HashMap, 순서를 유지하는 LinkedHashMap, 정렬된 맵을 제공하는 TreeMap 등이 있습니다. 2. HashMap은 해시 테이블 기반 **HashMap**은 Map 인터페이스의 구현체 중 하나로, 해시 테이블을 사용하여 데이터를 저장하고 관리합니다. 이는 빠른 조회와 삽입을 위해 해시 함수를 사용하며, 평균적으로 O(1)의 성능을 제공합니다. 따라서, HashMap은 해시 테이블 기반의 맵이 맞습니다. 3. 다른 Map 구현체들 Map 인터페이스는 여러 가지 구현체가 있으며, 각 구현체는 다른 방식으로 데이터를 저장하고 관리합니다.\nmapOf(): 내부적으로java.util.Collections.singletonMap() 을 사용, 불변인 map 객체를 반환 mutableMapOf() :내부적으로 LinkedHashMap 을 사용 1 2 3 4 5 // MapsJVM.kt public actual fun \u003cK, V\u003e mapOf(pair: Pair\u003cK, V\u003e): Map\u003cK, V\u003e = java.util.Collections.singletonMap(pair.first, pair.second) public fun \u003cK, V\u003e mutableMapOf(vararg pairs: Pair\u003cK, V\u003e): MutableMap\u003cK, V\u003e = LinkedHashMap\u003cK, V\u003e(mapCapacity(pairs.size)).apply { putAll(pairs) } 주요 Map 구현체: HashMap:\n해시 테이블 기반으로, 키의 순서를 유지하지 않으며 빠른 접근 성능(O(1))을 제공합니다. LinkedHashMap:\n해시 테이블을 기반으로 하지만, 삽입된 순서를 유지합니다. 따라서 데이터를 삽입한 순서대로 접근할 수 있습니다. TreeMap (자바):\n1 2 3 4 val treeMap: TreeMap\u003cString, Int\u003e = TreeMap\u003cString, Int\u003e().apply { put(\"b\", 2) put(\"a\", 1) } 코틀린에서 pass By 방법 Kotlin은 **기본적으로 “값에 의한 전달” (pass by value)**를 사용합니다.\n그러나 참조 타입을 사용할 때는, 참조의 값을 전달하는 방식으로 작동하기 때문에, **참조에 의한 전달(pass by reference)**와 비슷하게 동작할 수 있습니다.\n자세한 설명: 기본 타입 (Primitive Types): Int, Float, Double, Boolean과 같은 기본 데이터 타입은 **값에 의한 전달 (pass by value)**로 동작합니다. 즉, 함수에 값을 전달하면 복사본이 전달되며, 함수 내에서 값을 변경하더라도 원본에는 영향을 미치지 않습니다.\n예시:\n1 2 3 4 5 6 7 8 9 10 fun modifyValue(x: Int) { // x는 복사된 값이므로, 이 함수 내에서 변경되어도 원래 값에는 영향을 주지 않음 x = x + 1 } fun main() { var a = 10 modifyValue(a) println(a) // 출력: 10 (변경되지 않음) } 참조 타입 (Reference Types): Kotlin의 클래스 객체나 배열, 리스트 등 참조 타입의 경우, 값에 의한 전달이지만 참조의 값을 전달합니다. 즉, 객체 자체는 전달된 참조를 통해 접근할 수 있기 때문에, 객체의 속성을 변경할 수 있습니다. 하지만, 참조 자체를 변경하면, 그 변경은 함수 외부에 영향을 미치지 않습니다.\n예시:\n1 2 3 4 5 6 7 8 9 10 11 12 data class Person(var name: String) fun modifyPerson(person: Person) { // person은 참조의 값이 전달되므로, 객체의 속성을 변경할 수 있음 person.name = \"Modified\" } fun main() { val person = Person(\"Original\") modifyPerson(person) println(person.name) // 출력: Modified (속성이 변경됨) } 이 경우, 객체의 속성은 함수 내에서 변경할 수 있지만, 참조 자체를 다른 객체로 바꾸는 것은 함수 외부에 영향을 주지 않습니다. 요약: 기본 타입 (Primitive types): 값에 의한 전달 (pass by value)로 동작. 참조 타입 (Reference types): 참조의 값을 전달하지만, 객체의 속성을 변경할 수 있기 때문에 참조에 의한 전달처럼 동작할 수 있음. 실제로 Kotlin은 값에 의한 전달만 존재합니다. 다만 참조 타입을 함수에 전달할 때, 그 참조된 객체의 속성은 함수 내에서 변경될 수 있습니다.\n참고 result.add(combination.toList()) 에서 toList() 로 깊은 복사를 하지 않으면,\nresult 가 [[], [], []] 가 되어 버린다.\n이유는 combination를 result에 추가할 때 참조의 값를 그대로 넘겨주기 때문입니다.\nKotlin의 MutableList는 참조 타입이므로, combination가 변경되면 result에 있는 리스트도 함께 변경됩니다.\n따라서 나중에 값을 변경할 때 result에 추가된 값도 동일하게 변경되는 문제가 발생합니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 fun combineWithBackTracking(n: Int, k: Int): List\u003cList\u003cInt\u003e\u003e { // 참고용 val result = mutableListOf\u003cList\u003cInt\u003e\u003e() val combination = mutableListOf\u003cInt\u003e() fun backtrack(start: Int) { if (combination.size == k) { result.add(combination.toList()) return } for (i in start..n) { combination.add(i) backtrack(i + 1) combination.removeAt(combination.size - 1) } } Array 에서는? IntArray는 Kotlin에서 **기본 타입 배열(primitive array)**로, Int 타입의 값들을 저장하는 배열입니다.\n이 경우도 마찬가지로, Kotlin은 **값에 의한 전달(pass by value)**를 사용합니다. 하지만, IntArray 자체는 참조 타입으로 동작하므로, 참조의 값이 전달됩니다.\n따라서, 배열 내부의 요소는 함수에서 수정할 수 있지만, 배열 자체를 새로운 배열로 변경하는 것은 함수 외부에 영향을 미치지 않습니다.\n예시 1: 배열의 요소를 변경할 때 1 2 3 4 5 6 7 8 9 fun modifyArray(arr: IntArray) { arr[0] = 100 // 배열의 첫 번째 요소를 100으로 변경 } fun main() { val nums = intArrayOf(1, 2, 3) modifyArray(nums) println(nums.joinToString()) // 출력: 100, 2, 3 } 배열의 참조가 전달되므로, 배열의 내부 값을 수정할 수 있습니다. 위의 경우, 함수 내에서 배열의 첫 번째 요소가 변경되었고, 원래 배열(nums)도 이 변경 사항을 반영합니다. 예시 2: 배열 자체를 새로 할당할 때 1 2 3 4 5 6 7 8 9 fun reassignArray(arr: IntArray) { arr = intArrayOf(4, 5, 6) // 배열 자체를 새로 할당 (실제로는 함수 내에서만 영향) } fun main() { val nums = intArrayOf(1, 2, 3) reassignArray(nums) println(nums.joinToString()) // 출력: 1, 2, 3 (변경되지 않음) } 배열 자체를 새로운 배열로 할당하려고 하면, 함수 내에서만 새로운 배열이 할당되고, 원본 배열은 변경되지 않습니다. 이는 배열의 참조 값이 복사되어 전달되기 때문에, 원본 배열의 참조 자체는 변경되지 않는 것입니다. 요약: 배열의 요소는 함수 내에서 변경할 수 있으며, 이 변경 사항은 함수 외부에도 영향을 미칩니다. 이는 배열의 참조가 전달되기 때문입니다. 하지만 배열 자체를 새로운 배열로 할당하는 것은 함수 내에서만 영향을 미치며, 함수 외부의 배열에는 영향을 주지 않습니다. 따라서, IntArray의 경우에도 참조의 값이 전달되므로, 배열의 내부 값을 수정할 수는 있지만, 참조 자체는 변경되지 않습니다.\nIntArray vs Array Kotlin에서 IntArray와 Array는 모두 정수형 배열을 나타내지만,\n둘 사이에는 중요한 차이점이 있습니다. 이 차이는 메모리 효율성과 타입에 대한 처리 방식에서 비롯됩니다.\n1. IntArray Primitive 타입 배열로, 메모리 효율이 뛰어납니다. 배열의 요소가 int 타입의 원시값으로 저장되므로, **박싱(boxing)**이 발생하지 않습니다. Kotlin에서 제공하는 원시 배열 중 하나로, 자바의 primitive 배열(int[])과 대응됩니다. 주로 성능이 중요한 상황에서 사용됩니다. 1 val intArray = IntArray(5) { it * 2 } // 0, 2, 4, 6, 8 이 경우, 메모리에는 각 요소가 원시 정수로 저장됩니다.\nIntArray는 자바의 int[]와 대응\n2. Array 참조 타입 배열입니다. 배열의 각 요소가 객체(Integer)로 저장되며, **박싱(boxing)**이 발생합니다. 즉, 배열 요소들이 기본적으로 객체로 처리되므로, 추가적인 메모리 사용이 있습니다. Array는 제네릭 배열이므로 **Kotlin의 Array**와 대응됩니다. 1 val arrayInt = Array(5) { it * 2 } // 0, 2, 4, 6, 8 각 요소는 **객체(Integer)**로 저장되므로, 박싱이 발생합니다.\nArray는 Integer[]와 대응\n3. 차이점 요약 속성 IntArray Array 타입 Primitive 타입 (int) 참조 타입 (Integer) 메모리 효율성 더 효율적 (박싱 없음) 덜 효율적 (박싱 발생) 자바 대응 int[] Integer[] 주 사용 상황 성능이 중요한 경우 제네릭 배열이 필요한 경우 함수 지원 IntArray에 맞는 특수 함수 제공 Array에 맞는 일반 함수 제공 4. 어떤 경우에 사용하나요? IntArray: 성능과 메모리 사용이 중요한 경우, 예를 들어 대규모 데이터를 처리하거나, 원시 배열과의 호환성이 중요한 경우. Array: 일반적인 제네릭 배열이 필요한 경우 또는 참조 타입을 사용해야 하는 경우. 5. 변환 방법 두 배열 간의 변환이 필요한 경우 다음과 같이 처리할 수 있습니다:\nIntArray -\u003e Array 변환:\n1 2 val intArray = IntArray(5) { it } val arrayInt: Array\u003cInt\u003e = intArray.toTypedArray() Array -\u003e IntArray 변환:\n1 2 val arrayInt = arrayOf(1, 2, 3, 4, 5) val intArray: IntArray = arrayInt.toIntArray() Map의 반복 처리 Kotlin에서 **Map**이 Iterable 인터페이스를 직접 구현하지 않으면서도 반복 처리가 가능한 이유는 Map 자체가 entries, keys, 그리고 **values**라는 **컬렉션 뷰(Collection Views)**를 제공하기 때문입니다.\n이 각각의 뷰는 Set 또는 **Collection**으로 표현되며, 이들이 **Iterable**을 구현하고 있어 for 루프나 forEach와 같은 반복 처리가 가능해집니다.\n구체적인 설명: 1. Map 자체는 Iterable을 구현하지 않음 Map 인터페이스 자체는 **Iterable**을 직접 구현하지 않습니다. 즉, Map 자체는 키와 값의 쌍을 저장하는 고유한 자료구조로, 단순히 한 방향으로 순차적으로 탐색되는 데이터 구조가 아닙니다.\nMap의 key, value, entry들은 내부적으로 별도의 **컬렉션(Set, Collection 등)**을 통해 구현됩니다.\n2. entries, keys, values 컬렉션 Map에서 제공하는 세 가지 주요 컬렉션 뷰는 모두 반복 처리를 위한 Iterable을 구현하고 있습니다. 이 컬렉션들이 바로 Map을 반복 처리할 수 있게 도와줍니다.\nentries: Map의 모든 키-값 쌍을 나타내며, 이는 **Set","wordCount":"2990","inLanguage":"en","image":"https://2taezeat.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E","datePublished":"2023-12-06T11:30:03Z","dateModified":"2023-12-06T11:30:03Z","author":{"@type":"Person","name":"2taezeat"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://2taezeat.github.io/posts/dev/kotlin-%EC%A0%95%EB%A6%AC-3/"},"publisher":{"@type":"Organization","name":"2taezeat, blog","logo":{"@type":"ImageObject","url":"https://2taezeat.github.io/icon/favicon.ico"}}}</script></head><body id=top><header class=header><nav class=nav><div class=logo><a href=https://2taezeat.github.io/ accesskey=h title="2taezeat blog (Alt + H)"><img src=https://2taezeat.github.io/icon/apple-touch-icon.png alt aria-label=logo height=30>2taezeat blog</a><div class=logo-switches></div></div><ul id=menu><li><a href=https://2taezeat.github.io/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://2taezeat.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://2taezeat.github.io/searchs/ title=Search><span>Search</span></a></li><li><a href=https://github.com/2taezeat title=Github><span>Github</span>&nbsp;<svg fill="none" shape-rendering="geometricPrecision" stroke="currentcolor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2.5" viewBox="0 0 24 24" height="12" width="12"><path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"/><path d="M15 3h6v6"/><path d="M10 14 21 3"/></svg></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://2taezeat.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://2taezeat.github.io/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">Kotlin 정리 (3)</h1><div class=post-description>Kotlin 정리 (3)</div><div class=post-meta><span title='2023-12-06 11:30:03 +0000 +0000'>2023-12-06</span>&nbsp;·&nbsp;15 min&nbsp;·&nbsp;2990 words&nbsp;·&nbsp;2taezeat</div></header><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#코틀린-reflection-설명>코틀린 Reflection 설명</a></li><li><a href=#kotlin-19에서-enumentries-설명>Kotlin 1.9에서 Enum.entries 설명</a></li><li><a href=#코틀린-코드-컴파일-및-빌드>코틀린 코드 컴파일 및 빌드</a></li><li><a href=#map>Map</a><ul><li><a href=#1-map은-인터페이스>1. <strong><code>Map</code>은 인터페이스</strong></a></li><li><a href=#2-hashmap은-해시-테이블-기반>2. <strong><code>HashMap</code>은 해시 테이블 기반</strong></a></li><li><a href=#3-다른-map-구현체들>3. <strong>다른 <code>Map</code> 구현체들</strong></a><ul><li><a href=#주요-map-구현체>주요 <code>Map</code> 구현체:</a></li></ul></li></ul></li><li><a href=#코틀린에서-pass-by-방법>코틀린에서 pass By 방법</a><ul><li><a href=#자세한-설명>자세한 설명:</a></li><li><a href=#요약>요약:</a><ul><li><a href=#참고>참고</a></li></ul></li><li><a href=#array-에서는>Array 에서는?</a><ul><li><a href=#예시-1-배열의-요소를-변경할-때>예시 1: 배열의 요소를 변경할 때</a></li><li><a href=#예시-2-배열-자체를-새로-할당할-때>예시 2: 배열 자체를 새로 할당할 때</a></li><li><a href=#요약-1>요약:</a></li></ul></li></ul></li><li><a href=#intarray-vs-arrayint><code>IntArray</code> vs <code>Array&lt;Int></code></a><ul><li><ul><li><a href=#1-intarray>1. <strong><code>IntArray</code></strong></a></li><li><a href=#2-arrayint>2. <strong><code>Array&lt;Int></code></strong></a></li><li><a href=#3-차이점-요약>3. <strong>차이점 요약</strong></a></li><li><a href=#4-어떤-경우에-사용하나요>4. <strong>어떤 경우에 사용하나요?</strong></a></li><li><a href=#5-변환-방법>5. <strong>변환 방법</strong></a></li></ul></li></ul></li><li><a href=#map의-반복-처리>Map의 반복 처리</a><ul><li><ul><li><a href=#구체적인-설명>구체적인 설명:</a><ul><li><a href=#1-map-자체는-iterable을-구현하지-않음>1. <strong><code>Map</code> 자체는 <code>Iterable</code>을 구현하지 않음</strong></a></li><li><a href=#2-entries-keys-values-컬렉션>2. <strong><code>entries</code>, <code>keys</code>, <code>values</code> 컬렉션</strong></a></li></ul></li></ul></li></ul></li><li><a href=#함수-타입과-함수형-인터페이스>함수 타입과 함수형 인터페이스</a><ul><li><ul><li><a href=#1-kotlin의-함수-타입>1. <strong>Kotlin의 함수 타입</strong></a><ul><li><a href=#함수-타입을-인자로-사용하는-예시>함수 타입을 인자로 사용하는 예시:</a></li></ul></li><li><a href=#2-함수형-인터페이스와의-차이점>2. <strong>함수형 인터페이스와의 차이점</strong></a><ul><li><a href=#자바-스타일의-함수형-인터페이스-사용>자바 스타일의 함수형 인터페이스 사용:</a></li></ul></li><li><a href=#3-요약>3. 요약</a></li></ul></li></ul></li><li><a href=#reified-상세>reified 상세</a><ul><li><ul><li><a href=#reified가-필요할-때><code>reified</code>가 필요할 때:</a></li><li><a href=#예시-reified-사용>예시: <code>reified</code> 사용</a></li><li><a href=#설명>설명:</a><ul><li><a href=#reified-없는-경우-컴파일-오류-발생><code>reified</code> 없는 경우: 컴파일 오류 발생</a></li></ul></li><li><a href=#reified를-사용한-응용><code>reified</code>를 사용한 응용:</a></li><li><a href=#결론>결론:</a></li></ul></li></ul></li><li><a href=#runcatching>runCatching</a><ul><li><ul><li><a href=#사용법>사용법</a></li><li><a href=#반환되는-result-객체>반환되는 <code>Result</code> 객체</a></li><li><a href=#주요-함수>주요 함수</a></li><li><a href=#예시>예시</a><ul><li><a href=#성공-예시>성공 예시</a></li><li><a href=#실패-예시>실패 예시</a></li><li><a href=#getorelse로-기본-값-처리><code>getOrElse</code>로 기본 값 처리</a></li></ul></li><li><a href=#onsuccess와-onfailure><code>onSuccess</code>와 <code>onFailure</code></a><ul><li><a href=#장점><strong>장점</strong></a></li><li><a href=#단점><strong>단점</strong></a></li></ul></li></ul></li></ul></li></ul></nav></div></details></div><div class=post-content><h1 id=코틀린-reflection-설명>코틀린 Reflection 설명<a hidden class=anchor aria-hidden=true href=#코틀린-reflection-설명>#</a></h1><p>Reflection은 <strong>프로그램 실행 중에 코드의 구조 (클래스, 함수, 프로퍼티 등)를 분석하고 조작할 수 있는 기능</strong>입니다.</p><p>코틀린에서는 <code>kotlin-reflect</code> 라이브러리를 통해 Reflection을 사용할 수 있습니다.</p><p><strong>Reflection의 주요 기능:</strong></p><ul><li><strong>클래스 정보 조회:</strong> 클래스 이름, 상위 클래스, 인터페이스, 생성자, 메서드, 프로퍼티 등 클래스의 구조 정보를 가져올 수 있습니다.</li><li><strong>함수 호출:</strong> 함수 객체를 가져와 동적으로 함수를 호출하고 결과를 얻을 수 있습니다.</li><li><strong>프로퍼티 접근:</strong> 프로퍼티 객체를 가져와 값을 읽거나 변경할 수 있습니다.</li><li><strong>생성자 호출:</strong> 생성자 객체를 가져와 동적으로 객체를 생성할 수 있습니다.</li></ul><p><strong>코틀린 Reflection 사용 방법:</strong></p><ol><li><strong>의존성 추가:</strong> <code>build.gradle</code> 파일에 <code>kotlin-reflect</code> 라이브러리 의존성을 추가합니다.</li><li><strong>클래스 참조 가져오기:</strong> <code>::class</code> 연산자를 사용하여 <code>KClass</code> 객체를 가져옵니다.</li></ol><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-kotlin data-lang=kotlin><span class=line><span class=cl><span class=k>val</span> <span class=py>personClass</span> <span class=p>=</span> <span class=n>Person</span><span class=o>::</span><span class=k>class</span>
</span></span></code></pre></td></tr></table></div></div><ol start=3><li><strong>클래스 정보 조회:</strong> <code>KClass</code> 객체의 메서드를 사용하여 클래스 정보를 조회합니다.</li></ol><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-kotlin data-lang=kotlin><span class=line><span class=cl><span class=k>val</span> <span class=py>constructors</span> <span class=p>=</span> <span class=n>personClass</span><span class=p>.</span><span class=n>constructors</span>
</span></span><span class=line><span class=cl><span class=k>val</span> <span class=py>properties</span> <span class=p>=</span> <span class=n>personClass</span><span class=p>.</span><span class=n>memberProperties</span>
</span></span></code></pre></td></tr></table></div></div><ol start=4><li><strong>함수 호출:</strong> <code>KFunction</code> 객체의 <code>call()</code> 또는 <code>callBy()</code> 메서드를 사용하여 함수를 호출합니다.</li></ol><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-kotlin data-lang=kotlin><span class=line><span class=cl><span class=k>val</span> <span class=py>getNameFunction</span> <span class=p>=</span> <span class=n>personClass</span><span class=p>.</span><span class=n>members</span><span class=p>.</span><span class=n>find</span> <span class=p>{</span> <span class=k>it</span><span class=p>.</span><span class=n>name</span> <span class=o>==</span> <span class=s2>&#34;getName&#34;</span> <span class=p>}</span> <span class=k>as</span> <span class=n>KFunction</span><span class=p>&lt;*&gt;</span>
</span></span><span class=line><span class=cl><span class=k>val</span> <span class=py>name</span> <span class=p>=</span> <span class=n>getNameFunction</span><span class=p>.</span><span class=n>call</span><span class=p>(</span><span class=n>personInstance</span><span class=p>)</span>
</span></span></code></pre></td></tr></table></div></div><ol start=5><li><strong>프로퍼티 접근:</strong> <code>KProperty</code> 객체의 <code>getter</code> 또는 <code>setter</code>를 사용하여 프로퍼티 값을 읽거나 변경합니다.</li></ol><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-kotlin data-lang=kotlin><span class=line><span class=cl><span class=k>val</span> <span class=py>nameProperty</span> <span class=p>=</span> <span class=n>personClass</span><span class=p>.</span><span class=n>memberProperties</span><span class=p>.</span><span class=n>find</span> <span class=p>{</span> <span class=k>it</span><span class=p>.</span><span class=n>name</span> <span class=o>==</span> <span class=s2>&#34;name&#34;</span> <span class=p>}</span> <span class=k>as</span> <span class=n>KMutableProperty1</span><span class=p>&lt;</span><span class=n>Person</span><span class=p>,</span> <span class=n>String</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl><span class=n>nameProperty</span><span class=p>.</span><span class=k>set</span><span class=p>(</span><span class=n>personInstance</span><span class=p>,</span> <span class=s2>&#34;Alice&#34;</span><span class=p>)</span>
</span></span></code></pre></td></tr></table></div></div><p><strong>Reflection 사용 시 주의 사항:</strong></p><ul><li><p><strong>성능 저하:</strong> Reflection은 일반적인 메서드 호출이나 프로퍼티 접근보다 성능이 떨어질 수 있습니다.</p></li><li><p><strong>유지보수 어려움:</strong> Reflection을 사용하면 컴파일 시점에 타입 검사가 이루어지지 않으므로, 런타임 오류 발생 가능성이 높아지고 코드의 유지보수가 어려워질 수 있습니다.</p></li><li><p><strong>보안 문제:</strong> Reflection을 통해 private 멤버에 접근할 수 있으므로, 보안에 유의해야 합니다.</p></li></ul><p><strong>Reflection 사용 예시:</strong></p><ul><li><strong>JSON 파싱 라이브러리:</strong> Gson, Moshi 등의 JSON 파싱 라이브러리는 Reflection을 사용하여 JSON 데이터를 객체로 변환합니다.</li><li><strong>의존성 주입 프레임워크:</strong> Dagger, Hilt 등의 의존성 주입 프레임워크는 Reflection을 사용하여 의존성을 주입합니다.</li><li><strong>테스트 프레임워크:</strong> Mockito 등의 테스트 프레임워크는 Reflection을 사용하여 Mock 객체를 생성하고 메서드 호출을 가로챕니다.</li></ul><h1 id=kotlin-19에서-enumentries-설명>Kotlin 1.9에서 Enum.entries 설명<a hidden class=anchor aria-hidden=true href=#kotlin-19에서-enumentries-설명>#</a></h1><p>Kotlin 1.9.0부터 Enum 클래스에 <code>entries</code> 프로퍼티가 추가되었습니다.</p><p>이는 기존의 <code>values()</code> 함수의 대안으로, <strong>더 안전하고 효율적인 방식</strong>으로 <strong>Enum 상수 목록</strong>을 가져올 수 있도록 합니다.</p><p><img loading=lazy src=/images/before/image-20240520082948662.png alt=image-20240520082948662.png width=680 height=auto></p><p><strong>Enum.entries의 장점:</strong></p><ol><li><p><strong>불변성 (Immutability):</strong> <code>entries</code>는 Enum 상수 목록의 복사본을 반환하지 않고, <strong>원본 목록에 대한 참조를 반환</strong>합니다. 따라서 실수로 목록을 수정하여 예기치 않은 결과를 초래하는 것을 방지합니다.</p></li><li><p><strong>성능 향상:</strong> <code>values()</code> 함수는 매번 호출될 때마다 <strong>새로운 배열(Array)</strong> 을 생성하여 반환하는 반면,</p><ol><li><code>entries</code>는 한 번만 생성된 목록을 반환하므로 메모리 사용량을 줄이고 성능을 향상시킵니다.</li></ol></li><li><p><strong>List 인터페이스 지원:</strong> <code>entries</code>는 <code>List</code> 인터페이스를 구현하므로, <code>filter</code>, <code>map</code>, <code>forEach</code> 등 다양한 List 관련 함수를 활용할 수 있습니다.</p></li></ol><ul><li><p>values()는 모든 호출 마다 <strong>Mutable Array 복사본을 생성해서 반환</strong>하기 때문에, API 본질적 설계 버그입니다.</p></li><li><p>이는 values()이 반환한 Array 값을 악의적인 의도로 변경하거나 <strong>배열을 조작하려는 개발자의 실수</strong>로 이어질 수 있습니다.</p></li></ul><h1 id=코틀린-코드-컴파일-및-빌드>코틀린 코드 컴파일 및 빌드<a hidden class=anchor aria-hidden=true href=#코틀린-코드-컴파일-및-빌드>#</a></h1><p><img loading=lazy src=https://velog.velcdn.com/images%2Fba159sal%2Fpost%2F2d3a17cd-8816-461a-856f-e96d8cdb8e5c%2Fimage.png alt=https://velog.velcdn.com/images%2Fba159sal%2Fpost%2F2d3a17cd-8816-461a-856f-e96d8cdb8e5c%2Fimage.png width=680 height=auto></p><ul><li><code>코틀린 컴파일러</code>는 자바 컴파일러가 자바 소스코드를 컴파일할 때와 마찬가지로 <code>코틀린 소스코드(.kt)</code>를 분석해서 <code>.class</code> 파일을 만들어낸다.</li><li>만들어진 <code>.class</code> 파일은 개발 중인 애플리케이션의 유형에 맞는 표준 <code>패키징</code> 과정을 거쳐 실행될 수 있다.</li><li></li></ul><p><img loading=lazy src=https://velog.velcdn.com/images%2Fba159sal%2Fpost%2F865aeabf-b25c-4ff6-b903-f8fb3eba8674%2Fimage.png alt=https://velog.velcdn.com/images%2Fba159sal%2Fpost%2F865aeabf-b25c-4ff6-b903-f8fb3eba8674%2Fimage.png width=680 height=auto></p><ul><li>Java 코드와 Kotlin 코드의 빌드 과정은 다음과 같은 순서로 이루어진다.</li></ul><ol><li>코틀린 컴파일러가 코틀린 코드를 컴파일해 <code>.class</code> 파일을 생성한다. 이 과정에서 코틀린 코드가 참조하는 Java 코드가 함께 로딩되어 사용된다.</li><li>Java 컴파일러가 Java 코드를 컴파일해 <code>.class</code> 파일을 생성한다. 이때 이미 코틀린이 컴파일한 <code>.class</code> 파일의 경로를 클래스 패스에 추가해 컴파일한다.<ul><li>코틀린 컴파일러로 컴파일한 코드는 <code>코틀린 런타임 라이브러리(kotlin runtime library)</code>에 의존한다.</li><li><code>코틀린 런타임 라이브러리</code> : <code>코틀린 자체 표준 라이브러리 클래스</code> + <code>코틀린에서 자바 API의 기능을 확장한 내용</code></li><li>코틀린으로 컴파일한 애플리케이션을 배포할때는 <code>코틀린 런타임 라이브러리</code>도 함께 배포해야 한다.</li><li>프로젝트를 컴파일하기 위해 <code>메이븐(Maven)</code>과 <code>그레이(Gradle)</code>, <code>앤트(Ant)</code> 등의 빌드 시스템을 사용</li><li>빌드 시스템은 모두 코틀린과 자바가 코드베이스에 함께 들어있는 혼합 언어 프로젝트를 지원할 수 있다</li><li><code>메이븐(Maven)</code>과 <code>그레이(Gradle)</code>들은 애플리케이션을 패키지할 때 알아서 <code>코틀린 런타임 라이브러리</code>을 포함시켜준다.</li></ul></li></ol><h1 id=map>Map<a hidden class=anchor aria-hidden=true href=#map>#</a></h1><p>Kotlin의 <strong><code>Map</code></strong> 인터페이스는 <strong>구현 방법</strong>에 따라 다르며, 그 자체는 특정 자료구조(예: 해시 테이블)에 의존하지 않습니다.</p><p>**<code>Map</code>**은 단지 <strong>키-값 쌍</strong>을 관리하는 기능을 정의한 <strong>인터페이스</strong>일 뿐, 이를 어떻게 구현할지는 <strong>구체적인 구현체</strong>에 따라 달라집니다.</p><h2 id=1-map은-인터페이스>1. <strong><code>Map</code>은 인터페이스</strong><a hidden class=anchor aria-hidden=true href=#1-map은-인터페이스>#</a></h2><ul><li>**<code>Map</code>**은 <strong>키-값 쌍을 관리하는 추상적인 개념</strong>을 정의한 인터페이스입니다. <code>Map</code> 인터페이스를 구현하는 여러 클래스들이 존재하며, 이 클래스들이 각기 다른 방식으로 내부 동작을 처리합니다.</li><li>예를 들어, <code>Map</code> 인터페이스를 구현한 클래스 중에는 <strong>해시 테이블 기반의 <code>HashMap</code></strong>, <strong>순서를 유지하는 <code>LinkedHashMap</code></strong>, <strong>정렬된 맵을 제공하는 <code>TreeMap</code></strong> 등이 있습니다.</li></ul><h2 id=2-hashmap은-해시-테이블-기반>2. <strong><code>HashMap</code>은 해시 테이블 기반</strong><a hidden class=anchor aria-hidden=true href=#2-hashmap은-해시-테이블-기반>#</a></h2><ul><li>**<code>HashMap</code>**은 <code>Map</code> 인터페이스의 구현체 중 하나로, <strong>해시 테이블</strong>을 사용하여 데이터를 저장하고 관리합니다. 이는 <strong>빠른 조회</strong>와 <strong>삽입</strong>을 위해 해시 함수를 사용하며, 평균적으로 O(1)의 성능을 제공합니다.</li><li>따라서, <code>HashMap</code>은 <strong>해시 테이블 기반</strong>의 맵이 맞습니다.</li></ul><h2 id=3-다른-map-구현체들>3. <strong>다른 <code>Map</code> 구현체들</strong><a hidden class=anchor aria-hidden=true href=#3-다른-map-구현체들>#</a></h2><p><code>Map</code> 인터페이스는 <strong>여러 가지 구현체</strong>가 있으며, 각 구현체는 다른 방식으로 데이터를 저장하고 관리합니다.</p><ul><li><code>mapOf()</code>: 내부적으로<code>java.util.Collections.singletonMap()</code> 을 사용, 불변인 map 객체를 반환</li><li><code>mutableMapOf()</code> :내부적으로 <code>LinkedHashMap</code> 을 사용</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-kotlin data-lang=kotlin><span class=line><span class=cl><span class=c1>// MapsJVM.kt 
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>public</span> <span class=k>actual</span> <span class=k>fun</span> <span class=p>&lt;</span><span class=nc>K</span><span class=p>,</span> <span class=nc>V</span><span class=p>&gt;</span> <span class=nf>mapOf</span><span class=p>(</span><span class=n>pair</span><span class=p>:</span> <span class=n>Pair</span><span class=p>&lt;</span><span class=n>K</span><span class=p>,</span> <span class=n>V</span><span class=p>&gt;):</span> <span class=n>Map</span><span class=p>&lt;</span><span class=n>K</span><span class=p>,</span> <span class=n>V</span><span class=p>&gt;</span> <span class=p>=</span> <span class=n>java</span><span class=p>.</span><span class=n>util</span><span class=p>.</span><span class=nc>Collections</span><span class=p>.</span><span class=n>singletonMap</span><span class=p>(</span><span class=n>pair</span><span class=p>.</span><span class=n>first</span><span class=p>,</span> <span class=n>pair</span><span class=p>.</span><span class=n>second</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>public</span> <span class=k>fun</span> <span class=p>&lt;</span><span class=nc>K</span><span class=p>,</span> <span class=nc>V</span><span class=p>&gt;</span> <span class=nf>mutableMapOf</span><span class=p>(</span><span class=k>vararg</span> <span class=n>pairs</span><span class=p>:</span> <span class=n>Pair</span><span class=p>&lt;</span><span class=n>K</span><span class=p>,</span> <span class=n>V</span><span class=p>&gt;):</span> <span class=n>MutableMap</span><span class=p>&lt;</span><span class=n>K</span><span class=p>,</span> <span class=n>V</span><span class=p>&gt;</span> <span class=p>=</span>
</span></span><span class=line><span class=cl>    <span class=n>LinkedHashMap</span><span class=p>&lt;</span><span class=n>K</span><span class=p>,</span> <span class=n>V</span><span class=p>&gt;(</span><span class=n>mapCapacity</span><span class=p>(</span><span class=n>pairs</span><span class=p>.</span><span class=n>size</span><span class=p>)).</span><span class=n>apply</span> <span class=p>{</span> <span class=n>putAll</span><span class=p>(</span><span class=n>pairs</span><span class=p>)</span> <span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><h3 id=주요-map-구현체>주요 <code>Map</code> 구현체:<a hidden class=anchor aria-hidden=true href=#주요-map-구현체>#</a></h3><ol><li><p><strong><code>HashMap</code></strong>:</p><ul><li><strong>해시 테이블 기반</strong>으로, 키의 순서를 유지하지 않으며 <strong>빠른 접근 성능</strong>(O(1))을 제공합니다.</li></ul></li><li><p><strong><code>LinkedHashMap</code></strong>:</p><ul><li><strong>해시 테이블</strong>을 기반으로 하지만, 삽입된 <strong>순서를 유지</strong>합니다. 따라서 데이터를 삽입한 순서대로 접근할 수 있습니다.</li></ul></li><li><p><strong><code>TreeMap</code></strong> (자바):</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-kotlin data-lang=kotlin><span class=line><span class=cl><span class=k>val</span> <span class=py>treeMap</span><span class=p>:</span> <span class=n>TreeMap</span><span class=p>&lt;</span><span class=n>String</span><span class=p>,</span> <span class=n>Int</span><span class=p>&gt;</span> <span class=p>=</span> <span class=n>TreeMap</span><span class=p>&lt;</span><span class=n>String</span><span class=p>,</span> <span class=n>Int</span><span class=p>&gt;().</span><span class=n>apply</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>put</span><span class=p>(</span><span class=s2>&#34;b&#34;</span><span class=p>,</span> <span class=m>2</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>put</span><span class=p>(</span><span class=s2>&#34;a&#34;</span><span class=p>,</span> <span class=m>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div></li></ol><h1 id=코틀린에서-pass-by-방법>코틀린에서 pass By 방법<a hidden class=anchor aria-hidden=true href=#코틀린에서-pass-by-방법>#</a></h1><p>Kotlin은 **기본적으로 &ldquo;값에 의한 전달&rdquo; (pass by value)**를 사용합니다.</p><p>그러나 <strong>참조 타입</strong>을 사용할 때는, <strong>참조의 값을 전달하는 방식</strong>으로 작동하기 때문에, **참조에 의한 전달(pass by reference)**와 비슷하게 동작할 수 있습니다.</p><h2 id=자세한-설명>자세한 설명:<a hidden class=anchor aria-hidden=true href=#자세한-설명>#</a></h2><ol><li><p><strong>기본 타입 (Primitive Types)</strong>: <code>Int</code>, <code>Float</code>, <code>Double</code>, <code>Boolean</code>과 같은 <strong>기본 데이터 타입</strong>은 **값에 의한 전달 (pass by value)**로 동작합니다. 즉, 함수에 값을 전달하면 <strong>복사본</strong>이 전달되며, 함수 내에서 값을 변경하더라도 원본에는 영향을 미치지 않습니다.</p><p>예시:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-kotlin data-lang=kotlin><span class=line><span class=cl><span class=k>fun</span> <span class=nf>modifyValue</span><span class=p>(</span><span class=n>x</span><span class=p>:</span> <span class=n>Int</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// x는 복사된 값이므로, 이 함수 내에서 변경되어도 원래 값에는 영향을 주지 않음
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>x</span> <span class=p>=</span> <span class=n>x</span> <span class=p>+</span> <span class=m>1</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>fun</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>var</span> <span class=py>a</span> <span class=p>=</span> <span class=m>10</span>
</span></span><span class=line><span class=cl>    <span class=n>modifyValue</span><span class=p>(</span><span class=n>a</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>println</span><span class=p>(</span><span class=n>a</span><span class=p>)</span>  <span class=c1>// 출력: 10 (변경되지 않음)
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div></li><li><p><strong>참조 타입 (Reference Types)</strong>: Kotlin의 클래스 객체나 배열, 리스트 등 <strong>참조 타입</strong>의 경우, <strong>값에 의한 전달</strong>이지만 <strong>참조의 값</strong>을 전달합니다. 즉, 객체 자체는 전달된 참조를 통해 접근할 수 있기 때문에, 객체의 속성을 변경할 수 있습니다. 하지만, 참조 자체를 변경하면, 그 변경은 함수 외부에 영향을 미치지 않습니다.</p><p>예시:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-kotlin data-lang=kotlin><span class=line><span class=cl><span class=k>data</span> <span class=k>class</span> <span class=nc>Person</span><span class=p>(</span><span class=k>var</span> <span class=py>name</span><span class=p>:</span> <span class=n>String</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>fun</span> <span class=nf>modifyPerson</span><span class=p>(</span><span class=n>person</span><span class=p>:</span> <span class=n>Person</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// person은 참조의 값이 전달되므로, 객체의 속성을 변경할 수 있음
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>person</span><span class=p>.</span><span class=n>name</span> <span class=p>=</span> <span class=s2>&#34;Modified&#34;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>fun</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>val</span> <span class=py>person</span> <span class=p>=</span> <span class=n>Person</span><span class=p>(</span><span class=s2>&#34;Original&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>modifyPerson</span><span class=p>(</span><span class=n>person</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>println</span><span class=p>(</span><span class=n>person</span><span class=p>.</span><span class=n>name</span><span class=p>)</span>  <span class=c1>// 출력: Modified (속성이 변경됨)
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><ul><li>이 경우, <strong>객체의 속성</strong>은 함수 내에서</li><li>변경할 수 있지만, <strong>참조 자체를 다른 객체로 바꾸는 것은</strong> 함수 외부에 영향을 주지 않습니다.</li></ul></li></ol><h2 id=요약>요약:<a hidden class=anchor aria-hidden=true href=#요약>#</a></h2><ul><li><strong>기본 타입 (Primitive types)</strong>: 값에 의한 전달 (<code>pass by value</code>)로 동작.</li><li><strong>참조 타입 (Reference types)</strong>: 참조의 값을 전달하지만, 객체의 속성을 변경할 수 있기 때문에 참조에 의한 전달처럼 동작할 수 있음.</li></ul><p>실제로 Kotlin은 <strong>값에 의한 전달만</strong> 존재합니다. 다만 <strong>참조 타입</strong>을 함수에 전달할 때, 그 참조된 객체의 속성은 함수 내에서 변경될 수 있습니다.</p><h3 id=참고>참고<a hidden class=anchor aria-hidden=true href=#참고>#</a></h3><p><code>result.add(combination.toList())</code> 에서 <code>toList()</code> 로 <strong>깊은 복사</strong>를 하지 않으면,</p><p><code>result</code> 가 <code>[[], [], []]</code> 가 되어 버린다.</p><p>이유는 <code>combination</code>를 <code>result</code>에 추가할 때 <strong>참조의 값</strong>를 그대로 넘겨주기 때문입니다.</p><p>Kotlin의 <code>MutableList</code>는 <strong>참조 타입</strong>이므로, <code>combination</code>가 변경되면 <code>result</code>에 있는 리스트도 함께 변경됩니다.</p><p>따라서 나중에 값을 변경할 때 <code>result</code>에 추가된 값도 동일하게 변경되는 문제가 발생합니다.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-kotlin data-lang=kotlin><span class=line><span class=cl><span class=k>fun</span> <span class=nf>combineWithBackTracking</span><span class=p>(</span><span class=n>n</span><span class=p>:</span> <span class=n>Int</span><span class=p>,</span> <span class=n>k</span><span class=p>:</span> <span class=n>Int</span><span class=p>):</span> <span class=n>List</span><span class=p>&lt;</span><span class=n>List</span><span class=p>&lt;</span><span class=n>Int</span><span class=p>&gt;&gt;</span> <span class=p>{</span> <span class=c1>// 참고용
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>val</span> <span class=py>result</span> <span class=p>=</span> <span class=n>mutableListOf</span><span class=p>&lt;</span><span class=n>List</span><span class=p>&lt;</span><span class=n>Int</span><span class=p>&gt;&gt;()</span>
</span></span><span class=line><span class=cl>    <span class=k>val</span> <span class=py>combination</span> <span class=p>=</span> <span class=n>mutableListOf</span><span class=p>&lt;</span><span class=n>Int</span><span class=p>&gt;()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>fun</span> <span class=nf>backtrack</span><span class=p>(</span><span class=n>start</span><span class=p>:</span> <span class=n>Int</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=n>combination</span><span class=p>.</span><span class=n>size</span> <span class=o>==</span> <span class=n>k</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=n>result</span><span class=p>.</span><span class=n>add</span><span class=p>(</span><span class=n>combination</span><span class=p>.</span><span class=n>toList</span><span class=p>())</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=p>(</span><span class=n>i</span> <span class=k>in</span> <span class=n>start</span><span class=o>..</span><span class=n>n</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=n>combination</span><span class=p>.</span><span class=n>add</span><span class=p>(</span><span class=n>i</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=n>backtrack</span><span class=p>(</span><span class=n>i</span> <span class=p>+</span> <span class=m>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=n>combination</span><span class=p>.</span><span class=n>removeAt</span><span class=p>(</span><span class=n>combination</span><span class=p>.</span><span class=n>size</span> <span class=p>-</span> <span class=m>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><h2 id=array-에서는>Array 에서는?<a hidden class=anchor aria-hidden=true href=#array-에서는>#</a></h2><p><code>IntArray</code>는 Kotlin에서 **기본 타입 배열(primitive array)**로, <strong><code>Int</code> 타입의 값들을 저장하는 배열</strong>입니다.</p><p>이 경우도 마찬가지로, Kotlin은 **값에 의한 전달(pass by value)**를 사용합니다. 하지만, <code>IntArray</code> 자체는 참조 타입으로 동작하므로, <strong>참조의 값이 전달</strong>됩니다.</p><p>따라서, <strong>배열 내부의 요소</strong>는 함수에서 수정할 수 있지만, 배열 자체를 <strong>새로운 배열로 변경</strong>하는 것은 함수 외부에 영향을 미치지 않습니다.</p><h3 id=예시-1-배열의-요소를-변경할-때>예시 1: 배열의 요소를 변경할 때<a hidden class=anchor aria-hidden=true href=#예시-1-배열의-요소를-변경할-때>#</a></h3><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span><span class=lnt>9
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-kotlin data-lang=kotlin><span class=line><span class=cl><span class=k>fun</span> <span class=nf>modifyArray</span><span class=p>(</span><span class=n>arr</span><span class=p>:</span> <span class=n>IntArray</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>arr</span><span class=p>[</span><span class=m>0</span><span class=p>]</span> <span class=p>=</span> <span class=m>100</span>  <span class=c1>// 배열의 첫 번째 요소를 100으로 변경
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>fun</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>val</span> <span class=py>nums</span> <span class=p>=</span> <span class=n>intArrayOf</span><span class=p>(</span><span class=m>1</span><span class=p>,</span> <span class=m>2</span><span class=p>,</span> <span class=m>3</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>modifyArray</span><span class=p>(</span><span class=n>nums</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>println</span><span class=p>(</span><span class=n>nums</span><span class=p>.</span><span class=n>joinToString</span><span class=p>())</span>  <span class=c1>// 출력: 100, 2, 3
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><ul><li><strong>배열의 참조</strong>가 전달되므로, 배열의 내부 값을 수정할 수 있습니다.</li><li>위의 경우, 함수 내에서 배열의 첫 번째 요소가 변경되었고, 원래 배열(<code>nums</code>)도 이 변경 사항을 반영합니다.</li></ul><h3 id=예시-2-배열-자체를-새로-할당할-때>예시 2: 배열 자체를 새로 할당할 때<a hidden class=anchor aria-hidden=true href=#예시-2-배열-자체를-새로-할당할-때>#</a></h3><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span><span class=lnt>9
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-kotlin data-lang=kotlin><span class=line><span class=cl><span class=k>fun</span> <span class=nf>reassignArray</span><span class=p>(</span><span class=n>arr</span><span class=p>:</span> <span class=n>IntArray</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>arr</span> <span class=p>=</span> <span class=n>intArrayOf</span><span class=p>(</span><span class=m>4</span><span class=p>,</span> <span class=m>5</span><span class=p>,</span> <span class=m>6</span><span class=p>)</span>  <span class=c1>// 배열 자체를 새로 할당 (실제로는 함수 내에서만 영향)
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>fun</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>val</span> <span class=py>nums</span> <span class=p>=</span> <span class=n>intArrayOf</span><span class=p>(</span><span class=m>1</span><span class=p>,</span> <span class=m>2</span><span class=p>,</span> <span class=m>3</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>reassignArray</span><span class=p>(</span><span class=n>nums</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>println</span><span class=p>(</span><span class=n>nums</span><span class=p>.</span><span class=n>joinToString</span><span class=p>())</span>  <span class=c1>// 출력: 1, 2, 3 (변경되지 않음)
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><ul><li><strong>배열 자체</strong>를 새로운 배열로 할당하려고 하면, 함수 내에서만 새로운 배열이 할당되고, 원본 배열은 변경되지 않습니다.</li><li>이는 배열의 <strong>참조 값이 복사</strong>되어 전달되기 때문에, 원본 배열의 참조 자체는 변경되지 않는 것입니다.</li></ul><h3 id=요약-1>요약:<a hidden class=anchor aria-hidden=true href=#요약-1>#</a></h3><ul><li><strong>배열의 요소</strong>는 함수 내에서 변경할 수 있으며, 이 변경 사항은 함수 외부에도 영향을 미칩니다. 이는 배열의 참조가 전달되기 때문입니다.</li><li>하지만 <strong>배열 자체를 새로운 배열로 할당</strong>하는 것은 함수 내에서만 영향을 미치며, 함수 외부의 배열에는 영향을 주지 않습니다.</li></ul><p>따라서, <code>IntArray</code>의 경우에도 <strong>참조의 값</strong>이 전달되므로, 배열의 <strong>내부 값</strong>을 수정할 수는 있지만, <strong>참조 자체</strong>는 변경되지 않습니다.</p><h1 id=intarray-vs-arrayint><code>IntArray</code> vs <code>Array&lt;Int></code><a hidden class=anchor aria-hidden=true href=#intarray-vs-arrayint>#</a></h1><p>Kotlin에서 <code>IntArray</code>와 <code>Array&lt;Int></code>는 모두 <strong>정수형 배열</strong>을 나타내지만,</p><p>둘 사이에는 중요한 차이점이 있습니다. 이 차이는 <strong>메모리 효율성</strong>과 <strong>타입</strong>에 대한 처리 방식에서 비롯됩니다.</p><h3 id=1-intarray>1. <strong><code>IntArray</code></strong><a hidden class=anchor aria-hidden=true href=#1-intarray>#</a></h3><ul><li><strong>Primitive 타입 배열</strong>로, <strong>메모리 효율</strong>이 뛰어납니다.</li><li>배열의 요소가 <strong><code>int</code></strong> 타입의 원시값으로 저장되므로, **박싱(boxing)**이 발생하지 않습니다.</li><li>Kotlin에서 제공하는 원시 배열 중 하나로, 자바의 <strong>primitive 배열</strong>(<code>int[]</code>)과 대응됩니다.</li><li>주로 <strong>성능이 중요한 상황</strong>에서 사용됩니다.</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-kotlin data-lang=kotlin><span class=line><span class=cl><span class=k>val</span> <span class=py>intArray</span> <span class=p>=</span> <span class=n>IntArray</span><span class=p>(</span><span class=m>5</span><span class=p>)</span> <span class=p>{</span> <span class=k>it</span> <span class=p>*</span> <span class=m>2</span> <span class=p>}</span>  <span class=c1>// 0, 2, 4, 6, 8
</span></span></span></code></pre></td></tr></table></div></div><ul><li><p>이 경우, 메모리에는 각 요소가 <strong>원시 정수</strong>로 저장됩니다.</p></li><li><p><code>IntArray</code>는 자바의 <code>int[]</code>와 대응</p></li></ul><h3 id=2-arrayint>2. <strong><code>Array&lt;Int></code></strong><a hidden class=anchor aria-hidden=true href=#2-arrayint>#</a></h3><ul><li><strong>참조 타입 배열</strong>입니다. 배열의 각 요소가 <strong>객체</strong>(<code>Integer</code>)로 저장되며, **박싱(boxing)**이 발생합니다.</li><li>즉, 배열 요소들이 기본적으로 객체로 처리되므로, 추가적인 메모리 사용이 있습니다.</li><li><code>Array&lt;Int></code>는 <strong>제네릭 배열</strong>이므로 **Kotlin의 <code>Array&lt;T></code>**와 대응됩니다.</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-kotlin data-lang=kotlin><span class=line><span class=cl><span class=k>val</span> <span class=py>arrayInt</span> <span class=p>=</span> <span class=n>Array</span><span class=p>(</span><span class=m>5</span><span class=p>)</span> <span class=p>{</span> <span class=k>it</span> <span class=p>*</span> <span class=m>2</span> <span class=p>}</span>  <span class=c1>// 0, 2, 4, 6, 8
</span></span></span></code></pre></td></tr></table></div></div><ul><li><p>각 요소는 **객체(Integer)**로 저장되므로, <strong>박싱</strong>이 발생합니다.</p></li><li><p><code>Array&lt;Int></code>는 <code>Integer[]</code>와 대응</p></li></ul><h3 id=3-차이점-요약>3. <strong>차이점 요약</strong><a hidden class=anchor aria-hidden=true href=#3-차이점-요약>#</a></h3><table><thead><tr><th>속성</th><th><code>IntArray</code></th><th><code>Array&lt;Int></code></th></tr></thead><tbody><tr><td><strong>타입</strong></td><td>Primitive 타입 (<code>int</code>)</td><td>참조 타입 (<code>Integer</code>)</td></tr><tr><td><strong>메모리 효율성</strong></td><td>더 효율적 (박싱 없음)</td><td>덜 효율적 (박싱 발생)</td></tr><tr><td><strong>자바 대응</strong></td><td><code>int[]</code></td><td><code>Integer[]</code></td></tr><tr><td><strong>주 사용 상황</strong></td><td>성능이 중요한 경우</td><td>제네릭 배열이 필요한 경우</td></tr><tr><td><strong>함수 지원</strong></td><td><code>IntArray</code>에 맞는 특수 함수 제공</td><td><code>Array&lt;T></code>에 맞는 일반 함수 제공</td></tr></tbody></table><h3 id=4-어떤-경우에-사용하나요>4. <strong>어떤 경우에 사용하나요?</strong><a hidden class=anchor aria-hidden=true href=#4-어떤-경우에-사용하나요>#</a></h3><ul><li><strong><code>IntArray</code></strong>: 성능과 메모리 사용이 중요한 경우, 예를 들어 대규모 데이터를 처리하거나, 원시 배열과의 호환성이 중요한 경우.</li><li><strong><code>Array&lt;Int></code></strong>: 일반적인 <strong>제네릭 배열</strong>이 필요한 경우 또는 참조 타입을 사용해야 하는 경우.</li></ul><h3 id=5-변환-방법>5. <strong>변환 방법</strong><a hidden class=anchor aria-hidden=true href=#5-변환-방법>#</a></h3><p>두 배열 간의 변환이 필요한 경우 다음과 같이 처리할 수 있습니다:</p><ul><li><p><strong><code>IntArray</code> -> <code>Array&lt;Int></code> 변환</strong>:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-kotlin data-lang=kotlin><span class=line><span class=cl><span class=k>val</span> <span class=py>intArray</span> <span class=p>=</span> <span class=n>IntArray</span><span class=p>(</span><span class=m>5</span><span class=p>)</span> <span class=p>{</span> <span class=k>it</span> <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=k>val</span> <span class=py>arrayInt</span><span class=p>:</span> <span class=n>Array</span><span class=p>&lt;</span><span class=n>Int</span><span class=p>&gt;</span> <span class=p>=</span> <span class=n>intArray</span><span class=p>.</span><span class=n>toTypedArray</span><span class=p>()</span>
</span></span></code></pre></td></tr></table></div></div></li><li><p><strong><code>Array&lt;Int></code> -> <code>IntArray</code> 변환</strong>:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-kotlin data-lang=kotlin><span class=line><span class=cl><span class=k>val</span> <span class=py>arrayInt</span> <span class=p>=</span> <span class=n>arrayOf</span><span class=p>(</span><span class=m>1</span><span class=p>,</span> <span class=m>2</span><span class=p>,</span> <span class=m>3</span><span class=p>,</span> <span class=m>4</span><span class=p>,</span> <span class=m>5</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=k>val</span> <span class=py>intArray</span><span class=p>:</span> <span class=n>IntArray</span> <span class=p>=</span> <span class=n>arrayInt</span><span class=p>.</span><span class=n>toIntArray</span><span class=p>()</span>
</span></span></code></pre></td></tr></table></div></div></li></ul><h1 id=map의-반복-처리>Map의 반복 처리<a hidden class=anchor aria-hidden=true href=#map의-반복-처리>#</a></h1><p>Kotlin에서 **<code>Map</code>**이 <strong><code>Iterable</code></strong> 인터페이스를 직접 구현하지 않으면서도 반복 처리가 가능한 이유는 <strong><code>Map</code></strong> 자체가 <strong><code>entries</code></strong>, <strong><code>keys</code></strong>, 그리고 **<code>values</code>**라는 **컬렉션 뷰(Collection Views)**를 제공하기 때문입니다.</p><p>이 각각의 뷰는 <strong><code>Set</code></strong> 또는 **<code>Collection</code>**으로 표현되며, 이들이 **<code>Iterable</code>**을 구현하고 있어 <code>for</code> 루프나 <code>forEach</code>와 같은 반복 처리가 가능해집니다.</p><h3 id=구체적인-설명>구체적인 설명:<a hidden class=anchor aria-hidden=true href=#구체적인-설명>#</a></h3><h4 id=1-map-자체는-iterable을-구현하지-않음>1. <strong><code>Map</code> 자체는 <code>Iterable</code>을 구현하지 않음</strong><a hidden class=anchor aria-hidden=true href=#1-map-자체는-iterable을-구현하지-않음>#</a></h4><ul><li><p><code>Map</code> 인터페이스 자체는 **<code>Iterable</code>**을 직접 구현하지 않습니다. 즉, <code>Map</code> 자체는 키와 값의 쌍을 저장하는 고유한 자료구조로, 단순히 한 방향으로 순차적으로 탐색되는 데이터 구조가 아닙니다.</p></li><li><p><code>Map</code>의 <code>key</code>, <code>value</code>, <code>entry</code>들은 내부적으로 별도의 **컬렉션(Set, Collection 등)**을 통해 구현됩니다.</p></li></ul><h4 id=2-entries-keys-values-컬렉션>2. <strong><code>entries</code>, <code>keys</code>, <code>values</code> 컬렉션</strong><a hidden class=anchor aria-hidden=true href=#2-entries-keys-values-컬렉션>#</a></h4><p><code>Map</code>에서 제공하는 세 가지 주요 컬렉션 뷰는 모두 <strong>반복 처리</strong>를 위한 <code>Iterable</code>을 구현하고 있습니다. 이 컬렉션들이 바로 <code>Map</code>을 반복 처리할 수 있게 도와줍니다.</p><ul><li><strong><code>entries</code></strong>: <code>Map</code>의 모든 <strong>키-값 쌍</strong>을 나타내며, 이는 **<code>Set&lt;Map.Entry&lt;K, V>></code>**로 반환됩니다. <code>Set</code>은 <code>Iterable</code>을 구현하므로, 이 <code>entries</code> 컬렉션을 통해 <code>Map</code>의 각 엔트리를 순회할 수 있습니다.</li><li><strong><code>keys</code></strong>: <code>Map</code>의 모든 <strong>키</strong>를 포함한 컬렉션이며, 이는 **<code>Set&lt;K></code>**로 반환됩니다. 역시 <code>Set</code>이 <code>Iterable</code>을 구현하므로, <code>keys</code>를 통해 모든 키를 순회할 수 있습니다.</li><li><strong><code>values</code></strong>: <code>Map</code>의 모든 <strong>값</strong>을 포함한 컬렉션이며, 이는 **<code>Collection&lt;V></code>**로 반환됩니다. <code>Collection</code>은 <code>Iterable</code>을 구현하므로, <code>values</code>를 순회할 수 있습니다.</li></ul><h1 id=함수-타입과-함수형-인터페이스>함수 타입과 함수형 인터페이스<a hidden class=anchor aria-hidden=true href=#함수-타입과-함수형-인터페이스>#</a></h1><p>Kotlin은 자바와 달리 <strong>람다 표현식</strong>을 사용할 때 <strong>함수 타입</strong>을 지원합니다.</p><p>자바는 함수 타입을 지원하지 않기 때문에, 람다를 넘기려면 <strong>함수형 인터페이스</strong>를 사용해야 합니다.</p><p>그러나 Kotlin에서는 굳이 함수형 인터페이스를 만들 필요 없이, <strong>함수 타입</strong>을 직접 인자로 사용할 수 있기 때문에, 인터페이스에 의존하는 방식이 필요하지 않습니다.</p><h3 id=1-kotlin의-함수-타입>1. <strong>Kotlin의 함수 타입</strong><a hidden class=anchor aria-hidden=true href=#1-kotlin의-함수-타입>#</a></h3><p>Kotlin에서는 함수 타입을 파라미터로 정의할 수 있습니다. 예를 들어, <code>(Int) -> Unit</code>과 같은 함수 타입을 직접적으로 파라미터로 사용해 함수를 작성할 수 있습니다.</p><h4 id=함수-타입을-인자로-사용하는-예시>함수 타입을 인자로 사용하는 예시:<a hidden class=anchor aria-hidden=true href=#함수-타입을-인자로-사용하는-예시>#</a></h4><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-kotlin data-lang=kotlin><span class=line><span class=cl><span class=c1>// 함수 타입을 인자로 받는 함수
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>fun</span> <span class=nf>executeAction</span><span class=p>(</span><span class=n>action</span><span class=p>:</span> <span class=p>()</span> <span class=o>-&gt;</span> <span class=n>Unit</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>action</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>fun</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 함수 타입을 바로 람다로 전달
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>executeAction</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>println</span><span class=p>(</span><span class=s2>&#34;Doing something...&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>이 코드는 정상적으로 작동하며, <code>executeAction</code> 함수는 **함수 타입(<code>() -> Unit</code>)**을 인자로 받습니다. Kotlin에서는 이처럼 <strong>인터페이스 대신 함수 타입을 직접 사용</strong>할 수 있습니다.</p><h3 id=2-함수형-인터페이스와의-차이점>2. <strong>함수형 인터페이스와의 차이점</strong><a hidden class=anchor aria-hidden=true href=#2-함수형-인터페이스와의-차이점>#</a></h3><p>Kotlin에서는 <strong><code>fun interface</code></strong> 키워드를 사용하여 자바의 함수형 인터페이스와 유사한 방식을 사용할 수 있습니다. 하지만 기본적으로 <strong>함수 타입</strong>을 사용할 수 있기 때문에, 대부분의 경우 함수형 인터페이스보다 <strong>함수 타입</strong>을 더 선호합니다.</p><h4 id=자바-스타일의-함수형-인터페이스-사용>자바 스타일의 함수형 인터페이스 사용:<a hidden class=anchor aria-hidden=true href=#자바-스타일의-함수형-인터페이스-사용>#</a></h4><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-kotlin data-lang=kotlin><span class=line><span class=cl><span class=c1>// 함수형 인터페이스
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>fun</span> <span class=nf>interface</span> <span class=n>MyAction</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>fun</span> <span class=nf>perform</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// MyAction 인터페이스를 인자로 받는 함수
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>fun</span> <span class=nf>executeAction</span><span class=p>(</span><span class=n>action</span><span class=p>:</span> <span class=n>MyAction</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>action</span><span class=p>.</span><span class=n>perform</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>fun</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 인터페이스를 람다로 넘기기
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>executeAction</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>println</span><span class=p>(</span><span class=s2>&#34;Doing something...&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>위 코드는 <strong>함수형 인터페이스</strong>를 사용하여 인자로 넘기는 예시입니다. <code>fun interface</code>로 정의된 인터페이스는 **단일 추상 메서드(SAM)**를 가지기 때문에 람다로 구현할 수 있습니다.</p><p>하지만 이 방식은 자바와의 상호 운용성(interop)을 위해 사용되며, 일반적으로 Kotlin에서는 함수 타입을 사용하는 것이 더 자연스럽습니다.</p><h3 id=3-요약>3. 요약<a hidden class=anchor aria-hidden=true href=#3-요약>#</a></h3><p>Kotlin에서 <strong>하나의 추상 메서드만 있는 인터페이스</strong>를 인자로 받는 함수에 <strong>람다</strong>를 넘기려면, **<code>fun interface</code>**를 명시적으로 선언해야 합니다. 그렇지 않으면, Kotlin은 그 인터페이스를 <strong>함수 타입</strong>으로 간주하지 않기 때문에 <strong>람다 표현식을 바로 전달할 수 없고</strong> 오류가 발생합니다.</p><p>하지만 Kotlin에서는 함수형 인터페이스 없이도 <strong>함수 타입</strong>을 바로 사용할 수 있으므로, 함수 타입을 파라미터로 사용할 수 있는 경우에는 인터페이스를 굳이 정의하지 않아도 됩니다. 이는 <strong>Kotlin의 함수 타입 지원</strong> 덕분에 발생하는 차이점입니다.</p><h1 id=reified-상세>reified 상세<a hidden class=anchor aria-hidden=true href=#reified-상세>#</a></h1><p>Kotlin에서 <strong><code>reified</code></strong> 키워드는 <strong>제네릭 타입</strong>을 <strong>런타임</strong>에 **구체화(reify)**할 수 있게 해줍니다.</p><p>보통 제네릭 타입은 **런타임에 타입 정보가 소거(erase)**되지만, <code>reified</code>를 사용하면 <strong>타입 정보를 런타임에도 유지</strong>할 수 있어, 제네릭 타입에 대한 <strong>타입 검사</strong>나 <strong>타입 캐스팅</strong>을 런타임에 수행할 수 있게 됩니다.</p><h3 id=reified가-필요할-때><code>reified</code>가 필요할 때:<a hidden class=anchor aria-hidden=true href=#reified가-필요할-때>#</a></h3><ol><li><strong>제네릭 타입 소거(Type Erasure) 문제</strong>:<ul><li>일반적으로 <strong>제네릭 타입</strong>은 <strong>런타임</strong>에 <strong>소거</strong>됩니다. 즉, 제네릭 타입 정보는 컴파일 시에는 존재하지만, 런타임에서는 해당 정보가 제거되어 <strong>타입 정보를 알 수 없습니다</strong>.</li><li>예를 들어, 제네릭 함수에서 <code>T::class</code> 또는 <code>T is SomeClass</code>와 같은 <strong>타입 체크</strong>나 <strong>타입 캐스팅</strong>을 하려면 <code>reified</code>가 필요합니다.</li></ul></li></ol><h3 id=예시-reified-사용>예시: <code>reified</code> 사용<a hidden class=anchor aria-hidden=true href=#예시-reified-사용>#</a></h3><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-kotlin data-lang=kotlin><span class=line><span class=cl><span class=c1>// reified를 사용한 제네릭 인라인 함수
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>inline</span> <span class=k>fun</span> <span class=p>&lt;</span><span class=k>reified</span> <span class=nc>T</span><span class=p>&gt;</span> <span class=nf>checkType</span><span class=p>(</span><span class=k>value</span><span class=p>:</span> <span class=n>Any</span><span class=p>):</span> <span class=n>Boolean</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=k>value</span> <span class=k>is</span> <span class=n>T</span>  <span class=c1>// 런타임에 제네릭 타입 T에 대한 타입 검사 가능
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>fun</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>val</span> <span class=py>result1</span> <span class=p>=</span> <span class=n>checkType</span><span class=p>&lt;</span><span class=n>String</span><span class=p>&gt;(</span><span class=s2>&#34;Hello&#34;</span><span class=p>)</span>  <span class=c1>// true
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>val</span> <span class=py>result2</span> <span class=p>=</span> <span class=n>checkType</span><span class=p>&lt;</span><span class=n>Int</span><span class=p>&gt;(</span><span class=s2>&#34;Hello&#34;</span><span class=p>)</span>     <span class=c1>// false
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>println</span><span class=p>(</span><span class=n>result1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>println</span><span class=p>(</span><span class=n>result2</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><h3 id=설명>설명:<a hidden class=anchor aria-hidden=true href=#설명>#</a></h3><ol><li><strong><code>inline</code> 함수</strong>: <code>reified</code> 키워드는 <strong>인라인 함수</strong>에서만 사용할 수 있습니다. 인라인 함수는 컴파일 시 <strong>함수 호출을 본문으로 대체</strong>하므로, 제네릭 타입이 소거되지 않고 <strong>타입 정보가 유지</strong>됩니다.</li><li><strong><code>reified</code> 키워드</strong>: 제네릭 타입 <code>T</code>를 **구체화(reify)**하여, 런타임에서도 해당 타입에 접근할 수 있습니다. 이로 인해 <code>T is String</code>과 같은 타입 검사를 런타임에서 할 수 있습니다.</li></ol><h4 id=reified-없는-경우-컴파일-오류-발생><code>reified</code> 없는 경우: 컴파일 오류 발생<a hidden class=anchor aria-hidden=true href=#reified-없는-경우-컴파일-오류-발생>#</a></h4><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-kotlin data-lang=kotlin><span class=line><span class=cl><span class=k>fun</span> <span class=p>&lt;</span><span class=nc>T</span><span class=p>&gt;</span> <span class=nf>checkType</span><span class=p>(</span><span class=k>value</span><span class=p>:</span> <span class=n>Any</span><span class=p>):</span> <span class=n>Boolean</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 컴파일 오류: &#39;is&#39; 검사를 제네릭 타입 T에 대해 수행할 수 없음
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>return</span> <span class=k>value</span> <span class=k>is</span> <span class=n>T</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>위 코드에서 제네릭 타입 <code>T</code>는 <strong>타입 소거</strong>가 발생하기 때문에, 런타임에는 <code>T</code>의 타입 정보를 알 수 없습니다. 그래서 <code>value is T</code>와 같은 코드는 <strong>컴파일 오류</strong>가 발생합니다.</p><h3 id=reified를-사용한-응용><code>reified</code>를 사용한 응용:<a hidden class=anchor aria-hidden=true href=#reified를-사용한-응용>#</a></h3><ol><li><strong>제네릭 타입을 클래스 타입으로 변환</strong> (<code>T::class</code> 사용):</li></ol><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-kotlin data-lang=kotlin><span class=line><span class=cl><span class=k>inline</span> <span class=k>fun</span> <span class=p>&lt;</span><span class=k>reified</span> <span class=nc>T</span><span class=p>&gt;</span> <span class=nf>getTypeName</span><span class=p>():</span> <span class=n>String</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>T</span><span class=o>::</span><span class=k>class</span><span class=p>.</span><span class=n>simpleName</span> <span class=o>?:</span> <span class=s2>&#34;Unknown&#34;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>fun</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>println</span><span class=p>(</span><span class=n>getTypeName</span><span class=p>&lt;</span><span class=n>String</span><span class=p>&gt;())</span>  <span class=c1>// 출력: String
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>println</span><span class=p>(</span><span class=n>getTypeName</span><span class=p>&lt;</span><span class=n>Int</span><span class=p>&gt;())</span>     <span class=c1>// 출력: Int
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><ol start=2><li><strong>제네릭 타입의 인스턴스 생성</strong>:</li></ol><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-kotlin data-lang=kotlin><span class=line><span class=cl><span class=k>inline</span> <span class=k>fun</span> <span class=p>&lt;</span><span class=k>reified</span> <span class=nc>T</span><span class=p>&gt;</span> <span class=nf>createInstance</span><span class=p>():</span> <span class=n>T</span><span class=p>?</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>T</span><span class=o>::</span><span class=k>class</span><span class=p>.</span><span class=n>java</span><span class=p>.</span><span class=n>getDeclaredConstructor</span><span class=p>().</span><span class=n>newInstance</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>fun</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>val</span> <span class=py>instance</span><span class=p>:</span> <span class=n>String</span><span class=p>?</span> <span class=p>=</span> <span class=n>createInstance</span><span class=p>&lt;</span><span class=n>String</span><span class=p>&gt;()</span>
</span></span><span class=line><span class=cl>    <span class=n>println</span><span class=p>(</span><span class=n>instance</span><span class=p>)</span>  <span class=c1>// 출력: 빈 문자열 (기본 생성자 호출)
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><ol start=3><li><strong>제네릭 타입 캐스팅</strong>:</li></ol><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-kotlin data-lang=kotlin><span class=line><span class=cl><span class=k>inline</span> <span class=k>fun</span> <span class=p>&lt;</span><span class=k>reified</span> <span class=nc>T</span><span class=p>&gt;</span> <span class=nf>cast</span><span class=p>(</span><span class=k>value</span><span class=p>:</span> <span class=n>Any</span><span class=p>):</span> <span class=n>T</span><span class=p>?</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=k>value</span> <span class=k>as</span><span class=p>?</span> <span class=n>T</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>fun</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>val</span> <span class=py>stringValue</span><span class=p>:</span> <span class=n>String</span><span class=p>?</span> <span class=p>=</span> <span class=n>cast</span><span class=p>&lt;</span><span class=n>String</span><span class=p>&gt;(</span><span class=s2>&#34;Hello&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>println</span><span class=p>(</span><span class=n>stringValue</span><span class=p>)</span>  <span class=c1>// 출력: Hello
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>    <span class=k>val</span> <span class=py>intValue</span><span class=p>:</span> <span class=n>Int</span><span class=p>?</span> <span class=p>=</span> <span class=n>cast</span><span class=p>&lt;</span><span class=n>Int</span><span class=p>&gt;(</span><span class=s2>&#34;Hello&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>println</span><span class=p>(</span><span class=n>intValue</span><span class=p>)</span>  <span class=c1>// 출력: null (타입이 맞지 않음)
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><h3 id=결론>결론:<a hidden class=anchor aria-hidden=true href=#결론>#</a></h3><ul><li>**<code>reified</code>**는 <strong>제네릭 타입을 구체화</strong>하여 <strong>런타임에 타입 정보를 유지</strong>할 수 있게 해줍니다.</li><li>이를 통해 <strong>타입 검사</strong>, <strong>타입 캐스팅</strong>, **타입 관련 함수(T::class)**를 사용할 수 있습니다.</li><li><code>reified</code>는 <strong>인라인 함수</strong>와 함께 사용해야 하며, 일반 제네릭 함수에서는 사용할 수 없습니다.</li></ul><h1 id=runcatching>runCatching<a hidden class=anchor aria-hidden=true href=#runcatching>#</a></h1><p><code>runCatching</code>은 Kotlin에서 예외 처리와 관련된 함수로, 코드 블록을 실행하고 그 결과나 예외를 <code>Result</code> 객체로 반환한다.</p><p>이 함수는 코드에서 발생할 수 있는 예외를 간결하게 처리할 수 있도록 도와준다.</p><p><code>runCatching</code>은 함수 블록을 실행한 후 성공했을 경우에는 <code>Result.success</code>로, 예외가 발생했을 경우에는 <code>Result.failure</code>로 감싼 결과를 반환한다.</p><p>이를 통해 예외를 명시적으로 던지지 않고도 안전하게 처리할 수 있다.</p><h3 id=사용법>사용법<a hidden class=anchor aria-hidden=true href=#사용법>#</a></h3><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-kotlin data-lang=kotlin><span class=line><span class=cl><span class=k>val</span> <span class=py>result</span> <span class=p>=</span> <span class=n>runCatching</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 예외가 발생할 수 있는 코드
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><h3 id=반환되는-result-객체>반환되는 <code>Result</code> 객체<a hidden class=anchor aria-hidden=true href=#반환되는-result-객체>#</a></h3><ul><li><strong>성공 (<code>Result.success</code>)</strong>: 블록이 성공적으로 실행되면 결과 값을 포함한 <code>Result.success</code> 객체를 반환한다.</li><li><strong>실패 (<code>Result.failure</code>)</strong>: 블록에서 예외가 발생하면 해당 예외를 포함한 <code>Result.failure</code> 객체를 반환한다.</li></ul><h3 id=주요-함수>주요 함수<a hidden class=anchor aria-hidden=true href=#주요-함수>#</a></h3><ul><li><p><strong><code>isSuccess</code></strong>: 실행이 성공했는지 여부를 확인.</p></li><li><p><strong><code>isFailure</code></strong>: 예외가 발생했는지 여부를 확인.</p></li><li><p><strong><code>getOrNull()</code></strong>: 성공한 경우 결과 값을 반환하고, 실패한 경우 <code>null</code>을 반환.</p></li><li><p><strong><code>exceptionOrNull()</code></strong>: 실패한 경우 예외를 반환하고, 성공한 경우 <code>null</code>을 반환.</p></li><li><p><strong><code>getOrElse(defaultValue)</code></strong>: 성공하면 값을 반환하고, 실패하면 기본 값을 반환.</p></li><li><p><strong><code>onSuccess(action)</code></strong>: 성공했을 때 실행할 동작을 지정.</p><p><strong><code>onFailure(action)</code></strong>: 실패했을 때 실행할 동작을 지정.</p></li></ul><h3 id=예시>예시<a hidden class=anchor aria-hidden=true href=#예시>#</a></h3><h4 id=성공-예시>성공 예시<a hidden class=anchor aria-hidden=true href=#성공-예시>#</a></h4><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span><span class=lnt>9
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-kotlin data-lang=kotlin><span class=line><span class=cl><span class=k>fun</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>val</span> <span class=py>result</span> <span class=p>=</span> <span class=n>runCatching</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=c1>// 정상 실행
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=m>42</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>println</span><span class=p>(</span><span class=n>result</span><span class=p>)</span>  <span class=c1>// Result.success(42)
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>println</span><span class=p>(</span><span class=n>result</span><span class=p>.</span><span class=n>getOrNull</span><span class=p>())</span>  <span class=c1>// 42
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><h4 id=실패-예시>실패 예시<a hidden class=anchor aria-hidden=true href=#실패-예시>#</a></h4><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span><span class=lnt>9
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-kotlin data-lang=kotlin><span class=line><span class=cl><span class=k>fun</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>val</span> <span class=py>result</span> <span class=p>=</span> <span class=n>runCatching</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=c1>// 예외 발생
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=k>throw</span> <span class=n>IllegalArgumentException</span><span class=p>(</span><span class=s2>&#34;에러 발생&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>println</span><span class=p>(</span><span class=n>result</span><span class=p>)</span>  <span class=c1>// Result.failure(java.lang.IllegalArgumentException: 에러 발생)
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>println</span><span class=p>(</span><span class=n>result</span><span class=p>.</span><span class=n>exceptionOrNull</span><span class=p>())</span>  <span class=c1>// java.lang.IllegalArgumentException: 에러 발생
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><h4 id=getorelse로-기본-값-처리><code>getOrElse</code>로 기본 값 처리<a hidden class=anchor aria-hidden=true href=#getorelse로-기본-값-처리>#</a></h4><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span><span class=lnt>9
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-kotlin data-lang=kotlin><span class=line><span class=cl><span class=k>fun</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>val</span> <span class=py>result</span> <span class=p>=</span> <span class=n>runCatching</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>throw</span> <span class=n>IllegalArgumentException</span><span class=p>(</span><span class=s2>&#34;에러 발생&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// 실패할 경우 기본 값으로 처리
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>val</span> <span class=py>value</span> <span class=p>=</span> <span class=n>result</span><span class=p>.</span><span class=n>getOrElse</span> <span class=p>{</span> <span class=m>0</span> <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=n>println</span><span class=p>(</span><span class=k>value</span><span class=p>)</span>  <span class=c1>// 0
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><h3 id=onsuccess와-onfailure><code>onSuccess</code>와 <code>onFailure</code><a hidden class=anchor aria-hidden=true href=#onsuccess와-onfailure>#</a></h3><p><code>runCatching</code>에서 반환된 <code>Result</code> 객체는 <code>onSuccess</code>와 <code>onFailure</code>를 이용해 성공과 실패에 대해 각각의 후속 작업을 정의할 수 있다.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span><span class=lnt>9
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-kotlin data-lang=kotlin><span class=line><span class=cl><span class=k>fun</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>val</span> <span class=py>result</span> <span class=p>=</span> <span class=n>runCatching</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=s2>&#34;성공&#34;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>result</span>
</span></span><span class=line><span class=cl>        <span class=p>.</span><span class=n>onSuccess</span> <span class=p>{</span> <span class=n>println</span><span class=p>(</span><span class=s2>&#34;성공: </span><span class=si>$it</span><span class=s2>&#34;</span><span class=p>)</span> <span class=p>}</span>  <span class=c1>// 성공 시 처리
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=p>.</span><span class=n>onFailure</span> <span class=p>{</span> <span class=n>println</span><span class=p>(</span><span class=s2>&#34;실패: </span><span class=si>${it.message}</span><span class=s2>&#34;</span><span class=p>)</span> <span class=p>}</span>  <span class=c1>// 실패 시 처리
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><h4 id=장점><strong>장점</strong><a hidden class=anchor aria-hidden=true href=#장점>#</a></h4><ul><li>코드가 간결해지고 가독성이 향상된다.</li><li>함수형 프로그래밍 스타일과 잘 맞아 <code>onSuccess</code>, <code>onFailure</code> 등의 체이닝이 가능하다.</li><li>명시적인 예외 처리와 <code>Result</code> 객체를 활용한 구체적인 예외 처리 로직을 적용할 수 있다.</li></ul><h4 id=단점><strong>단점</strong><a hidden class=anchor aria-hidden=true href=#단점>#</a></h4><ul><li>복잡한 예외 처리에 적합하지 않다.</li><li>디버깅이 어려울 수 있고, 성능 오버헤드가 발생할 수 있다.</li><li>익숙하지 않은 경우 직관적으로 이해하기 어려울 수 있다.</li></ul></div><footer class=post-footer><ul class=post-tags><li><a href=https://2taezeat.github.io/tags/kotlin/>Kotlin</a></li></ul><nav class=paginav><a class=prev href=https://2taezeat.github.io/posts/dev/kotlin-%EC%A0%95%EB%A6%AC-4/><span class=title>« Prev</span><br><span>Kotlin 정리 (4)</span>
</a><a class=next href=https://2taezeat.github.io/posts/dev/kotlin-%EC%A0%95%EB%A6%AC-2/><span class=title>Next »</span><br><span>Kotlin 정리 (2)</span></a></nav><ul class=share-buttons><li><a target=_blank rel="noopener noreferrer" aria-label="share Kotlin 정리 (3) on x" href="https://x.com/intent/tweet/?text=Kotlin%20%ec%a0%95%eb%a6%ac%20%283%29&amp;url=https%3a%2f%2f2taezeat.github.io%2fposts%2fdev%2fkotlin-%25EC%25A0%2595%25EB%25A6%25AC-3%2f&amp;hashtags=Kotlin"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446C483.971.0 512 28.03 512 62.554zM269.951 190.75 182.567 75.216H56L207.216 272.95 63.9 436.783h61.366L235.9 310.383l96.667 126.4H456L298.367 228.367l134-153.151H371.033zM127.633 110h36.468l219.38 290.065H349.5z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Kotlin 정리 (3) on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2f2taezeat.github.io%2fposts%2fdev%2fkotlin-%25EC%25A0%2595%25EB%25A6%25AC-3%2f&amp;title=Kotlin%20%ec%a0%95%eb%a6%ac%20%283%29&amp;summary=Kotlin%20%ec%a0%95%eb%a6%ac%20%283%29&amp;source=https%3a%2f%2f2taezeat.github.io%2fposts%2fdev%2fkotlin-%25EC%25A0%2595%25EB%25A6%25AC-3%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Kotlin 정리 (3) on reddit" href="https://reddit.com/submit?url=https%3a%2f%2f2taezeat.github.io%2fposts%2fdev%2fkotlin-%25EC%25A0%2595%25EB%25A6%25AC-3%2f&title=Kotlin%20%ec%a0%95%eb%a6%ac%20%283%29"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Kotlin 정리 (3) on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2f2taezeat.github.io%2fposts%2fdev%2fkotlin-%25EC%25A0%2595%25EB%25A6%25AC-3%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Kotlin 정리 (3) on whatsapp" href="https://api.whatsapp.com/send?text=Kotlin%20%ec%a0%95%eb%a6%ac%20%283%29%20-%20https%3a%2f%2f2taezeat.github.io%2fposts%2fdev%2fkotlin-%25EC%25A0%2595%25EB%25A6%25AC-3%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Kotlin 정리 (3) on telegram" href="https://telegram.me/share/url?text=Kotlin%20%ec%a0%95%eb%a6%ac%20%283%29&amp;url=https%3a%2f%2f2taezeat.github.io%2fposts%2fdev%2fkotlin-%25EC%25A0%2595%25EB%25A6%25AC-3%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentcolor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Kotlin 정리 (3) on ycombinator" href="https://news.ycombinator.com/submitlink?t=Kotlin%20%ec%a0%95%eb%a6%ac%20%283%29&u=https%3a%2f%2f2taezeat.github.io%2fposts%2fdev%2fkotlin-%25EC%25A0%2595%25EB%25A6%25AC-3%2f"><svg width="30" height="30" viewBox="0 0 512 512" fill="currentcolor" xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"><path d="M449.446.0C483.971.0 512 28.03 512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446zM183.8767 87.9921h-62.034L230.6673 292.4508V424.0079h50.6655V292.4508L390.1575 87.9921H328.1233L256 238.2489z"/></svg></a></li></ul></footer><script src=https://utteranc.es/client.js repo=2taezeat/blog_comment issue-term=pathname label=comment theme=github-light crossorigin=anonymous async></script></article></main><footer class=footer><span>&copy; 2024 <a href=https://2taezeat.github.io/>2taezeat, blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>