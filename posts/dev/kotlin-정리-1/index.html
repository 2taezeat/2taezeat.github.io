<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Kotlin 정리 (1) | 2taezeat, blog</title>
<meta name=keywords content="Kotlin"><meta name=description content="Kotlin 정리 (1)"><meta name=author content="2taezeat"><link rel=canonical href=https://2taezeat.github.io/posts/dev/kotlin-%EC%A0%95%EB%A6%AC-1/><meta name=google-site-verification content="YaEERzgrvu-ZwPg7gswZdTzRMufkHw3uIH7i8hVal1c"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.fcb4dca47a3205209ed5ad677bea9ef840216e00cc778e31a6e3943bf8f843e1.css integrity="sha256-/LTcpHoyBSCe1a1ne+qe+EAhbgDMd44xpuOUO/j4Q+E=" rel="preload stylesheet" as=style><link rel=icon href=https://2taezeat.github.io/icon/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://2taezeat.github.io/icon/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://2taezeat.github.io/icon/favicon-32x32.png><link rel=apple-touch-icon href=https://2taezeat.github.io/icon/apple-touch-icon.png><link rel=mask-icon href=https://2taezeat.github.io/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://2taezeat.github.io/posts/dev/kotlin-%EC%A0%95%EB%A6%AC-1/><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><meta property="og:title" content="Kotlin 정리 (1)"><meta property="og:description" content="Kotlin 정리 (1)"><meta property="og:type" content="article"><meta property="og:url" content="https://2taezeat.github.io/posts/dev/kotlin-%EC%A0%95%EB%A6%AC-1/"><meta property="og:image" content="https://2taezeat.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-12-04T11:30:03+00:00"><meta property="article:modified_time" content="2023-12-04T11:30:03+00:00"><meta property="og:site_name" content="2taezeat, blog"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://2taezeat.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="Kotlin 정리 (1)"><meta name=twitter:description content="Kotlin 정리 (1)"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://2taezeat.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Kotlin 정리 (1)","item":"https://2taezeat.github.io/posts/dev/kotlin-%EC%A0%95%EB%A6%AC-1/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Kotlin 정리 (1)","name":"Kotlin 정리 (1)","description":"Kotlin 정리 (1)","keywords":["Kotlin"],"articleBody":"Kotlin 다시 보기 (1) ‘빅 너드 랜치의 코틀린 프로그래밍’ 을 읽고 정리\n타입 코틀린 타입 특징 정적 타입 시스템\n소스 코드에 정의된 타입을 컴파일러가 알고 있다. 프로그램을 컴파일하기 전에 타입 체킹 : 정적 타입 체킹\nbuilt-in, 내장 타입 String\nChar\nBoolean\nInt\nDouble\nList - 컬렉션 타입\nSet - 컬렉션 타입\nMap - 컬렉션 타입\n변수 val : read-only, 변경 불가능, 읽기 전용 var : 값이 변경 될 수 있음, writeable 쓰기 가능, 가변성 타입 추론 코틀린 컴파일러가 타입을 추론 해줌 따라서, 타입을 생략 가능, 컴파일러가 소스 코드의 타입을 알고 있음 코틀린은 기본 타입을 포함해서, 모든 타입이 객체다. 코틀린 컴파일러가 자바의 기본 타입과 가장 유사한 것과 매핑 컴파일 시점 상수(constant) val 변수는 상수(constant) 가 아니다. const val MAX_LIMIT = 50000 프로그램 실행 전에 생성 및 초기화 됨 초기화된 값을 절대로 변경하지 않는 값 프로그램 실행 전 컴파일러가 알 수 있어야 함으로, ‘built-in 타입’ 중 하나가 되어야 함 String, Int, Double, Float, Boolean, Char 모든 함수 외부에 정의 되어야 함, 컴파일 될때 값이 지정되야 함 상수와 달리, 변수들은 runtime에 생성되어 값이 지정된다. 코틀린의 자바 기본 타입 자바는 참조 타입과 기본 타입 2개가 존재\n기본 타입: 내장, 소문자\nint 참조 타입: 별도의 소스 코드 파일로 정의, Ex) 클래스, 항상 대문자\nInterger 모든 기본 타입은 그것과 대응되는 참조 타입이 있다. (역은 불가)\n기본 타입이 참조 타입보다 성능이 좋음\n기본 타입 배열(int[], byte[], boolean[])\n자바와 달리 코틀린은 참조 타입만 제공 (int가 아닌 Int만 제공) → 선택지가 하나로 됨, 코드 쉽게 작성 가능\n기본(primitive, 원시) 타입도 참조 타입(reference) 으로 사용\n코틀린 컴파일러는 가능한 한 자바 바이트코드의 기본(primitive) 타입을 사용한다. ( 더 좋은 성능을 내기에 )\n코틀린은 자바와 달리 원시 타입(Primitive Type) 과 참조 타입(Reference Type) 을 엄격하게 구분하지 않는다.\nNullable type(ex. Int?)은 자바의 Wrapper Class(Interger)로 컴파일된다.\n원시, 기본 타입 값을 직접 저장하는 데이터 타입입니다. 종류 정수 타입: Byte, Short, Int, Long 부동 소수점 타입: Float, Double 문자 타입: Char 불리언 타입: Boolean 특징 컴파일 시 자바의 기본 타입으로 변환됩니다. (예: Int -\u003e int) 숫자 타입은 객체처럼 사용할 수 있습니다. (박싱/언박싱 자동 처리) 기본형을 참조형으로 변환: 이 기능을 박싱(boxing) 오토박싱(Autoboxing)은 Java 컴파일러가 원시 타입과 해당 객체 래퍼 클래스 간에 수행하는 자동 변환을 말한다. (예시: int =\u003e Integer) 참조 타입 객체의 메모리 주소를 저장하는 데이터 타입입니다. 종류 클래스 (Class) 인터페이스 (Interface) 배열 (Arrays) 문자열 (String) 컬렉션 (Collection) 기타 객체 타입 특징 기본 타입 (Primitive Type) 참조 타입 (Reference Type) 메모리 할당 JVM의 스택(Stack) 영역에 직접 값 할당 JVM의 힙(Heap) 영역에 객체 생성 후 스택에 참조 값 저장 값 표현 실제 값 (정수, 실수, 문자, 논리 값 등) 객체의 메모리 주소 (참조 값) 크기 고정된 크기 (타입별로 정의됨) 가변적인 크기 (객체의 상태에 따라 달라짐) 연산 값 자체를 이용한 연산 참조 값을 이용한 연산 (객체의 메서드 호출 등) 비교 == 연산자로 값 비교 == 연산자로 참조 값 비교, .equals() 메서드로 객체 내용 비교 제네릭 사용 불가 사용 가능 종류 byte, short, int, long, float, double, boolean, char 클래스, 인터페이스, 배열, 열거형(enum), 문자열 등 메모리 사용량 적음 많음 속도 스택에서 값을 직접 사용, 빠름 스택에 저장된 참조 값을 통해 힙에 있는 객체에 접근, 느림 GC 없음 있음 OOP 불가 가능 조건문과 조건식 문과 식 문(Statement): 프로그램의 실행 흐름을 제어하는 명령어 또는 명령어들의 집합입니다.\n식(Expression): 값을 생성하는 코드 조각\n식은 문의 일부가 될 수 있다.\n특징 문 (Statement) 식 (Expression) 값 생성 X O 실행 결과 반환 X O 상태 변경 O X 세미콜론(;) O (일반적으로) X 예시 int x = 10 x + 5 조건 표현식 (conditional expression) if/else 문(Statement) 대신 조건 표현식 을 사용할 수 있다.\n식(Expression)은 값을 반환한다.\n1 2 3 4 5 6 7 8 9 10 11 val tmp1 = if () { \"yes\" } else { \"no\" } val tmp2 = when (para) { 100 -\u003e \"1\" in 1..90 -\u003e \"2\" else -\u003e \"3\" } when 문\nelse 없어도 상관 없음 when 표현식\nelse 가 꼭 있는지 컴파일러가 검증 결과를 반환하기때문 간결하고 다양하게 로직을 나타냄 when\n임의의 조건들을 검사할 수 있다 풀 스루가 아님 Java switch 문\n값만 검사 풀 스루 (break 없으면, 아래의 조건들도 검사) 함수 기본적으로 가시성 제한자가 public\n함수의 매개변수(===인자) 는 var이 아닌 val 이다.\n함수 내에 있는 지역 범수는 함수 범위에만 존재, 함수가 return 되면 소멸된다. (매개변수도 마찬가지)\n매개변수 또한 함수 종료시 소멸됨 파일 수준 변수는 프로젝트 어디서든 사용 가능\n자바 클래스의 static 메서드가 된다, ~.kt 파일을 Java byteCode(.class)를 decompile(역컴파일)로 확인 가능 파일 수준 변수는 초깃값이 지정되어야 한다. 아니면 컴파일 에러\n기본 인자 ( default argument ) 지원\n함수 인자가 기본값을 가짐 단일 표현식, 함수 대입 연산자 = 으로 정의\noverload 함수들은 컴파일러가 함수 호출시에 전달되는 인자의 타입과 갯수로 무슨 함수인지 알 수 있다.\nUnit 함수 아무 값도 return 하지 않는 함수 타입\nvoid 로는 제네릭 함수 를 구현할 방법이 없음, Unit 으로 해결\nvoid는 타입이 아니며, 타입 정보가 의미가 없으므로, 생략해라 라는 의미 Unit으로 함수의 반환 타입을 나타냄 =\u003e 제네릭 함수에도 사용 가능\nNothing 타입 함수의 실행이 끝나더라도, 호출 코드로 제어가 복귀되지 않는다 의도적으로 exception 예외를 발생시킬 때 사용 public inline fun TODO(): Nothing = throw NotImplementedError() 컴파일러는 이 TODO 코드를 에러로 처리하지 않는다. 제어가 복귀되지 않아서, 컴파일러가 TODO 코드의 다음 코드는 절대 실행되지 않는 것을 알게됨 자바의 파일 수준 함수 코틀린의 파일 수준 함수는 자바 클래스의 static 메서드가 된다. 코틀린 파일 이름의 Kt를 붙임 Game.kt =\u003e public final class GameKt 함수 Overloading 이름은 같지만 매개변수의 개수가 타입이 다른 여러 개의 함수로 구현하는 것 1 2 3 4 5 6 7 8 9 fun performCombat() { //... } fun performcombat (eneryName: String) { //... } fun performcombat (enemyName : string, isBlessed: Boolean) { // ... } 코틀린 컴파일러는 함수 호출시에 전달되는 인자의 개수와 타입의 일치되는 것을 알기 때문에 어떤 오버로딩 함수를 실행할지 알게됨 익명 함수와 함수 타입 익명 함수 말그대로, 이름이 없는 함수\n익명 함수 == 람다(lambda)\n다른 함수의 인자와 반환 가능\n익명 함수도 타입을 가질 수 있고, 이것을 함수 타입 이라고 한다\n함수의 타입을 컴파일러에게 알려 준다. 익명 함수를 변수화 할 수 있다.\n익명 함수는 익명 클래스 인스턴스로 생성된다.\n암시적 반환\n암시적으로 or 자동으로 함수 정의의 마지막 코드 결과를 반환한다. 람다에서 return 키워드는 사용이 금지되어 있음 어디로 복귀 되어야 하는지, 컴파일러는 알 수 없기 때문 하나의 인자만 받는 익명 함수의 매개변수 이름을 지정하는 대신 it 키워드를 사용할 수 있다.\n함수 타입 역시 타입 추론(type inference) 지원\n익명 함수가 값으로 지정되면 타입을 필수로 지정하지 않아된다. (당연히 해도 됨) 람다 (lambda) 익명 함수를 람다(lambda)라 부름 람다 표현식, 람다식: 익명 함수 정의 익명 함수의 반환 결과 : 람다 결과(lambda result) 어떤 함수에서 마지막 매개변수로 함수 타입을 받을때는 ()를 생략할 수 있다. \"Mississippi\".count ({ it == 's' }) \"Mississippi\".count { it == 's' } { it == 's' } 가 람다, 익명 함수 이다. 이것은 람다가 마지막 인자로 함수에 전달될 때만 가능, 따라서 함수 타입 매개변수를 마지막 매개변수로 선언하는 것이 좋다. inline 함수로 만들기 람다(익명 함수) 는 JVM에서 객체로 생성\n메모리 부담 인라인을 사용하면 람다의 객체 사용과 변수의 메모리 할당을 JVM이 하지 않아도 된다.\ninline 키워드를 추가하면, 람다가 객체로 전달 되지 않는다.\n컴파일러가 바이트 코드를 생성할 때, 람다 코드가 포함된 함수 몸체의 전체 코드를 복사한후, 함수를 호출하는 곧에 붙여 넣기 하여 교체 하기 때문\n하지만 재귀 함수는 무수히 많이 복사 됨으로, 코틀린 컴파일러는 재귀함수를 단순히 인라인 처리하지 않고, 루프 형태로 변경한다.\n함수 참조 람다를 사용해서 다른 함수의 인자로 함수를 전달하는 방법도 있지만, 다른 방법으로 함수 참조를 인자로 전달 함수 참조를 얻을 때는 함수 이름 앞에 :: 연산자를 사용한다. 매개변수에 적합한 이름 있는 함수가 있다면 람다 대신 함수 참조를 사용할 수 있다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 fun runsimulation(playerName: String, greetingFunction: (String, Int) -\u003e string) { val numBuildings = (1.3).shuffled().last() println (greetingFunction(playerName, numButlatngs)) } fun printConstructionCost(numBuildings: Int) { vaL cost = 500 println(\"건축 비용: sfcost * numBuildings}\") } fun main(args: Array\u003cstring\u003e) { runsimulation(\"김선달\", ::printConstructionCost) { playerName, numBuildings -\u003e val currentYear = 2019 \"simvitlage 방문을 환영합니다, SplayerName! (copyright scurrentyear)\" } } 반환 타입으로 함수 타입 사용하기 코틀린의 람다는 클로저(closure, close over) 이다.\n다른 함수에 포함한 함수(예를 들어, 람다) 에서 자신을 포함하는 함수의 매개변수와 변수를 사용할 수 있는 것을 말한다.\n람다(익명 함수)가 외부 변수의 참조를 갖는다.\n따라서 람다식은 자신이 포함된 외부 함수에 선언된 매개변수와 변수를 그냥 사용할 수 있다.\n외부 함수에 val 변수는 람다식에서 그 값이 바로 저장\nvar은 별도의 객체로 저장되며, 그 객체의 참조값이 람다식 코드에 저장되어 값을 변경할 때 사용\n다른 함수를 인자로 받거나 반환하는 함수를 고차 함수(higher-order function) 이라고 한다.\nfilter, map 등 코틀린에서는 익명 함수가 자신의 범위 밖에 정의된 변수를 변경하고 참조할 수 있다.\n람다가 외부의 변수를 포획한다는 의미 람다 vs 익명 내부 클래스 함수 타입을 사용하면 진부한 코드가 줄어들고 유연성이 증가한다.\n예를 들어, 자바 8과 같이 함수 타입을 제공하지 않는 언어 자바 8은 객체지향 프로그래밍과 람다 표현식을 모두 지원한다.\n그러나 함수의 매개변수나 변수 에 함수를 정의할 수 있는 기능이 없다. (함수의 변수화가 불가)\n대신에 자바는 익명 내부 클래스(anonymous inner cass) 를 제공\n이것은 단일 메서드(method)를 구현하기 위해 다른 클래스에 정의된 이름이 없는 클래스다.\n그리고 람다처럼 익명 내부 클래스를 인스턴스로 생성하여 전달할 수 있다.\n자바에서는 람다를 정의하는 함수를 나타내기 위해(변수화) 이름이 있는 타입(인터페이스나 클래스)의 정의가 추가로 필요하다\nnull 안전과 예외 코틀린의 null 처리 개요 nullable / non-nullable\n자바는 어떤 타입의 변수도 null 값을 가질 수 있다.\n코틀린은 non-nullable 변수는 null을 가질 수 없다. 따라서 런타임이 아닌 컴파일 시점에 방지 할 수 있다.\nnull이 필요 없다면 non-nullable 타입을 사용하는 것이 가장 안전하다.\n가능한 한, non-nullable 타입을 사용하자 에러 검출 시점(컴파일 vs 런타임) 코틀린은 컴파일러라는 특별한 프로그램에 의해, 기계어로 변환되는 컴파일 언어 이다. 런타임 에러는 프로그램이 실행된 이후에 발생된 에러임으로, 사전에 알려 줄 수 없다. null 안전 처리 안전 호출 연산자 → .?\nnon-null 단언(assertion) 연산자 → !!\nnull이면 런타임에 NPE 예외 발생 컴파일러가 null 발생을 미리 알 수 없는 상황이 생길 수 있을 때 사용된다. 프로그램의 오류가능성을 runtime에 예측하는 것은 거의 불가능하니, 조심해서 사용해야 함 값이 null인지 if 문 검사\n엘비스 연산자(null 복합 연산자) → ?:\nval beverageServed: String = beverage ?: \"맥주\"\n엘비스 연산자는 null이 될 수 있는 값을 바로잡는 데 사용될 수 있다.\n자바에서 @NotNull 어노테이션 → null 일 수 없다.\n코틀린 소스 코드가 컴파일되어 JVM의 자바 코드로 생성될 때, checkParameterIsNotNull 이라는 메서드가 사용됨. 자바로 역컴파일된 바이트코드를 보면 알 수 있다. 예외 던지기, Exception Throw 예외는 프로그램이 잘못되었다는 것을 나타낼때 사용 예외가 발생할 때는 그것을 처리해야 하며, 그렇지 않으면 실행이 중단(crash) 된다. 미처리 예외(unhandled exception): 처리되지 않은 예외 1 2 3 fun proficiencyCheck(swordsJuggling: Int?) { swordsJuggling ?: throw IllegalStateException(\"플레이어가 저글링을 할 수 없음!) } throw : 예외를 발생 시킨다. === 예외를 던진다\n실행전에 처리되어야 하는 문제를 알려 주기 위해 예외를 던진다.\nCrash 되는 이유를 명확히 알 수 있음\nstackTrace, message 예시에서, swordsJuggling 변수가 null 이되는 경우가 생긴다면, 개발하는 시점에 알 수 있는 가능성이 커진다.\n커스텀 예외 : 예외를 상속 받은 클래스, 코드 유연성 증가, 재사용성 증가, 에러 메서지 출력 가능\n예외 처리 가이드 논리 오류: 프로그램이 강제 종료되지도 않고 의도대로 동작하지도 않는 상황\n예외가 던져지지 않으므로 런타임에 발생하는 RuntimeException과는 다른 상황\n기존에는 예외가 던져지지 않았기에, 이런 경우에 예외를 던져보자 기본적으로 일단, 최대한 논리 오류가 태초에 발생 하지 않도록 만들어야 함\n그럼에도 불구하고, 논리 오류가 발생하는 경우에 예외를 던져야 함\n논리 오류는 에러 원인을 예측하기 어렵기 때문에 디버깅이 굉장히 어렵다.\nEx) 양수여야 하는 값이 음수인 경우\n논리 오류일 때만 예외를 던지세요.\n논리 오류가 아니면 예외를 던지지 말고, null을 반환하세요.\n실패하는 경우가 복잡해서 null로 처리할 수 없으면 sealed class를 반환하세요.\n성공, 실패들을 모두 sealed class로 선언해보세요. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class IdentityNumber(private val numbers: List\u003cInt\u003e) { companion object { fun from(front: List\u003cInt\u003e, back: List\u003cInt\u003e): IdentityNumberResult = when { front.size != 6 -\u003e IdentityNumberResult.InvalidFrontSize back.size != 7 -\u003e IdentityNumberResult.InvalidBackSize else -\u003e IdentityNumberResult.Success(IdentityNumber(front + back)) } } } sealed class IdentityNumberResult { data class Success(val identityNumber: IdentityNumber) : IdentityNumberResult() object InvalidFrontSize : IdentityNumberResult() object InvalidBackSize : IdentityNumberResult() } 일반적인 코틀린 코드에서 try-catch, runCatching()를 사용하지 마세요.\n예외는 반드시 예외적인 상황에서만 던져야 합니다.\n‘논리 오류일 때만 예외를 던지세요.’\n논리 오류일 때 던지는 예외를 포함해서, 프로그램 전체적으로 발생하는 예외들을 전역적으로 처리해주는 예외 처리기를 통해 보고해야 합니다.\n예시) 예상 가능한 네트워크 예외 처리에 대한, CoroutineExceptionHandler 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class PositiveNumber private constructor(val value: Int) { companion object { fun from(value: Int): PositiveNumber? { if (value \u003c= 0) return null return PositiveNumber(value) } }} class PositiveNumberTest { @Test fun `음수로는 만들 수 없다`() { // when val actual = PositiveNumber.from(-1) // then assertNull(actual) }} 생성자를 사용할 수 없도록 private으로 숨기고 from() 팩토리 함수를 추가하였습니다. 이렇게 하면 외부에서는 반드시 from() 함수를 통해서만 PositiveNumber를 만들어야 하고 만약 음수라면 null이 반환됩니다. 이 방식에서는 음수로 양수(PositiveNumber)를 만든다는 논리 오류 자체가 발생할 수가 없습니다. 예외 처리 try / catch\ntry문에서는 예외가 발생될 수 있는 코드를 넣는다.\ncatch문은 예외가 생길 때만 실행\ncatch 문에서는 처리할 예외의 특정 타입을 인자로 받는다\n코틀린에서의 예외는 unchecked 예외,\n예외를 생길 수 있는 모든 코드를 컴파일러가 try / catch문으로 처리하도록 강제하지 않는다. (자바는 checked, unchecked가 구분되어 있다.) 전제 조건 전제 조건 함수: 일부 코드가 실행되기 전에 충족되어야 하는 전제 조건을 정의한 함수 checkNotNull, require, requireNotNull, error, assert\n안전하게 코드 작성 가능\nnull 무엇이 좋을까? 값을 지정하지 않고 변수를 초기화 할 수 있다.\nnull으로 상태(State) 를 표시함 변수의 초깃값에 많이 사용 NPE를 피하는 방법\nempty 값을 통해 더 좋고 안전한 코드 초기화를 할 수 있다.\nnull 불가 타입으로 지정하고, 빈 문자열(\"\")로 초기화 null이 될 수 있다는 것을 인정하고, null 가능 타입의 처리 방법들 을 사용\nvar personName: String? = \"\" checked 예외와 unchecked 예외 코틀린에서는 모든 예외가 unchecked 예외다.\n즉, 예외가 생길 수 있는 모든 코드를 우리가 try / catch로 반드시 처리하도록 강요하지 않음 자바는 checked와 unchecked 예외 타입이 구분되어 있다.\nchecked 예외의 경우, 예외 처리를 했는지를 컴파일러가 검증함 대부분의 checked 예외(예를 들어, 파일을 저장, IOException) 는 발생했더라도 우리가 특별히 할 것이 없다.\n따라서 개발자들이 해당 예외의 catch 블록 안에 처리 코드를 작성하지 않는 경우가 있다\n예를 들어, catch (e: IOException) { } 해당 checked 예외가 무시되고(경보가 울렸는데 무시하는 것과 같다) 프로그램은 정상적으로 수행된다. 원인을 찾기 어려워짐\nchecked 예외는 문제를 해결하기 보다는 오히려 더 많은 문제를 야기할 수 있다.\n코드 중복, 어려운 에러 복구 로직, 예외 무시 문자열 해체 선언 (destructing declaration) val (type, name, price) = menuData.split(',')\n문자열은 불변이다. 코틀린의 모든 문자열(String 타입)은 val or var 중 어느 것으로 정의되든 자바처럼 불변이다. replace 처럼 값을 변경하는 것 처럼 보이는 어떤 함수도 실제로는 새로운 문자열로 변경값을 생성한다. 문자열 비교 참조 동등 : 특정 타입 인스턴스의 참조를 똑같이 갖는지 검사한다. heap 메모리 영역에 같은 객체를 참조하는지 검사한다. (=== 연산자) 자바에서는 == 연산자가 두 문자열의 참조를 비교하므로 코틀린과 다르다. 자바에서 문자열의 값을 비교할때는 equals 메서드를 사용해야 한다. 비교 연산 Kotlin Java 동등성(Equality, Structural equality) == equals 동일성(Identify, Referential equality) === == 자바, 코틀린 모두 원시 타입인 경우 동등성 비교는 == 으로 같은 연산자를 사용\n참조 타입일 때만, 달라짐\n구조적 동등성, Equality 비교 (==, !=)\n기본 타입인 경우: 값 비교, 값의 동등성 비교\n참조 타입인 경우: equals() 로 객체의 내용 비교\n==는 내부적으로 equals를 호출한다. (연산자 오버라이딩 기능) 참조 동등성, Identify 비교 (===, !==))\n객체의 메모리 주소를 비교\n코틀린은 자바에는 없는 ===연산자를 지원한다.\n즉, 자바의 주소 값 비교인 ==와 코틀린의 ===가 동일한 역할을 한다.\n1 2 3 4 5 6 7 8 9 10 int a = 1 // 원시 타입 int b = 2 int c = 1 System.out.println(a == b) // false System.out.println(a == c) // true String a = \"hi\" // 주소값 : 1번지, 참조 타입 String b = \"hi\" // 주소값 : 2번지 System.out.println(a == b) // false, Idenrify 비교 System.out.println(a.equals(b)) // true, Equality 비교 1 2 3 4 5 val a: String = \"hi\" val b: String = \"hi\" println(a === b) // false, Idenrify 비교 println(a == b) // true, Equality 비교 숫자 Byte (8비트)\nShort (16비트)\nInt (32비트)\nLong (64비트)\nFloat (32비트)\nDouble (64비트)\n숫자에는 정수와 소수가 있다.\n문자열을 숫자 타입으로 변환하기 toFloat, toDouble, toLong, toIntOrNull val gold: Int = \"5.91\".toIntOrNull ?: 0 소수 소수점값을 구하려면 코틀린이 부동 소수점 연산을 해야 한다.\n위치가 달라질 수 있는 소수점을 의미하는 부동 소수점은 실수의 근사치이며, 정밀도와 성능 모두를 지원하기 위해 근사치를 사용한다.\n%.2f.format(~~~) : 소수점 이하 두 자리 형식\nDouble 타입에 toInt 를 호출하면, 소수점 이하 값이 절삭되어 정수로 변환된다. (4.91.toInt → 4) 표준 함수 (범위 지정 함수) 코틀린의 표준 함수(범위 지정 함수) 는 내부적으로 확장 함수이며,\n확장 함수를 실행하는 주체를 수신자 또는 수신자 객체, 수신 객체, receiver 라고 한다.\n표준 함수(범위 지정 함수) 는 람다를 인자로 받아 동작한다.\n인자로 받은 block 변수(함수)를 실행 수신 객체라는 용어는 Kotlin의 확장 함수에서 등장한다.\n확장 함수에서 this는 확장된 클래스의 객체, 즉 확장 함수를 사용하는 그 객체가 된다.\n그 객체가 바로 수신 객체(Receiver object)이고,\n확장할 클래스가 수신 객체 타입(Receiver Type)\n수신: ‘(수신) 객체가 코드를 받는다.’\n수신 객체 지정 람다 (Lambdas with Receivers) 수신 객체 지정 람다는 람다에 확장 함수 처럼 수신 객체를 사용한 것이다. T.() -\u003e R\n확장 함수에서 수신 객체를 사용하여 블록 내에 객체를 전달했듯이,\n수신 객체 지정 람다(Lambdas with Receivers) 또한 수신 객체를 이용하여 객체를 전달한다. 따라서 수신 객체 지정 람다에서는 수신 객체를 this로 대신할 수 있다.\n또한 this를 생략하고 해당 객체의 멤버에 바로 접근이 가능하다.\n반면 일반 람다는 객체를 인자(파라미터) 로 전달한다. (T) -\u003e R\t람다의 매개변수가 하나뿐이고, 컴파일러가 타입을 추론할 수 있을 때 객체는 기본 매개변수인 it으로 받을 수 있다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 inline fun \u003cT\u003e T.apply(block: T.() -\u003e Unit): T { block() return this } inline fun \u003cT, R\u003e T.run(block: T.() -\u003e R): R { return block() } inline fun \u003cT, R\u003e with(receiver: T, block: T.() -\u003e R): R { return receiver.block() } inline fun \u003cT\u003e T.also(block: (T) -\u003e Unit): T { block(this) return this } inline fun \u003cT, R\u003e T.let(block: (T) -\u003e R): R { return block(this) } apply 수신자 객체의 참조 가능\nthis로 참조, this 생략 가능 람다의 실행이 끝나면 현재의 수신자 객체가 반환된다.\nrun apply와 다르게 run은 수신자 객체를 반환하지 않는다. 람다의 결과, 마지막 코드 줄의 실행 결과를 반환한다. 함수 호출이 여러 개 있을때 함수 중첩 보다 run을 사용하면 편리하다. \"~~~\".run(::myFun) = myFun(\"~~~\") with run 과 동일하게 동작하지만 호출 방식이 다르다.\n수신자 객체를 첫 번째 매개변수의 인자로 받는다.\nwith 대신 run을 사용할 것을 권한다.\n잘 사용 안됨 also let 처럼 자신을 호출한 수신자 객체를 람다의 인자로 전달한다. let과 달리, 람다의 결과를 반환하지 않고, 수신자 객체를 반환한다. let 수신 객체를 람다의 인자(파라미터) 로 전달\n전달된 람다를 실행한 후, 마지막 코드 줄의 실행 결과를 반환해준다.\nnull check 후 코드를 실행해야 하는 경우\n안전 호출 연산자 → .? ‘?.let’을 사용 하게 되면 let의 block은 수신객체가 null이 아닐 때만 수행된다. 따라서 let block에서의 it의 타입은 nullable하지 않은 타입이 된다. (스마트 캐스팅) nullable한 수신객체를 다른 타입의 변수로 변환해야 하는경우\n1 2 3 4 var person: Person? = null val isReserved = person?.let { it: Person -\u003e reserveMovie(it) } List, Set, Map 컬렉션은 연관된 값들을 모아서 저장하고 사용하는 자료구조 List, Map, Set이 있다. 컬렉션에 저장된 각각의 데이터를 element (요소) 라고 한다. 코틀린에서는 mutable(변경 가능한) 타입과 read-only(읽기 전용) 타입이 있다. 코틀린 컬렉션은 가변성 개념을 제공하면서, 강력한 기능을 제공 List List 에서\nmyType: 매개변수화 타입, 요소의 타입이 myType이라는 것을 알려줌. List은 제네릭 타입 이다. ⇒ List는 어떤 타입의 데이터도 저장할 수 있다\nlistOf 함수: 컬렉션 자체를 생성 하고, 데이터 추가 하는 일을 둘 다 하는 함수\n안전한 인덱스 사용 : getOrElse, 예외 대신 기본값을 반환 / getOrNull 와 :? 사용\ncontainsAll : 요소가 존재하는 지 한 번에 확인할때 사용\nList의 변경 가능 여부는 List의 타입에 의해 결정\n‘변경 가능(mutable)’ 은 저장된 요소를 변경할 수 있다는 것을 의미한다. List 타입은 read-only 이다. 변경 가능 ⇒ MutableList 타입을 사용해야 함, add, remove 사용 가능\ntoList \u003c=\u003e toMutableList 으로 상호 변경 가능\n반복 처리 in 키워드 : for 루프에서 반복 처리되는 객체를 나타낸다.\nitertation(반복 처리) 가능\nfor 루프로 요소의 이름을 지정하면, 코틀린 컴파일러가 타입을 알아서 처리 Iterable 타입은 반복 처리를 지원한다.\nList, Set, Map, IntRange 해체 선언 List는 또한, 맨 앞의 다섯 개 요소까지 변수로 해체 할 수 있는 기능을 제공한다. 해체를 원하는 않는 요소에 _(밑줄)을 사용해서 선택적으로 해체할 수도 있다. Set 수학의 집합처럼 요소가 고유한 것을 보장해 주는 컬렉션\n인덱스와 인덱스 연산자([])를 사용해서 요소를 처리할 수 없다.\nelementAt 함수를 사용해서 특정 인덱스의 요소를 요청 할 수 있다. 한 번에 하나의 요소를 반복해서 읽는다. (반복 처리 가능, itertation) 따라서, 인덱스 연산자 보다 느리다 순서를 갖지 않는다.\n‘값’ 이 고유하다.\nArray, 배열 타입 코틀린은 참조 타입밖에 없다. (컬렉션도 참조 타입)\n자바에서는 Array을 기본(원시) 타입으로 지원\n코틀린에서 기본 타입이 아닌 Arrays 라는 참조 타입으로 배열을 지원한다.\nval playerAges: IntArray = IntArrayOf(34, 23, 12) Kotlin에서 Arrays는 참조 타입이지만, 특별한 배열 타입을 통해 기본 타입 배열과 유사한 기능을 제공 내부적으로 원시 타입 값을 저장하여 메모리 사용량을 줄이고 성능을 향상 코틀린의 (특별한) 배열 타입(IntArray, ByteArray, BooleanArray) IntArray 타입은 자바의 기본 타입(배열 타입) 으로 컴파일 된다.\n코틀린 컬렉션을 자바의 기본 배열 타입으로 변환 가능\ntoIntArray val array1 = arrayOf(1, 2, 3) , val array2 = Array(5) { it }\n자바로 디컴파일 후 확인: @NotNull final Interger[] array1; val array1 = intarray(1, 2, 3) ,val array2 = IntArray(5) { it }\n자바로 디컴파일 후 확인: @NotNull final int[] array1; 1 2 3 4 5 6 7 8 9 10 11 // 일반 객체 배열 val numbers: Array\u003cInt\u003e = arrayOf(1, 2, 3) val strings: Array\u003cString\u003e = arrayOf(\"hello\", \"world\") // 기본 타입 배열 val intNumbers: IntArray = intArrayOf(1, 2, 3) val booleanValues: BooleanArray = booleanArrayOf(true, false, true) // 가변 배열 val mutableArray = Array(5) { 0 } // 0으로 초기화된 크기 5의 배열 mutableArray[0] = 1 읽기 전용 vs 변경 불가능 불변은 ‘변경 불가능’ 을 의미 따라서 코틀린 컬렉션은 ‘읽기 전용’이 더 어울림. 1 2 3 4 5 6 7 8 val x = listOf( mutableListOf(1, 2, 3) ) x[0].add(4) // x = list( mutableListOf(1, 2, 3, 4) ) var myList: List\u003cInt\u003e = listOf(1,2,3) (myList as MutableList)[2] = 1000 println(myList) // [1, 2, 1000] Map 키와 값의 쌍의 데이터 (entry 라고 한다.) iteration 반복 처리 지원 정수 인덱스 기반 처리 대신 키를 기반으로 데이터 처리 to 함수로 키와 값을 정의한다. getValue, [ ], getOrElse, getOrDefault ‘키’ 가 고유하다. 클래스 정의하기 클래스는 사물이나 개념을 추상화 한 프로그래밍 요소이다.\n속성(property)과 기능(function) 을 갖는다.\n행동(역할)과 데이터를 정의한다.\nOOP의 핵심 요소 default가 public\n인스턴스 생성하기 생성자(constructor) 를 호출하여 인스턴스를 생성한다. 함수 호출과 비슷 가시성 제한자 클래스 함수나 속성의 가시성을 제한 하는 개념을 OOP에서 정보은닉, 캡슐화라 한다.\npublic : 클래스 외부에서 클래스 요소 사용가능\nprivate : 클래스 내부에서만 요소 사용 가능\nprotected : 클래스 내부 or 클래스의 서브 클래스에서만 사용될 수 있다\ninternal : 클래스가 포함된 ‘모듈(module) ’에서 사용될 수 있다\n속성(프로퍼티) 프로퍼티는 클래스의 데이터 즉, 상태나 특성을 나타낸다.\n변수와 다르게 클래스 속성은 반드시 초깃값이 지정되어야 한다.\n인스턴스가 생성될 때 모든 속성이 값을 가져야 한다. 다른 함수나 프로그램에서 이 클래스의 속성에 접근할 수 도 있기 때문 속성(프로퍼티)의 getter와 setter 프로퍼티를 외부에서 사용할때, 코틀린은 자동으로 getter를 통해 가져오고, setter를 통해 값을 지정한다.\n정의한 각 속성에 대해 field와 getter or setter 가 생성된다.\ngetter 에서는 속성값을 읽는 방법이 명시된다.\n커스텀 getter, setter를 정의할 수 있다. ⇒ getter, setter를 overriding\n커스텀(override) 하지 않으면, 기본으로 생성되는 속성값을 있는 그대로 반환 및 지정 field 키워드는 프로퍼티에 대해 코틀린이 자동으로 관리해주는 backing field 를 참조한다.\nfield 키워드는 getter, setter에서만 사용할 수 있다.\nbacking field 는 getter, setter가 사용하는 프로퍼티의 데이터다.\ngetter는 backing field를 변경하지 않는다. setter는 backing field를 변경한다.\n프로퍼티는 외부에 노출시키되(public), setter는 노출시키지 않으려면 private set 으로 따로 정의도 가능하다.\n기본적으로 getter, setter 의 가시성은 속성 자체의 가시성과 일치 getter는 프로퍼티를 참조할 때 자동 호출\nsetter는 대입 연산자(ex. =)를 사용해서 속성에 값을 지정할 때 자동 호출\n1 2 3 4 5 var name = \"tae\" get() = field.capitialize() private set(value) { field = value.trim() } 산출 속성(computed property) 다른 속성이나 변수 등의 값을 사용해서 자신의 값을 산출하는 속성, backing field 생성하지 않음. 초깃값이나 기본값이 없다 1 2 3 4 class Dice() { val rolledValue get() = (1..6).shuffled().first() } 이런 경우에서도 볼 수 있듯, ‘변경 불가능’ 보다 ‘읽기 전용’ 이라는 표현이 더 적합 패키지 사용하기 Ex) com.myProject.presentation.music\n패키지(package) 는 폴더 처럼 비슷한 요소들을 분류하고 모아 놓은 것이다.\n프로그램에서 직접 패키지를 지정할 때는 package 키워드를 사용한다.\n지정된 .kt 파일이 컴파일되면, 생성된 바이트코드 파일(.clsas) 는 정의한 패키지 경로에 위치하게 된다.\n같은 패키지에 있는 클래스들은 기본적으로 같이 사용할 수 있다.\n단, 코틀린 표준 라이브러리의 모든 클래스나 함수 등은 import를 지정하지 않아도 바로 사용 가능 다른 패키지에 있는 클래스나 함수 등을 사용하려면 import 문을 사용해서 그것들의 위치를 컴파일러에게 알려주어야 한다.\n경합 상태(race condition) 1 2 3 4 5 6 7 8 9 10 11 12 class Weapon(val name: String) class Player { var weapon: Weapon? = Weapon(\"Ebony Kris\") fun printweaponName() { if (weapon != null) { println(weapon.name) // Weapon 타입으로 스마트 캐스팅 할 수 없는 컴파일 에러 } } } fun main(args: Array\u003cstring\u003e) { player().printWeaponName() } 컴파일러는 변수가 null이 아님이 if문 등으로 확인되더라도,\n경합 상태가 생길 수 있기 때문에(여러 개의 스레드로 실행될 가능성 존재) 스마트 캐스팅이 할 수 없고, 컴파일 에러를 알려준다. weapon의 값이 if로 확인된 시점과 println으로 weapon의 name을 출력하는 시점 사이에 weapon 이 null로 변경될 가능성이 여전히 있다. =\u003e 스마트 캐스팅 불가\n1 2 3 4 5 6 class Player { // 해결법 var weapon: Weapon? = Weapon(\"Ebony Kris\") fun printweaponName() { weapon?.also { print(it.name) } } } also를 사용하면 해결 가능 also 익명 함수 내에서만 존재하는 지역변수 it 으로 weapon 인스턴의 name 속성이 참조되기 때문 ?.로 null이 아님이 확인 되었고, it의 값은 프로그램의 다른 코드에서 변경불가능 함 컴파일러가 Weapon 타입으로 스마트 캐스팅 가능 패키지 가시성 자바는 기본적으로 패키지 가시성을 사용한다.\n같은 패키지에 있는 클래스에서만 사용 가능하다. 코틀린에서는 패키지 가시성이 없다.\n같은 패키지에 있는 클래스, 함수, 속성 등은 기본적으로 상호 사용가능하기 때문에 굳이 별도의 패키지 가시성을 가질 필요가 없기 때문이다. 모듈은 독자적으로 실행 및 테스트될 수 있는 프로그래밍 구성 단위\n코틀린은 internal 가시성을 지원한다. 자바는 지원하지 않음\n바이트코드 파일에서 internal은 public이 된다.\n초기화 클래스의 인스턴스를 생성하는 것은, 클래스에 정의된 속성을 구조로 갖는 객체를 메모리에 할당하는 것 기본 생성자 커스텀하지 않고, 자동으로 생성되는 기본 getter와 setter를 사용하는 속성의 경우에는,\n클래스 내부에 속성을 따로 정의하지 않고 기본 생성자에만 정의해도 된다. 기본 생성자에 정의된 변수는 클래스 속성과 생성자 매개변수 두 가지 역할을 하게 된다.\n기본 생성자에 속성을 정의할 때는 var, val을 추가해야 한다.\n1 2 3 4 5 6 7 class Player(_name: String, _health: Int) { val name = _name } class Player(private val name: String, var health: Int = 100) { } 보조 생성자 1 2 3 4 5 6 7 8 9 10 11 12 13 class Player(_name: string, val health: Int) { val race = \"DWARF\" val alignment: String init { require(health \u003e 0, {\"health는 양수여야 한다\"}) println(\"initializing player\") alignment =\"GOOD\" } constructor (_name: String) : this(_name, 100) { race = \"The Shire\"' } } 말 그대로, 기본 생성자에 정의된 속성을 다양하게 초기화하는 보조 역할을 수행\n보조 생성자에서는 클래스 속성(프로퍼티) 를 정의할 수 없다.\n속성은 기본 생성자 or 클래스 몸체에서 정의되어야 한다. this 키워드는 보조 생성자를 사용해서 생성되는 클래스 인스턴스의 기본 생성자를 뜻한다.\n초기화 블록 (init) 전제 조건 검사는 초기화 블록에서 주로 한다.\n생성자에 전달되는 인자가 적합한지 확인 require 문을 주로 사용 초기화 블록은 어떤 생성자가 호출되든 클래스 인스턴스가 생성될 때 마다 자동으로 호출되어 실행된다.\n속성을 초기화하는 코드가 복잡하다면, init 에 초기화 코드를 넣는 것도 가능하다.\n속성(프로퍼티) 초기화 속성(프로퍼티)은 정의된 타입으로 반드시 초기화되어야 한다. 초기화 순서 기본 생성자에 정의된 속성에 인자값 지정\n클래스 내부에 지정된 속성에 초깃값 저장\n초기화 블록(init) 실행\n보조 생성자 실행\n초기화 지연시키기 클래스 속성은 non-nullable 변수가, null이 아닌 값으로 초기화된 다는 것을 보장하기 때문에, 초기화는 중요하다.\n기본 타입(ex. Int) 이 아니고, 다른 객체를 참조하는 속성의 경우 ‘지연 초기화(lateinit)‘가 가능하다.\n다른 객체를 참조하는 속성의 경우, 생성자가 호출되는 방법과 시점은 우리가 제어할 수 없는 경우가 있기 때문에 Ex) 외부 프레임워크에서 초기화되는 경우, 안드로이드의 뷰 속성 lateinit 키워드는 개발자가 해당 속성을 사용하기 전에 초기화해야 된다는 것을 의미한다.\n개발자가 스스로 책임지고, 해당 속성을 사용하기 전에 초기화해야 된다는 것을 뜻함\n‘지연 초기화’\nisInitialized 함수는 속성이 초기화 되었는지 검사해준다.\nif (::alignment.isInitialized) 속성의 값이 아닌 참조를 전달해야 함으로 :: 를 붙임 클래스 인스턴스의 생성 시점에서 속성을 초기화 할 수 없다면, 지연 초기화를 사용해야 하고, lateinit 키워드를 사용해서 이를 나타낸다.\nlateinit\n기본 타입이 아니여야 함 다른 타입의 객체 참조 때문에 var non-nullable이어야 한다. 커스텀 getter, setter 정의 불가하고, 기본으로 생성되는 getter, setter 사용해야 하 lateinit 대신 nullable 타입으로 변수 선언하고, 변수에 null으로 초기화도 가능하긴 한데, null 체크를 개발자가 계속 해야 한다.\nvar tmp: String? = null lateinit은 클래스 속성 뿐만 아니라 최상위 수준 속성과 함수의 지역 변수에서도 사용 가능하다.\n늦 초기화 (lazy initalization) ‘지연 초기화’ 만이 초기화를 지연시킬 수 있는 유일한 방법은 아니다.\n변수나 속성이 ‘최초’ 사용될 때까지 초기화를 ‘연기’ 할 수도 있다.\n속성을 즉시로 사용할 필요가 없다면 ‘늦 초기화’가 좋은 선택이 된다.\n늦 초기화는 코틀린에서 delegation(위임) 패턴을 사용해서 구현한다. lazy 함수 를 대리자로 위임 처리 한다. lazy 함수는 람다를 인자로 받아 실행 시켜준다. lazy 함수와 람다로 초기화 후에 이후에는 다시 초기화되지 않고, 캐시에 저장되 결과가 사용된다. val homtTown by lazy { myFun() }\nby 키워드를 사용해서, 위임받은 일을 처리하는 대리자(delegate) 를 지정한다\n대리자로 커스텀 함수 또는 코틀린 표준 라이브러리의 함수를 사용할 수 있다. 컴파일러는 소스 코드상의 초기화 순서를 검사하지 않는다.\n속성을 사용하는 함수의 순서를 비교하지는 않는다. 상속 서브 클래스(자식 클래스) 는 상속해 주는 클래스의 모든 속성과 함수를 공유한다.\n상속해 주는 클래스를 부모 클래스 또는 슈퍼 클래스라고 한다. open 키워드를 붙혀서 서브 클래스를 가질 수 있게 해야 한다.\n상속 받은 속성과 함수를 그대로 사용하지 않고, overrideing 할 수도 있다.\n이때 override 하는 함수에도 open 키워드 사용해야 한다. super 키워드를 사용해서, 부모 클래스 함수 or 속성을, 자식(서브) 클래스에서 호출 or 접근 할 수 있다.\n슈퍼 클래스의 public, protected 속성과 함수를 사용할 수 있다. 슈퍼 클래스로 타입을 선언하면, 어떤 서브 클래스 인스턴스도 참조 할 수 있다. ⇒ 다형성\n서브 클래스는 기본적으로 open이 되므로, 서브 클래스의 서브 클래스는 언제든 override 할 수 있다.\n코틀린에서는 클래스가 정의될 때 기본적으로 서브 클래스를 만들지(상속 되게) 못하게 되어 있다.\nfinal 키워드: 키워드를 붙인 함수 or 속성만, override 될 수 없게 함.\n타입 검사 is 연산자로 객체가 특정 타입인지 검사할 수 있다.\n자식 클래스의 인스턴스는 해당 자식 클래스의 타입이면서 동시에 부모 클래스의 타입도 된다.\n사자 인스턴스는 사자 타입이면서 동시에 동물 타입이다. 코틀린 타입의 상속 계층 코틀린의 모든 non-nullable 클래스는 자동으로 Any라는 최상위 슈퍼 클래스로 부터 상속 받는다.\nAny는 자바의 모든 클래스가 java.lang.Object의 서브 클래스인 것과 비슷하다. as 연산자 : 상속 관계가 있을 때, 타입 변환에 사용\n변환된 타입의 속성 참조나 함수 호출을 할 수 있는 것이지 해당 객체가 갖는 값을 변환하는 것은 아니다. 두 타입 간에 상속 관계가 없으면 타입 변환은 불가능\n스마트 캐스팅 코틀린 컴파일러가 특정 조건에서 명시적 캐스팅이 아닌, 자동으로 타입 변환을 수행하는 것 간결성, 가독성, 안전성 직접 변환하지 않아도 스마트 캐스팅이 일어나면, 컴파일러는 해당 타입으로 간주한다. (컴파일 에러 안남) non-nullable 타입은 nullable 타입의 자식(서브) 타입이다. JVM 애플리케이션으로 컴파일하면 Any 클래스는 java.lang.Object로 바이트 코드에 구현되지만, 다른 플랫폼을 대상으로 컴파일하면 해당 플랫폼에 맞게 다른 형태로 구현된다. Any 클래스 1 2 3 4 5 public open class Any { public open operator fun equals(other: Any?): Boolean public open fun hashCode() : Int public open fun tostring(): String } 모든 클래스의 부모 클래스\n기본 메서드 제공: Any 클래스는 다음과 같은 기본 메서드를 제공합니다.\nequals(other: Any?): Boolean: 객체의 동등성을 비교합니다. hashCode(): Int: 객체의 해시 코드를 반환합니다. toString(): String: 객체의 문자열 표현을 반환합니다. 해당 타입에 맞게 오버라이딩해서 구현하라는 의미\n확장 함수 활용: Any 클래스는 확장 함수를 통해 다양한 기능을 추가할 수 있습니다. 예를 들어, to() 함수를 사용하여 Pair 객체를 생성할 수 있습니다.\n다양한 플랫폼에 독립적인 애플리케이션을 생성할 수 있게 해주는 방법 중 하나다.\n즉, 각 플랫폼에 공통적으로 사용할 수 있는 최상위 슈퍼 클래스인 것이다.\n코틀린 프로그램을 JVM 애플리케이션으로 컴파일하면 Any 클래스가 java, Lang.object로 바이트 코드에 구현됨\nPC 운영체제의 JVM에서 실행되는 애플리케이션 다른 플랫폼을 대상으로 컴파일하면 해당 플랫폼에 맞게 다른 형태로 구현된다.\nJVM 없이 실행되는 네이티브 App, 웹 브라우저에서 실행되는 자바스크립트, 안드로이드 App 따라서 우리 코드에서는 최상위 슈퍼 클래스가 Any라고 생각하고 사용하면 된다.\n코드가 실행된 각 플랫폼에서 Any가 어떻게 다르게 구현되는지 자세히 알 필요 없기 때문이다.\n객체 object 키워드 싱글톤은 하나의 인스턴스(객체)만 메모리에 생성되는 것을 말한다.\n코드의 정의된 곳에 생성되어 동작하며, 다른 클래스 내부에 포함시켜 사용할 수 있다.\n멀티 스레드로 실행될때는 반드시 하나의 객체만 생성되도록 동기화 처리를 해야 한다.\n최초 사용 시점에 하나만 생성되어, 계속 유지됨\n일반 클래스처럼 속성과 함수가 포함될 수 있고, 최초로 사용될 때 초기화 된다.\nobject 키워드를 사용하여 정의된 객체는 JVM에서 로드될 때 즉시 초기화되며, 이 때 쓰레드 안전(thread-safe) 하게 초기화됩니다. =\u003e 동기화 문제 해결\n객체 선언(object 키워드) 에도 일반 클래스처럼 속성과 함수가 포함될 수 있다. 그리고 이런 속성이나 함수가 최초로 사용될 때 비로소 해당 객체가 생성되고 초기화된다.\n객체 표현식 기존 클래스의 서브 클래스를 원하는 코드 안에 ‘이름 없이’ 정의 하고 바로 인스턴스를 생성해서 사용하는 경우 편하게 사용된다. annonymous 클래스 (익명 클래스) 라고 한다. 1 2 3 val anyClassInstance = object : ParentClass() { override fun load() = \"~~~\" } 익명 클래스는 ParentClass 의 자식 클래스임으로, 속성과 함수를 상속 받는다.\noverride 및 새로운 속성 및 함수 추가 가능하다. 'anyClassInstance'인스턴스는 싱글톤 객체가 됨으로,\n함수 내부에서 사용될 때는, 매번 인스턴스가 생성될 수 있기 때문에 사용시 유의해야 한다. 동반 객체 (companion object) 최상위 수준에서는 사용할 수 없고, 클래스 내부에서 정의하여 사용한다. 클래스 내부에 정의된 객체 선언(object) 하나의 클래스에서는 하나의 동반 객체만 포함될 수 있다. 클래스의 인스턴스가 얼마나 많이 생성되던, 동반 객체의 인스턴스는 하나만 생긴다. 중첩 클래스 다른 클래스 내부 안에 정의된 클래스, nested class 중첩된 클래스의 인스턴스는 외곽 클래스의 인스턴스가 생성되어야 사용할 수 있다. 외곽 클래스는 중첩 클래스의 속성과 함수를 사용할 수 있다. Nested Class는 외부 클래스의 인스턴스에 대한 참조를 가지지 않으며, 외부 클래스의 멤버에 직접 접근할 수 없습니다. 1 2 3 4 5 6 class OuterClass { private val outerValue = \"외부 클래스 값\" class NestedClass { // outerValue에 접근 불가 } } 내부 클래스 (inner class) Kotlin의 inner 키워드를 사용하여 선언된 클래스를 Inner Class(내부 클래스)라고 합니다. 자신을 감싸고 있는 외부 클래스(Outer Class)의 인스턴스에 대한 참조를 암시적으로 가지고 있습니다. nested class와 다름 암시적으로 참조하므로, 메모리 누수에 주의해야 합니다. Inner Class는 외부 클래스의 인스턴스 없이 생성할 수 없습니다. 1 2 3 4 5 6 7 8 class OuterClass { private val outerValue = \"외부 클래스 값\" inner class InnerClass { fun accessOuter() { println(outerValue) // 외부 클래스의 private 멤버 접근 가능 } } } data class 주로 데이터를 표현하는 객체를 간편하게 생성, 저장, 표현하기 위해 사용됩니다.\n일반 클래스와 달리 데이터 클래스는 컴파일러가 자동으로 몇 가지 유용한 메서드를 생성해줌\nJVM은 객체를 고유하기 관리하기 위해 해시 코드 값을 생성함\n인스턴스끼리 각 속성(프로퍼티) 의 값을 비교 (equals 함수)\nEquality, 동등성 연산에서 사용 인스턴스를 컬렉션(Ex. Map)에 저장할 때 사용할 키 값인 해시 코드를 생성 (hashCode 함수)\nhash와 관련된 연산을 할 때 사용 객체를 문자열로 나타내는 기능 (toString 함수)\n해체 선언 함수 (componentN 함수)\n기존 인스턴스(객체)의 속성값을 변경하여 새로운 인스턴스를 생성하는 (copy 함수)\n얕은 복사; Shallow Copy: copy() 메서드는 기본적으로 얕은 복사를 수행합니다. 원본 객체와 같은 참조를 공유합니다. 따라서 참조 타입 프로퍼티를 변경하면 원본 객체에도 영향을 미칠 수 있습니다.\ncopy() 를 사용하면 원시 타입 프로퍼티는 값 복사(Value Copy) 를 통해 새로운 객체에 복사됩니다.\ncopy() 를 사용하면 참조 타입 프로퍼티는 참조 복사(Reference Copy) 를 통해 새로운 객체에 복사됩니다.\n깊은 복사; Deep Copy: 새로운 객체 생성, 이는 코틀린에서 개발자가 직접 구현해야 합니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 data class Address(var city: String) data class Person(val name: String, val address: Address) // 참조 타입 복사 val address = Address(\"Seoul\") val person1 = Person(\"Alice\", address) val person2 = person1.copy() person2.address.city = \"Busan\" // person2의 address 변경 println(person1.address.city) // Busan (person1의 address도 변경됨) // 원시 타입 복사 val person1 = Person(\"Alice\", 25) val person2 = person1.copy() person2.age = 26 // person2의 age 값만 변경 println(person1.age) // 25 (person1의 age는 변경되지 않음) 위 5개의 함수를 코틀린 컴파일러가 자동으로 생성한다.\nAny 클래스의 (equals, toString, hashCode) 함수들을 오버라이딩 해준다. 반드시 ‘기본 생성자’ 에 속성들을 지정해야 한다.\nopen 으로 피상속 불가, 슈퍼 클래스 불가\n상속을 허용한다면, 부모 클래스에서 자동 생성된 메서드들이 자식 클래스의 모든 프로퍼티를 고려하여 정확하게 동작하도록 보장하기가 어렵기 때문 data class의 목적과 부합하지 않음 Data Class는 다른 클래스를 상속할 수 없으며, 인터페이스만 구현할 수 있습니다.\n해시 코드 값은 인스턴스를 고유하기 식별하기 위해 생성된 값이다.\nenum 클래스 ‘상수값’을 정의하는 열거형 클래스를 정의할때 사용\n상수보다 더 서술적이라서 무엇을 의미하기 알기 쉽다.\nenum 의 항목은 단순한 상수가 아니라, 서브 타입이다.\n각 상수(항목들) 는 자체적으로 프로퍼티와 메서드를 가질 수 있는 객체 항목들은 enum class 내부에서만 생성되며, 외부에서 임의로 생성할 수 없습니다.\nenum 는 모든 상수가 컴파일 타임에 결정되므로, 각 상수는 JVM 내부적으로 단일 인스턴스로 표현됩니다. (메모리 사용 측면에서 효율적)\nenum 클래스 내부적으로 ‘name’(항목 이름, String 타입), ‘ordinal’(항목 위치, Int 타입, 0부터 시작)\nEnumClass.values : 모든 항목 이름을 ‘배열’로 생성\nenum 클래스의 함수 호출은 ‘enum 클래스명.항목명.함수명’ 의 형태로 호출해야 한다.\n컴파일러가 모든 타입을 처리했는지 검사할 수 있다는 장점\n싱글턴 패턴과 유사한 특징을 가지고 있어, 싱글턴처럼 사용할 수 있습니다.\n하지만 상속 불가 및 값 표현 등의 차이점이 있으므로, 엄밀히 말하면 싱글턴은 아닙니다. 연산자 오버로딩 연산자 오버로딩: 피연산자의 타입이 무엇이든 같은 연산자를 사용해서 동일한 기능을 구현할 수 있게 해주는 것\n코틀린에서는 각 연산자를 사전에 약속된 함수로 구현하여 연산자 오버로딩을 지원한다.\n코틀린 컴파일러는 a+b 를 컴파일하여, a.plus(b) 를 실행하도록 바이트코드로 생성 + 연산자 를 사전에 약속된 plus 함수로 싱행하게 되면, 피연산자의 타입이 다르더라도 덧셈은 항상 + 로 표기가능 피연산자의 타입마다 서로 다른 덧셈 연산자를 사용하면, 불편하고 연산자 수가 매우 많아짐 코틀린에서== 비교 연산자 가 내부적으로 equals 함수로 호출되는 이유가 연산자 오버로딩 때문이다. (ex. +, plus() )\n객체의 값 비교하기 equals 함수를 override 할 때는 haseCode 함수도 같이 override 해야 한다. 동등성, Equality 연산 hash와 관련된 자료구조(hashMap, hashTable)는 동등성 연산(equals) 전에 먼저, Hash Value비교를 수행한다. 즉, hashCode()의 값이 같은 경우에만 동등성 연산이 수행된다.\n두 개의 다른 인스턴스에 대해 같은 Hash Value가 나오는 경우를 Hash 충돌(Hash Collision) 이라 한다.\nHash Value가 같으므로 동등성 연산(equals) 가 수행된다.\n같은 해시 값을 갖는 인스턴스들이 LinkedList 형태로 이어져있어 하나하나씩 Iteration이 돌아가면서 동등성 연산이 수행\n따라서 N개의 값 객체가 있고 해당 값 객체들이 모두 같은 Hash Value를 갖는다면 동등성 연산 수행에 O(N)의 시간 복잡도가 필요하다.\n하지만 만약 모든 값 객체들이 다른 Hash Value를 갖는다면 동등성 연산 수행에 O(1)의 시간 복잡도 따라서 hashCode()값을 Hash 충돌을 최대한 피할 수 있도록 짜야한다. 1 2 3 4 5 6 7 8 9 10 11 12 class GalaxyTab(val modelName: String, val size: Int) { override fun hashCode(): Int { return modelName[1].toString().toInt() } } val tabS6 = GalaxyTab(\"S6\", 11) val tabS7 = GalaxyTab(\"S7\", 11) val tabStock = mutableMapOf\u003cGalaxyTab,Int\u003e() tabStock[tabS6] = 0 tabStock[tabS7] = 2 JVM에서 Hash와 메모리 주소 값 비교 특징 Hash (해시 코드) 메모리 주소 값 의미 객체의 데이터를 기반으로 생성된 정수 값 객체가 저장된 메모리 상의 실제 위치 목적 객체 비교, 해시 기반 컬렉션 활용 객체 식별, 참조 비교 고유성 동일 객체는 항상 같은 값, 다른 객체는 다른 값을 가질 수 있음 (해시 충돌 가능) 각 객체마다 고유한 값 가변성 객체의 상태가 변하지 않으면 불변 가비지 컬렉션 등에 의해 변경될 수 있음 메모리 주소와의 관계 일반적으로 무관 직접적인 관계 JVM에서 hash와 메모리 주소 값은 둘 다 객체를 식별하는 데 사용되지만, (공통)\nHash는 주로 객체의 논리적 동등성 비교와 해시 기반 컬렉션에서 활용되며, 메모리 주소 값은 객체의 고유성 판별과 참조 비교에 사용됩니다. Hash\n객체의 데이터를 기반으로 생성된 정수 값입니다. Object 클래스의 hashCode() 메서드를 통해 얻을 수 있습니다. 해시 기반 컬렉션: 해시 기반 컬렉션에서 객체를 효율적으로 저장하고 검색하는 데 사용됩니다. 해시 코드를 통해 객체를 버킷에 분류하고, 충돌 발생 시 equals() 로 최종 비교 메모리 주소 값\n객체가 저장된 메모리 상의 실제 위치를 나타내는 값입니다. 자바는 == 연산자, 코틀린은 === 연산자 sealed class enum 항목이 복잡한 로직을 가질 경우, 각 항목을 클래스로 정의하고, 이를 sealed class로 묶어서 사용 가능 유연한 데이터 저장, 복잡한 구조 가능 자신의 서브(자식) 클래스 종류를 제한하기 위해 사용된다. enum 클래스의 각 항목은 하나의 인스턴스만 생성되지만, sealed class에 속하는 서브 클래스들은 일반 클래스 이므로, 인스턴스 개수에 제한이 없다. 컴파일러는 해당 수퍼 클래스의 서브 클래스들을 컴파일 타임에 파악할 수 있게됨 when 표현식과 함께 사용될 때 모든 하위 클래스를 검사하므로, else 절이 필요하지 않습니다. enum도 마찬가지 1 2 3 4 5 sealed interface ApiResult\u003cout T\u003e { data class Success\u003cout T\u003e(val data: T) : ApiResult\u003cT\u003e data class Error(val exception: Exception) : ApiResult\u003cNothing\u003e object Loading : ApiResult\u003cNothing\u003e } 말 그대로 인터페이스이기 때문에 다중 상속을 통한 타입의 다형성을 부여할 수 있습니다. 다시 말해, 특정 타입의 성질을 하위 타입에게 전달하기가 쉽습니다. 또한, when 문을 사용하여 타입을 참조하여 분기해야할 상황에서 장점이 명확해짐 enum의 한계 각 요소당 하나의 single instance를 사용하기 때문에 서로 다른 형태를 가질 수 없습니다. 1 2 3 4 enum class Result { SUCCESS, FAILED(val exception: Exception) // 이런 형태는 불가함. } ","wordCount":"6499","inLanguage":"en","image":"https://2taezeat.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E","datePublished":"2023-12-04T11:30:03Z","dateModified":"2023-12-04T11:30:03Z","author":{"@type":"Person","name":"2taezeat"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://2taezeat.github.io/posts/dev/kotlin-%EC%A0%95%EB%A6%AC-1/"},"publisher":{"@type":"Organization","name":"2taezeat, blog","logo":{"@type":"ImageObject","url":"https://2taezeat.github.io/icon/favicon.ico"}}}</script></head><body id=top><header class=header><nav class=nav><div class=logo><a href=https://2taezeat.github.io/ accesskey=h title="2taezeat blog (Alt + H)"><img src=https://2taezeat.github.io/icon/apple-touch-icon.png alt aria-label=logo height=30>2taezeat blog</a><div class=logo-switches></div></div><ul id=menu><li><a href=https://2taezeat.github.io/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://2taezeat.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://2taezeat.github.io/searchs/ title=Search><span>Search</span></a></li><li><a href=https://github.com/2taezeat title=Github><span>Github</span>&nbsp;<svg fill="none" shape-rendering="geometricPrecision" stroke="currentcolor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2.5" viewBox="0 0 24 24" height="12" width="12"><path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"/><path d="M15 3h6v6"/><path d="M10 14 21 3"/></svg></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://2taezeat.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://2taezeat.github.io/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">Kotlin 정리 (1)</h1><div class=post-description>Kotlin 정리 (1)</div><div class=post-meta><span title='2023-12-04 11:30:03 +0000 +0000'>2023-12-04</span>&nbsp;·&nbsp;31 min&nbsp;·&nbsp;6499 words&nbsp;·&nbsp;2taezeat</div></header><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#kotlin-다시-보기-1>Kotlin 다시 보기 (1)</a></li><li><a href=#타입>타입</a><ul><li><a href=#코틀린-타입-특징>코틀린 타입 특징</a></li><li><a href=#built-in-내장-타입>built-in, 내장 타입</a></li><li><a href=#변수>변수</a></li><li><a href=#타입-추론>타입 추론</a></li><li><a href=#컴파일-시점-상수constant>컴파일 시점 상수(constant)</a></li><li><a href=#코틀린의-자바-기본-타입>코틀린의 자바 기본 타입</a></li></ul></li><li><a href=#조건문과-조건식>조건문과 조건식</a><ul><li><a href=#문과-식>문과 식</a></li><li><a href=#조건-표현식-conditional-expression>조건 표현식 (conditional expression)</a></li></ul></li><li><a href=#함수>함수</a><ul><li><a href=#unit-함수>Unit 함수</a></li><li><a href=#nothing-타입>Nothing 타입</a></li><li><a href=#자바의-파일-수준-함수>자바의 파일 수준 함수</a></li><li><a href=#함수-overloading>함수 Overloading</a></li></ul></li><li><a href=#익명-함수와-함수-타입>익명 함수와 함수 타입</a><ul><li><a href=#익명-함수>익명 함수</a></li><li><a href=#람다-lambda>람다 (lambda)</a></li><li><a href=#inline-함수로-만들기>inline 함수로 만들기</a></li><li><a href=#함수-참조>함수 참조</a></li><li><a href=#반환-타입으로-함수-타입-사용하기>반환 타입으로 함수 타입 사용하기</a></li><li><a href=#람다-vs-익명-내부-클래스>람다 vs 익명 내부 클래스</a></li></ul></li><li><a href=#null-안전과-예외>null 안전과 예외</a><ul><li><a href=#코틀린의-null-처리-개요>코틀린의 null 처리 개요</a></li><li><a href=#에러-검출-시점컴파일-vs-런타임>에러 검출 시점(컴파일 vs 런타임)</a></li><li><a href=#null-안전-처리>null 안전 처리</a></li><li><a href=#예외-던지기-exception-throw>예외 던지기, Exception Throw</a></li><li><a href=#예외-처리-가이드>예외 처리 가이드</a></li><li><a href=#예외-처리>예외 처리</a></li><li><a href=#전제-조건>전제 조건</a></li><li><a href=#null-무엇이-좋을까>null 무엇이 좋을까?</a></li><li><a href=#checked-예외와-unchecked-예외>checked 예외와 unchecked 예외</a></li></ul></li><li><a href=#문자열>문자열</a><ul><li><a href=#해체-선언-destructing-declaration>해체 선언 (destructing declaration)</a></li><li><a href=#문자열은-불변이다>문자열은 불변이다.</a></li><li><a href=#문자열-비교>문자열 비교</a></li><li><a href=#비교-연산>비교 연산</a></li></ul></li><li><a href=#숫자>숫자</a><ul><li><a href=#문자열을-숫자-타입으로-변환하기>문자열을 숫자 타입으로 변환하기</a></li><li><a href=#소수>소수</a></li></ul></li><li><a href=#표준-함수-범위-지정-함수>표준 함수 (범위 지정 함수)</a><ul><li><ul><li><a href=#수신-객체-지정-람다-lambdas-with-receivers><strong>수신 객체 지정 람다 (Lambdas with Receivers)</strong></a></li></ul></li><li><a href=#apply>apply</a></li><li><a href=#run>run</a></li><li><a href=#with>with</a></li><li><a href=#also>also</a></li><li><a href=#let>let</a></li></ul></li><li><a href=#list-set-map>List, Set, Map</a><ul><li><a href=#list>List</a><ul><li><a href=#반복-처리>반복 처리</a></li><li><a href=#해체-선언>해체 선언</a></li></ul></li><li><a href=#set>Set</a></li><li><a href=#array-배열-타입>Array, 배열 타입</a></li><li><a href=#읽기-전용-vs-변경-불가능>읽기 전용 vs 변경 불가능</a></li><li><a href=#map>Map</a></li></ul></li><li><a href=#클래스-정의하기>클래스 정의하기</a><ul><li><a href=#인스턴스-생성하기>인스턴스 생성하기</a></li><li><a href=#가시성-제한자>가시성 제한자</a></li><li><a href=#속성프로퍼티>속성(프로퍼티)</a></li><li><a href=#속성프로퍼티의-getter와-setter>속성(프로퍼티)의 getter와 setter</a></li><li><a href=#산출-속성computed-property>산출 속성(computed property)</a></li><li><a href=#패키지-사용하기>패키지 사용하기</a></li><li><a href=#경합-상태race-condition>경합 상태(race condition)</a></li><li><a href=#패키지-가시성>패키지 가시성</a></li></ul></li><li><a href=#초기화>초기화</a><ul><li><a href=#기본-생성자>기본 생성자</a></li><li><a href=#보조-생성자>보조 생성자</a></li><li><a href=#초기화-블록-init>초기화 블록 (init)</a></li><li><a href=#속성프로퍼티-초기화>속성(프로퍼티) 초기화</a></li><li><a href=#초기화-순서>초기화 순서</a></li><li><a href=#초기화-지연시키기>초기화 지연시키기</a></li><li><a href=#늦-초기화-lazy-initalization>늦 초기화 (lazy initalization)</a></li></ul></li><li><a href=#상속>상속</a><ul><li><a href=#타입-검사>타입 검사</a></li><li><a href=#코틀린-타입의-상속-계층>코틀린 타입의 상속 계층</a></li><li><a href=#스마트-캐스팅>스마트 캐스팅</a></li><li><a href=#any-클래스>Any 클래스</a></li></ul></li><li><a href=#객체>객체</a><ul><li><a href=#object-키워드>object 키워드</a></li><li><a href=#객체-표현식>객체 표현식</a></li><li><a href=#동반-객체-companion-object>동반 객체 (companion object)</a></li><li><a href=#중첩-클래스>중첩 클래스</a></li><li><a href=#내부-클래스-inner-class>내부 클래스 (inner class)</a></li><li><a href=#data-class>data class</a></li><li><a href=#enum-클래스>enum 클래스</a></li><li><a href=#연산자-오버로딩>연산자 오버로딩</a></li><li><a href=#객체의-값-비교하기>객체의 값 비교하기</a></li><li><a href=#jvm에서-hash와-메모리-주소-값-비교>JVM에서 Hash와 메모리 주소 값 비교</a></li><li><a href=#sealed-class>sealed class</a><ul><li><a href=#enum의-한계>enum의 한계</a></li></ul></li></ul></li></ul></nav></div></details></div><div class=post-content><h1 id=kotlin-다시-보기-1>Kotlin 다시 보기 (1)<a hidden class=anchor aria-hidden=true href=#kotlin-다시-보기-1>#</a></h1><p><em>‘빅 너드 랜치의 코틀린 프로그래밍’</em> 을 읽고 정리</p><h1 id=타입>타입<a hidden class=anchor aria-hidden=true href=#타입>#</a></h1><h2 id=코틀린-타입-특징>코틀린 타입 특징<a hidden class=anchor aria-hidden=true href=#코틀린-타입-특징>#</a></h2><ul><li><p><strong>정적 타입 시스템</strong></p><ul><li>소스 코드에 정의된 타입을 컴파일러가 알고 있다.</li></ul></li><li><p>프로그램을 컴파일하기 전에 타입 체킹 : 정적 타입 체킹</p></li></ul><h2 id=built-in-내장-타입>built-in, 내장 타입<a hidden class=anchor aria-hidden=true href=#built-in-내장-타입>#</a></h2><ul><li><p>String</p></li><li><p>Char</p></li><li><p>Boolean</p></li><li><p>Int</p></li><li><p>Double</p></li><li><p>List - 컬렉션 타입</p></li><li><p>Set - 컬렉션 타입</p></li><li><p>Map - 컬렉션 타입</p></li></ul><h2 id=변수>변수<a hidden class=anchor aria-hidden=true href=#변수>#</a></h2><ul><li><code>val</code> : read-only, 변경 불가능, 읽기 전용</li><li><code>var</code> : 값이 변경 될 수 있음, writeable 쓰기 가능, 가변성</li></ul><h2 id=타입-추론>타입 추론<a hidden class=anchor aria-hidden=true href=#타입-추론>#</a></h2><ul><li>코틀린 컴파일러가 타입을 추론 해줌</li><li>따라서, 타입을 생략 가능, 컴파일러가 소스 코드의 타입을 알고 있음</li><li>코틀린은 기본 타입을 포함해서, 모든 타입이 객체다.<ul><li>코틀린 컴파일러가 자바의 기본 타입과 가장 유사한 것과 매핑</li></ul></li></ul><h2 id=컴파일-시점-상수constant>컴파일 시점 상수(constant)<a hidden class=anchor aria-hidden=true href=#컴파일-시점-상수constant>#</a></h2><ul><li>val 변수는 <code>상수(constant)</code> 가 아니다.</li><li><code>const val MAX_LIMIT = 50000</code></li><li>프로그램 실행 전에 <strong>생성 및 초기화</strong> 됨</li><li><strong>초기화된 값을 절대로 변경하지 않는 값</strong></li><li>프로그램 실행 전 컴파일러가 알 수 있어야 함으로, <strong>&lsquo;built-in 타입&rsquo;</strong> 중 하나가 되어야 함<ul><li>String, Int, Double, Float, Boolean, Char</li></ul></li><li>모든 함수 외부에 정의 되어야 함, 컴파일 될때 값이 지정되야 함</li><li>상수와 달리, <strong>변수</strong>들은 runtime에 생성되어 값이 지정된다.</li></ul><h2 id=코틀린의-자바-기본-타입>코틀린의 자바 기본 타입<a hidden class=anchor aria-hidden=true href=#코틀린의-자바-기본-타입>#</a></h2><ul><li><p>자바는 <strong>참조 타입과 기본 타입</strong> 2개가 존재</p><ul><li><p>기본 타입: 내장, 소문자</p><ul><li><code>int</code></li></ul></li><li><p>참조 타입: 별도의 소스 코드 파일로 정의, Ex) 클래스, 항상 대문자</p><ul><li><code>Interger</code></li></ul></li><li><p>모든 <strong>기본 타입</strong>은 그것과 대응되는 참조 타입이 있다. (역은 불가)</p></li><li><p>기본 타입이 참조 타입보다 성능이 좋음</p></li><li><p>기본 타입 배열(<code>int[]</code>, <code>byte[]</code>, <code>boolean[]</code>)</p></li></ul></li><li><p>자바와 달리 코틀린은 <strong>참조 타입</strong>만 제공 (int가 아닌 Int만 제공) → <strong>선택지가 하나로 됨, 코드 쉽게 작성 가능</strong></p></li><li><p><strong>기본(primitive, 원시) 타입</strong>도 <strong>참조 타입(reference)</strong> 으로 사용</p></li><li><p>코틀린 컴파일러는 <strong>가능한 한</strong> 자바 바이트코드의 <strong>기본(primitive) 타입</strong>을 사용한다. ( 더 좋은 성능을 내기에 )</p></li><li><p>코틀린은 자바와 달리 <strong>원시 타입(Primitive Type)</strong> 과 <strong>참조 타입(Reference Type)</strong> 을 <strong>엄격하게 구분하지 않는다.</strong></p></li><li><p><strong>Nullable type</strong>(ex. <code>Int?</code>)은 자바의 <strong>Wrapper Class</strong>(<code>Interger</code>)로 컴파일된다.</p></li></ul><ul><li><strong>원시, 기본 타입</strong><ul><li><strong>값을 직접 저장</strong>하는 데이터 타입입니다.</li><li><strong>종류</strong><ul><li>정수 타입: <code>Byte</code>, <code>Short</code>, <code>Int</code>, <code>Long</code></li><li>부동 소수점 타입: <code>Float</code>, <code>Double</code></li><li>문자 타입: <code>Char</code></li><li>불리언 타입: <code>Boolean</code></li></ul></li><li>특징<ul><li>컴파일 시 자바의 기본 타입으로 변환됩니다. (예: <code>Int</code> -> <code>int</code>)</li><li>숫자 타입은 객체처럼 사용할 수 있습니다. (<strong>박싱/언박싱 자동 처리</strong>)<ul><li>기본형을 참조형으로 변환: 이 기능을 <code>박싱(boxing)</code></li><li><code>오토박싱(Autoboxing)</code>은 Java 컴파일러가 <strong>원시 타입</strong>과 <strong>해당 객체 래퍼 클래스</strong> 간에 수행하는 자동 변환을 말한다. (예시: int => Integer)</li></ul></li></ul></li></ul></li><li><strong>참조 타입</strong><ul><li>객체의 <strong>메모리 주소를</strong> 저장하는 데이터 타입입니다.</li><li>종류<ul><li>클래스 (Class)</li><li>인터페이스 (Interface)</li><li>배열 (Arrays)</li><li><strong>문자열 (String)</strong></li><li>컬렉션 (Collection)</li><li>기타 객체 타입</li></ul></li></ul></li></ul><table><thead><tr><th>특징</th><th>기본 타입 (Primitive Type)</th><th>참조 타입 (Reference Type)</th></tr></thead><tbody><tr><td>메모리 할당</td><td>JVM의 스택(Stack) 영역에 <strong>직접 값 할당</strong></td><td>JVM의 힙(Heap) 영역에 객체 생성 후 <strong>스택에 참조 값</strong> 저장</td></tr><tr><td>값 표현</td><td>실제 값 (정수, 실수, 문자, 논리 값 등)</td><td>객체의 메모리 주소 (참조 값)</td></tr><tr><td>크기</td><td>고정된 크기 (타입별로 정의됨)</td><td>가변적인 크기 (객체의 상태에 따라 달라짐)</td></tr><tr><td>연산</td><td>값 자체를 이용한 연산</td><td>참조 값을 이용한 연산 (객체의 메서드 호출 등)</td></tr><tr><td>비교</td><td>== 연산자로 값 비교</td><td>== 연산자로 참조 값 비교, .equals() 메서드로 객체 내용 비교</td></tr><tr><td>제네릭</td><td>사용 불가</td><td>사용 가능</td></tr><tr><td>종류</td><td>byte, short, int, long, float, double, boolean, char</td><td>클래스, 인터페이스, 배열, 열거형(enum), 문자열 등</td></tr><tr><td>메모리 사용량</td><td>적음</td><td>많음</td></tr><tr><td>속도</td><td>스택에서 값을 직접 사용, 빠름</td><td>스택에 저장된 참조 값을 통해 힙에 있는 객체에 접근, 느림</td></tr><tr><td>GC</td><td>없음</td><td>있음</td></tr><tr><td>OOP</td><td>불가</td><td>가능</td></tr></tbody></table><h1 id=조건문과-조건식>조건문과 조건식<a hidden class=anchor aria-hidden=true href=#조건문과-조건식>#</a></h1><h2 id=문과-식>문과 식<a hidden class=anchor aria-hidden=true href=#문과-식>#</a></h2><ul><li><p><strong>문(Statement)</strong>: 프로그램의 실행 흐름을 제어하는 <strong>명령어 또는 명령어들의 집합</strong>입니다.</p></li><li><p><strong>식(Expression)</strong>: <strong>값을 생성하는 코드 조각</strong></p></li><li><p><strong>식</strong>은 <strong>문</strong>의 일부가 될 수 있다.</p></li></ul><table><thead><tr><th>특징</th><th>문 (Statement)</th><th>식 (Expression)</th></tr></thead><tbody><tr><td>값 생성</td><td>X</td><td>O</td></tr><tr><td>실행 결과 반환</td><td>X</td><td>O</td></tr><tr><td>상태 변경</td><td>O</td><td>X</td></tr><tr><td>세미콜론(;)</td><td>O (일반적으로)</td><td>X</td></tr><tr><td>예시</td><td><code>int x = 10</code></td><td><code>x + 5</code></td></tr></tbody></table><h2 id=조건-표현식-conditional-expression>조건 표현식 (conditional expression)<a hidden class=anchor aria-hidden=true href=#조건-표현식-conditional-expression>#</a></h2><ul><li><p>if/else <code>문(Statement)</code> 대신 <code>조건 표현식</code> 을 사용할 수 있다.</p></li><li><p><code>식(Expression)</code>은 <strong>값을 반환</strong>한다.</p></li><li><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-kotlin data-lang=kotlin><span class=line><span class=cl>  <span class=k>val</span> <span class=py>tmp1</span> <span class=p>=</span> <span class=k>if</span> <span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>   	<span class=s2>&#34;yes&#34;</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=s2>&#34;no&#34;</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=k>val</span> <span class=py>tmp2</span> <span class=p>=</span> <span class=k>when</span> <span class=p>(</span><span class=n>para</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=m>100</span> <span class=o>-&gt;</span> <span class=s2>&#34;1&#34;</span>
</span></span><span class=line><span class=cl>      <span class=k>in</span> <span class=m>1.</span><span class=p>.</span><span class=m>90</span> <span class=o>-&gt;</span> <span class=s2>&#34;2&#34;</span>
</span></span><span class=line><span class=cl>      <span class=k>else</span> <span class=o>-&gt;</span> <span class=s2>&#34;3&#34;</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div></li><li><p>when 문</p><ul><li>else 없어도 상관 없음</li></ul></li><li><p>when 표현식</p><ul><li>else 가 꼭 있는지 컴파일러가 검증</li><li>결과를 반환하기때문</li><li>간결하고 다양하게 로직을 나타냄</li></ul></li><li><p><strong>when</strong></p><ul><li><strong>임의의 <code>조건</code>들을 검사할 수 있다</strong></li><li>풀 스루가 아님</li></ul></li><li><p>Java switch 문</p><ul><li>값만 검사</li><li>풀 스루 (break 없으면, 아래의 조건들도 검사)</li></ul></li></ul><h1 id=함수>함수<a hidden class=anchor aria-hidden=true href=#함수>#</a></h1><ul><li><p>기본적으로 가시성 제한자가 public</p></li><li><p>함수의 <code>매개변수(===인자)</code> 는 <strong>var이 아닌 val</strong> 이다.</p></li><li><p>함수 내에 있는 <strong>지역 범수는 함수 범위에만 존재</strong>, 함수가 return 되면 소멸된다. (매개변수도 마찬가지)</p><ul><li>매개변수 또한 함수 종료시 소멸됨</li></ul></li><li><p>파일 수준 변수는 프로젝트 어디서든 사용 가능</p><ul><li>자바 클래스의 <code>static</code> 메서드가 된다, <code>~.kt 파일</code>을 <code>Java byteCode(.class)</code>를 decompile(역컴파일)로 확인 가능</li></ul></li><li><p>파일 수준 변수는 초깃값이 지정되어야 한다. 아니면 컴파일 에러</p></li><li><p><strong>기본 인자 ( default argument ) 지원</strong></p><ul><li>함수 인자가 기본값을 가짐</li></ul></li><li><p>단일 표현식, <code>함수 대입 연산자 =</code> 으로 정의</p></li><li><p>overload 함수들은 <strong>컴파일러가</strong> 함수 호출시에 전달되는 <strong>인자의 타입</strong>과 <strong>갯수</strong>로 무슨 함수인지 알 수 있다.</p></li></ul><h2 id=unit-함수>Unit 함수<a hidden class=anchor aria-hidden=true href=#unit-함수>#</a></h2><ul><li><p>아무 값도 return 하지 않는 함수 타입</p></li><li><p><strong>void 로는 제네릭 함수 를 구현할 방법이 없음, Unit 으로 해결</strong></p><ul><li>void는 타입이 아니며, 타입 정보가 의미가 없으므로, 생략해라 라는 의미</li></ul></li><li><p>Unit으로 함수의 반환 타입을 나타냄 => 제네릭 함수에도 사용 가능</p></li></ul><h2 id=nothing-타입>Nothing 타입<a hidden class=anchor aria-hidden=true href=#nothing-타입>#</a></h2><ul><li>함수의 실행이 끝나더라도, <strong>호출 코드로 제어가 복귀</strong>되지 않는다</li><li>의도적으로 <strong>exception 예외</strong>를 발생시킬 때 사용<ul><li><code>public inline fun TODO(): Nothing = throw NotImplementedError()</code></li><li>컴파일러는 이 TODO 코드를 에러로 처리하지 않는다.</li><li>제어가 복귀되지 않아서, 컴파일러가 TODO 코드의 다음 코드는 절대 실행되지 않는 것을 알게됨</li></ul></li></ul><h2 id=자바의-파일-수준-함수>자바의 파일 수준 함수<a hidden class=anchor aria-hidden=true href=#자바의-파일-수준-함수>#</a></h2><ul><li>코틀린의 <strong>파일 수준 함수</strong>는 <strong>자바 클래스의 static 메서드</strong>가 된다.<ul><li>코틀린 파일 이름의 Kt를 붙임</li><li><code>Game.kt</code> => <code>public final class GameKt</code></li></ul></li></ul><h2 id=함수-overloading>함수 Overloading<a hidden class=anchor aria-hidden=true href=#함수-overloading>#</a></h2><ul><li>이름은 같지만 <strong>매개변수의 개수가 타입이 다른 여러 개의 함수로 구현</strong>하는 것</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span><span class=lnt>9
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-kotlin data-lang=kotlin><span class=line><span class=cl><span class=k>fun</span> <span class=nf>performCombat</span><span class=p>()</span> <span class=p>{</span> 
</span></span><span class=line><span class=cl>    <span class=c1>//...
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=k>fun</span> <span class=nf>performcombat</span> <span class=p>(</span><span class=n>eneryName</span><span class=p>:</span> <span class=n>String</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>//...
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=k>fun</span> <span class=nf>performcombat</span> <span class=p>(</span><span class=n>enemyName</span> <span class=p>:</span> <span class=n>string</span><span class=p>,</span> <span class=n>isBlessed</span><span class=p>:</span> <span class=n>Boolean</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// ...
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><ul><li><strong>코틀린 컴파일러</strong>는 함수 호출시에 전달되는 <strong>인자의 개수</strong>와 <strong>타입의 일치</strong>되는 것을 알기 때문에 어떤 <strong>오버로딩 함수를 실행할지 알게됨</strong></li></ul><h1 id=익명-함수와-함수-타입>익명 함수와 함수 타입<a hidden class=anchor aria-hidden=true href=#익명-함수와-함수-타입>#</a></h1><h2 id=익명-함수>익명 함수<a hidden class=anchor aria-hidden=true href=#익명-함수>#</a></h2><ul><li><p>말그대로, <strong>이름이 없는 함수</strong></p></li><li><p><strong>익명 함수</strong> == <strong>람다(lambda)</strong></p></li><li><p>다른 함수의 인자와 반환 가능</p></li><li><p><strong>익명 함수도 타입</strong>을 가질 수 있고, 이것을 <code>함수 타입</code> 이라고 한다</p><ul><li>함수의 타입을 컴파일러에게 알려 준다.</li></ul></li><li><p>익명 함수를 <strong>변수화</strong> 할 수 있다.</p></li><li><p>익명 함수는 <strong>익명 클래스 인스턴스</strong>로 생성된다.</p></li><li><p><strong>암시적 반환</strong></p><ul><li>암시적으로 or 자동으로 함수 정의의 <strong>마지막 코드 결과를 반환</strong>한다.</li><li>람다에서 return 키워드는 사용이 금지되어 있음</li><li><strong>어디로 복귀 되어야 하는지, 컴파일러는 알 수 없기 때문</strong></li></ul></li><li><p>하나의 인자만 받는 익명 함수의 매개변수 이름을 지정하는 대신 <code>it</code> 키워드를 사용할 수 있다.</p></li><li><p><strong>함수 타입</strong> 역시 <strong>타입 추론(type inference)</strong> 지원</p><ul><li>익명 함수가 <strong>값으로 지정되</strong>면 타입을 필수로 지정하지 않아된다. (당연히 해도 됨)</li></ul></li></ul><h2 id=람다-lambda>람다 (lambda)<a hidden class=anchor aria-hidden=true href=#람다-lambda>#</a></h2><ul><li><strong>익명 함수를 람다(lambda)라 부름</strong></li><li><strong>람다 표현식, 람다식</strong>: <strong>익명 함수 정의</strong></li><li><strong>익명 함수의 반환 결과</strong> : 람다 결과(lambda result)</li><li>어떤 함수에서 <code>마지막</code> 매개변수로 함수 타입을 받을때는 ()를 생략할 수 있다.<ul><li><code>"Mississippi".count ({ it == 's' })</code></li><li><code>"Mississippi".count { it == 's' }</code></li><li><code>{ it == 's' }</code> 가 <strong>람다, 익명 함수</strong> 이다.</li><li>이것은 람다가 마지막 인자로 함수에 전달될 때만 가능, 따라서 함수 타입 매개변수를 <strong>마지막 매개변수</strong>로 선언하는 것이 좋다.</li></ul></li></ul><h2 id=inline-함수로-만들기>inline 함수로 만들기<a hidden class=anchor aria-hidden=true href=#inline-함수로-만들기>#</a></h2><ul><li><p><strong>람다(익명 함수)</strong> 는 <strong>JVM에서 객체</strong>로 생성</p><ul><li>메모리 부담</li></ul></li><li><p><code>인라인</code>을 사용하면 람다의 객체 사용과 변수의 메모리 할당을 JVM이 하지 않아도 된다.</p></li><li><p><strong>inline 키워드를 추가하면, 람다가 객체로 전달 되지 않는다.</strong></p></li><li><p>컴파일러가 바이트 코드를 생성할 때, <strong>람다 코드가 포함된 함수 몸체의 전체 코드를 복사한후</strong>, 함수를 호출하는 곧에 <strong>붙여 넣기 하여 교체</strong> 하기 때문</p></li><li><p>하지만 재귀 함수는 무수히 많이 복사 됨으로, 코틀린 컴파일러는 재귀함수를 단순히 인라인 처리하지 않고, 루프 형태로 변경한다.</p></li></ul><h2 id=함수-참조>함수 참조<a hidden class=anchor aria-hidden=true href=#함수-참조>#</a></h2><ul><li><strong>람다를 사용해서 다른 함수의 인자로 함수를 전달하는 방법도 있지만,</strong></li><li>다른 방법으로 <code>함수 참조</code>를 인자로 전달</li><li>함수 참조를 얻을 때는 함수 이름 앞에 <code>:: 연산자</code>를 사용한다.</li><li>매개변수에 적합한 이름 있는 함수가 있다면 람다 대신 함수 참조를 사용할 수 있다.</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-kotlin data-lang=kotlin><span class=line><span class=cl><span class=k>fun</span> <span class=nf>runsimulation</span><span class=p>(</span><span class=n>playerName</span><span class=p>:</span> <span class=n>String</span><span class=p>,</span> <span class=n>greetingFunction</span><span class=p>:</span> <span class=p>(</span><span class=n>String</span><span class=p>,</span> <span class=n>Int</span><span class=p>)</span> <span class=o>-&gt;</span> <span class=n>string</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>val</span> <span class=py>numBuildings</span> <span class=p>=</span> <span class=p>(</span><span class=m>1.3</span><span class=p>).</span><span class=n>shuffled</span><span class=p>().</span><span class=n>last</span><span class=p>()</span> 
</span></span><span class=line><span class=cl>	<span class=n>println</span> <span class=p>(</span><span class=n>greetingFunction</span><span class=p>(</span><span class=n>playerName</span><span class=p>,</span> <span class=n>numButlatngs</span><span class=p>))</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>fun</span> <span class=nf>printConstructionCost</span><span class=p>(</span><span class=n>numBuildings</span><span class=p>:</span> <span class=n>Int</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=n>vaL</span> <span class=n>cost</span> <span class=p>=</span> <span class=m>500</span>
</span></span><span class=line><span class=cl>	<span class=n>println</span><span class=p>(</span><span class=s2>&#34;건축 비용: sfcost * numBuildings}&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>fun</span> <span class=nf>main</span><span class=p>(</span><span class=n>args</span><span class=p>:</span> <span class=n>Array</span><span class=p>&lt;</span><span class=n>string</span><span class=p>&gt;)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=n>runsimulation</span><span class=p>(</span><span class=s2>&#34;김선달&#34;</span><span class=p>,</span> <span class=o>::</span><span class=n>printConstructionCost</span><span class=p>)</span> <span class=p>{</span> <span class=n>playerName</span><span class=p>,</span> <span class=n>numBuildings</span> <span class=o>-&gt;</span>
</span></span><span class=line><span class=cl>	<span class=k>val</span> <span class=py>currentYear</span> <span class=p>=</span> <span class=m>2019</span>
</span></span><span class=line><span class=cl>	<span class=s2>&#34;simvitlage 방문을 환영합니다, SplayerName! (copyright scurrentyear)&#34;</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><h2 id=반환-타입으로-함수-타입-사용하기>반환 타입으로 함수 타입 사용하기<a hidden class=anchor aria-hidden=true href=#반환-타입으로-함수-타입-사용하기>#</a></h2><ul><li><p>코틀린의 <strong>람다</strong>는 <strong>클로저(closure, close over)</strong> 이다.</p><ul><li><p>다른 함수에 포함한 함수(예를 들어, 람다) 에서 <strong>자신을 포함하는 함수의 매개변수와 변수</strong>를 사용할 수 있는 것을 말한다.</p></li><li><p>람다(익명 함수)가 <strong>외부 변수의 참조</strong>를 갖는다.</p></li></ul></li><li><p><strong>따라서 람다식은 자신이 포함된 외부 함수에 선언된 매개변수와 변수를 그냥 사용할 수 있다.</strong></p><ul><li><p>외부 함수에 val 변수는 람다식에서 그 값이 바로 저장</p></li><li><p><strong>var은 별도의 객체로 저장</strong>되며, 그 <strong>객체의 참조값</strong>이 람다식 코드에 저장되어 값을 변경할 때 사용</p></li></ul></li><li><p>다른 함수를 인자로 받거나 반환하는 함수를 <strong>고차 함수(higher-order function)</strong> 이라고 한다.</p><ul><li><code>filter, map</code> 등</li></ul></li><li><p><strong>코틀린에서는 익명 함수가 자신의 범위 밖에 정의된 변수를 변경하고 참조할 수 있다.</strong></p><ul><li>람다가 외부의 변수를 포획한다는 의미</li></ul></li></ul><h2 id=람다-vs-익명-내부-클래스>람다 vs 익명 내부 클래스<a hidden class=anchor aria-hidden=true href=#람다-vs-익명-내부-클래스>#</a></h2><ul><li><p>함수 타입을 사용하면 진부한 코드가 줄어들고 유연성이 증가한다.</p><ul><li>예를 들어, 자바 8과 같이 함수 타입을 제공하지 않는 언어</li></ul></li><li><p>자바 8은 <strong>객체지향 프로그래밍과 람다 표현식</strong>을 모두 지원한다.</p><ul><li><p>그러나 <strong>함수의 매개변수</strong>나 <strong>변수 에 함수를 정의</strong>할 수 있는 <strong>기능이 없다.</strong> (함수의 변수화가 불가)</p></li><li><p>대신에 자바는 <strong>익명 내부 클래스(anonymous inner cass)</strong> 를 제공</p></li><li><p>이것은 단일 메서드(method)를 구현하기 위해 다른 클래스에 정의된 이름이 없는 클래스다.</p></li><li><p>그리고 람다처럼 <strong>익명 내부 클래스를 인스턴스로 생성하여 전달</strong>할 수 있다.</p></li></ul></li><li><p>자바에서는 람다를 정의하는 함수를 나타내기 위해(변수화) 이름이 있는 <strong>타입(인터페이스나 클래스)의 정의가 추가로 필요</strong>하다</p></li></ul><h1 id=null-안전과-예외>null 안전과 예외<a hidden class=anchor aria-hidden=true href=#null-안전과-예외>#</a></h1><h2 id=코틀린의-null-처리-개요>코틀린의 null 처리 개요<a hidden class=anchor aria-hidden=true href=#코틀린의-null-처리-개요>#</a></h2><ul><li><p>nullable / non-nullable</p></li><li><p>자바는 어떤 타입의 변수도 null 값을 가질 수 있다.</p></li><li><p>코틀린은 non-nullable 변수는 null을 가질 수 없다. 따라서 <strong>런타임이 아닌 컴파일 시점에 방지 할 수 있다.</strong></p></li><li><p><strong>null이 필요 없다면 non-nullable 타입을 사용하는 것이 가장 안전하다.</strong></p><ul><li>가능한 한, non-nullable 타입을 사용하자</li></ul></li></ul><h2 id=에러-검출-시점컴파일-vs-런타임>에러 검출 시점(컴파일 vs 런타임)<a hidden class=anchor aria-hidden=true href=#에러-검출-시점컴파일-vs-런타임>#</a></h2><ul><li>코틀린은 컴파일러라는 특별한 프로그램에 의해, <strong>기계어로 변환되는 컴파일 언어</strong> 이다.</li><li>런타임 에러는 프로그램이 실행된 이후에 발생된 에러임으로, 사전에 알려 줄 수 없다.</li></ul><h2 id=null-안전-처리>null 안전 처리<a hidden class=anchor aria-hidden=true href=#null-안전-처리>#</a></h2><ul><li><p><strong>안전 호출 연산자</strong> → <code>.?</code></p></li><li><p><strong>non-null 단언(assertion) 연산자</strong> → !!</p><ul><li>null이면 런타임에 NPE 예외 발생</li><li>컴파일러가 null 발생을 미리 알 수 없는 상황이 생길 수 있을 때 사용된다.</li><li>프로그램의 오류가능성을 runtime에 예측하는 것은 거의 불가능하니, 조심해서 사용해야 함</li></ul></li><li><p>값이 null인지 if 문 검사</p></li><li><p>엘비스 연산자(null 복합 연산자) → <code>?:</code></p><ul><li><p><code>val beverageServed: String = beverage ?: "맥주"</code></p></li><li><p><strong>엘비스 연산자</strong>는 null이 될 수 있는 값을 바로잡는 데 사용될 수 있다.</p></li></ul></li><li><p>자바에서 @NotNull 어노테이션 → null 일 수 없다.</p><ul><li>코틀린 소스 코드가 컴파일되어 JVM의 자바 코드로 생성될 때, <code>checkParameterIsNotNull</code> 이라는 메서드가 사용됨.</li><li>자바로 역컴파일된 바이트코드를 보면 알 수 있다.</li></ul></li></ul><h2 id=예외-던지기-exception-throw>예외 던지기, Exception Throw<a hidden class=anchor aria-hidden=true href=#예외-던지기-exception-throw>#</a></h2><ul><li>예외는 프로그램이 잘못되었다는 것을 나타낼때 사용</li><li>예외가 발생할 때는 그것을 처리해야 하며, 그렇지 않으면 <strong>실행이 중단(crash)</strong> 된다.<ul><li><strong>미처리 예외(unhandled exception)</strong>: 처리되지 않은 예외</li></ul></li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-kotlin data-lang=kotlin><span class=line><span class=cl><span class=k>fun</span> <span class=nf>proficiencyCheck</span><span class=p>(</span><span class=n>swordsJuggling</span><span class=p>:</span> <span class=n>Int</span><span class=p>?)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=n>swordsJuggling</span> <span class=o>?:</span> <span class=k>throw</span> <span class=n>IllegalStateException</span><span class=p>(</span><span class=s2>&#34;플레이어가 저글링을 할 수 없음!)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><ul><li><p>throw : <strong>예외를 발생 시킨다. === 예외를 던진다</strong></p><ul><li><p><strong>실행전에 처리되어야 하는 문제를 알려 주기 위해 예외를 던진다.</strong></p></li><li><p>Crash 되는 이유를 명확히 알 수 있음</p><ul><li><code>stackTrace, message</code></li></ul></li><li><p>예시에서, swordsJuggling 변수가 null 이되는 경우가 생긴다면, 개발하는 시점에 알 수 있는 가능성이 커진다.</p></li></ul></li><li><p>커스텀 예외 : 예외를 상속 받은 클래스, 코드 유연성 증가, 재사용성 증가, 에러 메서지 출력 가능</p></li></ul><h2 id=예외-처리-가이드>예외 처리 가이드<a hidden class=anchor aria-hidden=true href=#예외-처리-가이드>#</a></h2><ul><li><p><strong>논리 오류</strong>: 프로그램이 <strong>강제 종료되지도 않고</strong> <strong>의도대로 동작하지도 않는 상황</strong></p><ul><li><p>예외가 던져지지 않으므로 런타임에 발생하는 <code>RuntimeException</code>과는 다른 상황</p><ul><li>기존에는 예외가 던져지지 않았기에, <strong>이런 경우에 예외를 던져보자</strong></li></ul></li><li><p>기본적으로 일단, <strong>최대한 논리 오류가 태초에 발생 하지 않도록 만들어야 함</strong></p></li><li><p>그럼에도 불구하고, 논리 오류가 발생하는 경우에 예외를 던져야 함</p></li><li><p>논리 오류는 에러 원인을 예측하기 어렵기 때문에 <strong>디버깅이 굉장히 어렵다.</strong></p></li><li><p>Ex) 양수여야 하는 값이 음수인 경우</p></li></ul></li></ul><ul><li><p>논리 오류일 때만 예외를 던지세요.</p></li><li><p>논리 오류가 아니면 예외를 던지지 말고, <strong>null을 반환</strong>하세요.</p></li><li><p>실패하는 경우가 복잡해서 null로 처리할 수 없으면 <code>sealed class</code>를 반환하세요.</p><ul><li>성공, 실패들을 모두 <code>sealed class</code>로 선언해보세요.</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-kotlin data-lang=kotlin><span class=line><span class=cl><span class=k>class</span> <span class=nc>IdentityNumber</span><span class=p>(</span><span class=k>private</span> <span class=k>val</span> <span class=py>numbers</span><span class=p>:</span> <span class=n>List</span><span class=p>&lt;</span><span class=n>Int</span><span class=p>&gt;)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>companion</span> <span class=k>object</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>fun</span> <span class=nf>from</span><span class=p>(</span><span class=n>front</span><span class=p>:</span> <span class=n>List</span><span class=p>&lt;</span><span class=n>Int</span><span class=p>&gt;,</span> <span class=n>back</span><span class=p>:</span> <span class=n>List</span><span class=p>&lt;</span><span class=n>Int</span><span class=p>&gt;):</span> <span class=n>IdentityNumberResult</span> <span class=p>=</span> <span class=k>when</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=n>front</span><span class=p>.</span><span class=n>size</span> <span class=o>!=</span> <span class=m>6</span> <span class=o>-&gt;</span> <span class=nc>IdentityNumberResult</span><span class=p>.</span><span class=n>InvalidFrontSize</span>
</span></span><span class=line><span class=cl>            <span class=n>back</span><span class=p>.</span><span class=n>size</span> <span class=o>!=</span> <span class=m>7</span> <span class=o>-&gt;</span> <span class=nc>IdentityNumberResult</span><span class=p>.</span><span class=n>InvalidBackSize</span>
</span></span><span class=line><span class=cl>            <span class=k>else</span> <span class=o>-&gt;</span> <span class=nc>IdentityNumberResult</span><span class=p>.</span><span class=n>Success</span><span class=p>(</span><span class=n>IdentityNumber</span><span class=p>(</span><span class=n>front</span> <span class=p>+</span> <span class=n>back</span><span class=p>))</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>sealed</span> <span class=k>class</span> <span class=nc>IdentityNumberResult</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>data</span> <span class=k>class</span> <span class=nc>Success</span><span class=p>(</span><span class=k>val</span> <span class=py>identityNumber</span><span class=p>:</span> <span class=n>IdentityNumber</span><span class=p>)</span> <span class=p>:</span> <span class=n>IdentityNumberResult</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=k>object</span> <span class=nc>InvalidFrontSize</span> <span class=p>:</span> <span class=n>IdentityNumberResult</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=k>object</span> <span class=nc>InvalidBackSize</span> <span class=p>:</span> <span class=n>IdentityNumberResult</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div></li><li><p>일반적인 코틀린 코드에서 <code>try-catch, runCatching()</code>를 사용하지 마세요.</p><ul><li><p>예외는 반드시 <strong>예외적인 상황에서만</strong> 던져야 합니다.</p></li><li><p>&lsquo;<em>논리 오류일 때만 예외를 던지세요.&rsquo;</em></p></li><li><p>논리 오류일 때 던지는 예외를 포함해서, 프로그램 전체적으로 발생하는 <strong>예외들</strong>을 <strong>전역적으로 처리해주는 예외 처리기를 통해 보고</strong>해야 합니다.</p><ul><li>예시) 예상 가능한 네트워크 예외 처리에 대한, <code>CoroutineExceptionHandler</code></li></ul></li></ul></li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-kotlin data-lang=kotlin><span class=line><span class=cl><span class=k>class</span> <span class=nc>PositiveNumber</span> <span class=k>private</span> <span class=k>constructor</span><span class=p>(</span><span class=k>val</span> <span class=py>value</span><span class=p>:</span> <span class=n>Int</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>companion</span> <span class=k>object</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>fun</span> <span class=nf>from</span><span class=p>(</span><span class=k>value</span><span class=p>:</span> <span class=n>Int</span><span class=p>):</span> <span class=n>PositiveNumber</span><span class=p>?</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=p>(</span><span class=k>value</span> <span class=o>&lt;=</span> <span class=m>0</span><span class=p>)</span> <span class=k>return</span> <span class=k>null</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=n>PositiveNumber</span><span class=p>(</span><span class=k>value</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>    <span class=p>}}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>PositiveNumberTest</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nd>@Test</span>
</span></span><span class=line><span class=cl>    <span class=k>fun</span> <span class=nf>`음수로는 만들 수 없다`</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=c1>// when
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=k>val</span> <span class=py>actual</span> <span class=p>=</span> <span class=nc>PositiveNumber</span><span class=p>.</span><span class=n>from</span><span class=p>(-</span><span class=m>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=c1>// then
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=n>assertNull</span><span class=p>(</span><span class=k>actual</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>}}</span>
</span></span></code></pre></td></tr></table></div></div><ul><li><strong>생성자를 사용할 수 없도록 private으로 숨기고</strong> <em>from()</em> <strong>팩토리 함수</strong>를 추가하였습니다.<ul><li>이렇게 하면 외부에서는 반드시 <code>from()</code> 함수를 통해서만 <code>PositiveNumber</code>를 만들어야 하고 만약 음수라면 <code>null</code>이 반환됩니다.</li><li>이 방식에서는 <strong>음수로 양수(PositiveNumber)를 만든다는 논리 오류 자체</strong>가 <strong>발생할 수가 없습니다.</strong></li></ul></li></ul><h2 id=예외-처리>예외 처리<a hidden class=anchor aria-hidden=true href=#예외-처리>#</a></h2><ul><li><p>try / catch</p></li><li><p>try문에서는 예외가 발생될 수 있는 코드를 넣는다.</p></li><li><p>catch문은 예외가 생길 때만 실행</p></li><li><p>catch 문에서는 처리할 예외의 특정 타입을 인자로 받는다</p></li><li><p>코틀린에서의 예외는 unchecked 예외,</p><ul><li>예외를 생길 수 있는 모든 코드를 컴파일러가 try / catch문으로 처리하도록 강제하지 않는다. (자바는 checked, unchecked가 구분되어 있다.)</li></ul></li></ul><h2 id=전제-조건>전제 조건<a hidden class=anchor aria-hidden=true href=#전제-조건>#</a></h2><ul><li><strong>전제 조건 함수</strong>: 일부 코드가 실행되기 전에 충족되어야 하는 전제 조건을 정의한 함수<ul><li><p><strong>checkNotNull, require, requireNotNull, error, assert</strong></p></li><li><p>안전하게 코드 작성 가능</p></li></ul></li></ul><h2 id=null-무엇이-좋을까>null 무엇이 좋을까?<a hidden class=anchor aria-hidden=true href=#null-무엇이-좋을까>#</a></h2><ul><li><p>값을 지정하지 않고 변수를 초기화 할 수 있다.</p><ul><li>null으로 <strong>상태(State)</strong> 를 표시함</li><li>변수의 초깃값에 많이 사용</li></ul></li><li><p><strong>NPE를 피하는 방법</strong></p><ul><li><p>empty 값을 통해 더 좋고 안전한 코드 초기화를 할 수 있다.</p><ul><li>null 불가 타입으로 지정하고, <code>빈 문자열("")</code>로 초기화</li></ul></li><li><p>null이 될 수 있다는 것을 인정하고, <strong>null 가능 타입의 처리 방법들</strong> 을 사용</p><ul><li><code>var personName: String? = ""</code></li></ul></li></ul></li></ul><h2 id=checked-예외와-unchecked-예외>checked 예외와 unchecked 예외<a hidden class=anchor aria-hidden=true href=#checked-예외와-unchecked-예외>#</a></h2><ul><li><p>코틀린에서는 모든 예외가 <strong>unchecked 예외</strong>다.</p><ul><li>즉, 예외가 생길 수 있는 모든 코드를 우리가 try / catch로 반드시 처리하도록 강요하지 않음</li></ul></li><li><p><strong>자바는 checked와 unchecked 예외 타입이 구분되어 있다.</strong></p><ul><li>checked 예외의 경우, 예외 처리를 했는지를 컴파일러가 검증함</li></ul></li><li><p>대부분의 <strong>checked 예외(예를 들어, 파일을 저장, IOException)</strong> 는 발생했더라도 <strong>우리가 특별히 할 것이 없다.</strong></p><ul><li><p>따라서 개발자들이 해당 예외의 catch 블록 안에 처리 코드를 작성하지 않는 경우가 있다</p><ul><li>예를 들어, <code>catch (e: IOException) { }</code></li></ul></li><li><p>해당 checked 예외가 무시되고(경보가 울렸는데 무시하는 것과 같다) 프로그램은 정상적으로 수행된다. 원인을 찾기 어려워짐</p></li></ul></li><li><p>checked 예외는 문제를 해결하기 보다는 오히려 더 많은 문제를 야기할 수 있다.</p><ul><li>코드 중복, 어려운 에러 복구 로직, 예외 무시</li></ul></li></ul><h1 id=문자열>문자열<a hidden class=anchor aria-hidden=true href=#문자열>#</a></h1><h2 id=해체-선언-destructing-declaration>해체 선언 (destructing declaration)<a hidden class=anchor aria-hidden=true href=#해체-선언-destructing-declaration>#</a></h2><p><code>val (type, name, price) = menuData.split(',')</code></p><h2 id=문자열은-불변이다>문자열은 불변이다.<a hidden class=anchor aria-hidden=true href=#문자열은-불변이다>#</a></h2><ul><li>코틀린의 모든 문자열(String 타입)은 <strong>val or var 중 어느 것으로 정의</strong>되든 <strong>자바처럼 불변</strong>이다.</li><li><code>replace</code> 처럼 값을 변경하는 것 처럼 보이는 어떤 함수도 실제로는 <strong>새로운 문자열로 변경값을 생성</strong>한다.</li></ul><h2 id=문자열-비교>문자열 비교<a hidden class=anchor aria-hidden=true href=#문자열-비교>#</a></h2><ul><li>참조 동등 : 특정 타입 인스턴스의 <strong>참조</strong>를 똑같이 갖는지 검사한다.<ul><li><strong>heap 메모리 영역에 같은 객체를 참조</strong>하는지 검사한다. (<code>=== 연산자</code>)</li></ul></li><li>자바에서는 <code>== 연산자</code>가 두 문자열의 참조를 비교하므로 코틀린과 다르다.<ul><li>자바에서 문자열의 값을 비교할때는 equals 메서드를 사용해야 한다.</li></ul></li></ul><h2 id=비교-연산>비교 연산<a hidden class=anchor aria-hidden=true href=#비교-연산>#</a></h2><table><thead><tr><th></th><th>Kotlin</th><th>Java</th></tr></thead><tbody><tr><td>동등성(Equality, Structural equality)</td><td>==</td><td>equals</td></tr><tr><td>동일성(Identify, Referential equality)</td><td>===</td><td>==</td></tr></tbody></table><ul><li><p>자바, 코틀린 모두 원시 타입인 경우 <strong>동등성 비교</strong>는 <code>==</code> 으로 <strong>같은 연산자를 사용</strong></p></li><li><p>참조 타입일 때만, 달라짐</p></li><li><p><strong>구조적 동등성, Equality 비교</strong> (<code>==</code>, <code>!=</code>)</p><ul><li><p>기본 타입인 경우: <strong>값</strong> 비교, 값의 동등성 비교</p></li><li><p>참조 타입인 경우: <code>equals()</code> 로 객체의 내용 비교</p><ul><li><code>==</code>는 내부적으로 <code>equals</code>를 호출한다. (<strong>연산자 오버라이딩</strong> 기능)</li></ul></li></ul></li><li><p><strong>참조 동등성, Identify 비교</strong> (<code>===</code>, <code>!==</code>))</p><ul><li><p>객체의 <strong>메모리 주소</strong>를 비교</p></li><li><p>코틀린은 자바에는 없는 <code>===</code>연산자를 지원한다.</p></li><li><p>즉, 자바의 주소 값 비교인 <code>==</code>와 코틀린의 <code>===</code>가 동일한 역할을 한다.</p></li></ul></li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kt>int</span><span class=w> </span><span class=n>a</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>1</span><span class=w> </span><span class=c1>// 원시 타입</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kt>int</span><span class=w> </span><span class=n>b</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>2</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kt>int</span><span class=w> </span><span class=n>c</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>1</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>System</span><span class=p>.</span><span class=na>out</span><span class=p>.</span><span class=na>println</span><span class=p>(</span><span class=n>a</span><span class=w> </span><span class=o>==</span><span class=w> </span><span class=n>b</span><span class=p>)</span><span class=w> </span><span class=c1>// false</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>System</span><span class=p>.</span><span class=na>out</span><span class=p>.</span><span class=na>println</span><span class=p>(</span><span class=n>a</span><span class=w> </span><span class=o>==</span><span class=w> </span><span class=n>c</span><span class=p>)</span><span class=w> </span><span class=c1>// true</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>String</span><span class=w> </span><span class=n>a</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=s>&#34;hi&#34;</span><span class=w> </span><span class=c1>// 주소값 : 1번지, 참조 타입</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>String</span><span class=w> </span><span class=n>b</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=s>&#34;hi&#34;</span><span class=w> </span><span class=c1>// 주소값 : 2번지</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>System</span><span class=p>.</span><span class=na>out</span><span class=p>.</span><span class=na>println</span><span class=p>(</span><span class=n>a</span><span class=w> </span><span class=o>==</span><span class=w> </span><span class=n>b</span><span class=p>)</span><span class=w> </span><span class=c1>// false, Idenrify 비교</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>System</span><span class=p>.</span><span class=na>out</span><span class=p>.</span><span class=na>println</span><span class=p>(</span><span class=n>a</span><span class=p>.</span><span class=na>equals</span><span class=p>(</span><span class=n>b</span><span class=p>))</span><span class=w> </span><span class=c1>// true, Equality 비교</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-kotlin data-lang=kotlin><span class=line><span class=cl><span class=k>val</span> <span class=py>a</span><span class=p>:</span> <span class=n>String</span> <span class=p>=</span> <span class=s2>&#34;hi&#34;</span>
</span></span><span class=line><span class=cl><span class=k>val</span> <span class=py>b</span><span class=p>:</span> <span class=n>String</span> <span class=p>=</span> <span class=s2>&#34;hi&#34;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>println</span><span class=p>(</span><span class=n>a</span> <span class=o>===</span> <span class=n>b</span><span class=p>)</span> <span class=c1>// false, Idenrify 비교
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>println</span><span class=p>(</span><span class=n>a</span> <span class=o>==</span> <span class=n>b</span><span class=p>)</span> <span class=c1>// true, Equality 비교
</span></span></span></code></pre></td></tr></table></div></div><h1 id=숫자>숫자<a hidden class=anchor aria-hidden=true href=#숫자>#</a></h1><ul><li><p>Byte (8비트)</p></li><li><p>Short (16비트)</p></li><li><p>Int (32비트)</p></li><li><p>Long (64비트)</p></li><li><p>Float (32비트)</p></li><li><p>Double (64비트)</p></li><li><p>숫자에는 <strong>정수와 소수</strong>가 있다.</p></li></ul><h2 id=문자열을-숫자-타입으로-변환하기>문자열을 숫자 타입으로 변환하기<a hidden class=anchor aria-hidden=true href=#문자열을-숫자-타입으로-변환하기>#</a></h2><ul><li>toFloat, toDouble, toLong, toIntOrNull</li><li><code>val gold: Int = "5.91".toIntOrNull ?: 0</code></li></ul><h2 id=소수>소수<a hidden class=anchor aria-hidden=true href=#소수>#</a></h2><ul><li><p>소수점값을 구하려면 코틀린이 <strong>부동 소수점 연산</strong>을 해야 한다.</p></li><li><p><strong>위치가 달라질 수 있는 소수점</strong>을 의미하는 부동 소수점은 실수의 근사치이며, 정밀도와 성능 모두를 지원하기 위해 근사치를 사용한다.</p></li><li><p><code>%.2f.format(~~~)</code> : 소수점 이하 두 자리 형식</p><ul><li>Double 타입에 toInt 를 호출하면, 소수점 이하 값이 절삭되어 정수로 변환된다. (4.91.toInt → 4)</li></ul></li></ul><h1 id=표준-함수-범위-지정-함수>표준 함수 (범위 지정 함수)<a hidden class=anchor aria-hidden=true href=#표준-함수-범위-지정-함수>#</a></h1><ul><li><p>코틀린의 <strong>표준 함수(범위 지정 함수)</strong> 는 내부적으로 확장 함수이며,</p></li><li><p><strong>확장 함수를 실행하는 주체</strong>를 <code>수신자 또는 수신자 객체, 수신 객체, receiver</code> 라고 한다.</p></li><li><p><strong>표준 함수(범위 지정 함수)</strong> 는 <strong>람다를 인자로 받아 동작</strong>한다.</p><ul><li>인자로 받은 block 변수(함수)를 실행</li></ul></li><li><p>수신 객체라는 용어는 Kotlin의 <strong>확장 함수</strong>에서 등장한다.</p></li></ul><ul><li><p>확장 함수에서 <code>this</code>는 확장된 클래스의 객체, 즉 확장 함수를 사용하는 그 객체가 된다.</p><ul><li><p>그 객체가 바로 <code>수신 객체(Receiver object)</code>이고,</p></li><li><p>확장할 클래스가 <code>수신 객체 타입(Receiver Type)</code></p></li><li><p>수신: ‘(수신) 객체가 코드를 받는다.’</p></li></ul></li></ul><h3 id=수신-객체-지정-람다-lambdas-with-receivers><strong>수신 객체 지정 람다 (Lambdas with Receivers)</strong><a hidden class=anchor aria-hidden=true href=#수신-객체-지정-람다-lambdas-with-receivers>#</a></h3><ul><li><p><code>수신 객체 지정 람다</code>는 람다에 <strong>확장 함수</strong> 처럼 수신 객체를 사용한 것이다. <code>T.() -> R</code></p><ul><li><p>확장 함수에서 <strong>수신 객체</strong>를 사용하여 <strong>블록 내에 객체를 전달했듯이</strong>,</p><ul><li><code>수신 객체 지정 람다(Lambdas with Receivers)</code> 또한 <strong>수신 객체를 이용하여 객체를 전달</strong>한다.</li></ul></li><li><p>따라서 <code>수신 객체 지정 람다</code>에서는 <strong>수신 객체를 this로 대신</strong>할 수 있다.</p></li><li><p>또한 <strong>this를 생략하고 해당 객체의 멤버에 바로 접근</strong>이 가능하다.</p></li></ul></li><li><p>반면 <code>일반 람다</code>는 객체를 <strong>인자(파라미터)</strong> 로 전달한다. <code>(T) -> R</code></p><ul><li>람다의 매개변수가 하나뿐이고, 컴파일러가 타입을 추론할 수 있을 때 객체는 기본 매개변수인 <code>it</code>으로 받을 수 있다.</li></ul></li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-kotlin data-lang=kotlin><span class=line><span class=cl><span class=k>inline</span> <span class=k>fun</span> <span class=p>&lt;</span><span class=nc>T</span><span class=p>&gt;</span> <span class=nf>T</span><span class=p>.</span><span class=n>apply</span><span class=p>(</span><span class=n>block</span><span class=p>:</span> <span class=nc>T</span><span class=p>.()</span> <span class=o>-&gt;</span> <span class=n>Unit</span><span class=p>):</span> <span class=n>T</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>block</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=k>this</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=k>inline</span> <span class=k>fun</span> <span class=p>&lt;</span><span class=nc>T</span><span class=p>,</span> <span class=nc>R</span><span class=p>&gt;</span> <span class=nf>T</span><span class=p>.</span><span class=n>run</span><span class=p>(</span><span class=n>block</span><span class=p>:</span> <span class=nc>T</span><span class=p>.()</span> <span class=o>-&gt;</span> <span class=n>R</span><span class=p>):</span> <span class=n>R</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>block</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=k>inline</span> <span class=k>fun</span> <span class=p>&lt;</span><span class=nc>T</span><span class=p>,</span> <span class=nc>R</span><span class=p>&gt;</span> <span class=nf>with</span><span class=p>(</span><span class=k>receiver</span><span class=p>:</span> <span class=n>T</span><span class=p>,</span> <span class=n>block</span><span class=p>:</span> <span class=nc>T</span><span class=p>.()</span> <span class=o>-&gt;</span> <span class=n>R</span><span class=p>):</span> <span class=n>R</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=k>receiver</span><span class=p>.</span><span class=n>block</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>inline</span> <span class=k>fun</span> <span class=p>&lt;</span><span class=nc>T</span><span class=p>&gt;</span> <span class=nf>T</span><span class=p>.</span><span class=n>also</span><span class=p>(</span><span class=n>block</span><span class=p>:</span> <span class=p>(</span><span class=n>T</span><span class=p>)</span> <span class=o>-&gt;</span> <span class=n>Unit</span><span class=p>):</span> <span class=n>T</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>block</span><span class=p>(</span><span class=k>this</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=k>this</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=k>inline</span> <span class=k>fun</span> <span class=p>&lt;</span><span class=nc>T</span><span class=p>,</span> <span class=nc>R</span><span class=p>&gt;</span> <span class=nf>T</span><span class=p>.</span><span class=n>let</span><span class=p>(</span><span class=n>block</span><span class=p>:</span> <span class=p>(</span><span class=n>T</span><span class=p>)</span> <span class=o>-&gt;</span> <span class=n>R</span><span class=p>):</span> <span class=n>R</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>block</span><span class=p>(</span><span class=k>this</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><h2 id=apply>apply<a hidden class=anchor aria-hidden=true href=#apply>#</a></h2><ul><li><p>수신자 객체의 참조 가능</p><ul><li>this로 참조, this 생략 가능</li></ul></li><li><p>람다의 실행이 끝나면 현재의 수신자 객체가 반환된다.</p></li></ul><h2 id=run>run<a hidden class=anchor aria-hidden=true href=#run>#</a></h2><ul><li>apply와 다르게 run은 수신자 객체를 반환하지 않는다.</li><li>람다의 결과, <strong>마지막 코드 줄의 실행 결과를 반환</strong>한다.</li><li>함수 호출이 여러 개 있을때 함수 중첩 보다 run을 사용하면 편리하다.</li><li><code>"~~~".run(::myFun)</code> = <code>myFun("~~~")</code></li></ul><h2 id=with>with<a hidden class=anchor aria-hidden=true href=#with>#</a></h2><ul><li><p>run 과 동일하게 동작하지만 호출 방식이 다르다.</p></li><li><p>수신자 객체를 첫 번째 매개변수의 인자로 받는다.</p></li><li><p><strong>with 대신 run을 사용할 것을 권한다.</strong></p><ul><li>잘 사용 안됨</li></ul></li></ul><h2 id=also>also<a hidden class=anchor aria-hidden=true href=#also>#</a></h2><ul><li>let 처럼 자신을 호출한 수신자 객체를 람다의 인자로 전달한다.</li><li>let과 달리, 람다의 결과를 반환하지 않고, <strong>수신자 객체를 반환</strong>한다.</li></ul><h2 id=let>let<a hidden class=anchor aria-hidden=true href=#let>#</a></h2><ul><li><p>수신 객체를 람다의 <strong>인자(파라미터)</strong> 로 전달</p></li><li><p>전달된 람다를 실행한 후, <strong>마지막 코드 줄의 실행 결과를 반환</strong>해준다.</p></li><li><p><strong>null check</strong> 후 코드를 실행해야 하는 경우</p><ul><li>안전 호출 연산자 → <code>.?</code></li><li>&lsquo;?.let&rsquo;을 사용 하게 되면 let의 block은 수신객체가 null이 아닐 때만 수행된다.</li><li>따라서 let block에서의 it의 타입은 nullable하지 않은 타입이 된다. (스마트 캐스팅)</li></ul></li><li><p><strong>nullable</strong>한 수신객체를 다른 타입의 변수로 변환해야 하는경우</p></li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-kotlin data-lang=kotlin><span class=line><span class=cl><span class=k>var</span> <span class=py>person</span><span class=p>:</span> <span class=n>Person</span><span class=p>?</span> <span class=p>=</span> <span class=k>null</span>
</span></span><span class=line><span class=cl><span class=k>val</span> <span class=py>isReserved</span> <span class=p>=</span> <span class=n>person</span><span class=o>?.</span><span class=n>let</span> <span class=p>{</span> <span class=k>it</span><span class=p>:</span> <span class=n>Person</span> <span class=o>-&gt;</span>
</span></span><span class=line><span class=cl>    <span class=n>reserveMovie</span><span class=p>(</span><span class=k>it</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><h1 id=list-set-map>List, Set, Map<a hidden class=anchor aria-hidden=true href=#list-set-map>#</a></h1><ul><li><strong>컬렉션</strong>은 <strong>연관된 값들을 모아서 저장하고 사용하는 자료구조</strong><ul><li>List, Map, Set이 있다.</li></ul></li><li>컬렉션에 저장된 각각의 데이터를 element (요소) 라고 한다.</li><li>코틀린에서는 <strong>mutable(변경 가능한) 타입과 read-only(읽기 전용) 타입</strong>이 있다.</li><li>코틀린 컬렉션은 <strong>가변성 개념을 제공</strong>하면서, 강력한 기능을 제공</li></ul><h2 id=list>List<a hidden class=anchor aria-hidden=true href=#list>#</a></h2><ul><li><p><code>List&lt;myType></code> 에서</p><ul><li><code>myType</code>: <strong>매개변수화 타입</strong>, 요소의 타입이 myType이라는 것을 알려줌.</li></ul></li><li><p>List은 <strong>제네릭 타입</strong> 이다. ⇒ List는 어떤 타입의 데이터도 저장할 수 있다</p></li><li><p><code>listOf 함수</code>: 컬렉션 자체를 <strong>생성</strong> 하고, <strong>데이터 추가</strong> 하는 일을 둘 다 하는 함수</p></li><li><p>안전한 인덱스 사용 : getOrElse, 예외 대신 기본값을 반환 / getOrNull 와 :? 사용</p></li><li><p>containsAll : 요소가 존재하는 지 한 번에 확인할때 사용</p></li><li><p>List의 변경 가능 여부는 <strong>List의 타입</strong>에 의해 결정</p><ul><li><strong>‘변경 가능(mutable)’ 은 저장된 요소를 변경할 수 있다는 것을 의미</strong>한다.</li><li><code>List</code> 타입은 read-only 이다.</li></ul></li><li><p>변경 가능 ⇒ <code>MutableList 타입</code>을 사용해야 함, add, remove 사용 가능</p></li><li><p><code>toList</code> &lt;=> <code>toMutableList</code> 으로 상호 변경 가능</p></li></ul><h3 id=반복-처리>반복 처리<a hidden class=anchor aria-hidden=true href=#반복-처리>#</a></h3><ul><li><p>in 키워드 : for 루프에서 반복 처리되는 객체를 나타낸다.</p></li><li><p>itertation(반복 처리) 가능</p><ul><li>for 루프로 요소의 이름을 지정하면, 코틀린 컴파일러가 타입을 알아서 처리</li></ul></li><li><p><code>Iterable 타입</code>은 반복 처리를 지원한다.</p><ul><li>List, Set, Map, IntRange</li></ul></li></ul><h3 id=해체-선언>해체 선언<a hidden class=anchor aria-hidden=true href=#해체-선언>#</a></h3><ul><li>List는 또한, 맨 앞의 다섯 개 요소까지 변수로 해체 할 수 있는 기능을 제공한다.</li><li>해체를 원하는 않는 요소에 <code>_(밑줄)</code>을 사용해서 선택적으로 해체할 수도 있다.</li></ul><h2 id=set>Set<a hidden class=anchor aria-hidden=true href=#set>#</a></h2><ul><li><p>수학의 집합처럼 <strong>요소가 고유한 것을 보장</strong>해 주는 컬렉션</p></li><li><p>인덱스와 인덱스 연산자([])를 사용해서 요소를 처리할 수 <strong>없다.</strong></p><ul><li><code>elementAt 함수</code>를 사용해서 특정 인덱스의 요소를 요청 할 수 있다.</li><li>한 번에 하나의 요소를 반복해서 읽는다. (반복 처리 가능, itertation)</li><li>따라서, 인덱스 연산자 보다 느리다</li></ul></li><li><p>순서를 갖지 않는다.</p></li><li><p>‘값’ 이 고유하다.</p></li></ul><h2 id=array-배열-타입>Array, 배열 타입<a hidden class=anchor aria-hidden=true href=#array-배열-타입>#</a></h2><ul><li><p>코틀린은 <strong>참조 타입</strong>밖에 없다. (<strong>컬렉션도 참조 타입</strong>)</p></li><li><p>자바에서는 <code>Array</code>을 <strong>기본(원시) 타입</strong>으로 지원</p></li><li><p>코틀린에서 기본 타입이 아닌 <strong><code>Arrays</code> 라는 참조 타입으로 배열</strong>을 지원한다.</p><ul><li><code>val playerAges: IntArray = IntArrayOf(34, 23, 12)</code></li><li>Kotlin에서 <code>Arrays</code>는 <strong>참조 타입</strong>이지만, <strong>특별한 배열 타입</strong>을 통해 기본 타입 배열과 유사한 기능을 제공</li><li>내부적으로 <strong>원시 타입 값</strong>을 저장하여 메모리 사용량을 줄이고 성능을 향상</li><li><strong>코틀린의 (특별한) 배열 타입</strong>(<code>IntArray</code>, <code>ByteArray</code>, <code>BooleanArray</code>)</li></ul></li><li><p><code>IntArray</code> 타입은 자바의 <strong>기본 타입(배열 타입)</strong> 으로 컴파일 된다.</p></li><li><p>코틀린 컬렉션을 자바의 기본 배열 타입으로 변환 가능</p><ul><li><code>toIntArray</code></li></ul></li><li><p><code>val array1 = arrayOf(1, 2, 3)</code> , <code>val array2 = Array(5) { it }</code></p><ul><li>자바로 디컴파일 후 확인: <code>@NotNull final Interger[] array1;</code></li></ul></li><li><p><code>val array1 = intarray(1, 2, 3)</code> ,<code>val array2 = IntArray(5) { it }</code></p><ul><li>자바로 디컴파일 후 확인: <code>@NotNull final int[] array1;</code></li></ul></li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-kotlin data-lang=kotlin><span class=line><span class=cl><span class=c1>// 일반 객체 배열
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>val</span> <span class=py>numbers</span><span class=p>:</span> <span class=n>Array</span><span class=p>&lt;</span><span class=n>Int</span><span class=p>&gt;</span> <span class=p>=</span> <span class=n>arrayOf</span><span class=p>(</span><span class=m>1</span><span class=p>,</span> <span class=m>2</span><span class=p>,</span> <span class=m>3</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=k>val</span> <span class=py>strings</span><span class=p>:</span> <span class=n>Array</span><span class=p>&lt;</span><span class=n>String</span><span class=p>&gt;</span> <span class=p>=</span> <span class=n>arrayOf</span><span class=p>(</span><span class=s2>&#34;hello&#34;</span><span class=p>,</span> <span class=s2>&#34;world&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 기본 타입 배열
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>val</span> <span class=py>intNumbers</span><span class=p>:</span> <span class=n>IntArray</span> <span class=p>=</span> <span class=n>intArrayOf</span><span class=p>(</span><span class=m>1</span><span class=p>,</span> <span class=m>2</span><span class=p>,</span> <span class=m>3</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=k>val</span> <span class=py>booleanValues</span><span class=p>:</span> <span class=n>BooleanArray</span> <span class=p>=</span> <span class=n>booleanArrayOf</span><span class=p>(</span><span class=k>true</span><span class=p>,</span> <span class=k>false</span><span class=p>,</span> <span class=k>true</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 가변 배열
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>val</span> <span class=py>mutableArray</span> <span class=p>=</span> <span class=n>Array</span><span class=p>(</span><span class=m>5</span><span class=p>)</span> <span class=p>{</span> <span class=m>0</span> <span class=p>}</span> <span class=c1>// 0으로 초기화된 크기 5의 배열
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>mutableArray</span><span class=p>[</span><span class=m>0</span><span class=p>]</span> <span class=p>=</span> <span class=m>1</span>
</span></span></code></pre></td></tr></table></div></div><h2 id=읽기-전용-vs-변경-불가능>읽기 전용 vs 변경 불가능<a hidden class=anchor aria-hidden=true href=#읽기-전용-vs-변경-불가능>#</a></h2><ul><li>불변은 ‘<strong>변경 불가능’</strong> 을 의미</li><li>따라서 코틀린 컬렉션은 ‘읽기 전용’이 더 어울림.</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-kotlin data-lang=kotlin><span class=line><span class=cl><span class=k>val</span> <span class=py>x</span> <span class=p>=</span> <span class=n>listOf</span><span class=p>(</span> <span class=n>mutableListOf</span><span class=p>(</span><span class=m>1</span><span class=p>,</span> <span class=m>2</span><span class=p>,</span> <span class=m>3</span><span class=p>)</span> <span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>x</span><span class=p>[</span><span class=m>0</span><span class=p>].</span><span class=n>add</span><span class=p>(</span><span class=m>4</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=c1>// x = list( mutableListOf(1, 2, 3, 4) )
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>var</span> <span class=py>myList</span><span class=p>:</span> <span class=n>List</span><span class=p>&lt;</span><span class=n>Int</span><span class=p>&gt;</span> <span class=p>=</span> <span class=n>listOf</span><span class=p>(</span><span class=m>1</span><span class=p>,</span><span class=m>2</span><span class=p>,</span><span class=m>3</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>(</span><span class=n>myList</span> <span class=k>as</span> <span class=n>MutableList</span><span class=p>)[</span><span class=m>2</span><span class=p>]</span> <span class=p>=</span> <span class=m>1000</span>
</span></span><span class=line><span class=cl><span class=n>println</span><span class=p>(</span><span class=n>myList</span><span class=p>)</span> <span class=c1>// [1, 2, 1000]
</span></span></span></code></pre></td></tr></table></div></div><h2 id=map>Map<a hidden class=anchor aria-hidden=true href=#map>#</a></h2><ul><li><strong>키와 값의 쌍</strong>의 데이터 (<strong>entry</strong> 라고 한다.)</li><li>iteration 반복 처리 지원</li><li>정수 인덱스 기반 처리 대신 키를 기반으로 데이터 처리</li><li><code>to 함수</code>로 키와 값을 정의한다.</li><li>getValue, [ ], getOrElse, getOrDefault</li><li>‘키’ 가 고유하다.</li></ul><h1 id=클래스-정의하기>클래스 정의하기<a hidden class=anchor aria-hidden=true href=#클래스-정의하기>#</a></h1><ul><li><p>클래스는 <strong>사물이나 개념을 추상화 한 프로그래밍 요소</strong>이다.</p></li><li><p><strong>속성(property)과 기능(function)</strong> 을 갖는다.</p></li><li><p><strong>행동(역할)과 데이터를 정의</strong>한다.</p><ul><li>OOP의 핵심 요소</li></ul></li><li><p>default가 public</p></li></ul><h2 id=인스턴스-생성하기>인스턴스 생성하기<a hidden class=anchor aria-hidden=true href=#인스턴스-생성하기>#</a></h2><ul><li>생성자(constructor) 를 <strong>호출</strong>하여 인스턴스를 생성한다.</li><li>함수 호출과 비슷</li></ul><h2 id=가시성-제한자>가시성 제한자<a hidden class=anchor aria-hidden=true href=#가시성-제한자>#</a></h2><ul><li><p>클래스 함수나 속성의 가시성을 제한 하는 개념을 OOP에서 <strong>정보은닉, 캡슐화</strong>라 한다.</p></li><li><p>public : <strong>클래스 외부</strong>에서 클래스 요소 사용가능</p></li><li><p>private : <strong>클래스 내부</strong>에서만 요소 사용 가능</p></li><li><p>protected : <strong>클래스 내부 or 클래스의 서브 클래스</strong>에서만 사용될 수 있다</p></li><li><p>internal : 클래스가 포함된 ‘<strong>모듈(module)</strong> ’에서 사용될 수 있다</p></li></ul><h2 id=속성프로퍼티>속성(프로퍼티)<a hidden class=anchor aria-hidden=true href=#속성프로퍼티>#</a></h2><ul><li><p><strong>프로퍼티</strong>는 클래스의 <strong>데이터</strong> 즉, <strong>상태나 특성</strong>을 나타낸다.</p></li><li><p><strong>변수</strong>와 다르게 <strong>클래스 속성</strong>은 <strong>반드시 초깃값이 지정</strong>되어야 한다.</p><ul><li>인스턴스가 생성될 때 <strong>모든 속성이 값</strong>을 가져야 한다.</li><li>다른 함수나 프로그램에서 이 클래스의 속성에 접근할 수 도 있기 때문</li></ul></li></ul><h2 id=속성프로퍼티의-getter와-setter>속성(프로퍼티)의 getter와 setter<a hidden class=anchor aria-hidden=true href=#속성프로퍼티의-getter와-setter>#</a></h2><ul><li><p>프로퍼티를 <strong>외부에서 사용</strong>할때, 코틀린은 자동으로 getter를 통해 가져오고, setter를 통해 값을 지정한다.</p></li><li><p>정의한 각 속성에 대해 <strong>field와 getter or setter 가 생성</strong>된다.</p></li><li><p>getter 에서는 속성값을 읽는 방법이 명시된다.</p></li><li><p>커스텀 getter, setter를 정의할 수 있다. ⇒ <strong>getter, setter</strong>를 <code>overriding</code></p><ul><li>커스텀(override) 하지 않으면, 기본으로 생성되는 속성값을 있는 그대로 반환 및 지정</li></ul></li><li><p><code>field 키워드</code>는 프로퍼티에 대해 <strong>코틀린이 자동으로 관리해주는 <code>backing field</code> 를 참조</strong>한다.</p><ul><li><p><code>field 키워드</code>는 getter, setter에서만 사용할 수 있다.</p></li><li><p><strong><code>backing field</code></strong> 는 getter, setter가 사용하는 <strong>프로퍼티의 데이터</strong>다.</p></li></ul></li><li><p>getter는 backing field를 변경하지 않는다. setter는 backing field를 변경한다.</p></li><li><p>프로퍼티는 외부에 노출시키되(public), setter는 노출시키지 않으려면 <code>private set</code> 으로 따로 정의도 가능하다.</p><ul><li>기본적으로 getter, setter 의 가시성은 속성 자체의 가시성과 일치</li></ul></li><li><p>getter는 프로퍼티를 참조할 때 <strong>자동 호출</strong></p></li><li><p>setter는 대입 연산자(ex. <code>=</code>)를 사용해서 속성에 값을 지정할 때 <strong>자동 호출</strong></p></li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-kotlin data-lang=kotlin><span class=line><span class=cl><span class=k>var</span> <span class=py>name</span> <span class=p>=</span> <span class=s2>&#34;tae&#34;</span>
</span></span><span class=line><span class=cl>	<span class=k>get</span><span class=p>()</span> <span class=p>=</span> <span class=k>field</span><span class=p>.</span><span class=n>capitialize</span><span class=p>()</span>
</span></span><span class=line><span class=cl>	<span class=k>private</span> <span class=k>set</span><span class=p>(</span><span class=k>value</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>field</span> <span class=p>=</span> <span class=k>value</span><span class=p>.</span><span class=n>trim</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><h2 id=산출-속성computed-property>산출 속성(computed property)<a hidden class=anchor aria-hidden=true href=#산출-속성computed-property>#</a></h2><ul><li>다른 속성이나 변수 등의 값을 사용해서 자신의 값을 산출하는 속성, <strong>backing field 생성하지 않음.</strong></li><li><strong>초깃값이나 기본값이 없다</strong></li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-kotlin data-lang=kotlin><span class=line><span class=cl><span class=k>class</span> <span class=nc>Dice</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>val</span> <span class=py>rolledValue</span>
</span></span><span class=line><span class=cl>    	<span class=k>get</span><span class=p>()</span> <span class=p>=</span> <span class=p>(</span><span class=m>1.</span><span class=p>.</span><span class=m>6</span><span class=p>).</span><span class=n>shuffled</span><span class=p>().</span><span class=n>first</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><ul><li>이런 경우에서도 볼 수 있듯, &lsquo;변경 불가능&rsquo; 보다 &lsquo;읽기 전용&rsquo; 이라는 표현이 더 적합</li></ul><h2 id=패키지-사용하기>패키지 사용하기<a hidden class=anchor aria-hidden=true href=#패키지-사용하기>#</a></h2><ul><li><p>Ex) <code>com.myProject.presentation.music</code></p></li><li><p><strong>패키지(package)</strong> 는 폴더 처럼 비슷한 요소들을 분류하고 모아 놓은 것이다.</p></li><li><p>프로그램에서 직접 패키지를 지정할 때는 <code>package</code> 키워드를 사용한다.</p></li><li><p><strong>지정된 .kt 파일이 컴파일</strong>되면, <strong>생성된 바이트코드 파일(.clsas)</strong> 는 정의한 패키지 경로에 위치하게 된다.</p></li><li><p>같은 패키지에 있는 클래스들은 기본적으로 같이 사용할 수 있다.</p><ul><li>단, <strong>코틀린 표준 라이브러리</strong>의 모든 클래스나 함수 등은 import를 지정하지 않아도 바로 사용 가능</li></ul></li><li><p>다른 패키지에 있는 클래스나 함수 등을 사용하려면 <code>import 문</code>을 사용해서 <strong>그것들의 위치를 컴파일러에게 알려주어야 한다.</strong></p></li></ul><h2 id=경합-상태race-condition>경합 상태(race condition)<a hidden class=anchor aria-hidden=true href=#경합-상태race-condition>#</a></h2><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-kotlin data-lang=kotlin><span class=line><span class=cl><span class=k>class</span> <span class=nc>Weapon</span><span class=p>(</span><span class=k>val</span> <span class=py>name</span><span class=p>:</span> <span class=n>String</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>Player</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>var</span> <span class=py>weapon</span><span class=p>:</span> <span class=n>Weapon</span><span class=p>?</span> <span class=p>=</span> <span class=n>Weapon</span><span class=p>(</span><span class=s2>&#34;Ebony Kris&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=k>fun</span> <span class=nf>printweaponName</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=k>if</span> <span class=p>(</span><span class=n>weapon</span> <span class=o>!=</span> <span class=k>null</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=n>println</span><span class=p>(</span><span class=n>weapon</span><span class=p>.</span><span class=n>name</span><span class=p>)</span> <span class=c1>// Weapon 타입으로 스마트 캐스팅 할 수 없는 컴파일 에러
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=k>fun</span> <span class=nf>main</span><span class=p>(</span><span class=n>args</span><span class=p>:</span> <span class=n>Array</span><span class=p>&lt;</span><span class=n>string</span><span class=p>&gt;)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=n>player</span><span class=p>().</span><span class=n>printWeaponName</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><ul><li><p>컴파일러는 변수가 null이 아님이 if문 등으로 확인되더라도,</p><ul><li><strong>경합 상태</strong>가 생길 수 있기 때문에(<strong>여러 개의 스레드로 실행될 가능성 존재</strong>)</li><li>스마트 캐스팅이 할 수 없고, 컴파일 에러를 알려준다.</li></ul></li><li><p><strong>weapon의 값이 if로 확인된 시점</strong>과 <strong>println으로 weapon의 name을 출력하는 시점</strong> 사이에 weapon 이 null로 변경될 가능성이 여전히 있다. => 스마트 캐스팅 불가</p></li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-kotlin data-lang=kotlin><span class=line><span class=cl><span class=k>class</span> <span class=nc>Player</span> <span class=p>{</span> <span class=c1>// 해결법
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=k>var</span> <span class=py>weapon</span><span class=p>:</span> <span class=n>Weapon</span><span class=p>?</span> <span class=p>=</span> <span class=n>Weapon</span><span class=p>(</span><span class=s2>&#34;Ebony Kris&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=k>fun</span> <span class=nf>printweaponName</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=n>weapon</span><span class=o>?.</span><span class=n>also</span> <span class=p>{</span> <span class=n>print</span><span class=p>(</span><span class=k>it</span><span class=p>.</span><span class=n>name</span><span class=p>)</span> <span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><ul><li>also를 사용하면 해결 가능</li><li><strong>also 익명 함수</strong> 내에서만 존재하는 <strong>지역변수 it</strong> 으로 weapon 인스턴의 name 속성이 참조되기 때문</li><li>?.로 null이 아님이 확인 되었고,</li><li><strong>it의 값은 프로그램의 다른 코드에서 변경불가능</strong> 함</li><li><strong>컴파일러가 Weapon 타입으로 스마트 캐스팅 가능</strong></li></ul><h2 id=패키지-가시성>패키지 가시성<a hidden class=anchor aria-hidden=true href=#패키지-가시성>#</a></h2><ul><li><p>자바는 기본적으로 <strong>패키지 가시성</strong>을 사용한다.</p><ul><li>같은 패키지에 있는 클래스에서만 사용 가능하다.</li></ul></li><li><p><strong>코틀린에서는 패키지 가시성이 없다.</strong></p><ul><li>같은 패키지에 있는 클래스, 함수, 속성 등은 기본적으로 상호 사용가능하기 때문에 굳이 별도의 패키지 가시성을 가질 필요가 없기 때문이다.</li></ul></li><li><p><strong>모듈</strong>은 독자적으로 <strong>실행 및 테스트</strong>될 수 있는 프로그래밍 구성 단위</p><ul><li><p>코틀린은 <code>internal 가시성</code>을 지원한다. 자바는 지원하지 않음</p></li><li><p>바이트코드 파일에서 internal은 public이 된다.</p></li></ul></li></ul><h1 id=초기화>초기화<a hidden class=anchor aria-hidden=true href=#초기화>#</a></h1><ul><li><strong>클래스의 인스턴스를 생성</strong>하는 것은, <strong>클래스에 정의된 속성을 구조</strong>로 갖는 <strong>객체를 메모리에 할당</strong>하는 것</li></ul><h2 id=기본-생성자>기본 생성자<a hidden class=anchor aria-hidden=true href=#기본-생성자>#</a></h2><ul><li><p>커스텀하지 않고, <strong>자동으로 생성되는 기본 getter와 setter를 사용하는 속성</strong>의 경우에는,</p><ul><li>클래스 내부에 속성을 따로 정의하지 않고 <strong>기본 생성자에만 정의</strong>해도 된다.</li></ul></li><li><p><strong>기본 생성자에 정의된 변수</strong>는 클래스 <strong>속성</strong>과 생성자 <strong>매개변수</strong> 두 가지 역할을 하게 된다.</p></li><li><p><strong>기본 생성자</strong>에 <strong>속성</strong>을 정의할 때는 <code>var, val</code>을 추가해야 한다.</p></li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-kotlin data-lang=kotlin><span class=line><span class=cl><span class=k>class</span> <span class=nc>Player</span><span class=p>(</span><span class=n>_name</span><span class=p>:</span> <span class=n>String</span><span class=p>,</span> <span class=n>_health</span><span class=p>:</span> <span class=n>Int</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>val</span> <span class=py>name</span> <span class=p>=</span> <span class=n>_name</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>Player</span><span class=p>(</span><span class=k>private</span> <span class=k>val</span> <span class=py>name</span><span class=p>:</span> <span class=n>String</span><span class=p>,</span> <span class=k>var</span> <span class=py>health</span><span class=p>:</span> <span class=n>Int</span> <span class=p>=</span> <span class=m>100</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><h2 id=보조-생성자>보조 생성자<a hidden class=anchor aria-hidden=true href=#보조-생성자>#</a></h2><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-kotlin data-lang=kotlin><span class=line><span class=cl><span class=k>class</span> <span class=nc>Player</span><span class=p>(</span><span class=n>_name</span><span class=p>:</span> <span class=n>string</span><span class=p>,</span> <span class=k>val</span> <span class=py>health</span><span class=p>:</span> <span class=n>Int</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>val</span> <span class=py>race</span> <span class=p>=</span> <span class=s2>&#34;DWARF&#34;</span>
</span></span><span class=line><span class=cl>    <span class=k>val</span> <span class=py>alignment</span><span class=p>:</span> <span class=n>String</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=k>init</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>require</span><span class=p>(</span><span class=n>health</span> <span class=p>&gt;</span> <span class=m>0</span><span class=p>,</span> <span class=p>{</span><span class=s2>&#34;health는 양수여야 한다&#34;</span><span class=p>})</span>
</span></span><span class=line><span class=cl>		<span class=n>println</span><span class=p>(</span><span class=s2>&#34;initializing player&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=n>alignment</span> <span class=p>=</span><span class=s2>&#34;GOOD&#34;</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=k>constructor</span> <span class=p>(</span><span class=n>_name</span><span class=p>:</span> <span class=n>String</span><span class=p>)</span> <span class=p>:</span> <span class=k>this</span><span class=p>(</span><span class=n>_name</span><span class=p>,</span> <span class=m>100</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=n>race</span> <span class=p>=</span> <span class=s2>&#34;The Shire&#34;</span><span class=err>&#39;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><ul><li><p>말 그대로, <strong>기본 생성자에 정의된 속성을 다양하게 초기화</strong>하는 <strong>보조 역할</strong>을 수행</p></li><li><p>보조 생성자에서는 <strong>클래스 속성(프로퍼티)</strong> 를 정의할 수 없다.</p><ul><li>속성은 기본 생성자 or 클래스 몸체에서 정의되어야 한다.</li></ul></li><li><p><code>this 키워드</code>는 보조 생성자를 사용해서 생성되는 클래스 인스턴스의 <strong>기본 생성자</strong>를 뜻한다.</p></li></ul><h2 id=초기화-블록-init>초기화 블록 (init)<a hidden class=anchor aria-hidden=true href=#초기화-블록-init>#</a></h2><ul><li><p><strong>전제 조건 검사</strong>는 초기화 블록에서 주로 한다.</p><ul><li>생성자에 전달되는 인자가 적합한지 확인</li><li><code>require</code> 문을 주로 사용</li></ul></li><li><p>초기화 블록은 어떤 생성자가 호출되든 클래스 <strong>인스턴스가 생성될 때 마다 자동으로 호출</strong>되어 실행된다.</p></li><li><p>속성을 초기화하는 코드가 복잡하다면, init 에 초기화 코드를 넣는 것도 가능하다.</p></li></ul><h2 id=속성프로퍼티-초기화>속성(프로퍼티) 초기화<a hidden class=anchor aria-hidden=true href=#속성프로퍼티-초기화>#</a></h2><ul><li><strong>속성(프로퍼티)은 정의된 타입으로 반드시 초기화</strong>되어야 한다.</li></ul><h2 id=초기화-순서>초기화 순서<a hidden class=anchor aria-hidden=true href=#초기화-순서>#</a></h2><ol><li><p><strong>기본 생성자</strong>에 정의된 속성에 인자값 지정</p></li><li><p>클래스 <strong>내부에 지정된 속성</strong>에 초깃값 저장</p></li><li><p><strong>초기화 블록(init)</strong> 실행</p></li><li><p><strong>보조 생성자</strong> 실행</p></li></ol><h2 id=초기화-지연시키기>초기화 지연시키기<a hidden class=anchor aria-hidden=true href=#초기화-지연시키기>#</a></h2><ul><li><p>클래스 <strong>속성</strong>은 non-nullable 변수가, null이 아닌 값으로 초기화된 다는 것을 보장하기 때문에, 초기화는 중요하다.</p></li><li><p>기본 타입(ex. Int) 이 아니고, 다른 객체를 참조하는 속성의 경우 &lsquo;<strong>지연 초기화(lateinit)</strong>&lsquo;가 가능하다.</p><ul><li>다른 객체를 <strong>참조</strong>하는 속성의 경우, <strong>생성자가 호출되는 방법과 시점은 우리가 제어할 수 없는 경우</strong>가 있기 때문에</li><li>Ex) 외부 프레임워크에서 초기화되는 경우, <strong>안드로이드의 뷰 속성</strong></li></ul></li><li><p><code>lateinit 키워드</code>는 개발자가 <strong>해당 속성을 사용하기 전에 초기화해야 된다는 것</strong>을 의미한다.</p><ul><li><p>개발자가 스스로 책임지고, 해당 속성을 사용하기 전에 초기화해야 된다는 것을 뜻함</p></li><li><p><strong>&lsquo;지연 초기화&rsquo;</strong></p></li></ul></li><li><p><code>isInitialized 함수</code>는 속성이 초기화 되었는지 검사해준다.</p><ul><li><code>if (::alignment.isInitialized)</code></li><li>속성의 <strong>값이 아닌 참조를 전달</strong>해야 함으로 <code>::</code> 를 붙임</li></ul></li><li><p><strong>클래스 인스턴스의 생성 시점에서 속성을 초기화 할 수 없다면</strong>, <strong>지연 초기화</strong>를 사용해야 하고, <code>lateinit 키워드</code>를 사용해서 이를 나타낸다.</p></li><li><p>lateinit</p><ul><li>기본 타입이 아니여야 함<ul><li>다른 타입의 객체 참조 때문에</li></ul></li><li>var</li><li>non-nullable이어야 한다.</li><li>커스텀 getter, setter 정의 불가하고, 기본으로 생성되는 getter, setter 사용해야 하</li></ul></li><li><p>lateinit 대신 nullable 타입으로 변수 선언하고, 변수에 null으로 초기화도 가능하긴 한데, null 체크를 개발자가 계속 해야 한다.</p><ul><li><code>var tmp: String? = null</code></li></ul></li><li><p>lateinit은 <strong>클래스 속성</strong> 뿐만 아니라 <strong>최상위 수준 속성과 함수의 지역 변수</strong>에서도 사용 가능하다.</p></li></ul><h2 id=늦-초기화-lazy-initalization>늦 초기화 (lazy initalization)<a hidden class=anchor aria-hidden=true href=#늦-초기화-lazy-initalization>#</a></h2><ul><li><p>&lsquo;지연 초기화&rsquo; 만이 초기화를 지연시킬 수 있는 유일한 방법은 아니다.</p></li><li><p>변수나 속성이 <strong>‘최초’</strong> 사용될 때까지 <strong>초기화를 ‘연기’</strong> 할 수도 있다.</p></li><li><p><strong>속성을 즉시로 사용할 필요가 없다면</strong> &lsquo;늦 초기화&rsquo;가 좋은 선택이 된다.</p><ul><li>늦 초기화는 코틀린에서 <strong>delegation(위임) 패턴</strong>을 사용해서 구현한다.</li><li><code>lazy 함수</code> 를 <strong>대리자로 위임</strong> 처리 한다.</li><li><code>lazy 함수</code>는 <strong>람다를 인자</strong>로 받아 실행 시켜준다.</li><li><strong>lazy 함수와 람다</strong>로 초기화 후에 이후에는 다시 초기화되지 않고, <strong>캐시에 저장되 결과가 사용</strong>된다.</li></ul></li><li><p><code>val homtTown by lazy { myFun() }</code></p></li><li><p>by 키워드를 사용해서, 위임받은 일을 처리하는 대리자(delegate) 를 지정한다</p><ul><li>대리자로 <strong>커스텀 함수</strong> 또는 <strong>코틀린 표준 라이브러리</strong>의 함수를 사용할 수 있다.</li></ul></li><li><p>컴파일러는 소스 코드상의 <strong>초기화 순서를 검사하지 않는다.</strong></p><ul><li><strong>속성을 사용하는 함수의 순서</strong>를 비교하지는 않는다.</li></ul></li></ul><h1 id=상속>상속<a hidden class=anchor aria-hidden=true href=#상속>#</a></h1><ul><li><p><strong>서브 클래스(자식 클래스)</strong> 는 상속해 주는 클래스의 모든 속성과 함수를 공유한다.</p><ul><li>상속해 주는 클래스를 <strong>부모 클래스 또는 슈퍼 클래스</strong>라고 한다.</li></ul></li><li><p><code>open 키워드</code>를 붙혀서 서브 클래스를 가질 수 있게 해야 한다.</p></li><li><p><strong>상속 받은 속성과 함수를 그대로 사용하지 않고, overrideing</strong> 할 수도 있다.</p><ul><li>이때 override 하는 함수에도 <code>open 키워드</code> 사용해야 한다.</li></ul></li><li><p><code>super 키워드</code>를 사용해서, 부모 클래스 함수 or 속성을, <strong>자식(서브) 클래스에서 호출 or 접근</strong> 할 수 있다.</p><ul><li>슈퍼 클래스의 <code>public, protected</code> 속성과 함수를 사용할 수 있다.</li></ul></li><li><p>슈퍼 클래스로 타입을 선언하면, 어떤 서브 클래스 인스턴스도 참조 할 수 있다. ⇒ 다형성</p></li><li><p>서브 클래스는 기본적으로 open이 되므로, 서브 클래스의 서브 클래스는 언제든 override 할 수 있다.</p></li><li><p>코틀린에서는 클래스가 정의될 때 기본적으로 서브 클래스를 만들지(상속 되게) 못하게 되어 있다.</p></li><li><p><code>final 키워드</code>: 키워드를 붙인 함수 or 속성만, override 될 수 없게 함.</p></li></ul><h2 id=타입-검사>타입 검사<a hidden class=anchor aria-hidden=true href=#타입-검사>#</a></h2><ul><li><p><code>is 연산자</code>로 객체가 <strong>특정 타입인지 검사</strong>할 수 있다.</p></li><li><p>자식 클래스의 인스턴스는 해당 자식 클래스의 타입이면서 동시에 부모 클래스의 타입도 된다.</p><ul><li>사자 인스턴스는 사자 타입이면서 동시에 동물 타입이다.</li></ul></li></ul><h2 id=코틀린-타입의-상속-계층>코틀린 타입의 상속 계층<a hidden class=anchor aria-hidden=true href=#코틀린-타입의-상속-계층>#</a></h2><ul><li><p>코틀린의 모든 non-nullable 클래스는 자동으로 <code>Any</code>라는 최상위 슈퍼 클래스로 부터 상속 받는다.</p><ul><li><code>Any</code>는 자바의 모든 클래스가 <code>java.lang.Object</code>의 서브 클래스인 것과 비슷하다.</li></ul></li><li><p><code>as 연산자</code> : <strong>상속 관계가 있을 때</strong>, 타입 변환에 사용</p><ul><li>변환된 타입의 <strong>속성 참조나 함수 호출을 할 수 있는 것</strong>이지 해당 객체가 갖는 값을 변환하는 것은 아니다.</li></ul></li><li><p>두 타입 간에 상속 관계가 없으면 타입 변환은 불가능</p></li></ul><h2 id=스마트-캐스팅>스마트 캐스팅<a hidden class=anchor aria-hidden=true href=#스마트-캐스팅>#</a></h2><ul><li><strong>코틀린 컴파일러가 특정 조건에서 명시적 캐스팅이 아닌, 자동으로 타입 변환을 수행하는 것</strong><ul><li>간결성, 가독성, 안전성</li></ul></li><li>직접 변환하지 않아도 스마트 캐스팅이 일어나면, 컴파일러는 해당 타입으로 간주한다. (컴파일 에러 안남)</li><li>non-nullable 타입은 nullable 타입의 자식(서브) 타입이다.</li><li>JVM 애플리케이션으로 컴파일하면 Any 클래스는 <code>java.lang.Object</code>로 바이트 코드에 구현되지만, 다른 플랫폼을 대상으로 컴파일하면 해당 플랫폼에 맞게 다른 형태로 구현된다.</li></ul><h2 id=any-클래스>Any 클래스<a hidden class=anchor aria-hidden=true href=#any-클래스>#</a></h2><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-kotlin data-lang=kotlin><span class=line><span class=cl><span class=k>public</span> <span class=k>open</span> <span class=k>class</span> <span class=nc>Any</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>public</span> <span class=k>open</span> <span class=k>operator</span> <span class=k>fun</span> <span class=nf>equals</span><span class=p>(</span><span class=n>other</span><span class=p>:</span> <span class=n>Any</span><span class=p>?):</span> <span class=n>Boolean</span>
</span></span><span class=line><span class=cl>    <span class=k>public</span> <span class=k>open</span> <span class=k>fun</span> <span class=nf>hashCode</span><span class=p>()</span> <span class=p>:</span> <span class=n>Int</span>
</span></span><span class=line><span class=cl>    <span class=k>public</span> <span class=k>open</span> <span class=k>fun</span> <span class=nf>tostring</span><span class=p>():</span> <span class=n>String</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><ul><li><p>모든 클래스의 부모 클래스</p></li><li><p><strong>기본 메서드 제공</strong>: <code>Any</code> 클래스는 다음과 같은 기본 메서드를 제공합니다.</p><ul><li><code>equals(other: Any?): Boolean</code>: 객체의 동등성을 비교합니다.</li><li><code>hashCode(): Int</code>: 객체의 해시 코드를 반환합니다.</li><li><code>toString(): String</code>: 객체의 문자열 표현을 반환합니다.</li></ul></li><li><p>해당 타입에 맞게 오버라이딩해서 구현하라는 의미</p></li><li><p><strong>확장 함수 활용</strong>: <code>Any</code> 클래스는 확장 함수를 통해 다양한 기능을 추가할 수 있습니다. 예를 들어, <code>to()</code> 함수를 사용하여 <code>Pair</code> 객체를 생성할 수 있습니다.</p></li><li><p>다양한 플랫폼에 독립적인 애플리케이션을 생성할 수 있게 해주는 방법 중 하나다.</p></li><li><p>즉, <strong>각 플랫폼에 공통적으로 사용할 수 있는 최상위 슈퍼 클래스</strong>인 것이다.</p><ul><li><p>코틀린 프로그램을 <strong>JVM 애플리케이션</strong>으로 컴파일하면 Any 클래스가 <code>java, Lang.object</code>로 바이트 코드에 구현됨</p><ul><li>PC 운영체제의 JVM에서 실행되는 애플리케이션</li></ul></li><li><p>다른 플랫폼을 대상으로 컴파일하면 해당 플랫폼에 맞게 다른 형태로 구현된다.</p><ul><li>JVM 없이 실행되는 네이티브 App, 웹 브라우저에서 실행되는 자바스크립트, 안드로이드 App</li></ul></li><li><p>따라서 우리 코드에서는 최상위 슈퍼 클래스가 Any라고 생각하고 사용하면 된다.</p></li><li><p><strong>코드가 실행된 각 플랫폼에서 Any가 어떻게 다르게 구현되는지 자세히 알 필요 없기 때문이다.</strong></p></li></ul></li></ul><h1 id=객체>객체<a hidden class=anchor aria-hidden=true href=#객체>#</a></h1><h2 id=object-키워드>object 키워드<a hidden class=anchor aria-hidden=true href=#object-키워드>#</a></h2><ul><li><p>싱글톤은 하나의 인스턴스(객체)만 메모리에 생성되는 것을 말한다.</p></li><li><p>코드의 정의된 곳에 생성되어 동작하며, 다른 클래스 내부에 포함시켜 사용할 수 있다.</p></li><li><p>멀티 스레드로 실행될때는 반드시 하나의 객체만 생성되도록 동기화 처리를 해야 한다.</p></li><li><p>최초 사용 시점에 하나만 생성되어, 계속 유지됨</p></li><li><p>일반 클래스처럼 속성과 함수가 포함될 수 있고, 최초로 사용될 때 초기화 된다.</p></li><li><p><code>object 키워드</code>를 사용하여 정의된 객체는 JVM에서 로드될 때 즉시 초기화되며, 이 때 <strong>쓰레드 안전(thread-safe)</strong> 하게 초기화됩니다. => 동기화 문제 해결</p></li><li><p>객체 선언(object 키워드) 에도 일반 클래스처럼 속성과 함수가 포함될 수 있다. 그리고 이런 속성이나 함수가 최초로 사용될 때 비로소 해당 객체가 생성되고 초기화된다.</p></li></ul><h2 id=객체-표현식>객체 표현식<a hidden class=anchor aria-hidden=true href=#객체-표현식>#</a></h2><ul><li>기존 클래스의 서브 클래스를 원하는 코드 안에 <strong>‘이름 없이’ 정의 하고 바로 인스턴스를 생성</strong>해서 사용하는 경우 편하게 사용된다.</li><li><strong>annonymous 클래스 (익명 클래스)</strong> 라고 한다.</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-kotlin data-lang=kotlin><span class=line><span class=cl><span class=k>val</span> <span class=py>anyClassInstance</span> <span class=p>=</span> <span class=k>object</span> <span class=err>: </span><span class=nc>ParentClass</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=k>override</span> <span class=k>fun</span> <span class=nf>load</span><span class=p>()</span> <span class=p>=</span> <span class=s2>&#34;~~~&#34;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><ul><li><p><strong>익명 클래스</strong>는 <strong>ParentClass 의 자식 클래스</strong>임으로, 속성과 함수를 상속 받는다.</p><ul><li>override 및 새로운 속성 및 함수 추가 가능하다.</li></ul></li><li><p><code>'anyClassInstance'</code>인스턴스는 <strong>싱글톤 객체</strong>가 됨으로,</p><ul><li>함수 내부에서 사용될 때는, 매번 인스턴스가 생성될 수 있기 때문에 사용시 유의해야 한다.</li></ul></li></ul><h2 id=동반-객체-companion-object>동반 객체 (companion object)<a hidden class=anchor aria-hidden=true href=#동반-객체-companion-object>#</a></h2><ul><li>최상위 수준에서는 사용할 수 없고, 클래스 내부에서 정의하여 사용한다.</li><li>클래스 내부에 정의된 <code>객체 선언(object)</code></li><li>하나의 클래스에서는 하나의 동반 객체만 포함될 수 있다.</li><li>클래스의 인스턴스가 얼마나 많이 생성되던, <strong>동반 객체의 인스턴스는 하나만 생긴다.</strong></li></ul><h2 id=중첩-클래스>중첩 클래스<a hidden class=anchor aria-hidden=true href=#중첩-클래스>#</a></h2><ul><li>다른 클래스 내부 안에 정의된 클래스, <strong>nested class</strong></li><li>중첩된 클래스의 인스턴스는 <strong>외곽 클래스의 인스턴스가 생성</strong>되어야 사용할 수 있다.</li><li>외곽 클래스는 중첩 클래스의 속성과 함수를 사용할 수 있다.</li><li>Nested Class는 외부 클래스의 인스턴스에 대한 참조를 가지지 않으며, 외부 클래스의 멤버에 직접 접근할 수 없습니다.</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-kotlin data-lang=kotlin><span class=line><span class=cl><span class=k>class</span> <span class=nc>OuterClass</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>private</span> <span class=k>val</span> <span class=py>outerValue</span> <span class=p>=</span> <span class=s2>&#34;외부 클래스 값&#34;</span>
</span></span><span class=line><span class=cl>    <span class=k>class</span> <span class=nc>NestedClass</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=c1>// outerValue에 접근 불가
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><h2 id=내부-클래스-inner-class>내부 클래스 (inner class)<a hidden class=anchor aria-hidden=true href=#내부-클래스-inner-class>#</a></h2><ul><li>Kotlin의 <code>inner</code> 키워드를 사용하여 선언된 클래스를 <strong>Inner Class(내부 클래스</strong>)라고 합니다.</li><li>자신을 감싸고 있는 <strong>외부 클래스(Outer Class)의 인스턴스에 대한 참조를 암시적으로 가지고</strong> 있습니다.<ul><li>nested class와 다름</li><li>암시적으로 참조하므로, <strong>메모리 누수에 주의</strong>해야 합니다.</li></ul></li><li>Inner Class는 외부 클래스의 인스턴스 없이 생성할 수 없습니다.</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-kotlin data-lang=kotlin><span class=line><span class=cl><span class=k>class</span> <span class=nc>OuterClass</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>private</span> <span class=k>val</span> <span class=py>outerValue</span> <span class=p>=</span> <span class=s2>&#34;외부 클래스 값&#34;</span>
</span></span><span class=line><span class=cl>    <span class=k>inner</span> <span class=k>class</span> <span class=nc>InnerClass</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>fun</span> <span class=nf>accessOuter</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=n>println</span><span class=p>(</span><span class=n>outerValue</span><span class=p>)</span> <span class=c1>// 외부 클래스의 private 멤버 접근 가능
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><h2 id=data-class>data class<a hidden class=anchor aria-hidden=true href=#data-class>#</a></h2><ul><li><p>주로 <strong>데이터를 표현</strong>하는 객체를 간편하게 <strong>생성, 저장, 표현</strong>하기 위해 사용됩니다.</p></li><li><p>일반 클래스와 달리 데이터 클래스는 컴파일러가 자동으로 몇 가지 유용한 메서드를 생성해줌</p></li><li><p>JVM은 객체를 고유하기 관리하기 위해 해시 코드 값을 생성함</p></li><li><p>인스턴스끼리 각 속성(프로퍼티) 의 <strong>값을 비교 (equals 함수)</strong></p><ul><li><strong>Equality, 동등성 연산에서 사용</strong></li></ul></li><li><p>인스턴스를 컬렉션(Ex. Map)에 저장할 때 사용할 키 값인 <strong>해시 코드를 생성 (hashCode 함수)</strong></p><ul><li>hash와 관련된 연산을 할 때 사용</li></ul></li><li><p>객체를 문자열로 나타내는 기능 (toString 함수)</p></li><li><p>해체 선언 함수 (componentN 함수)</p></li><li><p>기존 인스턴스(객체)의 속성값을 변경하여 <strong>새로운 인스턴스를 생성</strong>하는 (copy 함수)</p><ul><li><p><strong>얕은 복사; Shallow Copy</strong>: <code>copy()</code> 메서드는 <strong>기본적으로 얕은 복사</strong>를 수행합니다. <strong>원본 객체와 같은 참조를 공유</strong>합니다. 따라서 참조 타입 프로퍼티를 변경하면 원본 객체에도 영향을 미칠 수 있습니다.</p><ul><li><p><code>copy()</code> 를 사용하면 <strong>원시 타입</strong> 프로퍼티는 <strong>값 복사(Value Copy)</strong> 를 통해 새로운 객체에 복사됩니다.</p></li><li><p><code>copy()</code> 를 사용하면 <strong>참조 타입</strong> 프로퍼티는 <strong>참조 복사(Reference Copy)</strong> 를 통해 새로운 객체에 복사됩니다.</p></li></ul></li><li><p><strong>깊은 복사; Deep Copy</strong>: 새로운 객체 생성, 이는 코틀린에서 개발자가 직접 구현해야 합니다.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-kotlin data-lang=kotlin><span class=line><span class=cl><span class=k>data</span> <span class=k>class</span> <span class=nc>Address</span><span class=p>(</span><span class=k>var</span> <span class=py>city</span><span class=p>:</span> <span class=n>String</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=k>data</span> <span class=k>class</span> <span class=nc>Person</span><span class=p>(</span><span class=k>val</span> <span class=py>name</span><span class=p>:</span> <span class=n>String</span><span class=p>,</span> <span class=k>val</span> <span class=py>address</span><span class=p>:</span> <span class=n>Address</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 참조 타입 복사
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>val</span> <span class=py>address</span> <span class=p>=</span> <span class=n>Address</span><span class=p>(</span><span class=s2>&#34;Seoul&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=k>val</span> <span class=py>person1</span> <span class=p>=</span> <span class=n>Person</span><span class=p>(</span><span class=s2>&#34;Alice&#34;</span><span class=p>,</span> <span class=n>address</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=k>val</span> <span class=py>person2</span> <span class=p>=</span> <span class=n>person1</span><span class=p>.</span><span class=n>copy</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=n>person2</span><span class=p>.</span><span class=n>address</span><span class=p>.</span><span class=n>city</span> <span class=p>=</span> <span class=s2>&#34;Busan&#34;</span> <span class=c1>// person2의 address 변경
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>println</span><span class=p>(</span><span class=n>person1</span><span class=p>.</span><span class=n>address</span><span class=p>.</span><span class=n>city</span><span class=p>)</span> <span class=c1>// Busan (person1의 address도 변경됨)
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=c1>// 원시 타입 복사
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>val</span> <span class=py>person1</span> <span class=p>=</span> <span class=n>Person</span><span class=p>(</span><span class=s2>&#34;Alice&#34;</span><span class=p>,</span> <span class=m>25</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=k>val</span> <span class=py>person2</span> <span class=p>=</span> <span class=n>person1</span><span class=p>.</span><span class=n>copy</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=n>person2</span><span class=p>.</span><span class=n>age</span> <span class=p>=</span> <span class=m>26</span> <span class=c1>// person2의 age 값만 변경
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>println</span><span class=p>(</span><span class=n>person1</span><span class=p>.</span><span class=n>age</span><span class=p>)</span> <span class=c1>// 25 (person1의 age는 변경되지 않음)
</span></span></span></code></pre></td></tr></table></div></div></li></ul></li><li><p>위 5개의 함수를 <strong>코틀린 컴파일러가 자동으로 생성</strong>한다.</p><ul><li>Any 클래스의 (equals, toString, hashCode) 함수들을 오버라이딩 해준다.</li></ul></li><li><p>반드시 ‘기본 생성자’ 에 속성들을 지정해야 한다.</p></li><li><p><code>open</code> 으로 피상속 불가, 슈퍼 클래스 불가</p><ul><li>상속을 허용한다면, 부모 클래스에서 자동 생성된 메서드들이 <strong>자식 클래스의 모든 프로퍼티를 고려하여 정확하게 동작하도록 보장하기가 어렵기 때문</strong></li><li>data class의 목적과 부합하지 않음</li></ul></li><li><p>Data Class는 <strong>다른 클래스를 상속</strong>할 수 없으며, 인터페이스만 구현할 수 있습니다.</p></li><li><p><strong>해시 코드 값</strong>은 <strong>인스턴스를 고유하기 식별하기 위해 생성된 값</strong>이다.</p></li></ul><h2 id=enum-클래스>enum 클래스<a hidden class=anchor aria-hidden=true href=#enum-클래스>#</a></h2><ul><li><p>‘상수값’을 정의하는 열거형 클래스를 정의할때 사용</p><ul><li><p><strong>상수</strong>보다 <strong>더 서술적</strong>이라서 무엇을 의미하기 알기 쉽다.</p></li><li><p>enum 의 항목은 <strong>단순한 상수</strong>가 아니라, <strong>서브 타입</strong>이다.</p><ul><li><strong>각 상수(항목들)</strong> 는 자체적으로 프로퍼티와 메서드를 가질 수 있는 <strong>객체</strong></li></ul></li><li><p><strong>항목들</strong>은 enum class 내부에서만 생성되며, 외부에서 임의로 생성할 수 없습니다.</p></li><li><p>enum 는 <strong>모든 상수가 컴파일 타임</strong>에 결정되므로, 각 상수는 JVM 내부적으로 <strong>단일 인스턴스</strong>로 표현됩니다. (메모리 사용 측면에서 효율적)</p></li></ul></li><li><p>enum 클래스 내부적으로 <code>‘name’(항목 이름, String 타입)</code>, <code>‘ordinal’(항목 위치, Int 타입, 0부터 시작)</code></p></li><li><p><code>EnumClass.values</code> : 모든 항목 이름을 ‘배열’로 생성</p></li><li><p>enum 클래스의 함수 호출은 <code>‘enum 클래스명.항목명.함수명’</code> 의 형태로 호출해야 한다.</p></li><li><p><strong>컴파일러가 모든 타입을 처리했는지 검사할 수 있다는 장점</strong></p></li><li><p>싱글턴 패턴과 유사한 특징을 가지고 있어, 싱글턴처럼 사용할 수 있습니다.</p><ul><li>하지만 상속 불가 및 값 표현 등의 차이점이 있으므로, <strong>엄밀히 말하면 싱글턴은 아닙니다.</strong></li></ul></li></ul><h2 id=연산자-오버로딩>연산자 오버로딩<a hidden class=anchor aria-hidden=true href=#연산자-오버로딩>#</a></h2><ul><li><p><strong>연산자 오버로딩</strong>: 피연산자의 타입이 무엇이든 <strong>같은 연산자를 사용해서 동일한 기능</strong>을 구현할 수 있게 해주는 것</p></li><li><p>코틀린에서는 각 연산자를 사전에 약속된 함수로 구현하여 연산자 오버로딩을 지원한다.</p><ul><li>코틀린 컴파일러는 <code>a+b</code> 를 컴파일하여, <code>a.plus(b)</code> 를 실행하도록 바이트코드로 생성</li><li><code>+ 연산자</code> 를 사전에 약속된 plus 함수로 싱행하게 되면, 피연산자의 타입이 다르더라도 덧셈은 항상 <code>+</code> 로 표기가능</li><li>피연산자의 타입마다 서로 다른 덧셈 연산자를 사용하면, 불편하고 연산자 수가 매우 많아짐</li></ul></li><li><p>코틀린에서<code>== 비교 연산자</code> 가 내부적으로 <code>equals 함수</code>로 호출되는 이유가 <strong>연산자 오버로딩</strong> 때문이다. (ex. <code>+, plus()</code> )</p></li></ul><h2 id=객체의-값-비교하기>객체의 값 비교하기<a hidden class=anchor aria-hidden=true href=#객체의-값-비교하기>#</a></h2><ul><li>equals 함수를 override 할 때는 haseCode 함수도 같이 override 해야 한다.</li><li>동등성, Equality 연산</li></ul><ul><li><p>hash와 관련된 자료구조(hashMap, hashTable)는 동등성 연산(equals) 전에 먼저, Hash Value비교를 수행한다. 즉, <code>hashCode()</code>의 값이 같은 경우에만 <strong>동등성 연산</strong>이 수행된다.</p></li><li><p>두 개의 다른 인스턴스에 대해 같은 Hash Value가 나오는 경우를 <strong>Hash 충돌(Hash Collision)</strong> 이라 한다.</p><ul><li><p>Hash Value가 같으므로 <strong>동등성 연산(equals)</strong> 가 수행된다.</p></li><li><p>같은 해시 값을 갖는 인스턴스들이 LinkedList 형태로 이어져있어 하나하나씩 Iteration이 돌아가면서 동등성 연산이 수행</p></li></ul></li><li><p>따라서 N개의 값 객체가 있고 해당 값 객체들이 <strong>모두 같은 Hash Value를 갖는다면 동등성 연산 수행에 O(N)의 시간 복잡도가 필요하다.</strong></p><ul><li>하지만 만약 모든 값 객체들이 다른 Hash Value를 갖는다면 동등성 연산 수행에 O(1)의 시간 복잡도</li><li>따라서 hashCode()값을 Hash 충돌을 최대한 피할 수 있도록 짜야한다.</li></ul></li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-kotlin data-lang=kotlin><span class=line><span class=cl><span class=k>class</span> <span class=nc>GalaxyTab</span><span class=p>(</span><span class=k>val</span> <span class=py>modelName</span><span class=p>:</span> <span class=n>String</span><span class=p>,</span> <span class=k>val</span> <span class=py>size</span><span class=p>:</span> <span class=n>Int</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>override</span> <span class=k>fun</span> <span class=nf>hashCode</span><span class=p>():</span> <span class=n>Int</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>modelName</span><span class=p>[</span><span class=m>1</span><span class=p>].</span><span class=n>toString</span><span class=p>().</span><span class=n>toInt</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>val</span> <span class=py>tabS6</span> <span class=p>=</span> <span class=n>GalaxyTab</span><span class=p>(</span><span class=s2>&#34;S6&#34;</span><span class=p>,</span> <span class=m>11</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=k>val</span> <span class=py>tabS7</span> <span class=p>=</span> <span class=n>GalaxyTab</span><span class=p>(</span><span class=s2>&#34;S7&#34;</span><span class=p>,</span> <span class=m>11</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>val</span> <span class=py>tabStock</span> <span class=p>=</span> <span class=n>mutableMapOf</span><span class=p>&lt;</span><span class=n>GalaxyTab</span><span class=p>,</span><span class=n>Int</span><span class=p>&gt;()</span>
</span></span><span class=line><span class=cl><span class=n>tabStock</span><span class=p>[</span><span class=n>tabS6</span><span class=p>]</span> <span class=p>=</span> <span class=m>0</span>
</span></span><span class=line><span class=cl><span class=n>tabStock</span><span class=p>[</span><span class=n>tabS7</span><span class=p>]</span> <span class=p>=</span> <span class=m>2</span>
</span></span></code></pre></td></tr></table></div></div><h2 id=jvm에서-hash와-메모리-주소-값-비교>JVM에서 Hash와 메모리 주소 값 비교<a hidden class=anchor aria-hidden=true href=#jvm에서-hash와-메모리-주소-값-비교>#</a></h2><table><thead><tr><th>특징</th><th>Hash (해시 코드)</th><th>메모리 주소 값</th></tr></thead><tbody><tr><td>의미</td><td>객체의 데이터를 기반으로 생성된 정수 값</td><td>객체가 저장된 메모리 상의 실제 위치</td></tr><tr><td>목적</td><td>객체 <strong>비교</strong>, 해시 기반 컬렉션 활용</td><td>객체 <strong>식별</strong>, 참조 비교</td></tr><tr><td>고유성</td><td>동일 객체는 항상 같은 값, 다른 객체는 다른 값을 가질 수 있음 (해시 충돌 가능)</td><td>각 객체마다 고유한 값</td></tr><tr><td>가변성</td><td>객체의 상태가 변하지 않으면 불변</td><td>가비지 컬렉션 등에 의해 변경될 수 있음</td></tr><tr><td>메모리 주소와의 관계</td><td>일반적으로 무관</td><td>직접적인 관계</td></tr></tbody></table><ul><li><p>JVM에서 <strong>hash</strong>와 <strong>메모리 주소 값</strong>은 둘 다 <strong>객체를 식별하는 데 사용</strong>되지만, (공통)</p><ul><li>Hash는 주로 객체의 논리적 동등성 <strong>비교</strong>와 해시 기반 <strong>컬렉션에서 활용</strong>되며,</li><li>메모리 주소 값은 객체의 고유성 판별과 참조 비교에 사용됩니다.</li></ul></li><li><p><strong>Hash</strong></p><ul><li>객체의 데이터를 기반으로 생성된 정수 값입니다.</li><li><code>Object</code> 클래스의 <code>hashCode()</code> 메서드를 통해 얻을 수 있습니다.</li><li><strong>해시 기반 컬렉션</strong>: 해시 기반 컬렉션에서 객체를 효율적으로 저장하고 검색하는 데 사용됩니다.<ul><li>해시 코드를 통해 객체를 버킷에 분류하고, 충돌 발생 시 <code>equals()</code> 로 최종 비교</li></ul></li></ul></li><li><p><strong>메모리 주소 값</strong></p><ul><li>객체가 저장된 <strong>메모리 상의 실제 위치</strong>를 나타내는 값입니다.</li><li>자바는 <code>== 연산자</code>, 코틀린은 <code>=== 연산자</code></li></ul></li></ul><h2 id=sealed-class>sealed class<a hidden class=anchor aria-hidden=true href=#sealed-class>#</a></h2><ul><li><strong>enum 항목이 복잡한 로직을 가질 경우,</strong> 각 항목을 클래스로 정의하고, 이를 sealed class로 묶어서 사용 가능<ul><li>유연한 데이터 저장, 복잡한 구조 가능</li></ul></li><li>자신의 <strong>서브(자식) 클래스 종류를 제한</strong>하기 위해 사용된다.</li><li>enum 클래스의 <strong>각 항목은 하나의 인스턴스만 생성되지만,</strong> sealed class에 속하는 서브 클래스들은 <strong>일반 클래스</strong> 이므로, <strong>인스턴스 개수에 제한이 없다.</strong></li><li>컴파일러는 해당 수퍼 클래스의 서브 클래스들을 <strong>컴파일 타임</strong>에 파악할 수 있게됨<ul><li><code>when</code> 표현식과 함께 사용될 때 모든 하위 클래스를 검사하므로, <code>else</code> 절이 필요하지 않습니다.<ul><li>enum도 마찬가지</li></ul></li></ul></li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-kotlin data-lang=kotlin><span class=line><span class=cl><span class=k>sealed</span> <span class=k>interface</span> <span class=nc>ApiResult</span><span class=p>&lt;</span><span class=k>out</span> <span class=n>T</span><span class=p>&gt;</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>data</span> <span class=k>class</span> <span class=nc>Success</span><span class=p>&lt;</span><span class=k>out</span> <span class=n>T</span><span class=p>&gt;(</span><span class=k>val</span> <span class=py>data</span><span class=p>:</span> <span class=n>T</span><span class=p>)</span> <span class=p>:</span> <span class=n>ApiResult</span><span class=p>&lt;</span><span class=n>T</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl>    <span class=k>data</span> <span class=k>class</span> <span class=nc>Error</span><span class=p>(</span><span class=k>val</span> <span class=py>exception</span><span class=p>:</span> <span class=n>Exception</span><span class=p>)</span> <span class=p>:</span> <span class=n>ApiResult</span><span class=p>&lt;</span><span class=n>Nothing</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl>    <span class=k>object</span> <span class=nc>Loading</span> <span class=p>:</span> <span class=n>ApiResult</span><span class=p>&lt;</span><span class=n>Nothing</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><ul><li>말 그대로 인터페이스이기 때문에 다중 상속을 통한 <strong>타입의 다형성</strong>을 부여할 수 있습니다.</li><li>다시 말해, 특정 타입의 성질을 하위 타입에게 전달하기가 쉽습니다.</li><li>또한, <code>when</code> 문을 사용하여 타입을 참조하여 분기해야할 상황에서 장점이 명확해짐</li></ul><h3 id=enum의-한계>enum의 한계<a hidden class=anchor aria-hidden=true href=#enum의-한계>#</a></h3><ul><li>각 요소당 하나의 single instance를 사용하기 때문에 서로 다른 형태를 가질 수 없습니다.</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-kotlin data-lang=kotlin><span class=line><span class=cl><span class=k>enum</span> <span class=k>class</span> <span class=nc>Result</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>SUCCESS</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=n>FAILED</span><span class=p>(</span><span class=k>val</span> <span class=py>exception</span><span class=p>:</span> <span class=n>Exception</span><span class=p>)</span> <span class=c1>// 이런 형태는 불가함.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div></div><footer class=post-footer><ul class=post-tags><li><a href=https://2taezeat.github.io/tags/kotlin/>Kotlin</a></li></ul><nav class=paginav><a class=prev href=https://2taezeat.github.io/posts/dev/kotlin-%EC%A0%95%EB%A6%AC-2/><span class=title>« Prev</span><br><span>Kotlin 정리 (2)</span>
</a><a class=next href=https://2taezeat.github.io/posts/dev/jvm-%EC%A0%95%EB%A6%AC/><span class=title>Next »</span><br><span>JVM 정리</span></a></nav><ul class=share-buttons><li><a target=_blank rel="noopener noreferrer" aria-label="share Kotlin 정리 (1) on x" href="https://x.com/intent/tweet/?text=Kotlin%20%ec%a0%95%eb%a6%ac%20%281%29&amp;url=https%3a%2f%2f2taezeat.github.io%2fposts%2fdev%2fkotlin-%25EC%25A0%2595%25EB%25A6%25AC-1%2f&amp;hashtags=Kotlin"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446C483.971.0 512 28.03 512 62.554zM269.951 190.75 182.567 75.216H56L207.216 272.95 63.9 436.783h61.366L235.9 310.383l96.667 126.4H456L298.367 228.367l134-153.151H371.033zM127.633 110h36.468l219.38 290.065H349.5z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Kotlin 정리 (1) on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2f2taezeat.github.io%2fposts%2fdev%2fkotlin-%25EC%25A0%2595%25EB%25A6%25AC-1%2f&amp;title=Kotlin%20%ec%a0%95%eb%a6%ac%20%281%29&amp;summary=Kotlin%20%ec%a0%95%eb%a6%ac%20%281%29&amp;source=https%3a%2f%2f2taezeat.github.io%2fposts%2fdev%2fkotlin-%25EC%25A0%2595%25EB%25A6%25AC-1%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Kotlin 정리 (1) on reddit" href="https://reddit.com/submit?url=https%3a%2f%2f2taezeat.github.io%2fposts%2fdev%2fkotlin-%25EC%25A0%2595%25EB%25A6%25AC-1%2f&title=Kotlin%20%ec%a0%95%eb%a6%ac%20%281%29"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Kotlin 정리 (1) on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2f2taezeat.github.io%2fposts%2fdev%2fkotlin-%25EC%25A0%2595%25EB%25A6%25AC-1%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Kotlin 정리 (1) on whatsapp" href="https://api.whatsapp.com/send?text=Kotlin%20%ec%a0%95%eb%a6%ac%20%281%29%20-%20https%3a%2f%2f2taezeat.github.io%2fposts%2fdev%2fkotlin-%25EC%25A0%2595%25EB%25A6%25AC-1%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Kotlin 정리 (1) on telegram" href="https://telegram.me/share/url?text=Kotlin%20%ec%a0%95%eb%a6%ac%20%281%29&amp;url=https%3a%2f%2f2taezeat.github.io%2fposts%2fdev%2fkotlin-%25EC%25A0%2595%25EB%25A6%25AC-1%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentcolor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Kotlin 정리 (1) on ycombinator" href="https://news.ycombinator.com/submitlink?t=Kotlin%20%ec%a0%95%eb%a6%ac%20%281%29&u=https%3a%2f%2f2taezeat.github.io%2fposts%2fdev%2fkotlin-%25EC%25A0%2595%25EB%25A6%25AC-1%2f"><svg width="30" height="30" viewBox="0 0 512 512" fill="currentcolor" xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"><path d="M449.446.0C483.971.0 512 28.03 512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446zM183.8767 87.9921h-62.034L230.6673 292.4508V424.0079h50.6655V292.4508L390.1575 87.9921H328.1233L256 238.2489z"/></svg></a></li></ul></footer><script src=https://utteranc.es/client.js repo=2taezeat/blog_comment issue-term=pathname label=comment theme=github-light crossorigin=anonymous async></script></article></main><footer class=footer><span>&copy; 2024 <a href=https://2taezeat.github.io/>2taezeat, blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>