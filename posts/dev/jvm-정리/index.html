<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>JVM 정리 | 2taezeat, blog</title>
<meta name=keywords content="JVM"><meta name=description content="JVM 정리"><meta name=author content="2taezeat"><link rel=canonical href=https://2taezeat.github.io/posts/dev/jvm-%EC%A0%95%EB%A6%AC/><meta name=google-site-verification content="YaEERzgrvu-ZwPg7gswZdTzRMufkHw3uIH7i8hVal1c"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.0653c5fc8a439a898cd1fe8a206477ec49246832c1f79c575f5c6b9e1810bdb9.css integrity="sha256-BlPF/IpDmomM0f6KIGR37EkkaDLB95xXX1xrnhgQvbk=" rel="preload stylesheet" as=style><link rel=icon href=https://2taezeat.github.io/icon/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://2taezeat.github.io/icon/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://2taezeat.github.io/icon/favicon-32x32.png><link rel=apple-touch-icon href=https://2taezeat.github.io/icon/apple-touch-icon.png><link rel=mask-icon href=https://2taezeat.github.io/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://2taezeat.github.io/posts/dev/jvm-%EC%A0%95%EB%A6%AC/><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><meta property="og:title" content="JVM 정리"><meta property="og:description" content="JVM 정리"><meta property="og:type" content="article"><meta property="og:url" content="https://2taezeat.github.io/posts/dev/jvm-%EC%A0%95%EB%A6%AC/"><meta property="og:image" content="https://2taezeat.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-12-03T11:30:03+00:00"><meta property="article:modified_time" content="2023-12-03T11:30:03+00:00"><meta property="og:site_name" content="2taezeat, blog"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://2taezeat.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="JVM 정리"><meta name=twitter:description content="JVM 정리"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://2taezeat.github.io/posts/"},{"@type":"ListItem","position":2,"name":"JVM 정리","item":"https://2taezeat.github.io/posts/dev/jvm-%EC%A0%95%EB%A6%AC/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"JVM 정리","name":"JVM 정리","description":"JVM 정리","keywords":["JVM"],"articleBody":"코틀린 코드 컴파일 및 빌드 코틀린 컴파일러는 자바 컴파일러가 자바 소스코드를 컴파일할 때와 마찬가지로 코틀린 소스코드(.kt)를 분석해서 .class 파일을 만들어낸다. 만들어진 .class 파일은 개발 중인 애플리케이션의 유형에 맞는 표준 패키징 과정을 거쳐 실행될 수 있다. Java 코드와 Kotlin 코드의 빌드 과정은 다음과 같은 순서로 이루어진다.\n코틀린 컴파일러(kotlinc)가 코틀린 코드를 컴파일해 .class 파일을 생성한다. 이 과정에서 코틀린 코드가 참조하는 Java 코드가 함께 로딩되어 사용된다.\nParsing (파싱): 코틀린 컴파일러는 .kt 파일의 코드를 읽어 들여 문법적으로 올바른지 검사하고, 추상 구문 트리(AST, Abstract Syntax Tree)를 생성합니다.\nType Checking (타입 검사): AST를 분석하여 타입 정보를 추론하고, 타입 오류를 검사합니다. 코틀린의 강력한 타입 추론 시스템은 이 단계에서 중요한 역할을 합니다.\nCode Generation (코드 생성): 타입 검사가 완료된 AST를 기반으로 JVM 바이트코드(.class 파일)를 생성합니다. 이때 코틀린 런타임 라이브러리에 대한 참조가 추가됩니다.\nOptimization (최적화): 생성된 바이트코드를 최적화하여 실행 속도를 향상시킵니다.\nJava 컴파일러(javac)가 Java 코드를 컴파일해 .class 파일을 생성한다. 이때 이미 코틀린이 컴파일한 .class 파일의 경로를 클래스 패스에 추가해 컴파일한다.니\n코틀린 컴파일러로 컴파일한 코드는 코틀린 런타임 라이브러리(kotlin runtime library)에 의존한다.\n코틀린 런타임 라이브러리 : 코틀린 자체 표준 라이브러리 클래스 + 코틀린에서 자바 API의 기능을 확장한 내용\n코틀린으로 컴파일한 애플리케이션을 배포할때는 코틀린 런타임 라이브러리도 함께 배포해야 한다.\n프로젝트를 컴파일하기 위해 메이븐(Maven)과 그레이(Gradle), 앤트(Ant) 등의 빌드 시스템을 사용\n빌드 시스템은 모두 코틀린과 자바가 코드베이스에 함께 들어있는 혼합 언어 프로젝트를 지원할 수 있다\n메이븐(Maven)과 그레이(Gradle)들은 애플리케이션을 패키지할 때 알아서 코틀린 런타임 라이브러리을 포함시켜준다.\nJDK, JRE, JVM의 관계 및 역할 JDK (Java Development Kit):\n정의: 자바 개발 도구 모음입니다. 자바 애플리케이션을 개발, 컴파일, 실행하는 데 필요한 모든 것을 포함합니다. 개발하려면 필요\n구성 요소:\nJRE (Java Runtime Environment): 자바 애플리케이션을 실행하기 위한 환경입니다.\n컴파일러 (javac): 자바 소스 코드를 바이트코드로 변환합니다.\n디버거 (jdb): 자바 애플리케이션의 오류를 찾고 수정하는 데 사용됩니다.\n자바독 (javadoc): 자바 소스 코드에서 API 문서를 생성합니다.\n기타 도구: jar, jlink, jmod 등 다양한 개발 도구가 포함됩니다.\nJRE (Java Runtime Environment):\n정의: 자바 애플리케이션을 실행하기 위한 환경입니다. 실행하려면 필요\n구성 요소:\nJVM (Java Virtual Machine): 자바 바이트코드를 실행하는 가상 머신입니다.\n핵심 라이브러리: 자바 언어의 핵심 기능을 제공하는 클래스 라이브러리입니다.\nJVM (Java Virtual Machine):\n정의: 자바 바이트코드를 실행하는 가상 머신입니다.\n역할:\n플랫폼 독립성: JVM은 다양한 운영체제와 하드웨어에서 동일한 자바 바이트코드를 실행할 수 있도록 해줍니다.\n메모리 관리: JVM은 자바 애플리케이션의 메모리를 자동으로 관리합니다.\n보안: JVM은 자바 애플리케이션의 안전한 실행을 보장합니다.\n성능 최적화: JVM은 JIT(Just-In-Time) 컴파일러를 사용하여 바이트코드를 실행 중에 기계어로 변환하여 성능을 향상시킵니다.\n관계: JDK는 JRE를 포함하고, JRE는 JVM을 포함합니다. 즉, JDK를 설치하면 JRE와 JVM도 함께 설치됩니다.\n추가 정보:\nJVM은 자바 애플리케이션의 WORA(Write Once, Run Anywhere) 특성을 가능하게 합니다. JVM은 자바 언어의 핵심 기술이며, 다양한 자바 애플리케이션 개발에 사용됩니다. JAVA 컴파일 Java Compiler가 소스 코드 .java 파일을 .class 파일인 Byte Code(중간 레벨) 로 컴파일한다. 단, 해당 코드는 직접 CPU에서 동작할 수 있는 코드가 아니다. 정확히 말하면 가상머신 JVM이 이해할 수 있는 코드이다 이제 이 Byte Code를 기계어(Binary 코드) 로 변환시키기 위해 가상 머신이 필요한데, 이것이 JVM(Java Virtual Machine) 의 역할이다. JVM이 Byte Code(.class) 를 기계어(Binary Code) 로 변환한다. 이렇게 JVM에 의해 컴파일된 기계어는 바로 CPU에서 실행되어 사용자에게 서비스를 제공해준다. 단, 간과하지 말아야 할 점은 자바 프로그램과는 달리 자바 가상 머신(JVM)은 운영체제에 종속적이므로, 각 운영체제에 맞는 자바 가상 머신을 설치해야 한다는 점이다.\nJIT (Just-In_Time) 컴파일러 JIT 컴파일러는 같은 코드를 매번 해석하지 않고, 실행할 때 컴파일을 하면서 해당 코드를 캐싱 한다.\n이후에는 바뀐 부분만 컴파일하고 나머지는 캐싱된 코드를 사용한다. JIT 컴파일은 프로그램 실행 중에 기계어로 번역하는 컴파일 기법입니다.\n전통적인 인터프리터 방식과 정적 컴파일 방식의 장점을 결합하여 성능을 향상시키는 데 목표를 둡니다.\nJVM의 동작 방식 자바 프로그램을 실행하면 JVM은 OS로부터 메모리를 할당받는다. 자바 컴파일러(javac)가 자바 소스코드(.java)를 자바 바이트 코드(.class)로 컴파일 한다. Class Loader는 동적 로딩을 통해 필요한 클래스들을 로딩 및 링크 하여 Runtime Data Area(실질적인 메모리를 할당 받아 관리하는 영역) 에 올린다. Runtime Data Area에 로딩 된 바이트 코드는 Execution Engine을 통해 해석된다. 이 과정에서 Execution Engine에 의해 Garbage Collector의 작동과 Thread 동기화가 이루어진다. JVM의 구조 Execution Engine, 실행 엔진 실행 엔진은 클래스 로더를 통해 런타임 데이터 영역에 배치된 바이트 코드를 명령어 단위로 읽어서 실행한다\n자바 바이트 코드(*.class) 는 기계가 바로 수행할 수 있는 언어보다는 가상머신이 이해할 수 있는 중간 레벨로 컴파일 된 코드이다.\n그래서 실행 엔진은 이와 같은 바이트 코드를 실제로 JVM 내부에서 기계가 실행할 수 있는 형태로 변경해준다. 이 수행 과정에서 실행 엔진은 인터프리터와 JIT 컴파일러 두 가지 방식을 혼합하여 바이트 코드를 실행한다.\n런타임 데이터 영역 (Runtime Data Area) 런타입 데이터 영역은 쉽게 말하면 JVM의 메모리 영역으로 자바 애플리케이션을 실행할 때 사용되는 데이터들을 적재하는 영역이다. Method Area Method Area는 우리가 보통 정적(Static) 영역이라고 부르는 메모리이다. 프로그램 실행 중 클래스나 인터페이스를 사용하게 되면, JVM은 Class Loader을 이용해 클래스와 인터페이스의 메타 데이터를 Method Area에 저장한다. 즉, 클래스가 로드 되는 시점은 해당 클래스가 사용되기 위해 호출되는 시점이다. 메타 데이터는 Type Information, Runtime Constant Pool, Field Information, Method Information, Class Variable을 가리킨다. Stack Area Stack Area는 메서드가 호출될 시 할당되는 영역이다.\n메서드 호출 시 메서드 내부의 지역 변수 또한 Stack Area에 할당된다.\nHeap 공간에 객체 데이터를 올리고 그 객체 데이터에 대한 참조값이 할당된다는 뜻이다. 예외적으로 원시 타입(Primitive type) 변수는 Stack 영역에 값 자체가 할당된다.\n코어를 최대한 활용하기 위해 Thread를 사용하여 프로그래밍을 하는데, 각 스레드는 하나의 Stack 영역을 할당 받는다.\n즉, 스레드는 각자의 메모리 공간을 가지고 메서드를 수행하는 것이다. 메서드 호출 시마다 각각의 스택 프레임(그 메서드만을 위한 공간)이 생성되고 메서드 안에서 사용되는 값들을 저장하고,\n호출된 메서드의 매개변수, 지역변수, 리턴 값 및 연산 시 일어나는 값들을 임시로 저장한다.\n그리고 메서드 수행이 끝나면 프레임별로 삭제된다. (LIFO)\n프로세스가 메모리에 로드 될 때 스택 사이즈가 고정되어 있어, 런타임 시에 스택 사이즈를 바꿀 수는 없다.\nJVM 스택에서 프로그램 실행 중 메모리 크기가 충분하지 않다면 StackOverFlowError 발생 Heap Area Heap Area는 프로그램이 실행되면서 동적으로 생성된 객체(인스턴스) 가 저장되는 공간이다. Heap Area에 생성된 객체들은 다른 객체의 필드 또는 스택에 존재하는 다른 메서드에 의해 참조될 수 있다. 메서드가 실행되면서 Stack영역에는 참조값만을 저장해놓고 Heap Area에 객체 데이터를 저장해 놓는다. 자료구조에 관한 내용이 Heap Area에서 많이 쓰인다. 예를 들어 아래와 같이 배열과 리스트가 선언되었다고 해보자. 이런 경우 Stack 영역에는 참조값만 저장되며 Heap 영역에 실제 데이터가 저장된다. 1 2 var arrayExample: Array\u003cString\u003e = arrayOf(\"a\", \"b\", \"c\") var listExample: List\u003cString\u003e = listOf(\"a\", \"b\", \"c\") listOf는 Arrays.asList로 array를 전달하여 ArrayList를 생성하므로 위와 같은 결과가 나온다. String을 효율적으로 사용하기 위해 JVM상에서 String을 다른 객체들과 차별되게 저장되도록 해놓았는데, 그것이 바로 Heap Area 상의 String Constant Pool이다.\n1 2 3 4 5 6 7 8 9 10 11 val stringA1 = \"A\" val stringA2 = \"A\" stringA1 == stringA2 // true stringA1 === stringA2 // true val stringABC1 = String(charArrayOf('A','B','C')) val stringABC2 = \"ABC\" stringABC1 == stringABC2 // true stringABC1 === stringABC2 // false String Constant Pool은 플라이웨이트 패턴을 구현한 대표적인 예로 한 번 저장한 변수를 다시 저장하지 않도록 만들어졌다. 따라서 String을 을 이용하여 선언할 경우 먼저 String Constant Pool에 해당 변수가 있는지 확인 후 있으면 기존 값을 참조하도록 주소값을 설정하고, 아니라면 새로운 String은 String Constant Pool에 넣는다. 이러한 과정을 통해 String은 JVM 상에서 매우 효율적으로 동작할 수 있다. 그렇다면, 다른 변수들 처럼 String Constant Pool 바깥에 String을 저장할 수 있는 방법은 없을까? 당연히 있다. \"\"가 아니라 String 생성자를 이용하여 String을 생성할 경우 Constant Pool 바깥에 생성된다. PC 레지스터 (Program Counter Register) PC 레지스터는 쓰레드가 시작될 때 생성되며, 현재 수행중인 JVM 명령어 주소(Current Instruction Address)를 저장하는 공간이다.\nJVM 명령의 주소는 쓰레드가 어떤 부분을 무슨 명령으로 실행해야할 지에 대한 기록을 가지고 있다.\n하지만 자바의 PC Register는 CPU Register와 다르다.\n자바는 OS나 CPU의 입장에서는, 하나의 프로세스이기 때문에 가상 머신(JVM)의 리소스를 이용해야 한다.\n그래서 자바는 CPU에 직접 연산을 수행하도록 하는 것이 아닌, 현재 작업하는 내용을 CPU에게 연산으로 제공해야 하며,\n이를 위한 버퍼 공간으로 PC Register라는 메모리 영역을 만들게 된 것이다 따라서 JVM은 스택에서 비연산값 Operand를 뽑아 별도의 메모리 공간인 PC Register에 저장하는 방식을 취한다.\nJVM의 Stack, Heap 할당 방식 Stack에는 원시 타입 변수 값이나, Heap을 가리키는 주소값 둘 중 하나만 저장된다.\nStack은 좁은 메모리 공간이지만, Heap은 넓은 메모리 공간이다.\nStack 메모리에 값을 할당하고 해제하는 것은 많은 비용이 들지 않지만,\nHeap 메모리에 값을 할당하고 해제하는 것은 많은 비용을 요한다.\nJVM 프로세스와 멀티스레드 JVM(가상 머신)은 하나의 프로세스 이다. 하나의 프로세스는 여러 작업 단위를 가질수 있는데 이 작업 단위를 바로 스레드라고 한다. JVM에서는 Main Thread라 불리는 쓰레드가 있고, 우리가 main() 메서드를 사용해 불리는 것이 바로 Main Thread이다. Main Thread가 종료되면 나머지 Thread 들도 자동으로 종료가 된다 멀티 쓰레드의 경우 여러 쓰레드가 하나의 Heap 영역의 변수에 동시 접근하여 변경이 생기면, 동기화 이슈 발생\n해결법\n불변(읽기 전용) 변수로 선언, val 가변 변수일 경우 해당 값을 변경하는 연산을 @Synchronized 키워드를 이용해 한번에 하나의 스레드에서만 접근할 수 있게 막아야 함 가장 좋은 방법은 불변 변수로 선언하고, 임계 구역에서 접근하는 변수는 변화하지 않게 하는 것이다. 1 2 3 4 5 6 7 8 val immutableString = \"Kotlin World @Synchronized fun append(str: String?): StringBuffer? { toStringCache = null super.append(str) return this } 최근 CPU는 기본적으로 여러개의 코어를 가지고 있어 여러 개의 스레드를 활용하는 프로그래밍이 가능하다.\n따라서 멀티스레드를 활용하는 비동기 프로그래밍이 요즘 경향이다.\n비동기 프로그래밍이란, 연산을 다른 스레드로 넘겨버리고, 현재 스레드에서는 다른 작업을 할 수 있도록 하는 프로그래밍 방식이다.\n비동기 프로그래밍의 이점은 메인 스레드를 blocking 하지 않고 다른 스레드에서 작업을 수행하는 것이 가능하다는 것이다.\nUI가 있는 프로그램에서는 보통 메인스레드가 UI를 제어하게 되는데 메인 스레드가 non-blocking되면, UI가 끊기지 않아 사용자 경험 또한 개선시킬 수 있다.\nJVM에서 GC GC란, Heap 영역에서 동적으로 할당했던 메모리 중 필요 없게 된 메모리 객체(garbage) 를 모아 주기적으로 제거하는 것\n자동으로 처리해준다 해도 메모리가 언제 해제되는지 정확하게 알 수 없어 제어하기 힘들며,\n가비지 컬렉션(GC)이 동작하는 동안에는 다른 동작을 멈추기 때문에 오버헤드가 발생되는 문제점이 있다. =\u003e Stop the world\nGC 대상 GC 방식 Mark-Sweep 이란 다양한 GC에서 사용되는 객체를 솎아내는 내부 알고리즘이다.\n가비지 컬렉션이 동작하는 아주 기초적인 청소 과정이라고 생각하면 된다.\n모든 머신들이 그렇듯 JVM 또한 사용되지 않는 객체들이 제때 메모리에서 정리되지 못하고 한 번에 정리되거나 한다면 앱이 버벅거리거나, 제대로 동작하지 않을 수 있다.\n또한 만약 사용되지 않는 객체가 GC의 대상이 되지 못한다면 Out of Memory Error 로 인해 앱이 강제 종료될 수도 있다.\nYoung Generation 영역은 짧게 살아남는 메모리들이 존재하는 공간이다.\n모든 객체는 처음에는 Young Generation에 생성되며, Young Generation의 공간은 Old Generation에 비해 상대적으로 적기 때문에 메모리 상의 객체를 찾아 제거하는데 적은 시간이 걸린다. 작은 공간에서 데이터를 찾기 위해 걸리는 시간이 적기 때문이다. 이 때문에 Young Generation 영역에서 발생되는 GC는 Minor GC라 불린다. Old Generation은 길게 살아남는 메모리들이 존재하는 공간이다.\nOld Generation의 객체들은 처음에는 Young Generation에 의해 시작되었으나, GC 과정 중에 제거되지 않은 경우 Old Generation으로 이동한다. Old Generation은 Young Generation에 비해 상대적으로 큰 공간을 가지고 있으며 이 공간에서 메모리 상의 객체 제거에 많은 시간이 걸린다. 이 때문에 Old Generation에서 발생되는 GC는 Major GC라 불린다. Eden -\u003e Survior0 -\u003e Surviior1 이래도 GC에서도 살아남는다면, Old Generation 영역으로 넘어간다. Old Generation에서는 Major GC가 일어난다. Major GC는 매우 큰 공간이기 때문에 데이터를 지우는데 많은 시간이 걸린다. 또한 Major GC가 일어나면 Thread가 멈추고 Mark and Sweep 작업을 해야 해서 CPU에 부하를 주기 때문에 Major GC가 자주 일어나는 앱들에서는 GC가 일어날 때마다 멈추거나 버벅이는 현상이 발생한다. 따라서 최대한 Major GC는 일어나지 않도록 하는 것이 좋다. 제때 참조(Reference)를 해제하고, 오래 붙잡는 객체를 최소화해야 이러한 장애 상황을 최소화 할 수 있다. ","wordCount":"1756","inLanguage":"en","image":"https://2taezeat.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E","datePublished":"2023-12-03T11:30:03Z","dateModified":"2023-12-03T11:30:03Z","author":{"@type":"Person","name":"2taezeat"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://2taezeat.github.io/posts/dev/jvm-%EC%A0%95%EB%A6%AC/"},"publisher":{"@type":"Organization","name":"2taezeat, blog","logo":{"@type":"ImageObject","url":"https://2taezeat.github.io/icon/favicon.ico"}}}</script></head><body id=top><header class=header><nav class=nav><div class=logo><a href=https://2taezeat.github.io/ accesskey=h title="2taezeat blog (Alt + H)"><img src=https://2taezeat.github.io/icon/apple-touch-icon.png alt aria-label=logo height=30>2taezeat blog</a><div class=logo-switches></div></div><ul id=menu><li><a href=https://2taezeat.github.io/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://2taezeat.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://2taezeat.github.io/searchs/ title=Search><span>Search</span></a></li><li><a href=https://github.com/2taezeat title=Github><span>Github</span>&nbsp;<svg fill="none" shape-rendering="geometricPrecision" stroke="currentcolor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2.5" viewBox="0 0 24 24" height="12" width="12"><path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"/><path d="M15 3h6v6"/><path d="M10 14 21 3"/></svg></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://2taezeat.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://2taezeat.github.io/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">JVM 정리</h1><div class=post-description>JVM 정리</div><div class=post-meta><span title='2023-12-03 11:30:03 +0000 +0000'>2023-12-03</span>&nbsp;·&nbsp;9 min&nbsp;·&nbsp;1756 words&nbsp;·&nbsp;2taezeat</div></header><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#코틀린-코드-컴파일-및-빌드>코틀린 코드 컴파일 및 빌드</a></li><li><a href=#jdk-jre-jvm의-관계-및-역할>JDK, JRE, JVM의 관계 및 역할</a></li><li><a href=#java-컴파일>JAVA 컴파일</a><ul><li><a href=#jit-just-in_time-컴파일러>JIT (Just-In_Time) 컴파일러</a></li></ul></li><li><a href=#jvm의-동작-방식>JVM의 동작 방식</a></li><li><a href=#jvm의-구조>JVM의 구조</a><ul><li><a href=#execution-engine-실행-엔진>Execution Engine, 실행 엔진</a></li></ul></li><li><a href=#런타임-데이터-영역-runtime-data-area>런타임 데이터 영역 (Runtime Data Area)</a><ul><li><a href=#method-area>Method Area</a></li><li><a href=#stack-area>Stack Area</a></li><li><a href=#heap-area>Heap Area</a></li><li><a href=#pc-레지스터-program-counter-register>PC 레지스터 (Program Counter Register)</a></li></ul></li><li><a href=#jvm의-stack-heap-할당-방식>JVM의 Stack, Heap 할당 방식</a></li><li><a href=#jvm-프로세스와-멀티스레드>JVM 프로세스와 멀티스레드</a></li><li><a href=#jvm에서-gc>JVM에서 GC</a><ul><li><a href=#gc-대상>GC 대상</a></li><li><a href=#gc-방식>GC 방식</a></li></ul></li></ul></nav></div></details></div><div class=post-content><h1 id=코틀린-코드-컴파일-및-빌드>코틀린 코드 컴파일 및 빌드<a hidden class=anchor aria-hidden=true href=#코틀린-코드-컴파일-및-빌드>#</a></h1><p><img loading=lazy src=https://velog.velcdn.com/images%2Fba159sal%2Fpost%2F2d3a17cd-8816-461a-856f-e96d8cdb8e5c%2Fimage.png alt=https://velog.velcdn.com/images%2Fba159sal%2Fpost%2F2d3a17cd-8816-461a-856f-e96d8cdb8e5c%2Fimage.png width=680 height=auto></p><ul><li><code>코틀린 컴파일러</code>는 자바 컴파일러가 자바 소스코드를 컴파일할 때와 마찬가지로 <code>코틀린 소스코드(.kt)</code>를 분석해서 <code>.class</code> 파일을 만들어낸다.</li><li>만들어진 <code>.class</code> 파일은 개발 중인 애플리케이션의 유형에 맞는 표준 <code>패키징</code> 과정을 거쳐 실행될 수 있다.</li><li></li></ul><p><img loading=lazy src=https://velog.velcdn.com/images%2Fba159sal%2Fpost%2F865aeabf-b25c-4ff6-b903-f8fb3eba8674%2Fimage.png alt=https://velog.velcdn.com/images%2Fba159sal%2Fpost%2F865aeabf-b25c-4ff6-b903-f8fb3eba8674%2Fimage.png width=680 height=auto></p><p><strong>Java 코드와 Kotlin 코드의 빌드 과정은 다음과 같은 순서로 이루어진다.</strong></p><ol><li><p><code>코틀린 컴파일러(kotlinc)</code>가 코틀린 코드를 컴파일해 <code>.class</code> 파일을 생성한다. 이 과정에서 코틀린 코드가 참조하는 Java 코드가 함께 <strong>로딩</strong>되어 사용된다.</p><ul><li><p><strong>Parsing (파싱):</strong> 코틀린 컴파일러는 <code>.kt</code> 파일의 코드를 읽어 들여 문법적으로 올바른지 검사하고, 추상 구문 트리(AST, Abstract Syntax Tree)를 생성합니다.</p></li><li><p><strong>Type Checking (타입 검사):</strong> AST를 분석하여 타입 정보를 추론하고, 타입 오류를 검사합니다. 코틀린의 강력한 타입 추론 시스템은 이 단계에서 중요한 역할을 합니다.</p></li><li><p><strong>Code Generation (코드 생성):</strong> 타입 검사가 완료된 AST를 기반으로 JVM 바이트코드(<code>.class</code> 파일)를 생성합니다. 이때 <strong>코틀린 런타임 라이브러리</strong>에 <strong>대한 참조가 추가</strong>됩니다.</p></li><li><p><strong>Optimization (최적화):</strong> 생성된 바이트코드를 최적화하여 실행 속도를 향상시킵니다.</p></li></ul></li><li><p><code>Java 컴파일러(javac)</code>가 Java 코드를 컴파일해 <code>.class</code> 파일을 생성한다. 이때 이미 코틀린이 컴파일한 <code>.class</code> 파일의 경로를 클래스 패스에 추가해 컴파일한다.니</p><ul><li><p>코틀린 컴파일러로 컴파일한 코드는 <code>코틀린 런타임 라이브러리(kotlin runtime library)</code>에 의존한다.</p></li><li><p><code>코틀린 런타임 라이브러리</code> : <code>코틀린 자체 표준 라이브러리 클래스</code> + <code>코틀린에서 자바 API의 기능을 확장한 내용</code></p></li><li><p>코틀린으로 컴파일한 <strong>애플리케이션을 배포</strong>할때는 <code>코틀린 런타임 라이브러리</code>도 함께 배포해야 한다.</p></li><li><p>프로젝트를 컴파일하기 위해 <code>메이븐(Maven)</code>과 <code>그레이(Gradle)</code>, <code>앤트(Ant)</code> 등의 빌드 시스템을 사용</p></li><li><p>빌드 시스템은 모두 코틀린과 자바가 코드베이스에 함께 들어있는 혼합 언어 프로젝트를 지원할 수 있다</p></li><li><p><code>메이븐(Maven)</code>과 <code>그레이(Gradle)</code>들은 애플리케이션을 패키지할 때 알아서 <code>코틀린 런타임 라이브러리</code>을 포함시켜준다.</p></li></ul></li></ol><h1 id=jdk-jre-jvm의-관계-및-역할>JDK, JRE, JVM의 관계 및 역할<a hidden class=anchor aria-hidden=true href=#jdk-jre-jvm의-관계-및-역할>#</a></h1><p><img loading=lazy src=/images/before/image-20240519134814420.png alt=image-20240519134814420.png width=680 height=auto></p><p><strong>JDK (Java Development Kit):</strong></p><ul><li><p><strong>정의:</strong> 자바 개발 도구 모음입니다. 자바 애플리케이션을 개발, 컴파일, 실행하는 데 필요한 모든 것을 포함합니다. <strong>개발하려면 필요</strong></p></li><li><p>구성 요소:</p><ul><li><p><strong>JRE (Java Runtime Environment):</strong> 자바 애플리케이션을 실행하기 위한 환경입니다.</p></li><li><p><strong>컴파일러 (javac):</strong> 자바 소스 코드를 바이트코드로 변환합니다.</p></li><li><p><strong>디버거 (jdb):</strong> 자바 애플리케이션의 오류를 찾고 수정하는 데 사용됩니다.</p></li><li><p><strong>자바독 (javadoc):</strong> 자바 소스 코드에서 API 문서를 생성합니다.</p></li><li><p><strong>기타 도구:</strong> jar, jlink, jmod 등 다양한 개발 도구가 포함됩니다.</p></li></ul></li></ul><p><strong>JRE (Java Runtime Environment):</strong></p><ul><li><p><strong>정의:</strong> 자바 애플리케이션을 실행하기 위한 환경입니다. <strong>실행하려면 필요</strong></p></li><li><p>구성 요소:</p><ul><li><p><strong>JVM (Java Virtual Machine):</strong> 자바 바이트코드를 실행하는 가상 머신입니다.</p></li><li><p><strong>핵심 라이브러리:</strong> 자바 언어의 핵심 기능을 제공하는 클래스 라이브러리입니다.</p></li></ul></li></ul><p><strong>JVM (Java Virtual Machine):</strong></p><ul><li><p><strong>정의:</strong> <strong>자바 바이트코드를 실행하는 가상 머신</strong>입니다.</p></li><li><p>역할:</p><ul><li><p><strong>플랫폼 독립성:</strong> JVM은 다양한 운영체제와 하드웨어에서 동일한 자바 바이트코드를 실행할 수 있도록 해줍니다.</p></li><li><p><strong>메모리 관리:</strong> JVM은 자바 애플리케이션의 메모리를 자동으로 관리합니다.</p></li><li><p><strong>보안:</strong> JVM은 자바 애플리케이션의 안전한 실행을 보장합니다.</p></li><li><p><strong>성능 최적화:</strong> JVM은 <code>JIT(Just-In-Time)</code> 컴파일러를 사용하여 <strong>바이트코드</strong>를 <strong>실행 중에 기계어로 변환하여 성능을 향상</strong>시킵니다.</p></li></ul></li></ul><p><strong>관계:</strong> JDK는 JRE를 포함하고, JRE는 JVM을 포함합니다. 즉, JDK를 설치하면 JRE와 JVM도 함께 설치됩니다.</p><p><strong>추가 정보:</strong></p><ul><li>JVM은 자바 애플리케이션의 <strong>WORA(Write Once, Run Anywhere)</strong> 특성을 가능하게 합니다.</li><li>JVM은 자바 언어의 핵심 기술이며, 다양한 자바 애플리케이션 개발에 사용됩니다.</li></ul><h1 id=java-컴파일>JAVA 컴파일<a hidden class=anchor aria-hidden=true href=#java-컴파일>#</a></h1><ul><li>Java Compiler가 소스 코드 .java 파일을 <strong>.class 파일인 Byte Code(중간 레벨)</strong> 로 컴파일한다.<ul><li>단, 해당 코드는 직접 CPU에서 동작할 수 있는 코드가 아니다. 정확히 말하면 가상머신 <strong>JVM이 이해할 수 있는 코드</strong>이다</li></ul></li><li>이제 이 <strong>Byte Code</strong>를 <strong>기계어(Binary 코드)</strong> 로 변환시키기 위해 <strong>가상 머신</strong>이 필요한데, 이것이 <strong>JVM(Java Virtual Machine)</strong> 의 역할이다.</li><li>JVM이 <strong>Byte Code(.class)</strong> 를 <strong>기계어(Binary Code)</strong> 로 변환한다.</li><li>이렇게 JVM에 의해 컴파일된 기계어는 바로 CPU에서 실행되어 사용자에게 서비스를 제공해준다.</li></ul><blockquote><p>단, 간과하지 말아야 할 점은 자바 프로그램과는 달리 자바 가상 머신(JVM)은 <strong>운영체제에 종속적</strong>이므로, 각 운영체제에 맞는 <strong>자바 가상 머신</strong>을 설치해야 한다는 점이다.</p></blockquote><h2 id=jit-just-in_time-컴파일러>JIT (Just-In_Time) 컴파일러<a hidden class=anchor aria-hidden=true href=#jit-just-in_time-컴파일러>#</a></h2><p><img loading=lazy src=/images/before/image-20240519135439770.png alt=image-20240519135439770.png width=680 height=auto></p><ul><li><p>JIT 컴파일러는 <strong>같은 코드를 매번 해석</strong>하지 않고, 실행할 때 컴파일을 하면서 해당 코드를 <strong>캐싱</strong> 한다.</p><ul><li>이후에는 바뀐 부분만 컴파일하고 나머지는 캐싱된 코드를 사용한다.</li></ul></li><li><p>JIT 컴파일은 <strong>프로그램 실행 중</strong>에 기계어로 번역하는 컴파일 기법입니다.</p></li><li><p>전통적인 인터프리터 방식과 정적 컴파일 방식의 장점을 결합하여 성능을 향상시키는 데 목표를 둡니다.</p></li></ul><h1 id=jvm의-동작-방식>JVM의 동작 방식<a hidden class=anchor aria-hidden=true href=#jvm의-동작-방식>#</a></h1><p><img loading=lazy src=/images/before/image-20240519135733380.png alt=image-20240519135733380.png width=680 height=auto></p><ul><li>자바 프로그램을 실행하면 JVM은 OS로부터 메모리를 할당받는다.</li><li>자바 컴파일러(javac)가 <code>자바 소스코드(.java)</code>를 <code>자바 바이트 코드(.class)</code>로 컴파일 한다.</li><li><strong>Class Loader</strong>는 <strong>동적 로딩</strong>을 통해 필요한 <strong>클래스들을 로딩 및 링크</strong> 하여 <strong>Runtime Data Area(실질적인 메모리를 할당 받아 관리하는 영역)</strong> 에 올린다.</li><li><strong>Runtime Data Area</strong>에 로딩 된 바이트 코드는 <strong>Execution Engine을 통해 해석</strong>된다.</li><li>이 과정에서 Execution Engine에 의해 <strong>Garbage Collector의 작동</strong>과 <strong>Thread 동기화</strong>가 이루어진다.</li></ul><h1 id=jvm의-구조>JVM의 구조<a hidden class=anchor aria-hidden=true href=#jvm의-구조>#</a></h1><p><img loading=lazy src=/images/before/image-20240519135937524.png alt=image-20240519135937524.png width=680 height=auto></p><p><img loading=lazy src=/images/before/image-20240519140002581.png alt=image-20240519140002581.png width=680 height=auto></p><h2 id=execution-engine-실행-엔진>Execution Engine, 실행 엔진<a hidden class=anchor aria-hidden=true href=#execution-engine-실행-엔진>#</a></h2><ul><li><p><strong>실행 엔진</strong>은 클래스 로더를 통해 <strong>런타임 데이터 영역</strong>에 배치된 <strong>바이트 코드를 명령어 단위로 읽어서 실행</strong>한다</p></li><li><p><strong>자바 바이트 코드(*.class)</strong> 는 기계가 바로 수행할 수 있는 언어보다는 <strong>가상머신이 이해할 수 있는 중간 레벨로 컴파일 된 코드</strong>이다.</p><ul><li>그래서 <strong>실행 엔진</strong>은 이와 같은 바이트 코드를 실제로 JVM 내부에서 기계가 실행할 수 있는 형태로 변경해준다.</li></ul></li><li><p>이 수행 과정에서 실행 엔진은 <strong>인터프리터</strong>와 <strong>JIT 컴파일러</strong> 두 가지 방식을 혼합하여 <strong>바이트 코드를 실행한다.</strong></p></li></ul><p><img loading=lazy src=/images/before/image-20240519140102678.png alt=image-20240519140102678.png width=680 height=auto></p><h1 id=런타임-데이터-영역-runtime-data-area>런타임 데이터 영역 (Runtime Data Area)<a hidden class=anchor aria-hidden=true href=#런타임-데이터-영역-runtime-data-area>#</a></h1><p><img loading=lazy src=/images/before/image-20240519142249624.png alt=image-20240519142249624.png width=680 height=auto></p><p><img loading=lazy src=/images/before/image-20240519142529389.png alt=image-20240519142529389.png width=680 height=auto></p><ul><li><strong>런타입 데이터 영역</strong>은 쉽게 말하면 <strong>JVM의 메모리 영역</strong>으로 자바 애플리케이션을 실행할 때 사용되는 <strong>데이터들을 적재</strong>하는 영역이다.</li></ul><h2 id=method-area>Method Area<a hidden class=anchor aria-hidden=true href=#method-area>#</a></h2><ul><li>Method Area는 우리가 보통 <strong>정적(Static) 영역이라고 부르는 메모리</strong>이다.</li><li>프로그램 실행 중 클래스나 인터페이스를 사용하게 되면, JVM은 Class Loader을 이용해 클래스와 인터페이스의 <strong>메타 데이터를 Method Area</strong>에 저장한다.<ul><li>즉, 클래스가 로드 되는 시점은 해당 클래스가 사용되기 위해 호출되는 시점이다.</li><li><strong>메타 데이터</strong>는 <strong>Type Information, Runtime Constant Pool, Field Information, Method Information, Class Variable</strong>을 가리킨다.</li></ul></li></ul><p><img loading=lazy src=/images/before/image-20240519142652066.png alt=image-20240519142652066.png width=680 height=auto></p><h2 id=stack-area>Stack Area<a hidden class=anchor aria-hidden=true href=#stack-area>#</a></h2><ul><li><p>Stack Area는 <strong>메서드가 호출될 시 할당되는 영역</strong>이다.</p></li><li><p>메서드 호출 시 메서드 내부의 <strong>지역 변수</strong> 또한 Stack Area에 할당된다.</p><ul><li>Heap 공간에 객체 데이터를 올리고 그 <strong>객체 데이터에 대한 참조값</strong>이 할당된다는 뜻이다.</li></ul></li><li><p>예외적으로 원시 타입(Primitive type) 변수는 <strong>Stack 영역에 값 자체</strong>가 할당된다.</p></li><li><p>코어를 최대한 활용하기 위해 Thread를 사용하여 프로그래밍을 하는데, 각 스레드는 하나의 Stack 영역을 할당 받는다.</p><ul><li>즉, <strong>스레드는 각자의 메모리 공간</strong>을 가지고 메서드를 수행하는 것이다.</li></ul></li><li><p><strong>메서드 호출 시마다</strong> 각각의 <strong>스택 프레임(그 메서드만을 위한 공간</strong>)이 생성되고 메서드 안에서 사용되는 값들을 저장하고,</p></li><li><p>호출된 메서드의 매개변수, 지역변수, 리턴 값 및 연산 시 일어나는 <strong>값들을 임시로 저장</strong>한다.</p></li><li><p>그리고 메서드 수행이 끝나면 프레임별로 삭제된다. (<strong>LIFO</strong>)</p></li><li><p>프로세스가 메모리에 로드 될 때 스택 사이즈가 <strong>고정되어 있어, 런타임 시에 스택 사이즈를 바꿀 수는 없다.</strong></p><ul><li>JVM 스택에서 프로그램 실행 중 메모리 크기가 충분하지 않다면 StackOverFlowError 발생</li></ul></li></ul><p><img loading=lazy src=/images/before/image-20240519144141572.png alt=image-20240519144141572.png width=680 height=auto></p><h2 id=heap-area>Heap Area<a hidden class=anchor aria-hidden=true href=#heap-area>#</a></h2><p><img loading=lazy src=/images/before/image-20240519143026113.png alt=image-20240519143026113.png width=680 height=auto></p><ul><li>Heap Area는 프로그램이 실행되면서 <strong>동적으로 생성된 객체(인스턴스)</strong> 가 저장되는 공간이다.</li><li>Heap Area에 생성된 객체들은 다른 객체의 필드 또는 스<strong>택에 존재하는 다른 메서드에 의해 참조</strong>될 수 있다.</li><li>메서드가 실행되면서 <strong>Stack영역에는 참조값만</strong>을 저장해놓고 Heap Area에 <strong>객체 데이터를 저장</strong>해 놓는다.</li><li>자료구조에 관한 내용이 Heap Area에서 많이 쓰인다.</li><li>예를 들어 아래와 같이 배열과 리스트가 선언되었다고 해보자.</li><li>이런 경우 <strong>Stack 영역에는 참조값</strong>만 저장되며 <strong>Heap 영역에 실제 데이터가 저장</strong>된다.</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-kotlin data-lang=kotlin><span class=line><span class=cl><span class=k>var</span> <span class=py>arrayExample</span><span class=p>:</span> <span class=n>Array</span><span class=p>&lt;</span><span class=n>String</span><span class=p>&gt;</span> <span class=p>=</span> <span class=n>arrayOf</span><span class=p>(</span><span class=s2>&#34;a&#34;</span><span class=p>,</span> <span class=s2>&#34;b&#34;</span><span class=p>,</span> <span class=s2>&#34;c&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=k>var</span> <span class=py>listExample</span><span class=p>:</span> <span class=n>List</span><span class=p>&lt;</span><span class=n>String</span><span class=p>&gt;</span> <span class=p>=</span> <span class=n>listOf</span><span class=p>(</span><span class=s2>&#34;a&#34;</span><span class=p>,</span> <span class=s2>&#34;b&#34;</span><span class=p>,</span> <span class=s2>&#34;c&#34;</span><span class=p>)</span>
</span></span></code></pre></td></tr></table></div></div><blockquote><ul><li>listOf는 Arrays.asList로 array를 전달하여 ArrayList를 생성하므로 위와 같은 결과가 나온다.</li></ul></blockquote><p>String을 효율적으로 사용하기 위해 JVM상에서 String을 <strong>다른 객체들과 차별되게 저장</strong>되도록 해놓았는데, 그것이 바로 Heap Area 상의 <strong>String Constant Pool</strong>이다.</p><p><img loading=lazy src=/images/before/image-20240519143505108.png alt=image-20240519143505108.png width=680 height=auto></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-kotlin data-lang=kotlin><span class=line><span class=cl><span class=k>val</span> <span class=py>stringA1</span> <span class=p>=</span> <span class=s2>&#34;A&#34;</span>
</span></span><span class=line><span class=cl><span class=k>val</span> <span class=py>stringA2</span> <span class=p>=</span> <span class=s2>&#34;A&#34;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>stringA1</span> <span class=o>==</span> <span class=n>stringA2</span> <span class=c1>// true
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>stringA1</span> <span class=o>===</span> <span class=n>stringA2</span> <span class=c1>// true
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=k>val</span> <span class=py>stringABC1</span> <span class=p>=</span> <span class=n>String</span><span class=p>(</span><span class=n>charArrayOf</span><span class=p>(</span><span class=sc>&#39;A&#39;</span><span class=p>,</span><span class=sc>&#39;B&#39;</span><span class=p>,</span><span class=sc>&#39;C&#39;</span><span class=p>))</span>
</span></span><span class=line><span class=cl><span class=k>val</span> <span class=py>stringABC2</span> <span class=p>=</span> <span class=s2>&#34;ABC&#34;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>stringABC1</span> <span class=o>==</span> <span class=n>stringABC2</span> <span class=c1>// true
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>stringABC1</span> <span class=o>===</span> <span class=n>stringABC2</span> <span class=c1>// false
</span></span></span></code></pre></td></tr></table></div></div><ul><li>String Constant Pool은 플라이웨이트 패턴을 구현한 대표적인 예로 한 번 저장한 변수를 다시 저장하지 않도록 만들어졌다.</li><li>따라서 String을 을 이용하여 선언할 경우 먼저 String Constant Pool에 해당 변수가 있는지 확인 후 있으면 기존 값을 참조하도록 주소값을 설정하고, 아니라면 새로운 String은 String Constant Pool에 넣는다.</li><li>이러한 과정을 통해 String은 JVM 상에서 매우 효율적으로 동작할 수 있다.</li><li>그렇다면, 다른 변수들 처럼 String Constant Pool 바깥에 String을 저장할 수 있는 방법은 없을까? 당연히 있다.<ul><li><code>""</code>가 아니라 <code>String 생성자</code>를 이용하여 String을 생성할 경우 Constant Pool 바깥에 생성된다.</li></ul></li></ul><h2 id=pc-레지스터-program-counter-register>PC 레지스터 (Program Counter Register)<a hidden class=anchor aria-hidden=true href=#pc-레지스터-program-counter-register>#</a></h2><ul><li><p>PC 레지스터는 쓰레드가 시작될 때 생성되며, <strong>현재 수행중인 JVM 명령어 주소(Current Instruction Address)를 저장</strong>하는 공간이다.</p></li><li><p>JVM 명령의 주소는 <strong>쓰레드가 어떤 부분을 무슨 명령으로 실행해야할 지에 대한 기록</strong>을 가지고 있다.</p></li><li><p>하지만 자바의 PC Register는 CPU Register와 다르다.</p></li><li><p>자바는 OS나 CPU의 입장에서는, <strong>하나의 프로세스이기 때문에 가상 머신(JVM)의 리소스</strong>를 이용해야 한다.</p></li><li><p>그래서 자바는 CPU에 직접 연산을 수행하도록 하는 것이 아닌, 현재 작업하는 내용을 CPU에게 연산으로 제공해야 하며,</p><ul><li>이를 위한 <strong>버퍼 공간으로 PC Register라는 메모리 영역</strong>을 만들게 된 것이다</li></ul></li><li><p>따라서 JVM은 스택에서 <strong>비연산값 Operand</strong>를 뽑아 <strong>별도의 메모리 공간인 PC Register에 저장</strong>하는 방식을 취한다.</p></li></ul><h1 id=jvm의-stack-heap-할당-방식>JVM의 Stack, Heap 할당 방식<a hidden class=anchor aria-hidden=true href=#jvm의-stack-heap-할당-방식>#</a></h1><ul><li><p>Stack에는 <strong>원시 타입 변수 값</strong>이나, <strong>Heap을 가리키는 주소값</strong> 둘 중 하나만 저장된다.</p></li><li><p>Stack은 좁은 메모리 공간이지만, Heap은 넓은 메모리 공간이다.</p><ul><li><p>Stack 메모리에 값을 할당하고 해제하는 것은 많은 비용이 들지 않지만,</p></li><li><p>Heap 메모리에 값을 할당하고 해제하는 것은 많은 비용을 요한다.</p></li></ul></li></ul><h1 id=jvm-프로세스와-멀티스레드>JVM 프로세스와 멀티스레드<a hidden class=anchor aria-hidden=true href=#jvm-프로세스와-멀티스레드>#</a></h1><ul><li><strong>JVM(가상 머신)은 하나의 프로세스</strong> 이다.</li><li>하나의 프로세스는 여러 작업 단위를 가질수 있는데 <strong>이 작업 단위를 바로 스레드</strong>라고 한다.</li><li>JVM에서는 Main Thread라 불리는 쓰레드가 있고, 우리가 main() 메서드를 사용해 불리는 것이 바로 Main Thread이다.</li><li>Main Thread가 종료되면 나머지 Thread 들도 자동으로 종료가 된다</li></ul><p><strong>멀티 쓰레드의 경우 여러 쓰레드가 하나의 Heap 영역의 변수에 동시 접근하여 변경이 생기면, 동기화 이슈 발생</strong></p><p><strong>해결법</strong></p><ol><li><strong>불변(읽기 전용)</strong> 변수로 선언, <code>val</code></li><li>가변 변수일 경우 해당 값을 변경하는 연산을 <code>@Synchronized 키워드</code>를 이용해 한번에 하나의 스레드에서만 접근할 수 있게 막아야 함</li><li>가장 좋은 방법은 불변 변수로 선언하고, <strong>임계 구역</strong>에서 접근하는 변수는 변화하지 않게 하는 것이다.</li></ol><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-kotlin data-lang=kotlin><span class=line><span class=cl><span class=k>val</span> <span class=py>immutableString</span> <span class=p>=</span> <span class=s2>&#34;Kotlin World</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nd>@Synchronized</span>
</span></span><span class=line><span class=cl><span class=k>fun</span> <span class=nf>append</span><span class=p>(</span><span class=n>str</span><span class=p>:</span> <span class=n>String</span><span class=p>?):</span> <span class=n>StringBuffer</span><span class=p>?</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>toStringCache</span> <span class=p>=</span> <span class=k>null</span>
</span></span><span class=line><span class=cl>    <span class=k>super</span><span class=p>.</span><span class=n>append</span><span class=p>(</span><span class=n>str</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=k>this</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><ul><li><p>최근 CPU는 기본적으로 여러개의 코어를 가지고 있어 여러 개의 스레드를 활용하는 프로그래밍이 가능하다.</p></li><li><p>따라서 멀티스레드를 활용하는 비동기 프로그래밍이 요즘 경향이다.</p></li><li><p><code>비동기 프로그래밍</code>이란, <strong>연산을 다른 스레드로 넘겨</strong>버리고, <strong>현재 스레드에서는 다른 작업을 할 수 있도록 하는 프로그래밍 방식</strong>이다.</p><ul><li><p>비동기 프로그래밍의 이점은 메인 스레드를 blocking 하지 않고 다른 스레드에서 작업을 수행하는 것이 가능하다는 것이다.</p></li><li><p>UI가 있는 프로그램에서는 보통 메인스레드가 UI를 제어하게 되는데 메인 스레드가 non-blocking되면, UI가 끊기지 않아 사용자 경험 또한 개선시킬 수 있다.</p></li></ul></li></ul><h1 id=jvm에서-gc>JVM에서 GC<a hidden class=anchor aria-hidden=true href=#jvm에서-gc>#</a></h1><p><img loading=lazy src=/images/before/image-20240519150244342.png alt=image-20240519150244342.png width=680 height=auto></p><ul><li><p>GC란, Heap 영역에서 동적으로 할당했던 메모리 중 <strong>필요 없게 된 메모리 객체(garbage)</strong> 를 모아 주기적으로 제거하는 것</p></li><li><p>자동으로 처리해준다 해도 <strong>메모리가 언제 해제되는지 정확하게 알 수 없어 제어하기 힘들며</strong>,</p></li><li><p>가비지 컬렉션(GC)이 동작하는 동안에는 다른 동작을 멈추기 때문에 오버헤드가 발생되는 문제점이 있다. => <strong><code>Stop the world</code></strong></p></li></ul><h2 id=gc-대상>GC 대상<a hidden class=anchor aria-hidden=true href=#gc-대상>#</a></h2><p><img loading=lazy src=/images/before/image-20240519150935951.png alt=image-20240519150935951.png width=680 height=auto></p><h2 id=gc-방식>GC 방식<a hidden class=anchor aria-hidden=true href=#gc-방식>#</a></h2><ul><li><p><code>Mark-Sweep</code> 이란 다양한 GC에서 사용되는 객체를 솎아내는 내부 알고리즘이다.</p></li><li><p>가비지 컬렉션이 동작하는 아주 <strong>기초적인 청소 과정</strong>이라고 생각하면 된다.</p></li></ul><p><img loading=lazy src=/images/before/image-20240519151135000.png alt=image-20240519151135000.png width=680 height=auto></p><ul><li><p>모든 머신들이 그렇듯 JVM 또한 사용되지 않는 객체들이 제때 메모리에서 정리되지 못하고 한 번에 정리되거나 한다면 앱이 버벅거리거나, 제대로 동작하지 않을 수 있다.</p></li><li><p>또한 만약 사용되지 않는 객체가 GC의 대상이 되지 못한다면 <strong>Out of Memory Error</strong> 로 인해 앱이 강제 종료될 수도 있다.</p></li><li><p>Young Generation 영역은 짧게 살아남는 메모리들이 존재하는 공간이다.</p><ul><li>모든 객체는 처음에는 Young Generation에 생성되며, Young Generation의 공간은 Old Generation에 비해 상대적으로 적기 때문에 메모리 상의 객체를 찾아 제거하는데 적은 시간이 걸린다.</li><li>작은 공간에서 데이터를 찾기 위해 걸리는 시간이 적기 때문이다. 이 때문에 Young Generation 영역에서 발생되는 GC는 Minor GC라 불린다.</li></ul></li><li><p>Old Generation은 길게 살아남는 메모리들이 존재하는 공간이다.</p><ul><li>Old Generation의 객체들은 처음에는 Young Generation에 의해 시작되었으나, GC 과정 중에 제거되지 않은 경우 Old Generation으로 이동한다.</li><li>Old Generation은 Young Generation에 비해 상대적으로 큰 공간을 가지고 있으며 이 공간에서 메모리 상의 객체 제거에 많은 시간이 걸린다.</li><li>이 때문에 Old Generation에서 발생되는 GC는 Major GC라 불린다.</li></ul></li></ul><p><img loading=lazy src=/images/before/image-20240519150503084.png alt=image-20240519150503084.png width=680 height=auto></p><ul><li><code>Eden -> Survior0 -> Surviior1</code> 이래도 GC에서도 살아남는다면, Old Generation 영역으로 넘어간다.</li></ul><p><img loading=lazy src=/images/before/image-20240519150614980.png alt=image-20240519150614980.png width=680 height=auto></p><ul><li>Old Generation에서는 Major GC가 일어난다.</li><li>Major GC는 매우 큰 공간이기 때문에 데이터를 지우는데 많은 시간이 걸린다.</li><li>또한 Major GC가 일어나면 <strong>Thread가 멈추고 Mark and Sweep 작업</strong>을 해야 해서 <strong>CPU에 부하</strong>를 주기 때문에<ul><li>Major GC가 자주 일어나는 앱들에서는 GC가 일어날 때마다 멈추거나 버벅이는 현상이 발생한다.</li></ul></li><li>따라서 최대한 Major GC는 일어나지 않도록 하는 것이 좋다. <strong>제때 참조(Reference)를 해제하고, 오래 붙잡는 객체를 최소화해야 이러한 장애 상황을 최소화</strong> 할 수 있다.</li></ul></div><footer class=post-footer><ul class=post-tags><li><a href=https://2taezeat.github.io/tags/jvm/>JVM</a></li></ul><nav class=paginav><a class=prev href=https://2taezeat.github.io/posts/dev/kotlin-%EC%A0%95%EB%A6%AC-1/><span class=title>« Prev</span><br><span>Kotlin 정리 (1)</span>
</a><a class=next href=https://2taezeat.github.io/posts/dev/di-%EC%A0%95%EB%A6%AC/><span class=title>Next »</span><br><span>DI(Dependency Injection) 정리</span></a></nav><ul class=share-buttons><li><a target=_blank rel="noopener noreferrer" aria-label="share JVM 정리 on x" href="https://x.com/intent/tweet/?text=JVM%20%ec%a0%95%eb%a6%ac&amp;url=https%3a%2f%2f2taezeat.github.io%2fposts%2fdev%2fjvm-%25EC%25A0%2595%25EB%25A6%25AC%2f&amp;hashtags=JVM"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446C483.971.0 512 28.03 512 62.554zM269.951 190.75 182.567 75.216H56L207.216 272.95 63.9 436.783h61.366L235.9 310.383l96.667 126.4H456L298.367 228.367l134-153.151H371.033zM127.633 110h36.468l219.38 290.065H349.5z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share JVM 정리 on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2f2taezeat.github.io%2fposts%2fdev%2fjvm-%25EC%25A0%2595%25EB%25A6%25AC%2f&amp;title=JVM%20%ec%a0%95%eb%a6%ac&amp;summary=JVM%20%ec%a0%95%eb%a6%ac&amp;source=https%3a%2f%2f2taezeat.github.io%2fposts%2fdev%2fjvm-%25EC%25A0%2595%25EB%25A6%25AC%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share JVM 정리 on reddit" href="https://reddit.com/submit?url=https%3a%2f%2f2taezeat.github.io%2fposts%2fdev%2fjvm-%25EC%25A0%2595%25EB%25A6%25AC%2f&title=JVM%20%ec%a0%95%eb%a6%ac"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share JVM 정리 on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2f2taezeat.github.io%2fposts%2fdev%2fjvm-%25EC%25A0%2595%25EB%25A6%25AC%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share JVM 정리 on whatsapp" href="https://api.whatsapp.com/send?text=JVM%20%ec%a0%95%eb%a6%ac%20-%20https%3a%2f%2f2taezeat.github.io%2fposts%2fdev%2fjvm-%25EC%25A0%2595%25EB%25A6%25AC%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share JVM 정리 on telegram" href="https://telegram.me/share/url?text=JVM%20%ec%a0%95%eb%a6%ac&amp;url=https%3a%2f%2f2taezeat.github.io%2fposts%2fdev%2fjvm-%25EC%25A0%2595%25EB%25A6%25AC%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentcolor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share JVM 정리 on ycombinator" href="https://news.ycombinator.com/submitlink?t=JVM%20%ec%a0%95%eb%a6%ac&u=https%3a%2f%2f2taezeat.github.io%2fposts%2fdev%2fjvm-%25EC%25A0%2595%25EB%25A6%25AC%2f"><svg width="30" height="30" viewBox="0 0 512 512" fill="currentcolor" xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"><path d="M449.446.0C483.971.0 512 28.03 512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446zM183.8767 87.9921h-62.034L230.6673 292.4508V424.0079h50.6655V292.4508L390.1575 87.9921H328.1233L256 238.2489z"/></svg></a></li></ul></footer><script src=https://utteranc.es/client.js repo=2taezeat/blog_comment issue-term=pathname label=comment theme=github-light crossorigin=anonymous async></script></article></main><footer class=footer><span>&copy; 2024 <a href=https://2taezeat.github.io/>2taezeat, blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>