<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Clean Architecture 정리 | 2taezeat, blog</title>
<meta name=keywords content="Architecture"><meta name=description content="Clean Architecture 정리"><meta name=author content="2taezeat"><link rel=canonical href=https://2taezeat.github.io/posts/dev/clean-architecture-%EC%A0%95%EB%A6%AC/><meta name=google-site-verification content="YaEERzgrvu-ZwPg7gswZdTzRMufkHw3uIH7i8hVal1c"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.9875fca1b00769e44702dd56ab217bd958e5927ce88fa1fc5f2db91d133b90db.css integrity="sha256-mHX8obAHaeRHAt1WqyF72Vjlknzoj6H8Xy25HRM7kNs=" rel="preload stylesheet" as=style><link rel=icon href=https://2taezeat.github.io/icon/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://2taezeat.github.io/icon/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://2taezeat.github.io/icon/favicon-32x32.png><link rel=apple-touch-icon href=https://2taezeat.github.io/icon/apple-touch-icon.png><link rel=mask-icon href=https://2taezeat.github.io/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://2taezeat.github.io/posts/dev/clean-architecture-%EC%A0%95%EB%A6%AC/><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><meta property="og:title" content="Clean Architecture 정리"><meta property="og:description" content="Clean Architecture 정리"><meta property="og:type" content="article"><meta property="og:url" content="https://2taezeat.github.io/posts/dev/clean-architecture-%EC%A0%95%EB%A6%AC/"><meta property="og:image" content="https://2taezeat.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-12-01T11:30:03+00:00"><meta property="article:modified_time" content="2023-12-01T11:30:03+00:00"><meta property="og:site_name" content="2taezeat, blog"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://2taezeat.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="Clean Architecture 정리"><meta name=twitter:description content="Clean Architecture 정리"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://2taezeat.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Clean Architecture 정리","item":"https://2taezeat.github.io/posts/dev/clean-architecture-%EC%A0%95%EB%A6%AC/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Clean Architecture 정리","name":"Clean Architecture 정리","description":"Clean Architecture 정리","keywords":["Architecture"],"articleBody":" 핵심 소프트웨어를 고수준과 저수준으로 경계 짓고, 의존성 단방향 원칙을 따르는 아키텍처 자주 변경되는 것(저)과 변경되지 않는 것(고)의 경계를 나눠 분리시키자는 것 핵심: **계층 분리(layering)**를 통한 관심사 분리 presentation, domain, data layer로 나눔 특징 소스 코드 의존성은 반드시 안쪽으로, 고수준의 정책을 향해야 한다: 의존성 단방향 원칙 내부: 고수준, 추상화되어 변경이 잘 안됨 외부: 저수준, 구체화되어 변경이 잘 됨 외부는 내부를 의존, 내부는 외부의 존재를 모른다. 내부는 외부에 영향을 주지 않음 경계를 넘을 때는 추상화된 고수준의 인터페이스를 통한, 의존성 역전과 주입을 적용 저수준의 구현에 의존하던 것을 인터페이스에 의존하게 변경 (저-\u003e고) **소스 코드의 의존성(저→고)**과 **제어 흐름(고→저)**을 반대(역전)로 됨 구글 권장 아키텍처와 차이 구글 권장 아키텍처에서 domain layer이 옵셔널\n구글 권장 아키텍처는 domain -\u003e data layer를 참조함 (알고 있음)\ndomain layer가 프레임워크나 라이브러리에 종속될 수 있음 서비스가 커지고 비즈니스 로직이 늘어날 수록 ViewModel이 비대해지고,\n반복되는 비즈니스 로직들도 생겨났다. Domain layer 를 도입하여 관심사 분리가 필요\ndomain layer는 자체가 어떠한 언어로든 프레임워크나 라이브러리에 종속되지 않아(순수 kotlin) 테스트, 모듈화가 용이\n왜 쓰냐? 모바일 환경에서 사용자가 다양한 앱을 시도때도 없이 바꾸기도 하고 전화나 알림 등의 작업도 동시에 하기 때문에 앱에서 사용자 흐름이 중단되지 않고 연속적으로 흘러가도록 처리해야 함 App 컴포넌트 에 앱 데이터나 상태를 저장해서는 안되며, 앱 구성요소가 서로 종속되도록 개발해선 안됨 단위 테스트 하기 매우 어려워짐 생명주기에 의해, 메모리 릭이 발생 할 수도 있음 우리의 경우 멀티 모듈을 도입 -\u003e 클린 아키텍처가 멀티 모듈에는 적합하다 생각\n여러 모듈들을 조립하여 다른 앱 개발에 활용: 확장성 UP\n수정된 모듈만 빌드, 시간 단축: 생산성 UP\n모듈화를 통해 클린 아키텍쳐의 계층을 분리하고, 모듈들 간에 알아야 하는 대상과 몰라야 하는 대상의 제약이 강제됨: 휴먼 에러 제거 app 모듈: app 의 진입점이다.\nfeature 모듈 ( = presentation layer)\n독립적인 기능을 분리하였다. (home, playlist, search, my, player 등등) core 모듈\n다른 모듈에서 자주 사용 하는 공통 모듈이다. ui ( = presentation layer) : 다양한 기능에서 공통적으로 사용하는 UI를 포함하여 UI의 일관성을 유지하는데 도움을 준다.\ndomain ( = domain layer) : 앱의 비즈니스 로직을 캡슐화 한다. domain 모듈은 안드로이드의 의존성이 없는 순수 Java/Kotlin 코드로만 구성한다.\ndata ( = data layer) : data를 CRUD 한다.\n장점 도메인 단위 혹은 viewmodel 의 단위 테스트가 쉽게 가능\n유저의 동작으로 시작해서 화면에 보여지는 뷰의 데이터들의 흐름에 대해 파악하기 쉬워짐\nUI(View) → VM(프레젠터) → Usecase → Repository → Datasource 신규 개발자들도 파일 이름이나 클래스 명으로 어떤 기능을 해야 하고, 하고 있는지 알기 쉬워짐\ndomain과 data간의 분리가 이루어져 있기 때문에, 데이터 소스를 변경해도 domain 모듈에는 영향이 없기 때문에 비즈니스 로직은 피해없이 안전\n모듈간의 결합도가 낮아짐 (서로 영향을 덜 줌)\n단점 많은 파일들이 생겨남 단순 포워딩을 위한 Usecase가 생겨남 과도하게 집착하면, layering을 위한 수단으로 코드를 짜게 됨 (주객전도) 구성 요소 Entitiy : 핵심 비지니스 규칙을 캡슐화 Use Case : 비즈니스 로직을 정의 Interface Adapter : 어댑터들로 구성, Controller, Presenter, Gateway 가 속함. 인터페이스 역할 Framwork \u0026 Drivers : 시스템의 핵심 업무와는 관련 없는 세부 사항. layer Presentation 뷰(View): 직접적으로 플랫폼 의존적인 구현, 즉 UI 화면 표시와 사용자 입력을 담당합니다.단순하게 프레젠터가 명령하는 일만 수행합니다. 프레젠터(Presenter): MVVM의 ViewModel과 같이, 사용자 입력이 왔을 때 어떤 반응을 해야 하는지에 대한 판단을 하는 영역입니다. 무엇을 그려야 할지도 알고 있는 영역입니다. Domain 유즈 케이스(Use Case): 비즈니스 로직이 들어 있는 영역입니다.\n모델(Entity): 앱의 실질적인 데이터가 정의\nData 리포지터리(Repository): 유즈 케이스가 필요로 하는 데이터의 저장 및 수정 등의 기능을 제공하는 영역으로,\n데이터 소스를 인터페이스로 참조하여, 로컬 DB와 네트워크 통신을 자유롭게 할 수 있습니다. 데이터 소스(Data Source): 실제 데이터의 입출력이 여기서 실행됩니다.\n문제 해결 문제 상황 비즈니스 로직 수와 usecase 파일 수가 비례하기에, usecase 파일이 많아짐\n해결 단순 포워딩을 위한 usecase는 코틀린의 함수형 인터페이스 fun interface 으로 usecase의 보일러 코드 제거\n단순 포워딩이 아닌, viewmode에 복잡한 로직이 필요하거나 or 중복되는 로직이 있을 때는 기존 방식대로 사용\n단순 포워딩 -\u003e repository\nviewmodel 에 복잡한 로직이 필요할 때 -\u003e usecase\n간단한 로직인데 여러 Viewmodel 에서 중복되는 로직이 있을 때 -\u003e usecase\n두 repository 를 참고해야하는 로직일 때 -\u003e usecase\nSAM(single abstract method) 인터페이스 하나의 추상 메서드만 갖는 인터페이스 (코틀린이랑 상관없음)\n인터페이스 임으로, 하나의 타입이 된다 (컴파일러가 자동 타입 추론 및 에러 검출)\n함수형 인터페이스 라고도 불린다.\n1 2 3 public interface OnClickListener { // 대표적 예 void onClick(View v); } SAM 변환 자바 8 이전에는 함수형 인터페이스를 인자로 받는 Java 함수를 호출할 경우, 인터페이스를 구현한 익명 클래스 인스턴스를 만들어서 넘겨줘야 했다. 자바 8 이후와 코틀린에서 인터페이스를 인자로 받는 Java 메서드를 호출 할 경우, 객체(object) 대신 람다를 넘길 수 있다. 이를 SAM 변환이라고 한다. 동작 이유 컴파일러가 SAM 변환 기능이 있어서, 람다를 익명 내부 클래스 인스턴스 코드로 자동 변환해 주기 때문이다. 람다를 사용하지 않고 object 를 이용해 익명 객체를 넘길수도 있지만, 해당 코드를 수행할 때마다 익명 객체가 새로 생성된다. 람다를 이용한다면 프로그램 전체에서 객체는 하나만 만들어진다. 람다가 변수를 포획했을 때는 예외적으로 매번 생성한다, 왜냐하면 포획할 변수가 매번 바뀔 수 있기 때문 1 2 3 4 5 6 7 8 9 10 11 12 fun interface GetSomeUseCase : suspend () -\u003e List\u003cSomeModel\u003e single\u003cGetSomeUseCase\u003e { GetSomeUseCase( get\u003cSomeRepository\u003e()::getModels ) } fun interface IntPredicate { fun accept(i: Int): Boolean } val isEven = IntPredicate { it % 2 == 0 } 주의 사항 SAM 변환은 자바에서 작성한 인터페이스일 때만 동작 코틀린에서 하나의 추상 메소드만 있는 인터페이스를 생성하고, 그 인터페이스를 인자로 받는 함수에 람다를 넘기려고 하면 오류가 발생 이유는 코틀린에서는 함수를 파라미터로 사용할 수 있기 때문이다. 만약 코틀린에서 SAM 변환을 사용하고 싶다면, 인터페이스 앞에 fun 키워드를 붙여주면 된다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 fun main(){ doSomething{ println(\"a\") } // 방법 1 val practice = Practice{println(\"a\")} // 방법 2 doSomething(practice) } fun doSomething(practice: Practice){ practice.a() } fun interface Practice{ fun a() } ","wordCount":"892","inLanguage":"en","image":"https://2taezeat.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E","datePublished":"2023-12-01T11:30:03Z","dateModified":"2023-12-01T11:30:03Z","author":{"@type":"Person","name":"2taezeat"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://2taezeat.github.io/posts/dev/clean-architecture-%EC%A0%95%EB%A6%AC/"},"publisher":{"@type":"Organization","name":"2taezeat, blog","logo":{"@type":"ImageObject","url":"https://2taezeat.github.io/icon/favicon.ico"}}}</script></head><body id=top><header class=header><nav class=nav><div class=logo><a href=https://2taezeat.github.io/ accesskey=h title="2taezeat blog (Alt + H)"><img src=https://2taezeat.github.io/icon/apple-touch-icon.png alt aria-label=logo height=30>2taezeat blog</a><div class=logo-switches></div></div><ul id=menu><li><a href=https://2taezeat.github.io/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://2taezeat.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://2taezeat.github.io/searchs/ title=Search><span>Search</span></a></li><li><a href=https://github.com/2taezeat title=Github><span>Github</span>&nbsp;<svg fill="none" shape-rendering="geometricPrecision" stroke="currentcolor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2.5" viewBox="0 0 24 24" height="12" width="12"><path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"/><path d="M15 3h6v6"/><path d="M10 14 21 3"/></svg></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://2taezeat.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://2taezeat.github.io/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">Clean Architecture 정리</h1><div class=post-description>Clean Architecture 정리</div><div class=post-meta><span title='2023-12-01 11:30:03 +0000 +0000'>2023-12-01</span>&nbsp;·&nbsp;5 min&nbsp;·&nbsp;892 words&nbsp;·&nbsp;2taezeat</div></header><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#핵심>핵심</a></li><li><a href=#특징>특징</a></li><li><a href=#구글-권장-아키텍처와-차이>구글 권장 아키텍처와 차이</a></li><li><a href=#왜-쓰냐>왜 쓰냐?</a></li><li><a href=#장점>장점</a></li><li><a href=#단점>단점</a></li><li><a href=#구성-요소>구성 요소</a></li><li><a href=#layer>layer</a><ul><li><a href=#presentation>Presentation</a></li><li><a href=#domain>Domain</a></li><li><a href=#data>Data</a></li></ul></li><li><a href=#문제-해결>문제 해결</a><ul><li><a href=#문제-상황>문제 상황</a></li><li><a href=#해결>해결</a></li><li><a href=#samsingle-abstract-method-인터페이스>SAM(single abstract method) 인터페이스</a></li><li><a href=#sam-변환>SAM 변환</a></li><li><a href=#동작-이유>동작 이유</a></li><li><a href=#주의-사항>주의 사항</a></li></ul></li></ul></nav></div></details></div><div class=post-content><h1 id=핵심>핵심<a hidden class=anchor aria-hidden=true href=#핵심>#</a></h1><ul><li><strong>소프트웨어를 고수준과 저수준으로 경계 짓고, 의존성 단방향 원칙을 따르는 아키텍처</strong></li><li>자주 변경되는 것(저)과 변경되지 않는 것(고)의 <strong>경계를 나눠 분리</strong>시키자는 것<ul><li><strong>핵심</strong>: **계층 분리(layering)**를 통한 <strong>관심사 분리</strong></li><li>presentation, domain, data layer로 나눔</li></ul></li></ul><h1 id=특징>특징<a hidden class=anchor aria-hidden=true href=#특징>#</a></h1><ul><li>소스 코드 의존성은 <strong>반드시 안쪽으로, 고수준의 정책</strong>을 향해야 한다: <strong>의존성 단방향 원칙</strong></li><li>내부: 고수준, 추상화되어 변경이 잘 안됨</li><li>외부: 저수준, 구체화되어 변경이 잘 됨</li><li>외부는 내부를 의존, 내부는 외부의 존재를 모른다.<ul><li>내부는 외부에 영향을 주지 않음</li></ul></li><li>경계를 넘을 때는 추상화된 고수준의 인터페이스를 통한, 의존성 역전과 주입을 적용<ul><li>저수준의 구현에 의존하던 것을 인터페이스에 의존하게 변경 <strong>(저->고)</strong></li><li>**소스 코드의 의존성(저→고)**과 **제어 흐름(고→저)**을 반대(역전)로 됨</li></ul></li></ul><h1 id=구글-권장-아키텍처와-차이>구글 권장 아키텍처와 차이<a hidden class=anchor aria-hidden=true href=#구글-권장-아키텍처와-차이>#</a></h1><ul><li><p>구글 권장 아키텍처에서 domain layer이 옵셔널</p></li><li><p>구글 권장 아키텍처는 <strong>domain -> data layer를 참조함 (알고 있음)</strong></p><ul><li>domain layer가 프레임워크나 라이브러리에 종속될 수 있음</li></ul></li><li><p>서비스가 커지고 비즈니스 로직이 늘어날 수록 ViewModel이 비대해지고,</p></li><li><p>반복되는 비즈니스 로직들도 생겨났다. Domain layer 를 도입하여 관심사 분리가 필요</p></li><li><p>domain layer는 자체가 어떠한 언어로든 프레임워크나 라이브러리에 종속되지 않아(순수 kotlin) 테스트, 모듈화가 용이</p></li></ul><h1 id=왜-쓰냐>왜 쓰냐?<a hidden class=anchor aria-hidden=true href=#왜-쓰냐>#</a></h1><ul><li><strong>모바일 환경에서 사용자가 다양한 앱을 시도때도 없이 바꾸기도 하고 전화나 알림 등의 작업도 동시에 하기 때문에</strong><ul><li>앱에서 <strong>사용자 흐름이 중단</strong>되지 않고 연속적으로 흘러가도록 처리해야 함</li></ul></li><li>App 컴포넌트 <strong>에 앱 데이터나 상태를 저장해서는 안되며, 앱 구성요소가 서로 종속되도록 개발해선 안됨</strong><ul><li>단위 테스트 하기 매우 어려워짐</li><li>생명주기에 의해, 메모리 릭이 발생 할 수도 있음</li></ul></li></ul><ul><li><p>우리의 경우 <strong>멀티 모듈</strong>을 도입 -> <strong>클린 아키텍처가 멀티 모듈에는 적합하다 생각</strong></p></li><li><p>여러 <strong>모듈들을 조립</strong>하여 다른 앱 개발에 활용: <strong>확장성 UP</strong></p></li><li><p>수정된 모듈만 빌드, 시간 단축: <strong>생산성 UP</strong></p><ul><li>모듈화를 통해 <strong>클린 아키텍쳐의 계층을 분리</strong>하고, <strong>모듈들 간에 알아야 하는 대상과 몰라야 하는 대상의 제약이 강제됨</strong>: <strong>휴먼 에러 제거</strong></li></ul></li></ul><ul><li><p><strong>app 모듈</strong>: app 의 진입점이다.</p></li><li><p><strong>feature 모듈</strong> ( = <strong>presentation</strong> layer)</p><ul><li>독립적인 기능을 분리하였다. (home, playlist, search, my, player 등등)</li></ul></li><li><p><strong>core 모듈</strong></p><ul><li>다른 모듈에서 자주 사용 하는 공통 모듈이다.</li></ul><ul><li><p>ui ( = presentation layer) : 다양한 기능에서 공통적으로 사용하는 UI를 포함하여 UI의 일관성을 유지하는데 도움을 준다.</p></li><li><p>domain ( = domain layer) : 앱의 비즈니스 로직을 캡슐화 한다. domain 모듈은 안드로이드의 의존성이 없는 순수 Java/Kotlin 코드로만 구성한다.</p></li><li><p>data ( = data layer) : data를 CRUD 한다.</p></li></ul></li></ul><h1 id=장점>장점<a hidden class=anchor aria-hidden=true href=#장점>#</a></h1><ul><li><p>도메인 단위 혹은 viewmodel 의 단위 테스트가 쉽게 가능</p></li><li><p>유저의 동작으로 시작해서 화면에 보여지는 뷰의 데이터들의 흐름에 대해 파악하기 쉬워짐</p><ul><li>UI(View) → VM(프레젠터) → Usecase → Repository → Datasource</li></ul></li><li><p>신규 개발자들도 파일 이름이나 클래스 명으로 어떤 기능을 해야 하고, 하고 있는지 알기 쉬워짐</p></li><li><p>domain과 data간의 분리가 이루어져 있기 때문에, 데이터 소스를 변경해도 domain 모듈에는 영향이 없기 때문에 비즈니스 로직은 피해없이 안전</p></li><li><p>모듈간의 결합도가 낮아짐 (서로 영향을 덜 줌)</p></li></ul><h1 id=단점>단점<a hidden class=anchor aria-hidden=true href=#단점>#</a></h1><ul><li>많은 파일들이 생겨남</li><li>단순 포워딩을 위한 Usecase가 생겨남</li><li>과도하게 집착하면, <strong>layering을 위한 수단</strong>으로 코드를 짜게 됨 (<strong>주객전도</strong>)</li></ul><h1 id=구성-요소>구성 요소<a hidden class=anchor aria-hidden=true href=#구성-요소>#</a></h1><ul><li>Entitiy : 핵심 비지니스 규칙을 캡슐화</li><li>Use Case : 비즈니스 로직을 정의</li><li>Interface Adapter : 어댑터들로 구성, Controller, Presenter, Gateway 가 속함. 인터페이스 역할</li><li>Framwork & Drivers : 시스템의 핵심 업무와는 관련 없는 세부 사항.</li></ul><h1 id=layer>layer<a hidden class=anchor aria-hidden=true href=#layer>#</a></h1><h2 id=presentation>Presentation<a hidden class=anchor aria-hidden=true href=#presentation>#</a></h2><ul><li>뷰(View): 직접적으로 플랫폼 의존적인 구현, 즉 UI 화면 표시와 사용자 입력을 담당합니다.단순하게 <strong>프레젠터가 명령하는 일만 수행합니다.</strong></li><li>프레젠터(Presenter): MVVM의 ViewModel과 같이, <strong>사용자 입력이 왔을 때 어떤 반응을 해야 하는지에 대한 판단을 하는 영역</strong>입니다. 무엇을 그려야 할지도 알고 있는 영역입니다.</li></ul><h2 id=domain>Domain<a hidden class=anchor aria-hidden=true href=#domain>#</a></h2><ul><li><p>유즈 케이스(Use Case): 비즈니스 로직이 들어 있는 영역입니다.</p></li><li><p>모델(Entity): 앱의 실질적인 데이터가 정의</p></li></ul><h2 id=data>Data<a hidden class=anchor aria-hidden=true href=#data>#</a></h2><ul><li><p>리포지터리(Repository): <strong>유즈 케이스</strong>가 필요로 하는 데이터의 저장 및 수정 등의 기능을 제공하는 영역으로,</p><ul><li>데이터 소스를 인터페이스로 참조하여, 로컬 DB와 네트워크 통신을 자유롭게 할 수 있습니다.</li></ul></li><li><p>데이터 소스(Data Source): <strong>실제 데이터의 입출력</strong>이 여기서 실행됩니다.</p></li></ul><h1 id=문제-해결>문제 해결<a hidden class=anchor aria-hidden=true href=#문제-해결>#</a></h1><h2 id=문제-상황>문제 상황<a hidden class=anchor aria-hidden=true href=#문제-상황>#</a></h2><p><strong>비즈니스 로직 수와 usecase 파일 수가 비례하기에, usecase 파일이 많아짐</strong></p><h2 id=해결>해결<a hidden class=anchor aria-hidden=true href=#해결>#</a></h2><ul><li><p>단순 포워딩을 위한 usecase는 코틀린의 함수형 인터페이스 <code>fun interface</code> 으로 usecase의 보일러 코드 제거</p></li><li><p>단순 포워딩이 아닌, <strong>viewmode에 복잡한 로직이 필요하거나 or 중복되는 로직이 있을 때</strong>는 기존 방식대로 사용</p></li><li><p>단순 포워딩 -> <code>repository</code></p></li><li><p>viewmodel 에 복잡한 로직이 필요할 때 -> <code>usecase</code></p></li><li><p>간단한 로직인데 여러 Viewmodel 에서 중복되는 로직이 있을 때 -> <code>usecase</code></p></li><li><p>두 repository 를 참고해야하는 로직일 때 -> <code>usecase</code></p></li></ul><h2 id=samsingle-abstract-method-인터페이스>SAM(single abstract method) 인터페이스<a hidden class=anchor aria-hidden=true href=#samsingle-abstract-method-인터페이스>#</a></h2><ul><li><p>하나의 추상 메서드만 갖는 인터페이스 (<strong>코틀린이랑 상관없음</strong>)</p><ul><li><p>인터페이스 임으로, 하나의 <strong>타입</strong>이 된다 (컴파일러가 자동 타입 추론 및 에러 검출)</p></li><li><p><strong>함수형 인터페이스</strong> 라고도 불린다.</p></li><li><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>public</span><span class=w> </span><span class=kd>interface</span> <span class=nc>OnClickListener</span><span class=w> </span><span class=p>{</span><span class=w> </span><span class=c1>// 대표적 예</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kt>void</span><span class=w> </span><span class=nf>onClick</span><span class=p>(</span><span class=n>View</span><span class=w> </span><span class=n>v</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div></li></ul></li></ul><h2 id=sam-변환>SAM 변환<a hidden class=anchor aria-hidden=true href=#sam-변환>#</a></h2><ul><li>자바 8 이전에는 함수형 인터페이스를 인자로 받는 Java 함수를 호출할 경우, 인터페이스를 구현한 익명 클래스 인스턴스를 만들어서 넘겨줘야 했다.</li><li>자바 8 이후와 코틀린에서 인터페이스를 인자로 받는 Java 메서드를 호출 할 경우, <strong>객체(object) 대신 람다</strong>를 넘길 수 있다. 이를 <strong>SAM 변환</strong>이라고 한다.</li></ul><h2 id=동작-이유>동작 이유<a hidden class=anchor aria-hidden=true href=#동작-이유>#</a></h2><ul><li><strong>컴파일러</strong>가 SAM 변환 기능이 있어서, 람다를 <code>익명 내부 클래스</code> <strong>인스턴스 코드로 자동 변환</strong>해 주기 때문이다.</li></ul><ul><li>람다를 사용하지 않고 object 를 이용해 익명 객체를 넘길수도 있지만, 해당 코드를 <strong>수행할 때마다 익명 객체가 새로 생성</strong>된다.</li><li>람다를 이용한다면 <strong>프로그램 전체에서 객체는 하나만 만들어진다</strong>.<ul><li><strong>람다가 변수를 포획했을 때는 예외적으로 매번 생성한다, 왜냐하면 포획할 변수가 매번 바뀔 수 있기 때문</strong></li></ul></li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-kotlin data-lang=kotlin><span class=line><span class=cl><span class=k>fun</span> <span class=nf>interface</span> <span class=n>GetSomeUseCase</span> <span class=p>:</span> <span class=k>suspend</span> <span class=p>()</span> <span class=o>-&gt;</span> <span class=n>List</span><span class=p>&lt;</span><span class=n>SomeModel</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>single</span><span class=p>&lt;</span><span class=n>GetSomeUseCase</span><span class=p>&gt;</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>GetSomeUseCase</span><span class=p>(</span>  <span class=k>get</span><span class=p>&lt;</span><span class=n>SomeRepository</span><span class=p>&gt;()</span><span class=o>::</span><span class=n>getModels</span>  <span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>fun</span> <span class=nf>interface</span> <span class=n>IntPredicate</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>   <span class=k>fun</span> <span class=nf>accept</span><span class=p>(</span><span class=n>i</span><span class=p>:</span> <span class=n>Int</span><span class=p>):</span> <span class=n>Boolean</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>val</span> <span class=py>isEven</span> <span class=p>=</span> <span class=n>IntPredicate</span> <span class=p>{</span> <span class=k>it</span> <span class=p>%</span> <span class=m>2</span> <span class=o>==</span> <span class=m>0</span> <span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><h2 id=주의-사항>주의 사항<a hidden class=anchor aria-hidden=true href=#주의-사항>#</a></h2><ul><li>SAM 변환은 자바에서 작성한 인터페이스일 때만 동작</li><li>코틀린에서 하나의 추상 메소드만 있는 인터페이스를 생성하고, 그 인터페이스를 인자로 받는 함수에 람다를 넘기려고 하면 오류가 발생<ul><li>이유는 코틀린에서는 함수를 파라미터로 사용할 수 있기 때문이다.</li><li>만약 코틀린에서 SAM 변환을 사용하고 싶다면, <strong>인터페이스 앞에 fun 키워드</strong>를 붙여주면 된다.</li></ul></li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-kotlin data-lang=kotlin><span class=line><span class=cl><span class=k>fun</span> <span class=nf>main</span><span class=p>(){</span>
</span></span><span class=line><span class=cl>    <span class=n>doSomething</span><span class=p>{</span> <span class=n>println</span><span class=p>(</span><span class=s2>&#34;a&#34;</span><span class=p>)</span> <span class=p>}</span> 	<span class=c1>// 방법 1
</span></span></span><span class=line><span class=cl><span class=c1></span>    
</span></span><span class=line><span class=cl>    <span class=k>val</span> <span class=py>practice</span> <span class=p>=</span> <span class=n>Practice</span><span class=p>{</span><span class=n>println</span><span class=p>(</span><span class=s2>&#34;a&#34;</span><span class=p>)}</span>   <span class=c1>// 방법 2
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>doSomething</span><span class=p>(</span><span class=n>practice</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>fun</span> <span class=nf>doSomething</span><span class=p>(</span><span class=n>practice</span><span class=p>:</span> <span class=n>Practice</span><span class=p>){</span>
</span></span><span class=line><span class=cl>    <span class=n>practice</span><span class=p>.</span><span class=n>a</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>fun</span> <span class=nf>interface</span> <span class=n>Practice</span><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>fun</span> <span class=nf>a</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>}</span> 
</span></span></code></pre></td></tr></table></div></div></div><footer class=post-footer><ul class=post-tags><li><a href=https://2taezeat.github.io/tags/architecture/>Architecture</a></li></ul><nav class=paginav><a class=prev href=https://2taezeat.github.io/posts/dev/di-%EC%A0%95%EB%A6%AC/><span class=title>« Prev</span><br><span>DI(Dependency Injection) 정리</span>
</a><a class=next href=https://2taezeat.github.io/posts/android/jetpack-navigation/><span class=title>Next »</span><br><span>Jetpack Navigation 기초</span></a></nav><ul class=share-buttons><li><a target=_blank rel="noopener noreferrer" aria-label="share Clean Architecture 정리 on x" href="https://x.com/intent/tweet/?text=Clean%20Architecture%20%ec%a0%95%eb%a6%ac&amp;url=https%3a%2f%2f2taezeat.github.io%2fposts%2fdev%2fclean-architecture-%25EC%25A0%2595%25EB%25A6%25AC%2f&amp;hashtags=Architecture"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446C483.971.0 512 28.03 512 62.554zM269.951 190.75 182.567 75.216H56L207.216 272.95 63.9 436.783h61.366L235.9 310.383l96.667 126.4H456L298.367 228.367l134-153.151H371.033zM127.633 110h36.468l219.38 290.065H349.5z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Clean Architecture 정리 on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2f2taezeat.github.io%2fposts%2fdev%2fclean-architecture-%25EC%25A0%2595%25EB%25A6%25AC%2f&amp;title=Clean%20Architecture%20%ec%a0%95%eb%a6%ac&amp;summary=Clean%20Architecture%20%ec%a0%95%eb%a6%ac&amp;source=https%3a%2f%2f2taezeat.github.io%2fposts%2fdev%2fclean-architecture-%25EC%25A0%2595%25EB%25A6%25AC%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Clean Architecture 정리 on reddit" href="https://reddit.com/submit?url=https%3a%2f%2f2taezeat.github.io%2fposts%2fdev%2fclean-architecture-%25EC%25A0%2595%25EB%25A6%25AC%2f&title=Clean%20Architecture%20%ec%a0%95%eb%a6%ac"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Clean Architecture 정리 on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2f2taezeat.github.io%2fposts%2fdev%2fclean-architecture-%25EC%25A0%2595%25EB%25A6%25AC%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Clean Architecture 정리 on whatsapp" href="https://api.whatsapp.com/send?text=Clean%20Architecture%20%ec%a0%95%eb%a6%ac%20-%20https%3a%2f%2f2taezeat.github.io%2fposts%2fdev%2fclean-architecture-%25EC%25A0%2595%25EB%25A6%25AC%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Clean Architecture 정리 on telegram" href="https://telegram.me/share/url?text=Clean%20Architecture%20%ec%a0%95%eb%a6%ac&amp;url=https%3a%2f%2f2taezeat.github.io%2fposts%2fdev%2fclean-architecture-%25EC%25A0%2595%25EB%25A6%25AC%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentcolor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Clean Architecture 정리 on ycombinator" href="https://news.ycombinator.com/submitlink?t=Clean%20Architecture%20%ec%a0%95%eb%a6%ac&u=https%3a%2f%2f2taezeat.github.io%2fposts%2fdev%2fclean-architecture-%25EC%25A0%2595%25EB%25A6%25AC%2f"><svg width="30" height="30" viewBox="0 0 512 512" fill="currentcolor" xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"><path d="M449.446.0C483.971.0 512 28.03 512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446zM183.8767 87.9921h-62.034L230.6673 292.4508V424.0079h50.6655V292.4508L390.1575 87.9921H328.1233L256 238.2489z"/></svg></a></li></ul></footer><script src=https://utteranc.es/client.js repo=2taezeat/blog_comment issue-term=pathname label=comment theme=github-light crossorigin=anonymous async></script></article></main><footer class=footer><span>&copy; 2024 <a href=https://2taezeat.github.io/>2taezeat, blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>