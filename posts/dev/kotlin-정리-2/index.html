<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Kotlin 정리 (2) | 2taezeat, blog</title>
<meta name=keywords content="Kotlin"><meta name=description content="Kotlin 정리 (2)"><meta name=author content="2taezeat"><link rel=canonical href=https://2taezeat.github.io/posts/dev/kotlin-%EC%A0%95%EB%A6%AC-2/><meta name=google-site-verification content="YaEERzgrvu-ZwPg7gswZdTzRMufkHw3uIH7i8hVal1c"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.0653c5fc8a439a898cd1fe8a206477ec49246832c1f79c575f5c6b9e1810bdb9.css integrity="sha256-BlPF/IpDmomM0f6KIGR37EkkaDLB95xXX1xrnhgQvbk=" rel="preload stylesheet" as=style><link rel=icon href=https://2taezeat.github.io/icon/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://2taezeat.github.io/icon/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://2taezeat.github.io/icon/favicon-32x32.png><link rel=apple-touch-icon href=https://2taezeat.github.io/icon/apple-touch-icon.png><link rel=mask-icon href=https://2taezeat.github.io/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://2taezeat.github.io/posts/dev/kotlin-%EC%A0%95%EB%A6%AC-2/><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><meta property="og:title" content="Kotlin 정리 (2)"><meta property="og:description" content="Kotlin 정리 (2)"><meta property="og:type" content="article"><meta property="og:url" content="https://2taezeat.github.io/posts/dev/kotlin-%EC%A0%95%EB%A6%AC-2/"><meta property="og:image" content="https://2taezeat.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-12-05T11:30:03+00:00"><meta property="article:modified_time" content="2023-12-05T11:30:03+00:00"><meta property="og:site_name" content="2taezeat, blog"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://2taezeat.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="Kotlin 정리 (2)"><meta name=twitter:description content="Kotlin 정리 (2)"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://2taezeat.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Kotlin 정리 (2)","item":"https://2taezeat.github.io/posts/dev/kotlin-%EC%A0%95%EB%A6%AC-2/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Kotlin 정리 (2)","name":"Kotlin 정리 (2)","description":"Kotlin 정리 (2)","keywords":["Kotlin"],"articleBody":"Kotlin 다시 보기 (2) ‘빅 너드 랜치의 코틀린 프로그래밍’ 을 읽고 정리\n인터페이스와 추상 클래스 abstact 함수(추상 함수) : 함수의 헤더만 선언하고 몸체(Body)의 구현 코드가 없는 함수\n객체간의 상속 관계가 없으면서, 주로 공통적인 속성이나 행동을 갖는 경우 : 인터페이스\n객체간의 상속 관계가 있으면서, 주로 인스턴스 생성이 필요 없는 부모 클래스가 필요한 경우 : 추상 클래스\n인터페이스 구현하기 인터페이스는 무엇을 해야 하는지 정의한 것이므로, 클래스로 구현(implement) 해야 한다.\n해당 인터페이스를 구현하는 클래스를 정의(구현)한 후에 이 클래스에서 인터페이스에 명시된 속성과 함수의 구현 코드를 제공하게 한다.\n인터페이스의 속성과 함수는 open 키워드를 지정하지 않아도 된다.\n인터페이스는 how가 아닌 what을 정의한다.\nhow는 인터페이스의 구현 클래스에서 정의 인터페이스 타입의 매개변수를 가지므로 이 인터페이스를 구현하는 어떤 클래스의 인스턴스도 인자로 받을 수 있다\n인터페이스에 정의된 속성에 기본으로 구현된 getter와 함수에도 기본으로 구현된 몸체 코드를 제공할 수 있다.\ndamageRoll의 속성의 값을 지정하지 않을 경우 기본으로 구현된 getter에서 값이 지정됨 1 2 3 4 5 6 7 8 9 interface Fightable { var healthPoints: Int val damageRoll: Int get() = (O until dicecount).map { Random().nextInt(diceSides) + 1 }.sum() fun attack(opponent: Fightable): Int } SAM(single abstract method) 인터페이스 하나의 추상 메서드만 갖는 인터페이스 (코틀린이랑 상관없음)\n인터페이스 임으로, 하나의 타입이 된다 (컴파일러가 자동 타입 추론 및 에러 검출)\n함수형 인터페이스 라고도 불린다.\n1 2 3 public interface OnClickListener { // 대표적 예, Java 코드 void onClick(View v); } SAM 변환 자바 8 이전에는 함수형 인터페이스를 인자로 받는 Java 함수를 호출할 경우, 인터페이스를 구현한 익명 클래스 인스턴스를 만들어서 넘겨줘야 했다. 자바 8 이후와 코틀린에서 인터페이스를 인자로 받는 Java 메서드를 호출 할 경우, 객체(object) 대신 람다를 넘길 수 있다. 이를 SAM 변환이라고 한다. SAM 주의 사항 SAM 변환은 자바에서 작성한 인터페이스일 때만 동작 코틀린에서 하나의 추상 메소드만 있는 인터페이스를 생성하고, 그 인터페이스를 인자로 받는 함수에 람다를 넘기려고 하면 오류가 발생 이유는 코틀린에서는 함수를 파라미터로 사용할 수 있기 때문이다. 만약 코틀린에서 SAM 변환을 사용하고 싶다면, 인터페이스 앞에 fun 키워드를 붙여주면 된다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 fun interface Practice{ fun a() } fun main(){ doSomething{ println(\"a\") } // 방법 1 val practice = Practice{ println(\"a\") } // 방법 2 doSomething(practice) } fun doSomething(practice: Practice){ practice.a() } 추상 클래스 인터페이스와 비슷하게 추상 함수와 속성을 갖는다.\n구현 코드가 있는 일반 함수도 가질 수 있다.\n서브 클래스에서 추상 클래스의 속성과 함수를 상속받아 구현하도록 하는 것이 추상 클래스의 주 목적이다.\n추상 클래스는 주로 부모 클래스를 정의할 때 사용된다. (상속)\n인터페이스에 정의된 함수는 기본적으로 추상 함수지만, 추상 클래스에 정의되는 추상 함수에는 abstract 키워드를 지정해야 한다.\n일반 클래스는 하나의 추상 클래스만 부모 클래스로 가질 수 있지만, 인터페이스는 여러 개 구현 가능하다.\n제네릭 제네릭: 타입을 미리 확정하지 않고, 사용되는 시점에서 특정 타입을 지정할 수 있도록 해주는 기법\n동일한 인터페이스 및 클래스, 함수의 정의를 재사용할 수 있어서 코드의 중복을 줄여준다.\n컴파일 시점에서 사용 타입의 적합성을 확인할 수 있으므로, 타입 안전을 보장해 준다. (타입 추론 가능)\nList 는 ‘제네릭 인터페이스’로 정의 되었다.\n여기서 ‘List’ 는 raw 타입 \u003c\u003e 안에 지정된 타입을 제네릭 타입(generic type) 이라고 한다. List 제네릭 클래스의 인스턴스의 타입은 raw 타입과 제네릭 타입이 결합된 타입이 된다. ( 하나의 List 타입 )\n제네릭 타입 정의하기 1 2 3 4 5 6 7 8 9 10 11 12 class LootBox\u003cT\u003e(item: T) { private var loot: T = item var tmp = false fun fetch(): T? { // 제네릭 함수 return loot.takeIf { tmp } } fun \u003cR\u003e fetch( lootModFunction: (T) -\u003e R ): R? { // 복합 제네릭 타입 함수 return loot.takeIf { tmp } } } 제네릭 타입 매개변수 : T / \u003c \u003e안에 지정됨\n보통 return 타입 매개 변수는 ‘R’로 표현\n(T) -\u003e R =\u003e 함수 타입\n제네릭 타입 제약 제네릭 타입 T에: Loot를 지정하면, Loot 클래스 및 이것의 서브 클래스만 LootBox 클래스의 매개변수 타입으로 사용될 수 있다. 1 2 3 class LootBox\u003cT: Loot\u003e(itme: T) { } vararg 1 2 3 class LootBox\u003cT: Loot\u003e(vararg itme: T) { } vararg 키워드를 추가하면 매개변수가 배열(Array) 로 처리되므로 여러 개의 아이템을 인자로 전달할 수 있다. 코틀린에서 기본 타입이 아닌 Arrays 라는 참조 타입으로 배열을 지원한다. (코틀린은 모두 참조 타입) 여기서 배열은 컬렉션 타입이다. 1 2 3 4 5 6 7 8 9 10 class MyDataClass constructor(vararg val numbers: Int) { // ... } val myData1 = MyDataClass(1, 2, 3) val myData2 = MyDataClass() // 빈 배열 전달 가능 val myData3 = MyDataClass(4, 5) val numbers = intArrayOf(1, 2, 3) val myData = MyDataClass(*numbers) // 배열을 펼쳐서 전달 기본 생성자에서의 vararg\n코틀린의 기본 생성자에서 vararg를 사용하면, 생성자에 가변적인 개수의 인자를 전달하여 객체를 초기화할 수 있다. vararg 사용 시 주의 사항:\n하나의 생성자에 vararg 매개변수는 최대 하나만 사용할 수 있다.\nvararg 매개변수는 항상 마지막 매개변수로 와야 한다.\nvararg 매개변수는 내부적으로 배열로 처리된다.\n활용 예시:\n다양한 개수의 인자를 받는 함수: 예를 들어, 평균을 계산하는 함수를 정의할 때 vararg를 사용하면 여러 개의 숫자를 인자로 받아 처리할 수 있다.\n배열을 펼쳐서 전달: 스프레드 연산자(*)를 사용하여 배열을 펼쳐서 vararg 매개변수에 전달할 수 있다.\nin과 out 제네릭 클래스의 인스턴스는 raw 타입과 제네릭 타입이 결합된 것이 자신의 타입이 된다.\n\u003c\u003e로 나타낸 제네릭 타입 간의 부모-자식 관계가 있더라도 컴파일러가 인식하지 못한다.\n개발자 입장에서 불편함 이 불편을 해결 방법이 in과 out 이다.\nout 키워드를 지정하면, 두 제네릭 타입 간의 부모-자식 타입 관계를 ‘그대로’ 컴파일러가 고려해준다.\nList의 타입도 List로 되어 있다.\n제네릭 타입 매개변수에 out 키워드를 지정한 것을 공변형(covariance)\nin 키워드를 지정하면, 제레릭 타입 매개변수를 포함한 클래스나 인터페이스의 관계가 제네릭 타입 매개변수의 부모-자식 관계와 ‘반대’ 로 된다.\n‘동물’ 타입이 ‘사자’ 타입의 부모인 경우\n‘Pet\u003c동물\u003e 타입’이 ‘Pet\u003c사자\u003e 타입’의 자식 타입으로 간주된다.\n제네릭 타입 매개변수에 in 키워드를 지정한 것을 반공변형(contravariance)\nreified 키워드 컴파일된 JVM 바이트 코드에서는 제네릭 타입 매개변수의 정보가 수록되지 않고 소거된다.\nList, List 모두 JVM 바이트코드에는 raw 타입 List 로 처리된다. 실체화(reification): 코틀린은 이 문제를 해결하기 위해 제네릭 타입 매개변수를 컴파일러가 실제 타입으로 변경해주는 기능을 지원 제네릭 타입 매개변수의 실체화(reification) 제네릭 타입 매개변수가 지정된 클래스는 타입 검사에 사용될 수 없다.\nif (l is List) ⇒ 컴파일 에러 reified 키워드 를 사용하면 제네릭 매개변수로 전달된 인자의 타입과 인스턴스의 타입을 런타임 시에 검사할 수 있게 된다. (inline 키워드와 같이 사용)\n타입 매개변수의 실체화는 inline 키워드가 지정된 인라인 함수에서만 가능하다. 1 2 3 inline fun \u003creified T\u003e check(f1: () -\u003e T): T { // ~~~ } 확장 기존 타입(클래스 or 인터페이스)의 정의를 직접 변경하지 않고 새로운 기능을 추가해준다.\nJVM 바이트 코드는 코틀린 확장 함수가 static 메서드로 된다.\n각 타입에 대한 확장 함수나 속성을 포함하는 코틀린 표준 라이브러리 파일들은 타입 이름 끝에 s를 붙인 파일 이름을 갖는다.\nStrings.kt도 그렇고 Sequences.kt, Ranges.kt, Maps.kt 코틀린은 확장 함수를 굉장히 많이 사용하여 핵심 API를 정의하고 있다.\n표준 라이브러리의 크기가 작으면서도 많은 기능을 제공한다.\n확장을 사용하면 함수나 속성을 하나만 정의하여 여러 타입에 같은 기능을 제공할 수 있으므로 메모리 효율 상승\n확장 함수 정의하기 확장 함수를 추가할 타입을 수신자 타입 이라고 한다. 그리고 이것을 지정해야 한다.\nthis 는 확장 함수가 호출된 ‘수신자 객체’를 뜻한다.\n클래스의 자식 클래스를 만들 수 없거나, 해당 클래스의 정의를 변경할 수 없을때(외부 라이브러리), 주로 확장을 사용한다.\n제네릭 확장 함수 1 2 3 fun \u003cT\u003e T.easyPrint() : T { // } 제네릭 확장 함수인 ‘easyPrint’는 어떤 타입에도 사용 가능하며 타입 정보도 유지된다. 확장 속성 확장 속성은 backing field를 갖지 않으므로 초기화할 수 없다. var 대신 val을 지정하고, 원하는 값을 반환하는 get 을 반드시 정의해야 한다. 속성에서 반환될 값을 지정해줘야 한다. backing field에 데이터가 저장된다. 1 2 val String.numVowels get() = count { \"aeiouy\".contains(it) } infix 키워드 infix 키워드는 하나의 인자를 갖는 확장 함수와 클래스 함수에 모두 사용할 수 있다. infix(중위) 함수는 함수 호출 사이의 점(.) 과 괄호를 생략하게 해준다. 일반 함수 호출 처럼 호출도 가능 1 2 3 // 같은 함수 호출 null.printWithDefault(\"기본 문자열\") null printWithDefault \"기본 문자열\" 함수형 프로그래밍 함수형 프로그래밍은 컬렉션을 사용하도록 설계된 고차 함수가 반환하는 데이터에 의존한다.\n고차 함수의 연쇄적 호출 함수 타입의 역할 =\u003e 다른 함수를 값으로 정의해주거나, 인자로 받거나 반환하는 일급 함수을 지원 함수형 프로그램을 구성하는 함수의 유형에는 변환(transform), 필터(filter), 결합(combine) 이 있다.\n코틀린은 다중 프로그래밍 방식으로 상황에 따라, 객체지향과 함수형 프로그래밍을 혼합하여 코드를 작성 가능\n일급 함수 (First-Class Function)\n정의: 일급 함수는 다른 변수와 동일하게 다룰 수 있는 함수를 의미 변수화, 매개변수화, 반환 값으로 사용가능 val func: (Int) -\u003e Int = { it * 2 } 람다(익명 함수, 이름 없는 함수) 형태를 띔 고차 함수 (Higher-Order Function)\n정의: 고차 함수는 ‘일급 함수’를 인자로 받거나 반환하는 함수를 의미 val doubled = numbers.map { it * 2 } // map은 고차 함수 변환 (transform) 변환 함수는 입력 컬렉션에 저장된 모든 요소를 읽는다.\n지정 변환 함수를 실행하여 컬렉션의 각 요소나 항목을 변환한 후, 변경된 ‘새로운 컬렉션’을 반환한다.\n입력 컬렉션은 변경되지 않는다. 임시로 새로운 객체 생성 후, 다음 연쇄 호출된 함수로 넘김 map, flatMap\n제네릭 타입 매개변수를 사용함으로 인자의 타입과 반환 타입을 다르게 처리할 수 있다. Iterable.map(transform: (T) -\u003e R): List\nflatMap 함수는 인자로 전달된 변환 함수의 결과로 산출된 모든 요소를 하나의 컬렉션으로 생성하여 반환한다.\nlistOf( listOf(1,2,3), listOf(4,5,6) ).flatMap { it } // [1,2,3,4,5,6] 필터 (filter) 필터 함수는 컬렉션의 각 요소를 검사하고, true or false를 반환하는 술어 함수를 인자로 받는다.\nfilter 하나\ntrue를 반환하는 요소만 결과 컬렉션에 해당 요소가 추가 된다.\n결합 (combine) 서로 다른 컬렉션 인자로 받아서 모든 요소들이 합쳐진 새로운 컬렉션을 생성한다\nzip, fold\nfold : 최초 누적값을 인자로 받으며, 이 값은 각 요소에 대해 호출되는 익명 함수의 결과값으로 변경된다.\n왜 함수형 프로그래밍일까? 처리 중간에 값을 축적하는 변수들이 내부적으로 정의되므로, 상태를 보존하는 변수들을 줄일 수 있다.\n자동으로 축적 변수에 추가되므로, 코드 에러 발생 위험이 줄어든다.\nSide Effect 제거, 불변성 증가, 테스트 용이성 향상 새로운 연산이 필요하면, 함수의 연쇄 호출에 추가하면 된다.\n시퀀스 (sequence) 컬렉션 타입들은 eager collection( 조기 컬렉션 ) 이라고 한다.\n인스턴스가 생성될 때는 자신이 포함하는 요소나 항목이 추가되므로 바로 사용될 수 있기 때문이다. 지연 컬렉션(lazy collection)라는 내장된 타입 : sequence, 필요할 때만 값이 생성된다.\n시퀀스를 사용할 때는 새로운 값이 요청될 때마다 참조되는 반복자 함수를 정의한다.\n함수형 프로그래밍에는 보통, 새로운 컬렉션을 자주 생성해야 한다.\n그러나 시퀀스를 사용하면 대형 컬렉션에 사용할 수 있는 매커니즘을 제공한다.\n시퀀스로 검사할 항목개수의 상한값을 정의할 필요가 없기 때문이다. 1 2 3 val oneThousandPrimes = generatesequence(3) { value -\u003e value + 1 }.filter { it.isPrime() }.take(1000) 그러나 수십만 개의 요소를 가질 정도로 컬렉션이 커지면 컬렉션 타입을 변경하는 데따른 성능 향상이 중요해질 수 있다.\n이 경우에는 asSequence 함수를 사용해서 List를 시퀀스로 쉽게 변환할 수 있다. ","wordCount":"1642","inLanguage":"en","image":"https://2taezeat.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E","datePublished":"2023-12-05T11:30:03Z","dateModified":"2023-12-05T11:30:03Z","author":{"@type":"Person","name":"2taezeat"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://2taezeat.github.io/posts/dev/kotlin-%EC%A0%95%EB%A6%AC-2/"},"publisher":{"@type":"Organization","name":"2taezeat, blog","logo":{"@type":"ImageObject","url":"https://2taezeat.github.io/icon/favicon.ico"}}}</script></head><body id=top><header class=header><nav class=nav><div class=logo><a href=https://2taezeat.github.io/ accesskey=h title="2taezeat blog (Alt + H)"><img src=https://2taezeat.github.io/icon/apple-touch-icon.png alt aria-label=logo height=30>2taezeat blog</a><div class=logo-switches></div></div><ul id=menu><li><a href=https://2taezeat.github.io/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://2taezeat.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://2taezeat.github.io/searchs/ title=Search><span>Search</span></a></li><li><a href=https://github.com/2taezeat title=Github><span>Github</span>&nbsp;<svg fill="none" shape-rendering="geometricPrecision" stroke="currentcolor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2.5" viewBox="0 0 24 24" height="12" width="12"><path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"/><path d="M15 3h6v6"/><path d="M10 14 21 3"/></svg></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://2taezeat.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://2taezeat.github.io/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">Kotlin 정리 (2)</h1><div class=post-description>Kotlin 정리 (2)</div><div class=post-meta><span title='2023-12-05 11:30:03 +0000 +0000'>2023-12-05</span>&nbsp;·&nbsp;8 min&nbsp;·&nbsp;1642 words&nbsp;·&nbsp;2taezeat</div></header><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#kotlin-다시-보기-2>Kotlin 다시 보기 (2)</a></li><li><a href=#인터페이스와-추상-클래스>인터페이스와 추상 클래스</a><ul><li><a href=#인터페이스-구현하기>인터페이스 구현하기</a></li><li><a href=#samsingle-abstract-method-인터페이스>SAM(single abstract method) 인터페이스</a><ul><li><a href=#sam-변환>SAM 변환</a></li><li><a href=#sam-주의-사항>SAM 주의 사항</a></li></ul></li><li><a href=#추상-클래스>추상 클래스</a></li></ul></li><li><a href=#제네릭>제네릭</a><ul><li><a href=#제네릭-타입-정의하기>제네릭 타입 정의하기</a></li><li><a href=#제네릭-타입-제약>제네릭 타입 제약</a></li><li><a href=#vararg>vararg</a></li><li><a href=#in과-out>in과 out</a></li><li><a href=#reified-키워드>reified 키워드</a></li></ul></li><li><a href=#확장>확장</a><ul><li><a href=#확장-함수-정의하기>확장 함수 정의하기</a></li><li><a href=#제네릭-확장-함수>제네릭 확장 함수</a></li><li><a href=#확장-속성>확장 속성</a></li><li><a href=#infix-키워드>infix 키워드</a></li></ul></li><li><a href=#함수형-프로그래밍>함수형 프로그래밍</a><ul><li><a href=#변환-transform>변환 (transform)</a></li><li><a href=#필터-filter>필터 (filter)</a></li><li><a href=#결합-combine>결합 (combine)</a></li><li><a href=#왜-함수형-프로그래밍일까>왜 함수형 프로그래밍일까?</a></li><li><a href=#시퀀스-sequence>시퀀스 (sequence)</a></li></ul></li></ul></nav></div></details></div><div class=post-content><h1 id=kotlin-다시-보기-2>Kotlin 다시 보기 (2)<a hidden class=anchor aria-hidden=true href=#kotlin-다시-보기-2>#</a></h1><p><em>‘빅 너드 랜치의 코틀린 프로그래밍’</em> 을 읽고 정리</p><h1 id=인터페이스와-추상-클래스>인터페이스와 추상 클래스<a hidden class=anchor aria-hidden=true href=#인터페이스와-추상-클래스>#</a></h1><ul><li><p><strong>abstact 함수(추상 함수)</strong> : <strong>함수의 헤더만 선언</strong>하고 몸체(Body)의 구현 코드가 없는 함수</p></li><li><p>객체간의 <strong>상속 관계가 없으</strong>면서, 주로 공통적인 속성이나 행동을 갖는 경우 : <strong>인터페이스</strong></p></li><li><p>객체간의 <strong>상속 관계가 있으</strong>면서, 주로 인스턴스 생성이 필요 없는 부모 클래스가 필요한 경우 : <strong>추상 클래스</strong></p></li></ul><h2 id=인터페이스-구현하기>인터페이스 구현하기<a hidden class=anchor aria-hidden=true href=#인터페이스-구현하기>#</a></h2><ul><li><p>인터페이스는 무엇을 해야 하는지 정의한 것이므로, <strong>클래스로 구현(implement)</strong> 해야 한다.</p></li><li><p>해당 인터페이스를 구현하는 클래스를 정의(구현)한 후에 이 클래스에서 인터페이스에 명시된 속성과 함수의 구현 코드를 제공하게 한다.</p></li><li><p>인터페이스의 속성과 함수는 open 키워드를 지정하지 않아도 된다.</p></li><li><p>인터페이스는 how가 아닌 what을 정의한다.</p><ul><li>how는 <strong>인터페이스의 구현 클래스</strong>에서 정의</li></ul></li><li><p>인터페이스 타입의 매개변수를 가지므로 이 인터페이스를 구현하는 어떤 클래스의 인스턴스도 인자로 받을 수 있다</p></li><li><p>인터페이스에 정의된 <strong>속성에 기본으로 구현된 getter</strong>와 함수에도 기본으로 구현된 몸체 코드를 제공할 수 있다.</p><ul><li><code>damageRoll</code>의 속성의 값을 지정하지 않을 경우 기본으로 구현된 getter에서 값이 지정됨</li></ul></li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span><span class=lnt>9
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-kotlin data-lang=kotlin><span class=line><span class=cl><span class=k>interface</span> <span class=nc>Fightable</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>var</span> <span class=py>healthPoints</span><span class=p>:</span> <span class=n>Int</span>
</span></span><span class=line><span class=cl>	<span class=k>val</span> <span class=py>damageRoll</span><span class=p>:</span> <span class=n>Int</span>
</span></span><span class=line><span class=cl>		<span class=k>get</span><span class=p>()</span> <span class=p>=</span> <span class=p>(</span><span class=n>O</span> <span class=n>until</span> <span class=n>dicecount</span><span class=p>).</span><span class=n>map</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=n>Random</span><span class=p>().</span><span class=n>nextInt</span><span class=p>(</span><span class=n>diceSides</span><span class=p>)</span> <span class=p>+</span> <span class=m>1</span>
</span></span><span class=line><span class=cl>    <span class=p>}.</span><span class=n>sum</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>fun</span> <span class=nf>attack</span><span class=p>(</span><span class=n>opponent</span><span class=p>:</span> <span class=n>Fightable</span><span class=p>):</span> <span class=n>Int</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><h2 id=samsingle-abstract-method-인터페이스>SAM(single abstract method) 인터페이스<a hidden class=anchor aria-hidden=true href=#samsingle-abstract-method-인터페이스>#</a></h2><ul><li><p>하나의 추상 메서드만 갖는 인터페이스 (<strong>코틀린이랑 상관없음</strong>)</p><ul><li><p>인터페이스 임으로, 하나의 <strong>타입</strong>이 된다 (컴파일러가 자동 타입 추론 및 에러 검출)</p></li><li><p><strong>함수형 인터페이스</strong> 라고도 불린다.</p></li><li><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>public</span><span class=w> </span><span class=kd>interface</span> <span class=nc>OnClickListener</span><span class=w> </span><span class=p>{</span><span class=w> </span><span class=c1>// 대표적 예, Java 코드</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kt>void</span><span class=w> </span><span class=nf>onClick</span><span class=p>(</span><span class=n>View</span><span class=w> </span><span class=n>v</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div></li></ul></li></ul><h3 id=sam-변환>SAM 변환<a hidden class=anchor aria-hidden=true href=#sam-변환>#</a></h3><ul><li><strong>자바 8 이전</strong>에는 함수형 인터페이스를 인자로 받는 Java 함수를 호출할 경우, <strong>인터페이스를 구현한 익명 클래스 인스턴스</strong>를 만들어서 넘겨줘야 했다.</li><li><strong>자바 8 이후와 코틀린</strong>에서 인터페이스를 인자로 받는 Java 메서드를 호출 할 경우, <strong>객체(object) 대신 람다</strong>를 넘길 수 있다. 이를 <strong>SAM 변환</strong>이라고 한다.</li></ul><h3 id=sam-주의-사항>SAM 주의 사항<a hidden class=anchor aria-hidden=true href=#sam-주의-사항>#</a></h3><ul><li><strong>SAM 변환</strong>은 자바에서 작성한 인터페이스일 때만 동작</li><li>코틀린에서 하나의 추상 메소드만 있는 인터페이스를 생성하고, 그 인터페이스를 인자로 받는 함수에 람다를 넘기려고 하면 오류가 발생<ul><li>이유는 코틀린에서는 함수를 파라미터로 사용할 수 있기 때문이다.</li><li>만약 코틀린에서 SAM 변환을 사용하고 싶다면, <strong>인터페이스 앞에 fun 키워드</strong>를 붙여주면 된다.</li></ul></li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-kotlin data-lang=kotlin><span class=line><span class=cl><span class=k>fun</span> <span class=nf>interface</span> <span class=n>Practice</span><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>fun</span> <span class=nf>a</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>}</span> 
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>fun</span> <span class=nf>main</span><span class=p>(){</span>
</span></span><span class=line><span class=cl>    <span class=n>doSomething</span><span class=p>{</span> <span class=n>println</span><span class=p>(</span><span class=s2>&#34;a&#34;</span><span class=p>)</span> <span class=p>}</span> 	<span class=c1>// 방법 1
</span></span></span><span class=line><span class=cl><span class=c1></span>    
</span></span><span class=line><span class=cl>    <span class=k>val</span> <span class=py>practice</span> <span class=p>=</span> <span class=n>Practice</span><span class=p>{</span> <span class=n>println</span><span class=p>(</span><span class=s2>&#34;a&#34;</span><span class=p>)</span> <span class=p>}</span>   <span class=c1>// 방법 2
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>doSomething</span><span class=p>(</span><span class=n>practice</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>fun</span> <span class=nf>doSomething</span><span class=p>(</span><span class=n>practice</span><span class=p>:</span> <span class=n>Practice</span><span class=p>){</span>
</span></span><span class=line><span class=cl>    <span class=n>practice</span><span class=p>.</span><span class=n>a</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><h2 id=추상-클래스>추상 클래스<a hidden class=anchor aria-hidden=true href=#추상-클래스>#</a></h2><ul><li><p><strong>인터페이스</strong>와 비슷하게 <strong>추상 함수와 속성</strong>을 갖는다.</p></li><li><p><strong>구현 코드가 있는 일반 함수</strong>도 가질 수 있다.</p></li><li><p>서브 클래스에서 추상 클래스의 속성과 함수를 <strong>상속</strong>받아 구현하도록 하는 것이 <strong>추상 클래스의 주 목적</strong>이다.</p></li><li><p>추상 클래스는 주로 부모 클래스를 정의할 때 사용된다. (상속)</p></li><li><p>인터페이스에 정의된 함수는 기본적으로 추상 함수지만, 추상 클래스에 정의되는 추상 함수에는 <code>abstract 키워드</code>를 지정해야 한다.</p></li><li><p>일반 클래스는 <strong>하나의 추상 클래스만 부모 클래스</strong>로 가질 수 있지만, <strong>인터페이스는 여러 개 구현 가능</strong>하다.</p></li></ul><h1 id=제네릭>제네릭<a hidden class=anchor aria-hidden=true href=#제네릭>#</a></h1><p><img loading=lazy src=/images/before/image-20240517160018761.png alt=image-20240517160018761.png width=680 height=auto></p><ul><li><p><strong>제네릭</strong>: 타입을 미리 확정하지 않고, <strong>사용되는 시점에서 특정 타입을 지정</strong>할 수 있도록 해주는 기법</p></li><li><p>동일한 인터페이스 및 클래스, 함수의 정의를 재사용할 수 있어서 <strong>코드의 중복을 줄여</strong>준다.</p></li><li><p>컴파일 시점에서 사용 타입의 적합성을 확인할 수 있으므로, 타입 안전을 보장해 준다. (<strong>타입 추론 가능</strong>)</p></li><li><p>List 는 ‘<strong>제네릭 인터페이스</strong>’로 정의 되었다.</p><ul><li>여기서 &lsquo;List&rsquo; 는 <strong>raw 타입</strong></li><li>&lt;> 안에 지정된 타입을 <strong>제네릭 타입(generic type)</strong> 이라고 한다.</li><li><code>List&lt;out E></code></li></ul></li><li><p><strong>제네릭 클래스의 인스턴스의 타입</strong>은 <strong>raw 타입</strong>과 <strong>제네릭 타입</strong>이 결합된 타입이 된다. ( 하나의 <code>List&lt;Int></code> 타입 )</p></li></ul><h2 id=제네릭-타입-정의하기>제네릭 타입 정의하기<a hidden class=anchor aria-hidden=true href=#제네릭-타입-정의하기>#</a></h2><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-kotlin data-lang=kotlin><span class=line><span class=cl><span class=k>class</span> <span class=nc>LootBox</span><span class=p>&lt;</span><span class=n>T</span><span class=p>&gt;(</span><span class=n>item</span><span class=p>:</span> <span class=n>T</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>private</span> <span class=k>var</span> <span class=py>loot</span><span class=p>:</span> <span class=n>T</span> <span class=p>=</span> <span class=n>item</span>
</span></span><span class=line><span class=cl>    <span class=k>var</span> <span class=py>tmp</span> <span class=p>=</span> <span class=k>false</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>fun</span> <span class=nf>fetch</span><span class=p>():</span> <span class=n>T</span><span class=p>?</span> <span class=p>{</span> <span class=c1>// 제네릭 함수
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=k>return</span> <span class=n>loot</span><span class=p>.</span><span class=n>takeIf</span> <span class=p>{</span> <span class=n>tmp</span> <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>fun</span> <span class=p>&lt;</span><span class=nc>R</span><span class=p>&gt;</span> <span class=nf>fetch</span><span class=p>(</span> <span class=n>lootModFunction</span><span class=p>:</span> <span class=p>(</span><span class=n>T</span><span class=p>)</span> <span class=o>-&gt;</span> <span class=n>R</span> <span class=p>):</span> <span class=n>R</span><span class=p>?</span> <span class=p>{</span> <span class=c1>// 복합 제네릭 타입 함수
</span></span></span><span class=line><span class=cl><span class=c1></span>         <span class=k>return</span> <span class=n>loot</span><span class=p>.</span><span class=n>takeIf</span> <span class=p>{</span> <span class=n>tmp</span> <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><ul><li><p>제네릭 타입 매개변수 : T / &lt; >안에 지정됨</p></li><li><p>보통 return 타입 매개 변수는 ‘R’로 표현</p></li><li><p><code>(T) -> R</code> => <strong>함수 타입</strong></p></li></ul><h2 id=제네릭-타입-제약>제네릭 타입 제약<a hidden class=anchor aria-hidden=true href=#제네릭-타입-제약>#</a></h2><ul><li>제네릭 타입 <code>T</code>에<code>: Loot</code>를 지정하면, Loot 클래스 및 이것의 서브 클래스만 LootBox 클래스의 매개변수 타입으로 사용될 수 있다.</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-kotlin data-lang=kotlin><span class=line><span class=cl><span class=k>class</span> <span class=nc>LootBox</span><span class=p>&lt;</span><span class=n>T</span><span class=p>:</span> <span class=n>Loot</span><span class=p>&gt;(</span><span class=n>itme</span><span class=p>:</span> <span class=n>T</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><h2 id=vararg>vararg<a hidden class=anchor aria-hidden=true href=#vararg>#</a></h2><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-kotlin data-lang=kotlin><span class=line><span class=cl><span class=k>class</span> <span class=nc>LootBox</span><span class=p>&lt;</span><span class=n>T</span><span class=p>:</span> <span class=n>Loot</span><span class=p>&gt;(</span><span class=k>vararg</span> <span class=n>itme</span><span class=p>:</span> <span class=n>T</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><ul><li><code>vararg 키워드</code>를 추가하면 <strong>매개변수가 배열(Array)</strong> 로 처리되므로 <strong>여러 개의 아이템을 인자로 전달</strong>할 수 있다.<ul><li>코틀린에서 <strong>기본 타입</strong>이 아닌 <strong>Arrays 라는 참조 타입</strong>으로 <strong>배열</strong>을 지원한다. (코틀린은 모두 참조 타입)<ul><li>여기서 배열은 <strong>컬렉션 타입</strong>이다.</li></ul></li></ul></li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-kotlin data-lang=kotlin><span class=line><span class=cl><span class=k>class</span> <span class=nc>MyDataClass</span> <span class=k>constructor</span><span class=p>(</span><span class=k>vararg</span> <span class=k>val</span> <span class=py>numbers</span><span class=p>:</span> <span class=n>Int</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// ...
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>val</span> <span class=py>myData1</span> <span class=p>=</span> <span class=n>MyDataClass</span><span class=p>(</span><span class=m>1</span><span class=p>,</span> <span class=m>2</span><span class=p>,</span> <span class=m>3</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=k>val</span> <span class=py>myData2</span> <span class=p>=</span> <span class=n>MyDataClass</span><span class=p>()</span> <span class=c1>// 빈 배열 전달 가능
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>val</span> <span class=py>myData3</span> <span class=p>=</span> <span class=n>MyDataClass</span><span class=p>(</span><span class=m>4</span><span class=p>,</span> <span class=m>5</span><span class=p>)</span> 
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>val</span> <span class=py>numbers</span> <span class=p>=</span> <span class=n>intArrayOf</span><span class=p>(</span><span class=m>1</span><span class=p>,</span> <span class=m>2</span><span class=p>,</span> <span class=m>3</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=k>val</span> <span class=py>myData</span> <span class=p>=</span> <span class=n>MyDataClass</span><span class=p>(*</span><span class=n>numbers</span><span class=p>)</span> <span class=c1>// 배열을 펼쳐서 전달
</span></span></span></code></pre></td></tr></table></div></div><ul><li><p><strong>기본 생성자에서의 <code>vararg</code></strong></p><ul><li>코틀린의 기본 생성자에서 <code>vararg</code>를 사용하면, 생성자에 가변적인 개수의 인자를 전달하여 객체를 초기화할 수 있다.</li></ul></li><li><p><strong><code>vararg</code> 사용 시 주의 사항:</strong></p><ul><li><p>하나의 생성자에 <code>vararg</code> 매개변수는 <strong>최대 하나만</strong> 사용할 수 있다.</p></li><li><p><code>vararg</code> 매개변수는 <strong>항상 마지막 매개변수</strong>로 와야 한다.</p></li><li><p><code>vararg</code> 매개변수는 내부적으로 <strong>배열</strong>로 처리된다.</p></li></ul></li><li><p><strong>활용 예시:</strong></p><ul><li><p><strong>다양한 개수의 인자를 받는 함수:</strong> 예를 들어, 평균을 계산하는 함수를 정의할 때 <code>vararg</code>를 사용하면 여러 개의 숫자를 인자로 받아 처리할 수 있다.</p></li><li><p><strong>배열을 펼쳐서 전달:</strong> 스프레드 연산자(<code>*</code>)를 사용하여 배열을 펼쳐서 <code>vararg</code> 매개변수에 전달할 수 있다.</p></li></ul></li></ul><h2 id=in과-out>in과 out<a hidden class=anchor aria-hidden=true href=#in과-out>#</a></h2><ul><li><p>제네릭 클래스의 인스턴스는 <strong>raw 타입과 제네릭 타입</strong>이 결합된 것이 자신의 타입이 된다.</p><ul><li><p><strong>&lt;>로 나타낸 제네릭 타입 간의 부모-자식 관계가 있더라도 컴파일러가 인식하지 못한다.</strong></p><ul><li>개발자 입장에서 불편함</li></ul></li><li><p>이 불편을 해결 방법이 in과 out 이다.</p></li></ul></li><li><p><code>out 키워드</code>를 지정하면, 두 제네릭 타입 간의 <strong>부모-자식 타입 관계를 ‘그대로’ 컴파일러가 고려</strong>해준다.</p><ul><li><p>List의 타입도 <code>List&lt;out E></code>로 되어 있다.</p></li><li><p><strong>제네릭 타입 매개변수</strong>에 <code>out 키워드</code>를 지정한 것을 <code>공변형(covariance)</code></p></li></ul></li><li><p><code>in 키워드</code>를 지정하면, 제레릭 타입 매개변수를 포함한 클래스나 인터페이스의 관계가 <strong>제네릭 타입 매개변수</strong>의 <strong>부모-자식 관계와 ‘반대’</strong> 로 된다.</p><ul><li><p>‘동물’ 타입이 ‘사자’ 타입의 부모인 경우</p></li><li><p>‘Pet&lt;동물> 타입’이 ‘Pet&lt;사자> 타입’의 <code>자식 타입</code>으로 간주된다.</p></li><li><p><code>제네릭 타입 매개변수</code>에 in 키워드를 지정한 것을 <code>반공변형(contravariance)</code></p></li></ul></li></ul><h2 id=reified-키워드>reified 키워드<a hidden class=anchor aria-hidden=true href=#reified-키워드>#</a></h2><ul><li><p>컴파일된 JVM 바이트 코드에서는 <strong>제네릭 타입 매개변수의 정보</strong>가 수록되지 않고 소거된다.</p><ul><li><code>List&lt;Int></code>, <code>List&lt;Double></code> 모두 JVM 바이트코드에는 <code>raw 타입 List</code> 로 처리된다.</li><li><strong>실체화(reification):</strong> 코틀린은 이 문제를 해결하기 위해 제네릭 타입 매개변수를 컴파일러가 실제 타입으로 변경해주는 기능을 지원<ul><li>제네릭 타입 매개변수의 실체화(reification)</li></ul></li></ul></li><li><p>제네릭 타입 매개변수가 지정된 클래스는 타입 검사에 사용될 수 없다.</p><ul><li><code>if (l is List&lt;String>)</code> ⇒ 컴파일 에러</li></ul></li><li><p><code>reified 키워드</code> 를 사용하면 제네릭 매개변수로 전달된 인자의 타입과 인스턴스의 타입을 런타임 시에 검사할 수 있게 된다. (inline 키워드와 같이 사용)</p><ul><li>타입 매개변수의 실체화는 inline 키워드가 지정된 <strong>인라인 함수</strong>에서만 가능하다.</li></ul></li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-kotlin data-lang=kotlin><span class=line><span class=cl><span class=k>inline</span> <span class=k>fun</span> <span class=p>&lt;</span><span class=k>reified</span> <span class=nc>T</span><span class=p>&gt;</span> <span class=nf>check</span><span class=p>(</span><span class=n>f1</span><span class=p>:</span> <span class=p>()</span> <span class=o>-&gt;</span> <span class=n>T</span><span class=p>):</span> <span class=n>T</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=c1>// ~~~
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><h1 id=확장>확장<a hidden class=anchor aria-hidden=true href=#확장>#</a></h1><ul><li><p><strong>기존 타입(클래스 or 인터페이스)의 정의를 직접 변경하지 않고 새로운 기능을 추가해준다.</strong></p></li><li><p>JVM 바이트 코드는 코틀린 확장 함수가 <code>static</code> 메서드로 된다.</p></li><li><p>각 타입에 대한 확장 함수나 속성을 포함하는 <strong>코틀린 표준 라이브러리</strong> 파일들은 타입 이름 끝에 s를 붙인 파일 이름을 갖는다.</p><ul><li><code>Strings.kt도 그렇고 Sequences.kt, Ranges.kt, Maps.kt</code></li></ul></li><li><p>코틀린은 확장 함수를 굉장히 많이 사용하여 핵심 API를 정의하고 있다.</p></li><li><p>표준 라이브러리의 크기가 작으면서도 많은 기능을 제공한다.</p></li><li><p><strong>확장</strong>을 사용하면 <strong>함수나 속성을 하나만 정의</strong>하여 <strong>여러 타입에 같은 기능을 제공</strong>할 수 있으므로 <strong>메모리 효율 상승</strong></p></li></ul><h2 id=확장-함수-정의하기>확장 함수 정의하기<a hidden class=anchor aria-hidden=true href=#확장-함수-정의하기>#</a></h2><ul><li><p>확장 함수를 추가할 타입을 <code>수신자 타입</code> 이라고 한다. 그리고 이것을 지정해야 한다.</p></li><li><p><code>this</code> 는 확장 함수가 호출된 ‘<strong>수신자 객체</strong>’를 뜻한다.</p></li><li><p>클래스의 자식 클래스를 만들 수 없거나, 해당 클래스의 정의를 변경할 수 없을때(외부 라이브러리), 주로 <strong>확장</strong>을 사용한다.</p></li></ul><h2 id=제네릭-확장-함수>제네릭 확장 함수<a hidden class=anchor aria-hidden=true href=#제네릭-확장-함수>#</a></h2><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-kotlin data-lang=kotlin><span class=line><span class=cl><span class=k>fun</span> <span class=p>&lt;</span><span class=nc>T</span><span class=p>&gt;</span> <span class=nf>T</span><span class=p>.</span><span class=n>easyPrint</span><span class=p>()</span> <span class=p>:</span> <span class=n>T</span> <span class=p>{</span>
</span></span><span class=line><span class=cl> <span class=c1>//
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><ul><li>제네릭 확장 함수인 ‘easyPrint’는 어떤 타입에도 사용 가능하며 타입 정보도 유지된다.</li></ul><h2 id=확장-속성>확장 속성<a hidden class=anchor aria-hidden=true href=#확장-속성>#</a></h2><ul><li>확장 <strong>속성</strong>은 backing field를 갖지 않으므로 <strong>초기화할 수 없다.</strong><ul><li>var 대신 val을 지정하고, 원하는 값을 반환하는 <code>get</code> 을 반드시 정의해야 한다.</li><li>속성에서 <strong>반환될 값을 지정</strong>해줘야 한다.</li><li>backing field에 데이터가 저장된다.</li></ul></li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-kotlin data-lang=kotlin><span class=line><span class=cl><span class=k>val</span> <span class=py>String</span><span class=p>.</span><span class=n>numVowels</span>
</span></span><span class=line><span class=cl>    <span class=k>get</span><span class=p>()</span> <span class=p>=</span> <span class=n>count</span> <span class=p>{</span> <span class=s2>&#34;aeiouy&#34;</span><span class=p>.</span><span class=n>contains</span><span class=p>(</span><span class=k>it</span><span class=p>)</span> <span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><h2 id=infix-키워드>infix 키워드<a hidden class=anchor aria-hidden=true href=#infix-키워드>#</a></h2><ul><li><code>infix 키워드</code>는 <strong>하나의 인자를 갖는 확장 함수와 클래스 함수</strong>에 모두 사용할 수 있다.</li><li><strong>infix(중위) 함수</strong>는 함수 호출 사이의 <code>점(.) 과 괄호</code>를 생략하게 해준다. 일반 함수 호출 처럼 호출도 가능</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-kotlin data-lang=kotlin><span class=line><span class=cl><span class=c1>// 같은 함수 호출
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>null</span><span class=p>.</span><span class=n>printWithDefault</span><span class=p>(</span><span class=s2>&#34;기본 문자열&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=k>null</span> <span class=n>printWithDefault</span> <span class=s2>&#34;기본 문자열&#34;</span>
</span></span></code></pre></td></tr></table></div></div><h1 id=함수형-프로그래밍>함수형 프로그래밍<a hidden class=anchor aria-hidden=true href=#함수형-프로그래밍>#</a></h1><ul><li><p>함수형 프로그래밍은 컬렉션을 사용하도록 설계된 <strong>고차 함수가 반환하는 데이터에 의존</strong>한다.</p><ul><li>고차 함수의 연쇄적 호출</li><li>함수 타입의 역할 => 다른 함수를 값으로 정의해주거나, 인자로 받거나 반환하는 <strong>일급 함수</strong>을 지원</li></ul></li><li><p>함수형 프로그램을 구성하는 함수의 유형에는 <strong>변환(transform), 필터(filter), 결합(combine)</strong> 이 있다.</p></li><li><p>코틀린은 <strong>다중 프로그래밍 방식</strong>으로 상황에 따라, <strong>객체지향과 함수형 프로그래밍을 혼합</strong>하여 코드를 작성 가능</p></li><li><p><strong>일급 함수 (First-Class Function)</strong></p><ul><li><strong>정의:</strong> 일급 함수는 <strong>다른 변수와 동일하게</strong> 다룰 수 있는 함수를 의미<ul><li><strong>변수화, 매개변수화, 반환 값</strong>으로 사용가능</li></ul></li><li><code>val func: (Int) -> Int = { it * 2 }</code></li><li><strong><code>람다(익명 함수, 이름 없는 함수)</code></strong> 형태를 띔</li></ul></li><li><p><strong>고차 함수 (Higher-Order Function)</strong></p><ul><li><strong>정의:</strong> <strong>고차 함수</strong>는 &lsquo;일급 함수&rsquo;를 <strong>인자로 받거나 반환</strong>하는 함수를 의미</li><li><code>val doubled = numbers.map { it * 2 } // map은 고차 함수</code></li></ul></li></ul><h2 id=변환-transform>변환 (transform)<a hidden class=anchor aria-hidden=true href=#변환-transform>#</a></h2><ul><li><p>변환 함수는 입력 컬렉션에 저장된 모든 요소를 읽는다.</p></li><li><p>지정 변환 함수를 실행하여 컬렉션의 각 요소나 항목을 변환한 후, <strong>변경된 ‘새로운 컬렉션’을 반환한다.</strong></p><ul><li><strong>입력 컬렉션은 변경되지 않는다.</strong></li><li><strong>임시로 새로운 객체 생성 후, 다음 연쇄 호출된 함수로 넘김</strong></li></ul></li><li><p><code>map, flatMap</code></p><ul><li><strong>제네릭 타입 매개변수</strong>를 사용함으로 <strong>인자의 타입과 반환 타입을 다르게 처리</strong>할 수 있다.</li></ul></li><li><p><code>&lt;T, R> Iterable&lt;T>.map(transform: (T) -> R): List&lt;R></code></p></li><li><p><code>flatMap</code> 함수는 인자로 전달된 변환 함수의 결과로 산출된 모든 요소를 하나의 컬렉션으로 생성하여 반환한다.</p><ul><li><code>listOf( listOf(1,2,3), listOf(4,5,6) ).flatMap { it } // [1,2,3,4,5,6]</code></li></ul></li></ul><h2 id=필터-filter>필터 (filter)<a hidden class=anchor aria-hidden=true href=#필터-filter>#</a></h2><ul><li><p>필터 함수는 컬렉션의 각 요소를 검사하고, <strong>true or false를 반환하는</strong> <code>술어 함수</code>를 인자로 받는다.</p></li><li><p>filter 하나</p></li><li><p>true를 반환하는 요소만 결과 컬렉션에 해당 요소가 추가 된다.</p></li></ul><h2 id=결합-combine>결합 (combine)<a hidden class=anchor aria-hidden=true href=#결합-combine>#</a></h2><ul><li><p>서로 다른 컬렉션 인자로 받아서 모든 요소들이 합쳐진 <strong>새로운 컬렉션을 생성</strong>한다</p></li><li><p>zip, fold</p></li><li><p>fold : 최초 누적값을 인자로 받으며, 이 값은 각 요소에 대해 호출되는 익명 함수의 결과값으로 변경된다.</p></li></ul><h2 id=왜-함수형-프로그래밍일까>왜 함수형 프로그래밍일까?<a hidden class=anchor aria-hidden=true href=#왜-함수형-프로그래밍일까>#</a></h2><ul><li><p>처리 중간에 값을 축적하는 변수들이 내부적으로 정의되므로, <strong>상태를 보존하는 변수들을 줄일 수 있다.</strong></p></li><li><p>자동으로 축적 변수에 추가되므로, 코드 에러 발생 위험이 줄어든다.</p><ul><li>Side Effect 제거, 불변성 증가, 테스트 용이성 향상</li></ul></li><li><p>새로운 연산이 필요하면, <strong>함수의 연쇄 호출에 추가</strong>하면 된다.</p></li></ul><h2 id=시퀀스-sequence>시퀀스 (sequence)<a hidden class=anchor aria-hidden=true href=#시퀀스-sequence>#</a></h2><ul><li><p>컬렉션 타입들은 <strong>eager collection( 조기 컬렉션 )</strong> 이라고 한다.</p><ul><li>인스턴스가 생성될 때는 자신이 포함하는 요소나 항목이 추가되므로 <strong>바로 사용</strong>될 수 있기 때문이다.</li></ul></li><li><p><strong>지연 컬렉션(lazy collection)라는 내장된 타입 : <code>sequence</code>, 필요할 때만 값이 생성된다.</strong></p></li><li><p><strong>시퀀스</strong>를 사용할 때는 새로운 값이 요청될 때마다 <strong>참조되는 반복자 함수를 정의</strong>한다.</p></li><li><p>함수형 프로그래밍에는 보통, <strong>새로운 컬렉션을 자주 생성</strong>해야 한다.</p></li><li><p>그러나 <strong>시퀀스</strong>를 사용하면 대형 컬렉션에 사용할 수 있는 매커니즘을 제공한다.</p><ul><li>시퀀스로 검사할 항목개수의 상한값을 정의할 필요가 없기 때문이다.</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-kotlin data-lang=kotlin><span class=line><span class=cl><span class=k>val</span> <span class=py>oneThousandPrimes</span> <span class=p>=</span> <span class=n>generatesequence</span><span class=p>(</span><span class=m>3</span><span class=p>)</span> <span class=p>{</span> <span class=k>value</span> <span class=o>-&gt;</span>
</span></span><span class=line><span class=cl>	<span class=k>value</span> <span class=p>+</span> <span class=m>1</span>
</span></span><span class=line><span class=cl><span class=p>}.</span><span class=n>filter</span> <span class=p>{</span> <span class=k>it</span><span class=p>.</span><span class=n>isPrime</span><span class=p>()</span> <span class=p>}.</span><span class=n>take</span><span class=p>(</span><span class=m>1000</span><span class=p>)</span>
</span></span></code></pre></td></tr></table></div></div></li><li><p>그러나 수십만 개의 요소를 가질 정도로 컬렉션이 커지면 <strong>컬렉션 타입</strong>을 변경하는 데따른 성능 향상이 중요해질 수 있다.</p><ul><li>이 경우에는 <code>asSequence 함수</code>를 사용해서 <strong>List를 시퀀스로 쉽게 변환</strong>할 수 있다.</li></ul></li></ul></div><footer class=post-footer><ul class=post-tags><li><a href=https://2taezeat.github.io/tags/kotlin/>Kotlin</a></li></ul><nav class=paginav><a class=prev href=https://2taezeat.github.io/posts/dev/kotlin-%EC%A0%95%EB%A6%AC-3/><span class=title>« Prev</span><br><span>Kotlin 정리 (3)</span>
</a><a class=next href=https://2taezeat.github.io/posts/dev/kotlin-%EC%A0%95%EB%A6%AC-1/><span class=title>Next »</span><br><span>Kotlin 정리 (1)</span></a></nav><ul class=share-buttons><li><a target=_blank rel="noopener noreferrer" aria-label="share Kotlin 정리 (2) on x" href="https://x.com/intent/tweet/?text=Kotlin%20%ec%a0%95%eb%a6%ac%20%282%29&amp;url=https%3a%2f%2f2taezeat.github.io%2fposts%2fdev%2fkotlin-%25EC%25A0%2595%25EB%25A6%25AC-2%2f&amp;hashtags=Kotlin"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446C483.971.0 512 28.03 512 62.554zM269.951 190.75 182.567 75.216H56L207.216 272.95 63.9 436.783h61.366L235.9 310.383l96.667 126.4H456L298.367 228.367l134-153.151H371.033zM127.633 110h36.468l219.38 290.065H349.5z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Kotlin 정리 (2) on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2f2taezeat.github.io%2fposts%2fdev%2fkotlin-%25EC%25A0%2595%25EB%25A6%25AC-2%2f&amp;title=Kotlin%20%ec%a0%95%eb%a6%ac%20%282%29&amp;summary=Kotlin%20%ec%a0%95%eb%a6%ac%20%282%29&amp;source=https%3a%2f%2f2taezeat.github.io%2fposts%2fdev%2fkotlin-%25EC%25A0%2595%25EB%25A6%25AC-2%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Kotlin 정리 (2) on reddit" href="https://reddit.com/submit?url=https%3a%2f%2f2taezeat.github.io%2fposts%2fdev%2fkotlin-%25EC%25A0%2595%25EB%25A6%25AC-2%2f&title=Kotlin%20%ec%a0%95%eb%a6%ac%20%282%29"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Kotlin 정리 (2) on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2f2taezeat.github.io%2fposts%2fdev%2fkotlin-%25EC%25A0%2595%25EB%25A6%25AC-2%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Kotlin 정리 (2) on whatsapp" href="https://api.whatsapp.com/send?text=Kotlin%20%ec%a0%95%eb%a6%ac%20%282%29%20-%20https%3a%2f%2f2taezeat.github.io%2fposts%2fdev%2fkotlin-%25EC%25A0%2595%25EB%25A6%25AC-2%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Kotlin 정리 (2) on telegram" href="https://telegram.me/share/url?text=Kotlin%20%ec%a0%95%eb%a6%ac%20%282%29&amp;url=https%3a%2f%2f2taezeat.github.io%2fposts%2fdev%2fkotlin-%25EC%25A0%2595%25EB%25A6%25AC-2%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentcolor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Kotlin 정리 (2) on ycombinator" href="https://news.ycombinator.com/submitlink?t=Kotlin%20%ec%a0%95%eb%a6%ac%20%282%29&u=https%3a%2f%2f2taezeat.github.io%2fposts%2fdev%2fkotlin-%25EC%25A0%2595%25EB%25A6%25AC-2%2f"><svg width="30" height="30" viewBox="0 0 512 512" fill="currentcolor" xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"><path d="M449.446.0C483.971.0 512 28.03 512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446zM183.8767 87.9921h-62.034L230.6673 292.4508V424.0079h50.6655V292.4508L390.1575 87.9921H328.1233L256 238.2489z"/></svg></a></li></ul></footer><script src=https://utteranc.es/client.js repo=2taezeat/blog_comment issue-term=pathname label=comment theme=github-light crossorigin=anonymous async></script></article></main><footer class=footer><span>&copy; 2024 <a href=https://2taezeat.github.io/>2taezeat, blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>