<!doctype html><html lang=en dir=auto><head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>2taezeat, blog</title>
<meta name=keywords content><meta name=description content="CS / 코틀린 (1) 코틀린 언어 특징 정적 타입 언어 모든 프로그램의 구성요소의 타입을 컴파일 시점에 알 수 있고, 컴파일러가 타입을 검증 해줌. 자바와 다르게 개발자가 타입을 선언하지 않아도 타입 추론이 지원됨 컴파일러가 프로그램 타입의 정확성을 검증하기 때문에 런타임에 프로그램이 오류로 중단될 가능성이 적어짐. NULL 안전성 코틀린은 null이 될 수 있는 타입도 지원한다. null 값 허용여부를 컴파일 단계에서 검사하기 때문에 널 포인터 에러로 인한 프로그램 중단 예방 가능 null pointer exception 에서 자바와 다르게 이 에러를 컴파일 탐임에 에러를 알려준다."><meta name=author content="2taezeat"><link rel=canonical href=http://localhost:1313/posts/dev/kotlin-4/><meta name=google-site-verification content="YaEERzgrvu-ZwPg7gswZdTzRMufkHw3uIH7i8hVal1c"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.6e2e604ea5f627f6fb97a6a218445753397c457285e9bb47bd4cea346337d49e.css integrity="sha256-bi5gTqX2J/b7l6aiGERXUzl8RXKF6btHvUzqNGM31J4=" rel="preload stylesheet" as=style><link rel=icon href=http://localhost:1313/icon/favicon.ico><link rel=icon type=image/png sizes=16x16 href=http://localhost:1313/icon/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=http://localhost:1313/icon/favicon-32x32.png><link rel=apple-touch-icon href=http://localhost:1313/icon/apple-touch-icon.png><link rel=mask-icon href=http://localhost:1313/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=http://localhost:1313/posts/dev/kotlin-4/><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><meta property="og:title" content><meta property="og:description" content="CS / 코틀린 (1) 코틀린 언어 특징 정적 타입 언어 모든 프로그램의 구성요소의 타입을 컴파일 시점에 알 수 있고, 컴파일러가 타입을 검증 해줌. 자바와 다르게 개발자가 타입을 선언하지 않아도 타입 추론이 지원됨 컴파일러가 프로그램 타입의 정확성을 검증하기 때문에 런타임에 프로그램이 오류로 중단될 가능성이 적어짐. NULL 안전성 코틀린은 null이 될 수 있는 타입도 지원한다. null 값 허용여부를 컴파일 단계에서 검사하기 때문에 널 포인터 에러로 인한 프로그램 중단 예방 가능 null pointer exception 에서 자바와 다르게 이 에러를 컴파일 탐임에 에러를 알려준다."><meta property="og:type" content="article"><meta property="og:url" content="http://localhost:1313/posts/dev/kotlin-4/"><meta property="og:image" content="http://localhost:1313/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta property="article:section" content="posts"><meta property="og:site_name" content="2taezeat, blog"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="http://localhost:1313/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content><meta name=twitter:description content="CS / 코틀린 (1) 코틀린 언어 특징 정적 타입 언어 모든 프로그램의 구성요소의 타입을 컴파일 시점에 알 수 있고, 컴파일러가 타입을 검증 해줌. 자바와 다르게 개발자가 타입을 선언하지 않아도 타입 추론이 지원됨 컴파일러가 프로그램 타입의 정확성을 검증하기 때문에 런타임에 프로그램이 오류로 중단될 가능성이 적어짐. NULL 안전성 코틀린은 null이 될 수 있는 타입도 지원한다. null 값 허용여부를 컴파일 단계에서 검사하기 때문에 널 포인터 에러로 인한 프로그램 중단 예방 가능 null pointer exception 에서 자바와 다르게 이 에러를 컴파일 탐임에 에러를 알려준다."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"http://localhost:1313/posts/"},{"@type":"ListItem","position":2,"name":"","item":"http://localhost:1313/posts/dev/kotlin-4/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"","name":"","description":"CS / 코틀린 (1) 코틀린 언어 특징 정적 타입 언어 모든 프로그램의 구성요소의 타입을 컴파일 시점에 알 수 있고, 컴파일러가 타입을 검증 해줌. 자바와 다르게 개발자가 타입을 선언하지 않아도 타입 추론이 지원됨 컴파일러가 프로그램 타입의 정확성을 검증하기 때문에 런타임에 프로그램이 오류로 중단될 가능성이 적어짐. NULL 안전성 코틀린은 null이 될 수 있는 타입도 지원한다. null 값 허용여부를 컴파일 단계에서 검사하기 때문에 널 포인터 에러로 인한 프로그램 중단 예방 가능 null pointer exception 에서 자바와 다르게 이 에러를 컴파일 탐임에 에러를 알려준다.","keywords":[],"articleBody":"CS / 코틀린 (1) 코틀린 언어 특징 정적 타입 언어 모든 프로그램의 구성요소의 타입을 컴파일 시점에 알 수 있고, 컴파일러가 타입을 검증 해줌. 자바와 다르게 개발자가 타입을 선언하지 않아도 타입 추론이 지원됨 컴파일러가 프로그램 타입의 정확성을 검증하기 때문에 런타임에 프로그램이 오류로 중단될 가능성이 적어짐. NULL 안전성 코틀린은 null이 될 수 있는 타입도 지원한다. null 값 허용여부를 컴파일 단계에서 검사하기 때문에 널 포인터 에러로 인한 프로그램 중단 예방 가능 null pointer exception 에서 자바와 다르게 이 에러를 컴파일 탐임에 에러를 알려준다. 함수 타입에 대한 지원 코틀린은 함수형 프로그래밍 순수함수 같은 인자에 대하여 항상 같은 값을 반환 함수 외부의 어떤 상태도 바꾸지 않음 함수형 프로그래밍에서는 함수를 일급객체로 여김 일급 객체란 함수의 인자로 전달 가능 함수의 반환값으로 사용 가능 변수에 담기 가능 람다식 지원 람다식이란, 다른 함수의 인자로 넘기는 함수, 함수의 결과값으로 반환하는 함수, 변수에 저장하는 함수 고차 함수 : 고차 함수는 다른 함수를 인자로 사용하거나, 함수를 결과값 반환하는 함수를 말함. 일급 객체 or 일급 함수를 서로 주고 받을 수 있는 함수가 고차함수가 된다. 일급 객체인 함수, 그로인한 내부 상태가 절대로 바뀌지 않은 불변 객체를 사용해 side effect가 없음. 입력이 같으면 항상 같은 출력을 내놓고, 다른 객체의 상태를 변경하지 않으며, 함수 외부나 다른 바깥 환경과 상호작용하지 않은 순수함수를 사용할 수 있음. 자바와 호환성 JAVA Virtual Machine이 코틀린의 타겟 플랫폼이기 때문에 자바 메소드 호출, 자바 클래스 상속, 인터페이스 구현 등 자바에서 적용하던걸 모두 코틀린에서 할 수 있음. 자바 표준 라이브러리 클래스에 의존하기에 자바 라이브러리를 활용 할 수 있다. 간결성 getter, setter 같은 자바의 보일러 코드를 코틀린에서는 묵시적으로 제공 안전성 JVM에서 실행 하기 때문에 메모리 안전성과 버퍼 오버 플로우, 동적 메모리 할당의 문제 예방 가능 정적 타입 언어로 타입 자동 추론을 통해 타입 안전성 보장 null 타입 가능성도 지원하기 때문에 NullPointerException 으로 인한 프로그램 오류 방지 Class Cast Exception 예방 : 자바와 달리 코틀린에서는 타입 검사와 Cast가 한 연산자에 의해 이뤄진다. 어떤 객체의 타입을 검사했고, 그 객체가 그 타입에 속한다면 별도의 Cast 없이 해당 타입의 메소드나 필드 등의 멤버를 사용할 수 있다. 따라서 타입 검사를 생략할 이유가 없기에, 검사를 생략해서 생기는 오류가 발생할 일이 없다. val과 var의 차이점 val은 불변 변수입니다. val로 지정된 불변 타입 변수는 초기에 값을 할당하게 되면 나중에 값을 변경할 수 없다. val은 java의 final과 같다고 볼 수 있다. val은 값을 변경시키는 것은 불가능하지만, 변수의 참조가 가리키는 객체의 내부 값은 변경 가능 var로 지정된 가변 타입 변수는 초기화 후 값의 변경이 가능합니다. 하지만 var 변수는 다른 타입의 값을 넣을 수는 없습니다. 이미 정의된 타입을 변경하려면 ‘형 변환’을 해주어야 합니다. Null Safey와 Nullable Types 이란? Elvis 연산자란? 코틀린은 NPE를 방지하기 위해, String?, Int? 같은 nullable 타입들을 이용합니다. 이러한 타입들은 null 값을 가질 수 있습니다. 엘비스 연산자는 이런 nullable 타입들을 안전하게 값을 이용할 수 있도록 사용할 수 있게 합니다. nullable 타입 뒤에 ?: 로 표시하며, nullable 타입의 값이 null 일 경우 오른쪽 값을 이용합니다. null 이 아니면 엘비스 연산자의 왼쪽 값이 변수에 할당 됩니다. const와 val 비교 기본적으로 val 프로퍼티는 runtrime에 결정됨. const 를 붙이면, val은 compile-time에 상수가 됩니다. !! 와 ? 의 차이점은? nullable 값을 안전하게 이용 할 수 있는 다른 방법은? !! 는 nullable 타입의 값을 강제로 가져오기 위해 쓰입니다. !! 은 개발자가 null이 아니라고 확신 할때만 이용해야 합니다. 아니라면 NPE가 발생합니다. ?(안전한 호출 연산자)는 피연사자가 null이 아닌 경우 일반적인 함수 호출 처럼 작동함. 하지만 수신 객체가 null이면 안전한 호출 연산자는 호출을 수행하지 않고 그냥 null을 돌려 준다. let 함수를 ? 연산자 뒤에 사용하여, null이 아닌 경우에만 함수 타입의 람다를 실행하게끔 할 수 도 있다. == 와 === 의 차이점 == : value 비교 ==== : reference 비교 코틀린에서 생성자의 타입들은 어떤 차이가 있는가? Primary Class Header에 정의 Logic을 가질 수 없음. Class당 하나만 존재 Secondary Class Body에 정의 Primary 생성자가 있는 경우, 반드시 위임 해야 한다. Logic을 가질 수 있다. Class 당 1개 이상 존재 가능 코틀린에서 init block이란? init은 코틀린의 초기화 block 이다. Primar 생성자가 인스턴스화 되면 실행됨. Secondary 생성자가 호출되면, Primary 생성자 다음에 실행됨. 생성자 내부 argument들의 타입들은? var로 따로 지정하지 않는 한, 기본적으로 val이다. 코틀린에서 switch 문에 해당하는 것은? JAVA와의 차이점은? when 에서는 임의 조건을 검사할 수 있지만, switch에서는 주어진 식의 여러가지 값 중 하나만 선택할 수 있다. when 은 switch와 다르게 fall-through 를 하지 않고, 조건을 만족하는 가지만 실행한다. data class 란? Java에서는 data를 저장하는 class를 생성하기 위해, 변수마다 getter, setter를 설정하고, toString(), haseCode(), copy() 함수를 직접 override 해야 한다. 하지만 코틀린에서는 class 앞에 data 키워드를 추가하면, 위와 같은 코드를 자동으로 생성해줌. 구조 분해 선언(destructing declaration) 이란? 구조 분해 선언이란 객체가 가지고 있는 여러 값을 분해해서 여러 변수에 한꺼번에 초기화 할 수 있는 방법 구조 분해 선언의 내부에서는 각 변수를 초기화 하기 위해 componentN이라는 함수를 호출하게 되며, 여기서 N은 구조 분해 선언에 있는 변수 위치에 따라 붙는 번호 이다. lazy 와 lateinit lateinit을 사용하면 변수의 값을 지정하는 작업을 뒤로 미룸. Nullable 하지 않는 변수를 선언하면서 Assign 하는 작업을 뒤로 미루고 싶을때는 lateinit 키워드를 사용하면 가능하다. lateinit은 mutable 한 변수만 가능하기 때문에 var 키워드를 가진 변수에서만 사용이 가능하다. by lazy 키워드는 lateinit과 비슷하게 값을 지정하는 작업을 미루는 것인데, Assign 되는 시점이 변수를 호출하는 시점이다. by lazy는 immutable 변수에서만 적용이 가능해, val 키워드 변수에만 적용이 가능하다. 변수에 값을 최초에만 설정하고 변경할 필요가 없는 경우에 사용하면 유용하다. 코틀린 코드 컴파일 및 빌드 코틀린 컴파일러는 자바 컴파일러가 자바 소스코드를 컴파일할 때와 마찬가지로 코틀린 소스코드(.kt)를 분석해서 .class 파일을 만들어낸다. 만들어진 .class 파일은 개발 중인 애플리케이션의 유형에 맞는 표준 패키징 과정을 거쳐 실행될 수 있다. Java 코드와 Kotlin 코드의 빌드 과정은 다음과 같은 순서로 이루어진다. 코틀린 컴파일러가 코틀린 코드를 컴파일해 .class 파일을 생성한다. 이 과정에서 코틀린 코드가 참조하는 Java 코드가 함께 로딩되어 사용된다. Java 컴파일러가 Java 코드를 컴파일해 .class 파일을 생성한다. 이때 이미 코틀린이 컴파일한 .class 파일의 경로를 클래스 패스에 추가해 컴파일한다. 코틀린 컴파일러로 컴파일한 코드는 코틀린 런타임 라이브러리(kotlin runtime library)에 의존한다. 코틀린 런타임 라이브러리 : 코틀린 자체 표준 라이브러리 클래스 + 코틀린에서 자바 API의 기능을 확장한 내용 코틀린으로 컴파일한 애플리케이션을 배포할때는 코틀린 런타임 라이브러리도 함께 배포해야 한다. 프로젝트를 컴파일하기 위해 메이븐(Maven)과 그레이(Gradle), 앤트(Ant) 등의 빌드 시스템을 사용 빌드 시스템은 모두 코틀린과 자바가 코드베이스에 함께 들어있는 혼합 언어 프로젝트를 지원할 수 있다 메이븐(Maven)과 그레이(Gradle)들은 애플리케이션을 패키지할 때 알아서 코틀린 런타임 라이브러리을 포함시켜준다. ","wordCount":"979","inLanguage":"en","image":"http://localhost:1313/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E","datePublished":"0001-01-01T00:00:00Z","dateModified":"0001-01-01T00:00:00Z","author":{"@type":"Person","name":"2taezeat"},"mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:1313/posts/dev/kotlin-4/"},"publisher":{"@type":"Organization","name":"2taezeat, blog","logo":{"@type":"ImageObject","url":"http://localhost:1313/icon/favicon.ico"}}}</script></head><body id=top><header class=header><nav class=nav><div class=logo><a href=http://localhost:1313/ accesskey=h title="2taezeat blog (Alt + H)"><img src=http://localhost:1313/icon/apple-touch-icon.png alt aria-label=logo height=30>2taezeat blog</a><div class=logo-switches></div></div><ul id=menu><li><a href=http://localhost:1313/tags/ title=Tags><span>Tags</span></a></li><li><a href=http://localhost:1313/archives/ title=Archives><span>Archives</span></a></li><li><a href=http://localhost:1313/searchs/ title=Search><span>Search</span></a></li><li><a href=https://github.com/2taezeat title=Github><span>Github</span>&nbsp;<svg fill="none" shape-rendering="geometricPrecision" stroke="currentcolor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2.5" viewBox="0 0 24 24" height="12" width="12"><path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"/><path d="M15 3h6v6"/><path d="M10 14 21 3"/></svg></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=http://localhost:1313/>Home</a>&nbsp;»&nbsp;<a href=http://localhost:1313/posts/>Posts</a></div><h1 class="post-title entry-hint-parent"></h1><div class=post-meta>5 min&nbsp;·&nbsp;979 words&nbsp;·&nbsp;2taezeat</div></header><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#cs--코틀린-1>CS / 코틀린 (1)</a><ul><li><ul><li><a href=#코틀린-언어-특징><em><strong>코틀린 언어 특징</strong></em></a></li><li><a href=#val과-var의-차이점><em><strong>val과 var의 차이점</strong></em></a></li><li><a href=#null-safey와-nullable-types-이란-elvis-연산자란><em><strong>Null Safey와 Nullable Types 이란? Elvis 연산자란?</strong></em></a></li><li><a href=#const와-val-비교><em><strong>const와 val 비교</strong></em></a></li><li><a href=#-와--의-차이점은-nullable-값을-안전하게-이용-할-수-있는-다른-방법은><em><strong>!! 와 ? 의 차이점은? nullable 값을 안전하게 이용 할 수 있는 다른 방법은?</strong></em></a></li><li><a href=#-와--의-차이점><em><strong>== 와 === 의 차이점</strong></em></a></li><li><a href=#코틀린에서-생성자의-타입들은-어떤-차이가-있는가><em><strong>코틀린에서 생성자의 타입들은 어떤 차이가 있는가?</strong></em></a></li><li><a href=#코틀린에서-init-block이란><em><strong>코틀린에서 init block이란?</strong></em></a></li><li><a href=#생성자-내부-argument들의-타입들은><em><strong>생성자 내부 argument들의 타입들은?</strong></em></a></li><li><a href=#코틀린에서-switch-문에-해당하는-것은-java와의-차이점은><em><strong>코틀린에서 switch 문에 해당하는 것은? JAVA와의 차이점은?</strong></em></a></li><li><a href=#data-class-란><em><strong>data class 란?</strong></em></a></li><li><a href=#구조-분해-선언destructing-declaration-이란><em><strong>구조 분해 선언(destructing declaration) 이란?</strong></em></a></li><li><a href=#lazy-와-lateinit><em><strong>lazy 와 lateinit</strong></em></a></li><li><a href=#코틀린-코드-컴파일-및-빌드><em><strong>코틀린 코드 컴파일 및 빌드</strong></em></a></li></ul></li></ul></li></ul></nav></div></details></div><div class=post-content><h1 id=cs--코틀린-1>CS / 코틀린 (1)<a hidden class=anchor aria-hidden=true href=#cs--코틀린-1>#</a></h1><hr><h3 id=코틀린-언어-특징><em><strong>코틀린 언어 특징</strong></em><a hidden class=anchor aria-hidden=true href=#코틀린-언어-특징>#</a></h3><ol><li>정적 타입 언어<ol><li>모든 프로그램의 구성요소의 타입을 컴파일 시점에 알 수 있고, 컴파일러가 타입을 검증 해줌.</li><li>자바와 다르게 개발자가 타입을 선언하지 않아도 타입 추론이 지원됨</li><li>컴파일러가 프로그램 타입의 정확성을 검증하기 때문에 런타임에 프로그램이 오류로 중단될 가능성이 적어짐.</li></ol></li><li>NULL 안전성<ol><li>코틀린은 null이 될 수 있는 타입도 지원한다.</li><li>null 값 허용여부를 컴파일 단계에서 검사하기 때문에 널 포인터 에러로 인한 프로그램 중단 예방 가능</li><li>null pointer exception 에서 자바와 다르게 이 에러를 컴파일 탐임에 에러를 알려준다.</li></ol></li><li>함수 타입에 대한 지원<ol><li>코틀린은 함수형 프로그래밍</li><li>순수함수<ol><li>같은 인자에 대하여 항상 같은 값을 반환</li><li>함수 외부의 어떤 상태도 바꾸지 않음</li></ol></li><li><strong>함수형 프로그래밍에서는 함수를 일급객체로 여김</strong></li><li>일급 객체란<ol><li>함수의 인자로 전달 가능</li><li>함수의 반환값으로 사용 가능</li><li>변수에 담기 가능</li></ol></li><li>람다식 지원<ol><li>람다식이란, 다른 함수의 인자로 넘기는 함수, 함수의 결과값으로 반환하는 함수, 변수에 저장하는 함수</li><li>고차 함수 : 고차 함수는 다른 함수를 인자로 사용하거나, 함수를 결과값 반환하는 함수를 말함. 일급 객체 or 일급 함수를 서로 주고 받을 수 있는 함수가 고차함수가 된다.</li><li>일급 객체인 함수, 그로인한 내부 상태가 절대로 바뀌지 않은 불변 객체를 사용해 side effect가 없음. 입력이 같으면 항상 같은 출력을 내놓고, 다른 객체의 상태를 변경하지 않으며, 함수 외부나 다른 바깥 환경과 상호작용하지 않은 순수함수를 사용할 수 있음.</li></ol></li></ol></li><li>자바와 호환성<ol><li>JAVA Virtual Machine이 코틀린의 타겟 플랫폼이기 때문에 자바 메소드 호출, 자바 클래스 상속, 인터페이스 구현 등 자바에서 적용하던걸 모두 코틀린에서 할 수 있음.</li><li>자바 표준 라이브러리 클래스에 의존하기에 자바 라이브러리를 활용 할 수 있다.</li></ol></li><li>간결성<ol><li>getter, setter 같은 자바의 보일러 코드를 코틀린에서는 묵시적으로 제공</li></ol></li><li>안전성<ol><li>JVM에서 실행 하기 때문에 메모리 안전성과 버퍼 오버 플로우, 동적 메모리 할당의 문제 예방 가능</li><li>정적 타입 언어로 타입 자동 추론을 통해 타입 안전성 보장</li><li>null 타입 가능성도 지원하기 때문에 NullPointerException 으로 인한 프로그램 오류 방지</li><li>Class Cast Exception 예방 : 자바와 달리 코틀린에서는 타입 검사와 Cast가 한 연산자에 의해 이뤄진다. 어떤 객체의 타입을 검사했고, 그 객체가 그 타입에 속한다면 별도의 Cast 없이 해당 타입의 메소드나 필드 등의 멤버를 사용할 수 있다. 따라서 타입 검사를 생략할 이유가 없기에, 검사를 생략해서 생기는 오류가 발생할 일이 없다.</li></ol></li></ol><hr><h3 id=val과-var의-차이점><em><strong>val과 var의 차이점</strong></em><a hidden class=anchor aria-hidden=true href=#val과-var의-차이점>#</a></h3><ol><li>val은 불변 변수입니다. val로 지정된 불변 타입 변수는 초기에 값을 할당하게 되면 나중에 값을 변경할 수 없다.</li><li>val은 java의 final과 같다고 볼 수 있다.</li><li>val은 값을 변경시키는 것은 불가능하지만, 변수의 참조가 가리키는 객체의 내부 값은 변경 가능</li><li>var로 지정된 가변 타입 변수는 초기화 후 값의 변경이 가능합니다.</li><li>하지만 var 변수는 다른 타입의 값을 넣을 수는 없습니다.</li><li>이미 정의된 타입을 변경하려면 ‘형 변환’을 해주어야 합니다.</li></ol><hr><h3 id=null-safey와-nullable-types-이란-elvis-연산자란><em><strong>Null Safey와 Nullable Types 이란? Elvis 연산자란?</strong></em><a hidden class=anchor aria-hidden=true href=#null-safey와-nullable-types-이란-elvis-연산자란>#</a></h3><ol><li>코틀린은 NPE를 방지하기 위해, String?, Int? 같은 nullable 타입들을 이용합니다. 이러한 타입들은 null 값을 가질 수 있습니다.</li><li>엘비스 연산자는 이런 nullable 타입들을 안전하게 값을 이용할 수 있도록 사용할 수 있게 합니다. nullable 타입 뒤에 ?: 로 표시하며, nullable 타입의 값이 null 일 경우 오른쪽 값을 이용합니다. null 이 아니면 엘비스 연산자의 왼쪽 값이 변수에 할당 됩니다.</li></ol><hr><h3 id=const와-val-비교><em><strong>const와 val 비교</strong></em><a hidden class=anchor aria-hidden=true href=#const와-val-비교>#</a></h3><ol><li>기본적으로 val 프로퍼티는 runtrime에 결정됨.</li><li>const 를 붙이면, val은 compile-time에 상수가 됩니다.</li></ol><hr><h3 id=-와--의-차이점은-nullable-값을-안전하게-이용-할-수-있는-다른-방법은><em><strong>!! 와 ? 의 차이점은? nullable 값을 안전하게 이용 할 수 있는 다른 방법은?</strong></em><a hidden class=anchor aria-hidden=true href=#-와--의-차이점은-nullable-값을-안전하게-이용-할-수-있는-다른-방법은>#</a></h3><ol><li>!! 는 nullable 타입의 값을 강제로 가져오기 위해 쓰입니다.</li><li>!! 은 개발자가 null이 아니라고 확신 할때만 이용해야 합니다. 아니라면 NPE가 발생합니다.</li><li>?(안전한 호출 연산자)는 피연사자가 null이 아닌 경우 일반적인 함수 호출 처럼 작동함. 하지만 수신 객체가 null이면 안전한 호출 연산자는 호출을 수행하지 않고 그냥 null을 돌려 준다.</li><li>let 함수를 ? 연산자 뒤에 사용하여, null이 아닌 경우에만 함수 타입의 람다를 실행하게끔 할 수 도 있다.</li></ol><hr><h3 id=-와--의-차이점><em><strong>== 와 === 의 차이점</strong></em><a hidden class=anchor aria-hidden=true href=#-와--의-차이점>#</a></h3><ol><li>== : value 비교</li><li>==== : reference 비교</li></ol><hr><h3 id=코틀린에서-생성자의-타입들은-어떤-차이가-있는가><em><strong>코틀린에서 생성자의 타입들은 어떤 차이가 있는가?</strong></em><a hidden class=anchor aria-hidden=true href=#코틀린에서-생성자의-타입들은-어떤-차이가-있는가>#</a></h3><ol><li>Primary<ol><li>Class Header에 정의</li><li>Logic을 가질 수 없음.</li><li>Class당 하나만 존재</li></ol></li><li>Secondary<ol><li>Class Body에 정의</li><li>Primary 생성자가 있는 경우, 반드시 위임 해야 한다.</li><li>Logic을 가질 수 있다.</li><li>Class 당 1개 이상 존재 가능</li></ol></li></ol><hr><h3 id=코틀린에서-init-block이란><em><strong>코틀린에서 init block이란?</strong></em><a hidden class=anchor aria-hidden=true href=#코틀린에서-init-block이란>#</a></h3><ol><li>init은 코틀린의 초기화 block 이다.</li><li>Primar 생성자가 인스턴스화 되면 실행됨.</li><li>Secondary 생성자가 호출되면, Primary 생성자 다음에 실행됨.</li></ol><hr><h3 id=생성자-내부-argument들의-타입들은><em><strong>생성자 내부 argument들의 타입들은?</strong></em><a hidden class=anchor aria-hidden=true href=#생성자-내부-argument들의-타입들은>#</a></h3><ol><li>var로 따로 지정하지 않는 한, 기본적으로 val이다.</li></ol><hr><h3 id=코틀린에서-switch-문에-해당하는-것은-java와의-차이점은><em><strong>코틀린에서 switch 문에 해당하는 것은? JAVA와의 차이점은?</strong></em><a hidden class=anchor aria-hidden=true href=#코틀린에서-switch-문에-해당하는-것은-java와의-차이점은>#</a></h3><ol><li>when 에서는 임의 조건을 검사할 수 있지만, switch에서는 주어진 식의 여러가지 값 중 하나만 선택할 수 있다.</li><li>when 은 switch와 다르게 fall-through 를 하지 않고, 조건을 만족하는 가지만 실행한다.</li></ol><hr><h3 id=data-class-란><em><strong>data class 란?</strong></em><a hidden class=anchor aria-hidden=true href=#data-class-란>#</a></h3><ol><li>Java에서는 data를 저장하는 class를 생성하기 위해, 변수마다 getter, setter를 설정하고, toString(), haseCode(), copy() 함수를 직접 override 해야 한다.</li><li>하지만 코틀린에서는 class 앞에 data 키워드를 추가하면, 위와 같은 코드를 자동으로 생성해줌.</li></ol><hr><h3 id=구조-분해-선언destructing-declaration-이란><em><strong>구조 분해 선언(destructing declaration) 이란?</strong></em><a hidden class=anchor aria-hidden=true href=#구조-분해-선언destructing-declaration-이란>#</a></h3><ol><li>구조 분해 선언이란 객체가 가지고 있는 여러 값을 분해해서 여러 변수에 한꺼번에 초기화 할 수 있는 방법</li><li>구조 분해 선언의 내부에서는 각 변수를 초기화 하기 위해 componentN이라는 함수를 호출하게 되며, 여기서 N은 구조 분해 선언에 있는 변수 위치에 따라 붙는 번호 이다.</li></ol><hr><h3 id=lazy-와-lateinit><em><strong>lazy 와 lateinit</strong></em><a hidden class=anchor aria-hidden=true href=#lazy-와-lateinit>#</a></h3><ol><li>lateinit을 사용하면 변수의 값을 지정하는 작업을 뒤로 미룸.</li><li>Nullable 하지 않는 변수를 선언하면서 Assign 하는 작업을 뒤로 미루고 싶을때는 lateinit 키워드를 사용하면 가능하다.</li><li>lateinit은 mutable 한 변수만 가능하기 때문에 var 키워드를 가진 변수에서만 사용이 가능하다.</li><li>by lazy 키워드는 lateinit과 비슷하게 값을 지정하는 작업을 미루는 것인데, <strong>Assign 되는 시점이 변수를 호출</strong>하는 시점이다.</li><li>by lazy는 immutable 변수에서만 적용이 가능해, val 키워드 변수에만 적용이 가능하다. <strong>변수에 값을 최초에만 설정하고 변경할 필요가 없는 경우에 사용</strong>하면 유용하다.</li></ol><hr><h3 id=코틀린-코드-컴파일-및-빌드><em><strong>코틀린 코드 컴파일 및 빌드</strong></em><a hidden class=anchor aria-hidden=true href=#코틀린-코드-컴파일-및-빌드>#</a></h3><p><img loading=lazy src=https://velog.velcdn.com/images%2Fba159sal%2Fpost%2F2d3a17cd-8816-461a-856f-e96d8cdb8e5c%2Fimage.png alt=https://velog.velcdn.com/images%2Fba159sal%2Fpost%2F2d3a17cd-8816-461a-856f-e96d8cdb8e5c%2Fimage.png></p><ul><li><code>코틀린 컴파일러</code>는 자바 컴파일러가 자바 소스코드를 컴파일할 때와 마찬가지로 <code>코틀린 소스코드(.kt)</code>를 분석해서 <code>.class</code> 파일을 만들어낸다.</li><li>만들어진 <code>.class</code> 파일은 개발 중인 애플리케이션의 유형에 맞는 표준 <code>패키징</code> 과정을 거쳐 실행될 수 있다.</li><li></li></ul><p><img loading=lazy src=https://velog.velcdn.com/images%2Fba159sal%2Fpost%2F865aeabf-b25c-4ff6-b903-f8fb3eba8674%2Fimage.png alt=https://velog.velcdn.com/images%2Fba159sal%2Fpost%2F865aeabf-b25c-4ff6-b903-f8fb3eba8674%2Fimage.png></p><ul><li>Java 코드와 Kotlin 코드의 빌드 과정은 다음과 같은 순서로 이루어진다.</li></ul><ol><li>코틀린 컴파일러가 코틀린 코드를 컴파일해 <code>.class</code> 파일을 생성한다. 이 과정에서 코틀린 코드가 참조하는 Java 코드가 함께 로딩되어 사용된다.</li><li>Java 컴파일러가 Java 코드를 컴파일해 <code>.class</code> 파일을 생성한다. 이때 이미 코틀린이 컴파일한 <code>.class</code> 파일의 경로를 클래스 패스에 추가해 컴파일한다.<ul><li>코틀린 컴파일러로 컴파일한 코드는 <code>코틀린 런타임 라이브러리(kotlin runtime library)</code>에 의존한다.</li><li><code>코틀린 런타임 라이브러리</code> : <code>코틀린 자체 표준 라이브러리 클래스</code> + <code>코틀린에서 자바 API의 기능을 확장한 내용</code></li><li>코틀린으로 컴파일한 애플리케이션을 배포할때는 <code>코틀린 런타임 라이브러리</code>도 함께 배포해야 한다.</li><li>프로젝트를 컴파일하기 위해 <code>메이븐(Maven)</code>과 <code>그레이(Gradle)</code>, <code>앤트(Ant)</code> 등의 빌드 시스템을 사용</li><li>빌드 시스템은 모두 코틀린과 자바가 코드베이스에 함께 들어있는 혼합 언어 프로젝트를 지원할 수 있다</li><li><code>메이븐(Maven)</code>과 <code>그레이(Gradle)</code>들은 애플리케이션을 패키지할 때 알아서 <code>코틀린 런타임 라이브러리</code>을 포함시켜준다.</li></ul></li></ol></div><footer class=post-footer><ul class=post-tags></ul><nav class=paginav><a class=prev href=http://localhost:1313/posts/dev/kotlin-3/><span class=title>« Prev</span><br><span></span>
</a><a class=next href=http://localhost:1313/posts/dev/kotlin-%EC%A0%95%EB%A6%AC-1/><span class=title>Next »</span><br><span></span></a></nav><ul class=share-buttons><li><a target=_blank rel="noopener noreferrer" aria-label="share  on x" href="https://x.com/intent/tweet/?text=&amp;url=http%3a%2f%2flocalhost%3a1313%2fposts%2fdev%2fkotlin-4%2f&amp;hashtags="><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446C483.971.0 512 28.03 512 62.554zM269.951 190.75 182.567 75.216H56L207.216 272.95 63.9 436.783h61.366L235.9 310.383l96.667 126.4H456L298.367 228.367l134-153.151H371.033zM127.633 110h36.468l219.38 290.065H349.5z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share  on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=http%3a%2f%2flocalhost%3a1313%2fposts%2fdev%2fkotlin-4%2f&amp;title=&amp;summary=&amp;source=http%3a%2f%2flocalhost%3a1313%2fposts%2fdev%2fkotlin-4%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share  on reddit" href="https://reddit.com/submit?url=http%3a%2f%2flocalhost%3a1313%2fposts%2fdev%2fkotlin-4%2f&title="><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share  on facebook" href="https://facebook.com/sharer/sharer.php?u=http%3a%2f%2flocalhost%3a1313%2fposts%2fdev%2fkotlin-4%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share  on whatsapp" href="https://api.whatsapp.com/send?text=%20-%20http%3a%2f%2flocalhost%3a1313%2fposts%2fdev%2fkotlin-4%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share  on telegram" href="https://telegram.me/share/url?text=&amp;url=http%3a%2f%2flocalhost%3a1313%2fposts%2fdev%2fkotlin-4%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentcolor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share  on ycombinator" href="https://news.ycombinator.com/submitlink?t=&u=http%3a%2f%2flocalhost%3a1313%2fposts%2fdev%2fkotlin-4%2f"><svg width="30" height="30" viewBox="0 0 512 512" fill="currentcolor" xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"><path d="M449.446.0C483.971.0 512 28.03 512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446zM183.8767 87.9921h-62.034L230.6673 292.4508V424.0079h50.6655V292.4508L390.1575 87.9921H328.1233L256 238.2489z"/></svg></a></li></ul></footer><script src=https://utteranc.es/client.js repo=2taezeat/blog_comment issue-term=pathname label=comment theme=github-light crossorigin=anonymous async></script></article></main><footer class=footer><span>&copy; 2024 <a href=http://localhost:1313/>2taezeat, blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>