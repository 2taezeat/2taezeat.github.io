[{"content":"new-post-kotlin asdasd\nasdwerre\nasdasd\nSample Image asd werwer\n","permalink":"https://2taezeat.github.io/posts/new-post-%EC%BD%94%ED%8B%80%EB%A6%B0/","summary":"new-post-kotlin asdasd\nasdwerre\nasdasd\nSample Image asd werwer","title":"new-post-kotlin"},{"content":"hello world 😀 qwe 😀\nqwew asdf qwie 이 떄, 직렬화를 지원하지 않는 클래스인 User 클래스를 직렬화를 지원하는 Project 클래스의 프로퍼티로 넣으면 다음과 같이 컴파일 에러가 발생한다. Polymorphic serialization 상속 구조나 다형성을 파악해 직렬화를 해준다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 @Serializable sealed class Project { abstract val name: String var status = \u0026#34;open\u0026#34; } @Serializable @SerialName(\u0026#34;owned\u0026#34;) class OwnedProject(override val name: String, val owner: String) : Project() fun main() { val json = Json { encodeDefaults = true } // \u0026#34;status\u0026#34; will be skipped otherwise val data: Project = OwnedProject(\u0026#34;kotlinx.coroutines\u0026#34;, \u0026#34;kotlin\u0026#34;) println(json.encodeToString(data)) } // {\u0026#34;type\u0026#34;:\u0026#34;owned\u0026#34;,\u0026#34;status\u0026#34;:\u0026#34;open\u0026#34;,\u0026#34;name\u0026#34;:\u0026#34;kotlinx.coroutines\u0026#34;,\u0026#34;owner\u0026#34;:\u0026#34;kotlin\u0026#34;} ertertre qweqe\nasdasd qwe\n3. 역할, 책임, 협력 협력: 객체들이 앺ㄹ리케이션의 기능을 구현하기 위해 수행하는 상호작용 책임: 객체가 협력에 참여하기 위해 수행하는 로직 객체들이 협력 안에서 수행하는 책임들이 모여 객체가 수행하는 역할을 구성한다. 협력 메시지 전송(message sending) 은 협력을 위해 사용할 수 있는 유일한 커뮤니케이션 수단\n객체가 스스로 메시지를 처리할 방법(메서드)을 자율적으로 선택\n자율적인 객체가 되기 위해서는 자신이 할 수 없는 일을 다른 객체에게 위임하면 협력에서 전체적인 자율성이 향상\n가장 기본적인 방법은 캡슐화 이다. 협력이 설계를 위한 문맥을 결정한다 객체의 행동을 결정하는 것은 객체가 참여하고 있는 협력이다.\n협력은 객체가 필요한 이유와 객체가 수행하는 행동의 동기를 제공한다.\nMovie의 행동을 결정하는 것은 영화 예매를 위한 협력이다.\n협력이라는 문맥을 고려하지 않고 Moive의 행동을 결정하는 것은 아무런 의미가 없다. 상태는 객체가 행동하는 데 필요한 정보에 의해 결정되고 행동은 협력 안에서 객체가 처리할 메시지로 결정 된다.\n객체가 참여하는 협력이 객체를 구성하는 상태와 행동 모두를 결정한다.\n협력은 설계에 필요한 **context(문맥)**을 제공한다. kotest-assertions-core module에서 제공한다.\nGeneral asdasd obj.shouldBe(other) General purpose assertion that the given obj and other are both equal expr.shouldBeTrue() Convenience assertion that the expression is true. Equivalent to expr.shouldBe(true) expr.shouldBeFalse() Convenience assertion that the expression is false. Equivalent to expr.shouldBe(false) shouldThrow\u0026lt;T\u0026gt; { block } General purpose construct that asserts that the block throws a T Throwable or a subtype of T shouldThrowExactly\u0026lt;T\u0026gt; { block } General purpose construct that asserts that the block throws exactly T shouldThrowAny { block } General purpose construct that asserts that the block throws a Throwable of any type shouldThrowMessage(message) { block } Verifies that a block of code throws any Throwable with given message 책임 책임이란 객체에 의해 정의되는 응집도 있는 행위의 집합 객체의 책임은 \u0026lsquo;무엇을 알고 있는가(knowing)\u0026rsquo;, \u0026lsquo;무엇을 할 수 있는가(doing)\u0026rsquo; 으로 구성 된다. 두 개는 밀접하게 연관되어 있다. 객체는 책임을 수행하는 데 필요한 정보를 알고 있을 책임 할 수 없는 작업을 도와줄 객체를 알고 있을 책임 그 책임을 수행하는 데 필요한 정보도 알아야할 책임 책임은 메시지 보다 추상적이면서 개념적으로 더 크다. 책임은 객체지향 설계의 핵심, 책임을 능숙하게 소프트웨어 객체에게 할당하는 것은 매우 중요하다. 객체의 구현 방법은 책임보다 상대적으로 덜 중요하고 책임 이후에 고민해도 늦지 않다. ","permalink":"https://2taezeat.github.io/posts/new-post-four/","summary":"hello world 😀 qwe 😀\nqwew asdf qwie 이 떄, 직렬화를 지원하지 않는 클래스인 User 클래스를 직렬화를 지원하는 Project 클래스의 프로퍼티로 넣으면 다음과 같이 컴파일 에러가 발생한다. Polymorphic serialization 상속 구조나 다형성을 파악해 직렬화를 해준다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 @Serializable sealed class Project { abstract val name: String var status = \u0026#34;open\u0026#34; } @Serializable @SerialName(\u0026#34;owned\u0026#34;) class OwnedProject(override val name: String, val owner: String) : Project() fun main() { val json = Json { encodeDefaults = true } // \u0026#34;status\u0026#34; will be skipped otherwise val data: Project = OwnedProject(\u0026#34;kotlinx.","title":"new-post-four"}]