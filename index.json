[{"content":"7.1 상속 관계 매핑 RDB에는 OOP의 상속이라는 개념이 없고, 슈퍼타입 서브타입 관계 라는 모델링 기법이 상속의 개념과 가장 유사하다.\nORM에서 상속 관계 매핑은 객체의 상속 구조와 DB의 슈퍼타입 서브 타입 관계를 매핑하는 것\n[ 슈퍼타입 서브타입 논리 모델을 실제 물리 모델인 테이블로 구현하는 3가지 방법 ]\n각각의 테이블로 변환: 각각을 모두 테이블로 만들고 조회할 때 조인을 사용한다. JPA에서는 조인 전략이라 한다. 통합 테이블로 변환: 테이블을 하나만 사용해서 통합한다. JPA에서는 단일 테이블 전략이라 한다. 서브타입 테이블로 변환: 서브 타입마다 하나의 테이블을 만든다. JPA에서는 구현 클래스마다 테이블 전략이라 한다. 7.1.1 조인 전략 조인 전략 Joined Strategy 은 엔티티 각각을 모두 테이블로 만들고 자식 테이블이 부모 테이블의 기본 키를 받아서 기본 키 + 외래 키로 사용하는 전략이다.\n따라서 조회할 때 조인을 자주 사용한다.\n주의할 점 객체는 타입으로 구분할 수 있지만 테이블은 타입의 개념이 없다. 따라서 타입을 구분하는 컬럼을 추가해야 한다.\n여기서는 DTYPE 컬럼을 구분 컬럼으로 사용한다.\n@Inheritance(strategy = InheritanceType.JOINED)\n상속 매핑은 부모 클래스에 @Inheritance 를 사용해야 한다. 매핑 전략을 지정해야 하는데 여기서는 조인 전략을 사용하므로 InheritanceType.JOINED를 사용했다. @DiscriminatorColumn(name = \u0026quot;DTYPE\u0026quot;)\n부모 클래스에 구분 컬럼을 지정한다. 이 컬럼으로 저장된 자식 테이블을 구분할 수 있다. 기본값이 DTYPE이므로 @DiscriminatorColumn으로 줄여 사용해도 된다. @DiscriminatorValue(\u0026quot;M\u0026quot;)\n엔티티를 저장할 때 구분 컬럼에 입력할 값을 지정한다. 만약 영화 엔티티를 저장하면 구분 컬럼인 DTYPE에 값 M이 저장된다. @PrimaryKeyJoinColumn:\n기본값으로 자식 테이블은 부모 테이블의 ID 컬럼명을 그대로 사용하는데, 만약 자식 테이블의 기본 키 컬럼명을 변경하고 싶을 때 사용 장점\n테이블이 정규화된다. 외래 키 참조 무결성 제약조건을 활용할 수 있다. 저장공간을 효율적으로 사용한다. 단점\n조회할 때 조인이 많이 사용되므로 성능이 저하될 수 있다. 조회 쿼리가 복잡하다. 데이터를 등록할 INSERT SQL을 두 번 실행한다. 특징\nJPA 표준 명세는 구분 컬럼을 사용하도록 하지만 하이버네이트를 포함한 몇몇 구현체는 구분 컬럼( @Discriminatorcolumn ) 없이도 동작한다. 7.1.2 단일 테이블 전략 단일 테이블 전략 Single-Table Strategy 은 이름 그대로 테이블을 하나만 사용한다.\n구분 컬럼(DTYPE) 으로 어떤 자식 데이터가 저장되었는지 구분한다.\n장점\n조인이 필요 없으므로 일반적으로 조회 성능이 빠르다. 조회 쿼리가 단순하다. 단점\n자식 엔티티가 매핑한 컬럼은 모두 null을 허용해야 한다. 예를 들어 Book 엔티티를 저장하면 ITEM 테이블의 AUTHOR, ISEN 컬럼만 사용하고 다른 엔티티와 매핑된 ARTIST, DIRBCTOR, ACTOR 컬럼은 사용하지 않으므로 null이 입력되기 때문이다. 단일 테이블에 모든 것을 저장하므로 테이블이 커질 수 있다. 그러므로 상황에 따라서는 조회 성능이 오히려 느려질 수 있다. 특징\n구분 컬럼을 꼭 사용해야 한다. 따라서 @DiscriminatorColumn을 꼭 설정해야 한다. @DiscriminatorValue를 지정하지 않으면 기본으로 엔티티 이름을 사용한다. (예 Moive, Album, Book) 7.1.3 구현 클래스마다 테이블 전략 구현 클래스마다 테이블 전략 Table per Concrete Class Stategy은 자식 엔티티마다 테이블을 만든다.\n자식 테이블 각각에 필요한 컬럼이 모두 있다.\n장점 서브 타입을 구분해서 처리할 때 효과적이다. not null 제약조건을 사용할 수 있다. 단점 여러 자식 테이블을 함께 조회할 때 성능이 느리다(SQL에 UNION을 사용해야 한다). 자식 테이블을 통합해서 쿼리하기 어렵다. 특징 구분 컬럼을 사용하지 않는다. 이 전략은 데이터베이스 설계자와 ORM 전문가 둘 다 추천하지 않는 전략이다. 조인이나 단일 테이블 전략을 고려하자.\n7.2 @MappedSuperclass 지금까지 학습한 상속 관계 매핑은 부모 클래스와 자식 클래스를 모두 데이터베이스 테이블과 매핑했다.\n부모 클래스는 테이블과 매핑하지 않고 부모 클래스를 상속받는 자식 클래스에게 매핑 정보만 제공하고 싶으면 @MappedSuperclass를 사용하면 된다.\n@MappedSuperclass는 비유를 하자면 추상 클래스와 비슷한데 @Entity는 실제 테이블과 매핑되지만 @MappedSuperclass는 실제 테이블과는 매핑되지 않는다.\n이것은 단순히 매핑 정보를 상속할 목적으로만 사용된다.\nBaseEntity에는 객체들이 주로 사용하는 공통 매핑 정보를 정의했다. 자식 엔티티들은 상속을 통해 BaseEntity의 매핑 정보를 물려받았다.\n여기서 BaseEntity는 테이블과 매핑할 필요가 없고 자식 엔티티에게 공통으로 사용되는 매핑 정보만 제공하면 된다.\n따라서 @MappedSuperclass를 사용\n부모로부터 물려받은 매핑 정보를 재정의하려면 @AttributeOverrides나 @AttributOoverride를 사용\n연관관계를 재정의하려면 @AssociationOverrides나 @AssociationOverride를 사용한다.\n​\t@MappedSuperclass의 특징 테이블과 매핑되지 않고 자식 클래스에 엔티티의 매핑 정보를 상속하기 위해 사용한다.\n@MappedSuperclass로 지정한 클래스는 엔티티가 아니므로 em.find()나 JPQL에 서 사용할 수 없다.\n이 클래스를 직접 생성해서 사용할 일은 거의 없으므로 추상 클래스로 만드는 것을 권장한다.\n@MappedSuperclass는 테이블과는 관계가 없고 단순히 엔티티가 공통으로 사용하는 매핑 정보를 모아주는 역할을 할 뿐이다.\nORM에서 이야기하는 진정한 상속 매핑은 객체 상속을 데이터베이스의 슈퍼타입 서브타입 관계와 매핑하는 것이다. @Mappedsuperclass를 사용하면 등록일자, 수정일자, 등록자, 수정자 같은 여러 엔티티에서 공통으로 사용하는 속성을 효과적으로 관리할 수 있다.\n엔티티(@Entity)는 @Entity 이거나 @MappedSuperclass로 지정한 클래스만 상속받을수 있다.\n7.3 복합 키와 식별 관계 매핑 7.3.1 식별 관계 vs 비식별 관계 데이터베이스 테이블 사이에 관계는 외래 키가 기본 키에 포함되는지 여부에 따라 식별 관계와 비식별 관계로 구분한다.\n식별 관계는 부모 테이블의 기본 키를 내려받아서 자식 테이블의 기본 키 + 외래 키로 사용하는 관계다.\n비식별 관계는 부모 테이블의 기본 키를 받아서 자식 테이블의 외래 키로만 사용하는 관계다.\n필수적 비식별 관계(Mandatory): 외래 키에 NULL을 허용하지 않는다. 연관관계를 필수적으로 맺어야 한다. 선택적 비식별 관계(Optional): 외래 키에 NULL을 허용한다. 연관관계를 맺을지 말지 선택할 수 있다. 데이터베이스 테이블을 설계할 때 식별 관계나 비식별 관계 중 하나를 선택해야 한다. 최근에는 비식별 관계를 주로 사용하고 꼭 필요한 곳에만 식별 관계를 사용하는 추세다. JPA는 식별 관계와 비식별 관계를 모두 지원한다. 7.3.2 복합 키: 비식별 관계 매핑 JPA에서 식별자를 둘 이상 사용하려면 별도의 식별자 클래스를 만들어야 한다.\n식별자 필드가 하나일 때는 보통 자바의 기본 타입을 사용하므로 문제가 없지만, 식별자 필드가 2개 이상이면 별도의 식별자 클래스를 만들고 그곳에 equals와 hashcode를 구현해야 한다.\nJPA는 복합 키를 지원하기 위해 @IdClass와 @EmbeddedId 2가지 방법을 제공하는데,\n@IdClass는 관계형 데이터베이스에 가까운 방법이고 @EmbeddedId는 좀 더 객체지향에 가까운 방법이다.\n@IdClass [ 식별자 클래스가 만족해야 하는 조건 ]\n식별자 클래스의 속성명과 엔티티에서 사용하는 식별자의 속성명이 같아야 한다. 예제의 Parent.id1과 Parentid.id1, 그리고 Parent.id2와 Parentid.id2가 같다. Serializable 인터페이스를 구현해야 한다. equals, hashCode를 구현해야 한다. 기본 생성자가 있어야 한다. 식별자 클래스는 public이어야 한다. 부모 테이블의 기본 키 컬럼이 복합 키이므로 자식 테이블의 외래 키도 복합 키다.\n따라서 외래 키 매핑 시 여러 컬럼을 매핑해야 하므로 @JoinColumn 어노테이션을 사용하고 각각의 외래 키 컬럼을 @JoinColumn으로 매핑한다.\n참고로 @JoinColumn의 name 속성과 referencedColumnName 속성의 값이 같으면 referencedColumnName은 생략해도 된다.\n@EmbeddedId Parent 엔티티에서 식별자 클래스를 직접 사용하고 @EmbeddedId 어노테이션을 적어주면 된다.\n@IdClass와는 다르게 @EmbeddedId를 적용한 식별자 클래스는 식별자 클래스에 기본 키를 직접 매핑한다.\n[ @EmbeddedId를 적용한 식별자 클래스가 만족해야 하는 조건 ]\n@Embeddable 어노테이션을 붙여주어야 한다.\nSerializable 인터페이스를 구현해야 한다.\nequals, hashCode를 구현해야 한다.\n기본 생성자가 있어야 한다.\n식별자 클래스는 public이어야 한다.\n복합 키와 equals, haseCode 자바의 모든 클래스는 기본으로 object 클래스를 상속받는데 이 클래스가 제공하는 기본 equals()는 **인스턴스 참조 값 비교인 == 비교(동일성 비교)**를 한다. 자바의 == 비교는, 코틀린의 == 비교와 다름 영속성 컨텍스트는 엔티티의 식별자를 키로 사용해서 엔티티를 관리한다. 식별자를 비교할 때 equals()와 hashcode() 를 사용한다. 따라서 식별자 **객체의 동등성(equals 비교)**이 지켜지지 않으면 영속성 컨텍스트가 엔티티를 관리하는 데 심각한 문제가 발생한다. 따라서 복합 키는 equals()와 hashcode()를 필수로 구현해야 한다. 식별자 클래스는 보통 equals()와 hashcode()를 구현할 때 모든 필드를 사용한다. @IdClass vs @EmbeddedId @EmbeddedId가 @IdClass와 비교해서 더 객체지향적이고 중복도 없어서 지만, 특정 상황에 JPQL이 조금 더 길어질 수 있다.\n7.3.5 일대일 식별 관계 일대일 식별 관계는 자식 테이블의 기본 키 값으로 부모 테이블의 기본 키 값만 사용한다.\n그래서 부모 테이블의 기본 키가 복합 키가 아니면 자식 테이블의 기본 키는 복합 키로 구성하지 않아도 된다.\nBoardDetail 처럼 식별자가 단순히 컬럼 하나면 @MapsId를 사용하고 속성 값은 비워두면 된다.\n이때 @MapsId는 @Id를 사용해서 식별자로지정한 BoardDetail.boardId와 매핑된다.\n@MapsId는 외래키와 매핑한 연관관계를 기본 키에도 매핑하겠다는 뜻이다.\n@MapsId의 속성 값은 @EmbeddedId를 사용한 식별자 클래스의 기본 키 필드를 지정하면 된다.\n7.3.6 식별, 비식별 관계의 장단점 [ 데이터베이스 설계 관점에서 식별 관계보다는 비식별 관계를 선호하는 이유 ]\n식별 관계는 부모 테이블의 기본 키를 자식 테이블로 전파하면서 자식 테이블의 기본 키 컬럼이 점점 늘어난다.\n예를 들어 부모 테이블은 기본 키 컬럼이 하나였지만 자식 테이블은 기본 키 컬럼이 2개, 손자는 기본 키 컬럼이 3개로 점점 늘어난다. 결국 조인할 때 SQL이 복잡해지고 기본 키 인덱스가 불필요하게 커질 수 있다. 식별 관계는 2개 이상의 컬럼을 합해서 복합 기본 키를 만들어야 하는 경우가 많다.\n식별 관계를 사용할 때 기본 키로 비즈니스 의미가 있는 자연 키 컬럼을 조합하는 경우가 많다.\n반면에 비식별 관계의 기본 키는 비즈니스와 전혀 관계없는 대리 키를 주로 사용한다. 식별 관계의 자연 키 컬럼들이 자식에 손자까지 전파되면 변경하기 힘들다. 식별 관계는 부모 테이블의 기본 키를 자식 테이블의 기본 키로 사용하므로 비식별 관계보다 테이블 구조가 유연하지 못하다.\n[ 객체 관계 매핑의 관점에서 비식별 관계를 선호하는 이유 ]\n일대일 관계를 제외하고 식별 관계는 2개 이상의 컬럼을 묶은 복합 기본 키를 사용한다. JPA에서 복합 키는 별도의 복합 키 클래스를 만들어서 사용해야 한다. 따라서 컬럼이 하나인 기본 키를 매핑하는 것보다 많은 노력이 필요하다. 비식별 관계의 기본 키는 주로 대리 키를 사용하는데 JPA는 @GenerateValue처럼 대리 키를 생성하기 위한 편리한 방법을 제공한다. [ 식별 관계가 가지는 장점도 존재 ]\n기본 키 인덱스를 활용하기 좋다.\n상위 테이블들의 기본 키 컬럼을 자식, 손자 테이블들이 가지고 있으므로 조인 없이 하위 테이블만으로 검색을 완료할 수 있다.\n[ 내용 정리 ]\nORM 신규 개발 진행시 추천하는 방법은 비식별 관계를 사용하고 기본 키는 Long 타입의 대리 키를 사용하는 것이다.\n대리 키는 비즈니스와 아무 관련이 없다. 따라서 비즈니스가 변경되어도 유연한 대처가 가능하다는 장점이 있다. 식별자의 데이터 타입은 Long을 추천, 자바에서 Integer는 20억 정도면 끝나지만, Long은 아주 커서(약 920경) 안전하다.\n선택적 비식별 관계보다는 필수적 비식별 관계를 사용하는 것이 좋다.\n선택적인 비식별 관계는 NULL을 허용하므로 조인할 때에 외부 조인을 사용해야 한다. 반면에 필수적 관계는 NOT NULL로 항상 관계가 있다는 것을 보장하므로 내부 조인만 사용해도 된다. 7.4 조인 테이블 [ 데이터베이스 테이블의 연관관계를 설계하는 2가지 방법 ]\n조인 컬럼 사용 (외래 키) 조인 테이블 사용 (테이블 사용) [ 조인 컬럼 ]\n선택적 비식별 관계는 외래 키에 NULL을 허용하므로 회원과 사물함을 조인할 때 외부 조인 OUTER JOIN을 사용해야 한다. 실수로 내부 조인을 사용하면 사물함과 관계가 없는 회원은 조회되지 않는다. 회원과 사물함이 아주 가끔 관계를 맺는다면 외래 키 값 대부분이 null로 저장되는 단점이 있다. [ 조인 테이블 ]\n연관관계를 관리하는 조인 테이블(MEMBER_LOCKER) 을 추가하고 여기서 두 테이블의 외래 키를 가지고 연관관계를 관리한다. 따라서 MEMBER와 LOCKER에는 연관관계를 관리하기 위한 외래 키 컬럼이 없다. 회원과 사물함 데이터를 각각 등록했다가 회원이 원할 때 사물함을 선택하면 MEMBER_LOCKER 테이블에만 값을 추가하면 된다. 조인 테이블의 큰 단점은 테이블을 하나 추가해야 한다는 점이다. 관리해야 하는 테이블이 늘어나고 회원과 사물함 두 테이블을 조인하려면 MEMBER_LOCKER 테이블 까지 추가로 조인해야 한다. 따라서 기본적으로 조인 컬럼을 사용하고, 필요하다고 판단되면 조인 테이블을 사용하자 객체와 테이블을 매핑할 때 조인 컬럼은 @JoinColumn으로 매핑하고 조인 테이블은 @JoinTable로 매핑한다. 조인 테이블을 연결 테이블, 링크 테이블로도 부른다. 조인 테이블에 컬럼을 추가하면 @JoinTable 전략을 사용할 수 없다.\n대신에 새로운 엔티티를 만들어서 조인 테이블과 매핑해야 한다.\n7.4.1 일대일 조인 테이블 일대일 관계를 만들려면 조인 테이블의 외래 키 컬럼 각각에 총 2개의 유니크 제약조건을 걸어야 한다\n(PARENT_ID는 기본 키이므로 유니크 제약조건이 걸려 있다.)\n[@JoinTable의 속성 ]\nname: 매핑할 조인 테이블 이름 joinColumns: 현재 엔티티를 참조하는 외래 키 inverseJoinColumns: 반대방향 엔티티를 참조하는 외래 키 7.4.2 일대다 조인 테이블 일대다 관계를 만들려면 조인 테이블의 컬럼 중 다(N) 와 관련된 컬럼인 CHILD_ID에 유니크 제약조건을 걸어야 한다\n(CHILD_ID 는 기본 키이므로 유니크 제약조건이 걸려 있다)\n7.4.3 다대일 조인 테이블 다대일은 일대다에서 방향만 반대이므로 조인 테이블 모양은 일대다와 같다.\n7.4.4 다대다 조인 테이블 다대다 관계를 만들려면 조인 테이블의 두 컬럼을 합해서 하나의 복합 유니크 제약조건을 걸어야 한다\n(PARENTD_ID, CHILD.ID는 복합 기본키이므로 유니크 제약조건이 걸려 있다)\n7.5 엔티티 하나에 여러 테이블 매핑 잘 사용하지는 않지만 @SecondaryTable을 사용하면 한 엔티티에 여러 테이블을 매핑할 수 있다.\n@SecondaryTable을 사용해서 두 테이블을 하나의 엔티티에 매핑하는 방법보다는, 테이블당 엔티티를 각각 만들어서 일대일 매핑하는 것을 권장한다.\n@SecondaryTable 방법은 항상 두 테이블을 조회하므로 최적화하기 어렵다.\n반면에 일대일 매핑은 원하는 부분만 조회 할 수 있고 필요하면 둘을 함께 조회하면 된다.\nReference 자바 ORM 표준 JPA 프로그래밍 (김영한) https://product.kyobobook.co.kr/detail/S000001766367 ","permalink":"https://2taezeat.github.io/posts/jpa/%EC%9E%90%EB%B0%94-orm-%ED%91%9C%EC%A4%80-jpa-ch07.-%EA%B3%A0%EA%B8%89-%EB%A7%A4%ED%95%91/","summary":"7.1 상속 관계 매핑 RDB에는 OOP의 상속이라는 개념이 없고, 슈퍼타입 서브타입 관계 라는 모델링 기법이 상속의 개념과 가장 유사하다.\nORM에서 상속 관계 매핑은 객체의 상속 구조와 DB의 슈퍼타입 서브 타입 관계를 매핑하는 것\n[ 슈퍼타입 서브타입 논리 모델을 실제 물리 모델인 테이블로 구현하는 3가지 방법 ]\n각각의 테이블로 변환: 각각을 모두 테이블로 만들고 조회할 때 조인을 사용한다. JPA에서는 조인 전략이라 한다. 통합 테이블로 변환: 테이블을 하나만 사용해서 통합한다. JPA에서는 단일 테이블 전략이라 한다.","title":"[자바 ORM 표준 JPA] ch07. 고급 매핑"},{"content":"6.1 다대일 (N:1) 6.1.1 다대일, 단방향, [N:1] @Joincolumn (name = \u0026quot;TEAM_ID\u0026quot;)를 사용해서 Member.team 필드를 TEAM_ID 외래 키와 매핑했다.\n따라서 Member.team 필드로 회원 테이블의 TEAM_ID 외래키를 관리한다.\n6.1.2 다대일, 양방향, [N:1, 1:N] 양뱡향은 외래 키가 있는 쪽이 연관관계의 주인이다. 일대다와 다대일 연관관계는 항상 다(N)에 외래 키가 있다. 여기서는 다쪽인 MEMBER 테이블이 외래 키를 가지고 있으므로 Member.team이 연관관계의 주인이다. JPA는 외래 키를 관리할 때 연관관계의 주인만 사용한다. 주인이 아닌 Team.members는 조회를 위한 JPQL이나 객체 그래프를 탐색할 때 사용한다. 양뱡향 연관관계는 항상 서로를 참조해야 한다. 항상 서로 참조하게 하려면 편의 메소드가 있으면 좋다, Ex) 회원의 setTeam(), 팀의 addMember() 양쪽에 다 작성하면 무한루프에 빠지므로 주의해야 한다. 6.2 일대다 (1:N) 6.2.1 일대다, 단방향, [1:N] 일대다 단방향 관계는 약간 특이한데, 엔티티의 Team.members로 회원 테이블의 TEAM_ID 외래 키를 관리한다.\n보통 자신이 매핑한 테이블의 외래 키를 관리하는데, 이 매핑은 반대쪽 테이블에 있는 외래 키를 관리한다.\n그럴 수밖에 없는 것이 일대다 관계에서 외래 키는 항상 다쪽 테이블에 있다. 하지만 다 쪽인 Member 엔티티에는 외래 키를 매핑할 수 있는 참조 필드가 없다. 대신에 반대쪽인 Team 엔티티에만 참조 필드인 members가 있다. 따라서 반대편 테이블의 외래 키를 관리하는 특이한 모습이 나타난다. 일대다 단방향 관계를 매핑할 때는 @JoinColumn을 명시해야 한다.\n그렇지 않으면 JPA는 조인 테이블(JoinTable) 전략을 기본으로 사용해서 매핑한다. [ 일대다 단방향 매핑의 단점 ]\n일대다 단방향 매핑의 단점은 매핑한 객체가 관리하는 외래 키가 다른 테이블에 있다는 점이다.\n본인 테이블에 외래 키가 있으면 엔티티의 저장과 연관관계 처리를 INSERT SQL 한 번으로 끝낼 수 있다\n하지만, 다른 테이블에 외래 키가 있으면 연관관계 처리를 위한 UPDATE SQL을 추가로 실행해야 한다.\n일대다 단방향 매핑보다는 다대일 양방향 매핑을 사용하자\n일대다 단방향 매핑을 사용하면 엔티티를 매핑한 테이블이 아닌 다른 테이블의 외래 키를 관리해야 한다. 성능 문제도 있지만 관리도 부담 문제를 해결하는 좋은 방법은 일대다 단방향 매핑 대신에 다대일 양방향 매핑을 사용하는 것이다. 6.2.2 일대다, 양방향, [1:N, N:1] 일대다 양방향 매핑은 존재하지 않는다. 대신 다대일 양방향 매핑을 사용해야 한다\n일대다 양방향과 다대일 양방향은 사실 똑같은 말이다. 여기서는 왼쪽을 연관관계의 주인으로 가정해서 분류했다. 예를 들어 다대일이면 다(N)가 연관관계의 주인이다. 더 정확히 말하자면 양방향 매핑에서 @OneToMany는 연관관계의 주인이 될 수 없다.\n왜냐하면 관계형 데이터베이스의 특성상 일대다, 다대일 관계는 항상 다쪽에 외래 키가 있다. 따라서 @OneToMany, @ManyToOne 둘 중에 연관관계의 주인은 항상 다 쪽인 @ManyToOne을 사용한 곳이다.\n이런 이유로 @ManyToOne에는 mappedBy 속성이 없다. 그렇다고 일대다 양방향 매핑이 완전히 불가능한 것은 아니다.\n일대다 단방향 매핑 반대편에 같은 외래 키를 사용하는 다대일 단방향 매핑을 읽기 전용으로 하나 추가하면 된다.\n하지만 일대다 단방향 매핑이 가지는 단점을 그대로 가지기 때문에, 될 수 있으면 다대일 양방향 매핑을 사용하자\n6.3 일대일 (1:1) 일대일 관계는 그 반대도 일대일 관계다. 테이블 관계에서 일대다, 다대일은 항상 다(N)쪽이 외래 키를 가진다. 반면에 일대일 관계는 주 테이블이나 대상 테이블 둘 중 어느 곳이나 외래 키를 가질 수 있다. 따라서 일대일 관계는 주 테이블이나 대상 테이블 중에 누가 외래 키를 가질지 선택해야 한다. 6.3.1 주 테이블에 외래 키 일대일 관계를 구성할 때 객체지향 개발자들은 주 테이블에 외래 키가 있는 것을 선호한다.\nJPA도 주 테이블에 외래 키가 있으면 좀 더 편리하게 매핑할 수 있다.\n단방향 일대일 관계이므로 객체 매핑에 @OneToOne을 사용했고 데이터베이스에는 LOCKER_ID 외래 키에 유니크 제약 조건(UNI) 을 추가했다. 이 관계는 다대일 단방향(@ManyToOne)과 거의 비슷하다. 양방향 양방향이므로 연관관계의 주인을 정해야 한다. MEMBER 테이블이 외래 키를 가지고 있으므로 Member 엔티티에 있는 Member.locker가 연관관계의 주인이다. 따라서 반대 매핑인 사물함의 Locker.member는 mappedBy를 선언해서 연관관계의 주인이 아니라고 설정 6.3.2 대상 테이블에 외래 키 단방향 양방향 일대일 매핑에서 대상 테이블에 외래 키를 두고 싶으면 이렇게 양방향으로 매핑한다. 주 엔티티인 Member 엔티티 대신에 대상 엔티티인 Locker를 연관관계의 주인으로 만들어서, LOCKER 테이블의 외래 키를 관리 6.4 다대다 (N:M) 관계형 데이터베이스는 정규화된 테이블 2개로 다대다 관계를 표현할 수 없다.\n그래서 보통 다대다 관계를 일대다, 다대일 관계로 풀어내는 연결 테이블을 사용한다.\n예를 들어 회원들은 상품을 주문한다. 반대로 상품들은 회원들에 의해 주문된다.\n둘은 다대다 관계다. 따라서 회원 테이블과 상품 테이블만으로는 이 관계를 표현할 수 없다.\n그런데 객체는 테이블과 다르게 객체 2개로 다대다 관계를 만들 수 있다.\n회원 객체는 컬렉션을 사용해서 상품들을 참조하면 되고 반대로 상품들도 컬렉션을 사용해서 회원들을 참조하면 된다.\n@ManyToMany를 사용하면 다대다 관계를 편리하게 매핑할 수 있다.\n6.4.1 다대다: 단방향 회원 엔티티와 상품 엔티티를 @ManyToMany로 매핑했다.\n중요한 점은 @ManyToMany와 @JoinTable을 사용해서 연결 테이블을 바로 매핑한 것이다.\n따라서 회원과 상품을 연결하는 회원_상품(Member_Product) 엔티티 없이 매핑을 완료할수 있다.\n@ManyToMany로 매핑한 덕분에 다대다 관계를 사용할 때는 이 연결 테이블을 신경 쓰지 않아도 된다.\n[ 연결 테이블을 매핑하는 @JoinTable의 속성 ]\n@JoinTable.name: 연결 테이블을 지정한다. 여기서는 MEMBER_PRODUCT 테이블을 선택 @JoinTable.joinColumns: 현재 방향인 회원과 매핑할 조인 컬럼 정보를 지정한다. MEMBER_ID로 지정 @JoinTable.inversejoinColumns: 반대 방향인 상품과 매핑할 조인 컬럼 정보를 지정한다. PRODUCT_ID로 지정 6.4.2 다대다: 양방향 6.4.3 다대다: 매핑의 한계와 극복, 연결 엔티티 사용 @ManyToMany를 사용하면 연결 테이블을 자동으로 처리해주므로 도메인 모델이 단순해지고 여러 가지로 편리하다.\n하지만 이 매핑을 실무에서 사용하기에는 한계가 있다. 회원이 상품을 주문하면 연결 테이블에 단순히 주문한 회원 아이디와 상품 아이디만 담고 끝나지 않는다.\n보통은 연결 테이블에 주문 수량 컬럼이나 주문한 날짜 같은 컬럼이 더 필요하다.\n결국, 연결 테이블을 매핑하는 연결 엔티티를 만들고 이곳에 추가한 컬럼들을 매핑해야 한다.\n그리고 엔티티 간의 관계도 테이블 관계처럼 다대다에서 일대다, 다대일 관계로 풀어야 한다.\n여기서는 회원상품(MemberProduct) 엔티티를 추가했다.\n회원상품(MemberProduct) 엔티티를 보면, 기본 키를 매핑하는 @Id 와 외래 키를 매핑하는 @JoinColumn을 동시에 사용해서 기본 키 + 외래 키를 한번에 매핑했다.\n그리고 @Idclass를 사용해서 복합 기본 키를 매핑했다.\n복합 기본 키 회원상품 엔티티는 기본 키가 MEMBER_ID와 PRODUCT_ID로 이루어진 복합 기본 키(=복합 키)\nJPA에서 복합 키를 사용하려면 별도의 식별자 클래스를 만들어야 한다.\n그리고 엔티티에 @IdClass를 사용해서 식별자 클래스를 지정하면 된다.\nMemberProductId 클래스를 복합 키를 위한 식별자 클래스로 사용한다.\n[ 복합 키를 위한 식별자 클래스 특징 ]\n복합 키는 별도의 식별자 클래스로 만들어야 한다. Serializable을 구현해야 한다. equals와 hashCode 메소드를 구현해야 한다. 기본 생성자가 있어야 한다. 식별자 클래스는 public이어야 한다. @ldClass를 사용하는 방법 외에 @EmbeddedId를 사용하는 방법도 있다. 회원상품(MemberProduct) 은 회원과 상품의 기본 키를 받아서 자신의 기본 키로 사용한다.\n이렇게 부모 테이블의 기본 키를 받아서 자신의 기본 키 + 외래 키로 사용하는 것을 식별 관계 (Identifying Relationship) 라 한다.\n지금까지는 기본 키가 단순해서 기본 키를 위한 객체를 사용하는 일이 없었지만 복합 키가 되면 이야기가 달라진다.\n복합 키는 항상 식별자 클래스를 만들어야한다. em.find()를 보면 생성한 식별자 클래스로 엔티티를 조회한다.\n복합 키를 사용하는 방법은 복잡하다. 복합 키를 사용하면 ORM 매핑에서 처리할 일이 상당히 많아진다.\n6.4.4 다대다: 새로운 기본 키 사용 추천하는 기본 키 생성 전략은 데이터베이스에서 자동으로 생성해주는 대리 키를 Long 값으로 사용하는 것이다.\n장점은 간편하고 거의 영구히 쓸 수 있으며, 비즈니스에 의존하지 않는다.\n또한 ORM 매핑 시에 복합 키를 만들지 않아도 되므로 간단히 매핑을 완성할 수 있다.\n식별자 클래스를 사용하지 않아서 코드가 한결 단순해짐\n이처럼 새로운 기본 키를 사용해서 다대다 관계를 풀어내는 것도 좋은 방법\n6.4.5 다대다 연관관계 정리 식별 관계: 받아온 식별자를 기본 키 + 외래 키로 사용한다. 비식별 관계: 받아온 식별자는 외래 키로만 사용하고 새로운 식별자를 추가한다. 식별자 클래스를 만들지 않아도 편리하게 ORM 매핑 가능 이런 이유로 식별 관계보다는 비식별 관계를 추천 6.5 활용 (Kotlin) 요구 사항 분석 및 설계 Code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 // build.gradle.kts에 아래 설정이 있다고 가정 // Kotlin으로 JPA을 쉽게 사용하기 위한 설정 plugins { kotlin(\u0026#34;plugin.jpa\u0026#34;) version \u0026#34;1.9.24\u0026#34; } allOpen { annotation(\u0026#34;jakarta.persistence.Entity\u0026#34;) annotation(\u0026#34;jakarta.persistence.Embeddable\u0026#34;) annotation(\u0026#34;jakarta.persistence.MappedSuperclass\u0026#34;) } noArg { annotation(\u0026#34;jakarta.persistence.Entity\u0026#34;) } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 package ~~ import jakarta.persistence.* import java.util.Date @Entity class Member( name: String, street: String, zipcode: String ) { @Id @GeneratedValue @Column(name = \u0026#34;MEMBER_ID\u0026#34;) var id: Long? = null protected set var name = name protected set var street = street protected set var zipcode = zipcode protected set @OneToMany(mappedBy = \u0026#34;member\u0026#34;) val orders: MutableList\u0026lt;Order\u0026gt; = mutableListOf() } enum class OrderStatus { ORDER, CANCEL } enum class DeliveryStatus { READY, COMP } @Entity @Table(name = \u0026#34;DELIVERY\u0026#34;) class Delivery( zipcode: String, status: DeliveryStatus ) { @Id @GeneratedValue @Column(name = \u0026#34;DELIVERY_ID\u0026#34;) var id: Long? = null protected set var zipcode = zipcode protected set @Enumerated(EnumType.STRING) var status: DeliveryStatus = status protected set @OneToOne(mappedBy = \u0026#34;delivery\u0026#34;) var order: Order? = null protected set fun associateWithOrder(order: Order) { this.order = order } } @Entity @Table(name = \u0026#34;ORDERS\u0026#34;) class Order( member: Member, orderDate: Date, status: OrderStatus ) { @Id @GeneratedValue @Column(name = \u0026#34;ORDER_ID\u0026#34;) var id: Long? = null protected set @Column(name = \u0026#34;MEMBER_ID\u0026#34;) var memberId: Long? = null protected set @Temporal(TemporalType.TIMESTAMP) var orderDate: Date = orderDate protected set @Enumerated(EnumType.STRING) var status: OrderStatus = status protected set @ManyToOne @JoinColumn(name = \u0026#34;MEMBER_ID\u0026#34;) var member: Member? = member protected set @OneToMany(mappedBy = \u0026#34;order\u0026#34;) val orderItems: MutableList\u0026lt;OrderItem\u0026gt; = mutableListOf() @OneToOne @JoinColumn(name = \u0026#34;DELIVERY_ID\u0026#34;) var delivery: Delivery? = null protected set fun settingMember(member: Member) { this.member?.let { it.orders.remove(this) } this.member = member member.orders.add(this) } fun addOrderItem(orderItem: OrderItem) { orderItem.order?.let { it.orderItems.remove(orderItem) } orderItems.add(orderItem) orderItem.associateWithOrder(this) } fun settingDelivery(delivery: Delivery) { this.delivery = delivery delivery.associateWithOrder(this) } } @Entity class OrderItem( orderPrice: Int, count: Int ) { @Id @GeneratedValue @Column(name = \u0026#34;ORDER_ITEM_ID\u0026#34;) var id: Long? = null protected set @Column(name = \u0026#34;ITEM_ID\u0026#34;) var itemID: Long? = null protected set var orderPrice: Int = orderPrice protected set var count: Int = count protected set @ManyToOne @JoinColumn(name = \u0026#34;ORDER_ID\u0026#34;) var order: Order? = null protected set fun associateWithOrder(order: Order) { this.order = order } } @Entity class Item( name: String, price: Int, stockQuantity: Int ) { @Id @GeneratedValue @Column(name = \u0026#34;ITEM_ID\u0026#34;) var id: Long? = null var name: String = name protected set var price: Int = price protected set var stockQuantity: Int = stockQuantity protected set } Reference 자바 ORM 표준 JPA 프로그래밍 (김영한) https://product.kyobobook.co.kr/detail/S000001766367 ","permalink":"https://2taezeat.github.io/posts/jpa/%EC%9E%90%EB%B0%94-orm-%ED%91%9C%EC%A4%80-jpa-ch06.-%EB%8B%A4%EC%96%91%ED%95%9C-%EC%97%B0%EA%B4%80%EA%B4%80%EA%B3%84-%EB%A7%A4%ED%95%91/","summary":"6.1 다대일 (N:1) 6.1.1 다대일, 단방향, [N:1] @Joincolumn (name = \u0026quot;TEAM_ID\u0026quot;)를 사용해서 Member.team 필드를 TEAM_ID 외래 키와 매핑했다.\n따라서 Member.team 필드로 회원 테이블의 TEAM_ID 외래키를 관리한다.\n6.1.2 다대일, 양방향, [N:1, 1:N] 양뱡향은 외래 키가 있는 쪽이 연관관계의 주인이다. 일대다와 다대일 연관관계는 항상 다(N)에 외래 키가 있다. 여기서는 다쪽인 MEMBER 테이블이 외래 키를 가지고 있으므로 Member.team이 연관관계의 주인이다. JPA는 외래 키를 관리할 때 연관관계의 주인만 사용한다. 주인이 아닌 Team.members는 조회를 위한 JPQL이나 객체 그래프를 탐색할 때 사용한다.","title":"[자바 ORM 표준 JPA] ch06. 다양한 연관관계 매핑"},{"content":"객체 관계 매핑 ORM 에서 가장 어려운 부분이 바로 객체 연관 관계와 테이블 연관관계를 매핑하는 일이다.\n방향(Direction):\n[ 단방향, 양방향 ]이 있다. 한 쪽만 참조하는 것을 단방향 관계라 하고, 양쪽 모두 서로 참조하는 것을 양방향 관계라 한다. 방향은 객체관계에만 존재하고 테이블 관계는 항상 양방향이다. 다중성(Multiplicity):\n[ 다대일(N:1), 일대다(1:N), 일대일(1:1), 다대다(N:M) ] 다중성이있다.\n예를 들어 회원과 팀이 관계가 있을 때 여러 회원은 한 팀에 속하므로 회원과 팀은 다대일 관계다.\n반대로 한 팀에 여러 회원이 소속될 수 있으므로 팀과 회원은 일대다 관계다.\n연관관계의 주인(Owner): 객체를 양방향 연관관계로 만들면 연관관계의 주인을 정해야 한다.\n5.1 단방향 연관관계 객체 연관관계와 테이블 연관관계의 가장 큰 차이 참조를 통한 연관관계는 언제나 단방향이다.\n객체간에 연관관계를 양방향으로 만들고 싶으면 반대쪽에도 필드를 추가해서 참조를 보관해야 한다.\n결국 연관관계를 하나 더 만들어야 한다. 이렇게 양쪽에서 서로 참조하는 것을 양방향 연관관계라 한다.\n하지만 정확히 이야기하면 이것은 양방향 관계가 아니라 서로 다른 단방향 관계 2개다. 반면에 테이블은 외래 키 하나로 양방향으로 조인할 수 있다.\n객체 연관관계 vs 테이블 연관관계 정리\n객체는 참조(주소) 로 연관관계를 맺는다. 객체 참조 단방향 객체를 양방향으로 참조하려면 단방향 연관관계를 2개 만들어야 한다. 테이블은 외래 키로 연관관계를 맺는다. 조인(join) 양방향 객체는 참조를 사용해서 연관관계를 탐색할 수 있는데 이것을 객체 그래프 탐색이라 한다.\nMember.team과 MEMBER.TEAM_ID를 매핑하는 것이 연관관계 매핑이다.\n@ManyToOne: 이름 그대로 다대일(N:1) 관계라는 매핑 정보다.\n회원과 팀은 다대일 관계다. 연관관계를 매핑할 때 이렇게 다중성을 나타내는 어노테이션을필수로 사용해야 한다. @JoinColumn(name=\u0026quot;TEAM_ID\u0026quot;): 조인 컬럼은 외래 키를 매핑할 때 사용한다.\nname 속성에는 매핑할 외래 키 이름을 지정한다. 회원과 팀 테이블은 TEAMLID 외래 키로 연관관계를 맺으므로 이 값을 지정하면 된다. 이 어노테이션은 생략할 수 있다. 5.2 연관관계 사용 JPA에서 엔티티를 저장할 때 연관된 모든 엔티티는 영속 상태여야 한다.\n5.2.1 저장 5.2.2 조회 [ 연관관계가 있는 엔티티를 조회 하는 방법 ]\n객체 그래프 탐색(객체 연관관계를 사용한 조회)\n객체지향 쿼리 사용; JPQL\nJPQL도 조인을 지원한다.\n조인해서 검색조건을 사용하면 된다.\n:teamName 과 같이 : 로 시작하는 것은 파라미터를 바인딩받는 문법이다.\n5.2.3 수정 엔티티의 값만 변경해두면 트랙잭션을 커밋할 때 플러시가 일어나면서 변경 감지 기능이 작동하고, 변경사항을 DB에 자동 반영한다.\n5.2.4 연관관계 제거 5.2.5 연관된 엔티티 삭제 연관된 엔티티를 삭제하려면 기존에 있던 연관관계를 먼저 제거하고 삭제해야 한다.\n그렇지 않으면 외래 키 제약조건으로 인해, 데이터베이스에서 오류가 발생한다.\n5.3 양방향 연관관계 팀에서도 회원으로 접근할 수 있도록 하자 회원 -\u0026gt; 팀 (Member.team) 다대일, N:1 팀 -\u0026gt; 회원 (Team.members) 일대다, 1:N 여러 건과 연관계를 맺을 수 있으므로, 컬렉션 사용 테이블은 외래 키 하나로 양방향 조회가 가능 A JOIN B, B JOIN A 둘 다 가능 5.4 연관관계의 주인 엄밀히 이야기하면 객체에는 양방향 연관관계라는 것이 없다.\n서로 다른 단방향 연관관계 2개를 애플리케이션 로직으로 잘 묶어서 양방향인 것처럼 보이게 할 뿐이다. 반면에 데이터베이스 테이블은 앞서 설명했듯이 외래 키 하나로 양쪽이 서로 조인할 수 있다.\n따라서 테이블은 외래 키 하나만으로 양방향 연관관계를 맺는다. 엔티티를 양방향 연관관계로 설정하면 객체의 참조는 둘인데 외래 키는 하나다. 따라서 둘 사이에 차이가 발생한다.\n그렇다면 둘 중 어떤 관계를 사용해서 외래 키를 관리해야 할까?\nJPA에서는 두 객체 연관관계 중 하나를 정해서 테이블의 외래키를 관리해야 하는데, 이를 연관관계의 주인(Owner) 이라 한다. 5.4.1 양방향 매핑의 규칙: 연관관계의 주인 양방향 연관관계 매핑 시 지켜야 할 규칙이 있는데 두 연관관계 중 하나를 연관관계의 주인으로 정해야 한다. 연관관계의 주인만이 데이터베이스 연관관계와 매핑되고 외래 키를 관리 (등록, 수정, 삭제) 반면에 주인이 아닌 쪽은 읽기만 할 수있다. 어떤 연관관계를 주인으로 정할지는 mappedBy 속성을 사용하면 된다. 주인은 mappedBy 속성을 사용하지 않는다. 주인이 아니면 mappedBy 속성을 사용해서 속성의 값으로 연관관계의 주인을 지정해야 한다. 연관관계의 주인을 정한다는 것은 사실 외래 키 관리자를 선택하는 것이다. 회원 테이블에 있는 TEAM_ID 외래 키를 관리할 관리자를 선택해야 한다. 회원 엔티티에 있는 Member.team을 주인으로 선택하면, 자기 테이블에 있는 외래 키를 관리하면 된다. 하지만 팀 엔티티에 있는 Team.members를 주인으로 선택하면 물리적으로 전혀 다른 테이블의 외래 키를 관리해야 한다. 비즈니스 로직상 더 중요하다고 연관관계의 주인으로 선택하면 안 된다.\n비즈니스 중요도를 배제하고 단순히 외래 키 관리자 정도의 의미만 부여해야 한다.\n5.4.2 연관관계의 주인은 외래 키가 있는 곳 데이터베이스 테이블의 다대일, 일대다 관계에서는 항상 다 쪽이 외래 키를 가진다.\n다 쪽인 @ManyToOne은 항상 연관관계의 주인이 되므로 mappedBy를 설정할 수 없다.\n따라서 @ManyToOne에는 mappedBy 속성이 없다.\n양방향 매핑 시에는 무한 루프에 빠지지 않게 조심해야 한다.\n예를 들어 Member.toString()에서 getTeam()을 호출하고 Team.toString()에서 getMember()를 호출하면 무한 루프에 빠질수 있다.\n이런 문제는 엔티티를 JSON으로 변환할 때 자주 발생, 그리고 Lombok이라는 라이브러리를 사용할 때도 자주 발생\nJSON 라이브러리들은 보통 무한루프에 빠지지 않도록 하는 어노테이션이나 기능을 제공한다.\n5.5 양방향 연관관계 저장 주인이 아닌 곳에 입력된 값은 외래 키에 영향을 주지 않는다. 양방향 연관관계는 연관관계의 주인이 외래 키를 관리한다. 따라서 주인이 아닌 방향은 값을 설정하지 않아도 데이터베이스에 외래 키 값이 정상 입력된다. 5.6 양방향 연관관계의 주의점 양방향 연관관계를 설정하고 가장 흔히 하는 실수는 연관관계의 주인에는 값을 입력하지 않고, 주인이 아닌 곳에만 값을 입력하는 것이다.\n5.6.1 순수한 객체까지 고려한 양방향 연관관계 그렇다면 정말 연관관계의 주인에만 값을 저장하고 주인이 아닌 곳에는 값을 저장하지 않아도 될까? 사실은 객체 관점에서 양쪽 방향에 모두 값을 입력해주는 것이 가장 안전하다. 양쪽 방향 모두 값을 입력하지 않으면 JPA를 사용하지 않는 순수한 객체 상태에서 심각한 문제가 발생할 수 있다. 객체까지 고려하면 이렇게 양쪽 다 관계를 맺어야 한다. Member.team: 연관관계의 주인, 이 값으로 외래 키를 관리한다. Team.members: 연관관계의 주인이 아니다. 따라서 저장 시에 사용되지 않는다. 5.6.2 연관관계 편의 메소드 양방향 관계에서 두 코드(회원 -\u0026gt; 팀, 팀 -\u0026gt; 회원)는 하나인 것처럼 사용하는 것이 안전하다. 양방향 관계를 설정하는 메소드를 연관관계 편의 메소드라 한다. 5.6.3 연관관계 편의 메소드 작성 시 주의사항 연관관계를 변경할 때는 기존 팀이 있으면 기존 팀과 회원의 연관관계를 삭제하는 코드를 추가해야 한다. Reference 자바 ORM 표준 JPA 프로그래밍 (김영한) https://product.kyobobook.co.kr/detail/S000001766367 ","permalink":"https://2taezeat.github.io/posts/jpa/%EC%9E%90%EB%B0%94-orm-%ED%91%9C%EC%A4%80-jpa-ch05.-%EC%97%B0%EA%B4%80%EA%B4%80%EA%B3%84-%EB%A7%A4%ED%95%91-%EA%B8%B0%EC%B4%88/","summary":"객체 관계 매핑 ORM 에서 가장 어려운 부분이 바로 객체 연관 관계와 테이블 연관관계를 매핑하는 일이다.\n방향(Direction):\n[ 단방향, 양방향 ]이 있다. 한 쪽만 참조하는 것을 단방향 관계라 하고, 양쪽 모두 서로 참조하는 것을 양방향 관계라 한다. 방향은 객체관계에만 존재하고 테이블 관계는 항상 양방향이다. 다중성(Multiplicity):\n[ 다대일(N:1), 일대다(1:N), 일대일(1:1), 다대다(N:M) ] 다중성이있다.\n예를 들어 회원과 팀이 관계가 있을 때 여러 회원은 한 팀에 속하므로 회원과 팀은 다대일 관계다.\n반대로 한 팀에 여러 회원이 소속될 수 있으므로 팀과 회원은 일대다 관계다.","title":"[자바 ORM 표준 JPA] ch05. 연관관계 매핑 기초"},{"content":"4.1 @Entity @Entity가 붙은 클래스는 JPA가 관리하는 것으로, 엔티티라 부른다.\n설정하지 않으면 클래스 이름을 그대로 사용한다.\n기본 생성자는 필수다 (파라미터가 없는 public 또는 protected 생성자).\nfinal, enum, interface, inner 클래스에는 사용할 수 없다.\n저장할 필드에 final을 사용하면 안 된다.\n4.2 @Table @Table은 엔티티와 매핑할 테이블을 지정한다. 4.3 다양한 매핑 사용 enum을 사용하려면 @Enumerated 어노테이션으로 매핑해야 한다. 날짜 타입은 @Temporal을 사용해서 매핑한다. @Lob을 사용하면 CLOB, BLOB 타입을 매핑할 수 있다. 4.4 데이터베이스 스키마 자동 생성 JPA는 데이터베이스 스키마를 자동으로 생성하는 기능을 지원한다.\n클래스의 매핑정보를 보면 어떤 테이블에 어떤 컬럼을 사용하는지 알 수 있다. JPA는 이 매핑정보와 데이터베이스 방언을 사용해서 데이터베이스 스키마를 생성한다.\n4.5 DDL 생성 기능 스키마 자동 생성하기를 통해 만들어지는 DDL에 제약조건을 추가\n유니크 제약조건\n이런 기능들은 단지 DDL을 자동 생성할 때만 사용되고 JPA의 실행 로직에는 영향을 주지 않는다.\n4.6 기본 키 매핑 [ JPA가 제공하는 데이터베이스 기본 키 생성 전략 ]\n직접 할당: 기본 키를 애플리케이션에서 직접 할당한다.\n자동 생성: 대리 키 사용 방식\nIDENTITY: 기본 키 생성을 데이터베이스에 위임한다.\nSEQUENCE: 데이터베이스 시퀀스를 사용해서 기본 키를 할당한다.\nTABLE: 키 생성 테이블을 사용한다.\n4.6.1 기본 키 직접 할당 전략 기본 키를 직접 할당하려면 다음 코드와 같이 @Id로 매핑하면 된다.\n기본 키 직접 할당 전략은 em.persist()로 엔티티를 저장하기 전에 애플리케이션에서 기본 키를 직접 할당하는 방법이다.\n4.6.2 자동 생성 전략, IDENTITY IDENTITY는 기본 키 생성을 데이터베이스에 위임하는 전략이다. 주로 MySQL, PostgreSQL, SQL Server, DB2에서 사용한다.\n@Generatedvalue의 strategy 속성 값을 GenerationType.IDENTITY로 지정하면 된다.\n4.6.3. 자동 생성 전략, SEQUENCE 데이터베이스 시퀀스는 유일한 값을 순서대로 생성하는 특별한 데이터베이스 오브젝트다. SEQUENCE 전략은 이 시퀀스를 사용해서 기본 키를 생성한다. 이 전략은 시퀀스를 지원하는 오라클, PostgreSQL, DB2, H2 데이터베이스에서 사용할수 있다. 4.6.4. 자동 생성 전략, TABLE TABLE 전략은 키 생성 전용 테이블을 하나 만들고 여기에 이름과 값으로 사용할 컬럼을 만들어 데이터베이스 시퀀스를 흉내내는 전략이다. 이 전략은 테이블을 사용하므로 모든 데이터베이스에 적용할 수 있다. TABLE 전략은 시퀀스 대신에 테이블을 사용한다는 것만 제외하면 SEQUENCE 전략과 내부 동작방식이 같다. 4.6.5. 자동 생성 전략, AUTO 데이터베이스의 종류도 많고 기본 키를 만드는 방법도 다양하다.\nGenerationType .AUTO 는 선택한 데이터베이스 방언에 따라 IDENTITY, SEQUENCE, TABLE 전략 중 하나를 자동으로 선택한다.\n예를 들어 오라클을 선택하면 SBQUENCE를, MySQL을 선택하면 IDENTITY를 사용한다.\nAUTO 전략의 장점은 데이터베이스를 변경해도 코드를 수정할 필요가 없다는 것이다. 특히 키 생성 전략이 아직 확정되지 않은 개발 초기 단계나 프로토타입 개발 시 편리하게 사용할 수 있다. AUTO를 사용할 때 SEQUENCEL TABLE 전략이 선택되면 시퀀스나 키 생성용 테이블을 미리 만들어 두어야 한다. 스키마 자동 생성 기능을 사용한다면, 하이버네이트가 기본값을 사용해서 적절한 시퀀스나 키 생성용 테이블을 만든다. 4.6.6 기본 키 매핑 정리 직접 할당: em.persist()를 호출하기 전에 애플리케이션에서 직접 식별자 값을 할당해야 한다.\n만약 식별자 값이 없으면 예외가 발생한다. IDENTITY: 데이터베이스에 엔티티를 저장해서 식별자 값을 획득한 후, 영속성 컨텍스트에 저장한다\nIDENTITY 전략은 테이블에 데이터를 저장해야 식별자 값을 획득할 수 있다. SEQUENCE: 데이터베이스 시퀀스에서 식별자 값을 획득한 후, 영속성 컨텍스트에 저장한다.\nTABLE: 데이터베이스 시퀀스 생성용 테이블에서 식별자 값을 획득한 후, 영속성 컨텍스트에 저장한다.\n[ 권장하는 식별자 선택 전략 ]\n데이터베이스 기본 키는 다음 3가지 조건을 모두 만족해야 한다.\nnull값은 허용하지 않는다.\n유일해야 한다.\n변해선 안 된다.\n테이블의 기본 키를 선택하는 전략은 크게 2가지가 있다.\n자연 키(natural key)\n비즈니스에 의미가 있는 키\n예: 주민등록번호, 이메일, 전화번호\n대리 키(surrogate key)\n비즈니스와 관련 없는 임의로 만들어진 키, 대체 키로도 불린다.\n예: 오라클 시퀀스, auto_increment, 키생성 테이블 사용\n자연 키보다는 대리 키를 권장\n비즈니스 환경은 언젠가 변하기 때문 JPA는 모든 엔티티에 일관된 방식으로 대리 키 사용을 권장한다\n기본 키는 변하면 안 된다는 기본 원칙으로 인해, 저장된 엔티티의 기본 키 값은 절대 변경하면 안 된다.\n이 경우 JPA는 예외를 발생시키거나 정상 동작하지 않는다. setd() 같이 식별자를 수정하는 메소드를 외부에 공개하지 않는 것도 문제를 예방하는 하나의 방법이 될 수 있다. 4.7 필드와 컬럼 매핑: 레퍼런스 4.8 기본 매핑 활용 (Kotlin) 요구 사항 분석 및 설계 Code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 // build.gradle.kts에 아래 설정이 있다고 가정 // Kotlin으로 JPA을 쉽게 사용하기 위한 설정 plugins { kotlin(\u0026#34;plugin.jpa\u0026#34;) version \u0026#34;1.9.24\u0026#34; } allOpen { annotation(\u0026#34;jakarta.persistence.Entity\u0026#34;) annotation(\u0026#34;jakarta.persistence.Embeddable\u0026#34;) annotation(\u0026#34;jakarta.persistence.MappedSuperclass\u0026#34;) } noArg { annotation(\u0026#34;jakarta.persistence.Entity\u0026#34;) } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 package ~~~~~ import jakarta.persistence.* import java.util.Date @Entity class Member( name: String, street: String, zipcode: String ) { @Id @GeneratedValue @Column(name = \u0026#34;MEMBER_ID\u0026#34;) var id: Long? = null protected set var name = name protected set var street = street protected set var zipcode = zipcode protected set } enum class OrderStatus { ORDER, CANCEL } @Entity @Table(name = \u0026#34;ORDERS\u0026#34;) class Order( orderDate: Date, status: OrderStatus ) { @Id @GeneratedValue @Column(name = \u0026#34;ORDER_ID\u0026#34;) var id: Long? = null protected set @Column(name = \u0026#34;MEMBER_ID\u0026#34;) var memberId: Long? = null protected set @Temporal(TemporalType.TIMESTAMP) var orderDate: Date = orderDate protected set @Enumerated(EnumType.STRING) var status: OrderStatus = status protected set } @Entity class OrderItem( orderPrice: Int, count: Int ) { @Id @GeneratedValue @Column(name = \u0026#34;ORDER_ITEM_ID\u0026#34;) var id: Long? = null protected set @Column(name = \u0026#34;ITEM_ID\u0026#34;) var itemID: Long? = null protected set @Column(name = \u0026#34;ORDER_ID\u0026#34;) var orderId: Long? = null protected set var orderPrice: Int = orderPrice protected set var count: Int = count protected set } @Entity class Item( name: String, price: Int, stockQuantity: Int ) { @Id @GeneratedValue @Column(name = \u0026#34;ITEM_ID\u0026#34;) var id: Long? = null var name: String = name protected set var price: Int = price protected set var stockQuantity: Int = stockQuantity protected set } Reference 자바 ORM 표준 JPA 프로그래밍 (김영한) https://product.kyobobook.co.kr/detail/S000001766367\n코틀린 JPA Entity 작성법\n스포카에서 Kotlin으로 JPA Entity를 정의하는 방법\n","permalink":"https://2taezeat.github.io/posts/jpa/%EC%9E%90%EB%B0%94-orm-%ED%91%9C%EC%A4%80-jpa-ch04.-%EC%97%94%ED%8B%B0%ED%8B%B0-%EB%A7%A4%ED%95%91/","summary":"4.1 @Entity @Entity가 붙은 클래스는 JPA가 관리하는 것으로, 엔티티라 부른다.\n설정하지 않으면 클래스 이름을 그대로 사용한다.\n기본 생성자는 필수다 (파라미터가 없는 public 또는 protected 생성자).\nfinal, enum, interface, inner 클래스에는 사용할 수 없다.\n저장할 필드에 final을 사용하면 안 된다.\n4.2 @Table @Table은 엔티티와 매핑할 테이블을 지정한다. 4.3 다양한 매핑 사용 enum을 사용하려면 @Enumerated 어노테이션으로 매핑해야 한다. 날짜 타입은 @Temporal을 사용해서 매핑한다. @Lob을 사용하면 CLOB, BLOB 타입을 매핑할 수 있다. 4.4 데이터베이스 스키마 자동 생성 JPA는 데이터베이스 스키마를 자동으로 생성하는 기능을 지원한다.","title":"[자바 ORM 표준 JPA] ch04. 엔티티 매핑"},{"content":"3.1 엔티티 매니저 팩토리와 엔티티 매니저 엔티티 매니저는 엔티티와 관련된 모든 일을 처리 (CRUD 등) 개발자 입장에서는 엔티티 매니저를 가상의 DB라고 생각하면 된다 엔티티 매니저 팩토리는 여러 스레드가 동시에 접근해도 안전하므로 서로 다른 스레드 간에 공유해도 된다 엔티티 매니저는 여러 스레드가 동시에 접근하면 동시성 문제가 발생하므로 스레드 간에 절대 공유하면 안 된다. 엔티티 매니저는 데이터베이스 연결(connection)은 트랜잭션을 시작할 때 획득 3.2 영속성 컨텍스트란? 영속성 컨텍스트(persistence context) 는 엔티티를 영구 저장하는 환경 이다. 엔티티 매니저는 영속성 컨텍스트에 엔티티를 보관 및 관리 persist() 메서드는 엔티티 매니저를 사용해서 회원 엔티티를 영속성 컨텍스트에 저장 논리적인 개념에 가깝다. 3.3 엔티티의 생명주기 비영속(new/transient) : 영속성 컨텍스트와 전혀 관계가 없는 상태\n영속(managed) : 영속성 컨텍스트에 저장된 상태, 영속성 컨텍스트가 관리하는 상태\n​\tem.find() 나 JPQL 을 사용해서 조회한 엔티티도 영속 상태이다. 준영속(detached) : 영속성 컨텍스트에 저장되었다가 분리된 상태\n특정 엔티티를 준영속 상태로 만들려면 em.detach() 를 호출하면 된다 em.close() ,em.clear() 로 영속성 컨텍스트를 초기화 해도 관리하던 엔티티는 준영속 상태가 된다 삭제(removed) : 엔티티를 영속성 컨텍스트와 DB에 삭제된 상태\n3.4 영속성 컨텍스트의 특징 영속성 컨텍스트와 식별자 값\n영속성 컨텍스트는 엔티티를 식별자 값(@Id 로 테이블의 기본 키와 매핑한 값)으로 구분한다.\n따라서 영속 상태는 식별자 값이 반드시 있어야 한다.\n식별자 값이 없으면 예외가 발생한다.\n영속성 컨텍스트에 엔티티를 저장하면 이 엔티티는 언제 데이터베이스에 저장될까?\nJPA는 보통 트랜잭션을 커밋하는 순간 영속성 컨텍스트에 새로 저장된 엔티티를 데이터베이스에 반영, 이것을 플러시(flush) 라 한다. 영속성 컨텍스트가 엔티티를 관리할 때 장점\n1차 캐시\n동일성 보장\n트랜잭션을 지원하는 쓰기 지연\n변경 감지\n지연 로딩\n3.4.1 엔티티 조회 영속성 컨텍스트는 내부에 캐시를 가지고 있는데 이것을 1차 캐시라 한다.\n1차 캐시의 키는 식별자 값, 영속성 컨텍스트에 데이터를 저장, 조회하는 모든 기준은 DB의 기본 키 값\n1차 캐시에서 조회 DB에서 조회 만약 em.find() 를 호출했는데 엔티티가 1차 캐시에 없으면 엔티티 매니저는 데이터베이스를 조회해서 엔티티를 생성한다. 그리고 1차 캐시에 저장한 후에 영속 상태의 엔티티를 반환한다. 영속 엔티티의 동일성 보장 1 2 3 4 Menber a = em.find(Member.class, \u0026#34;member1\u0026#34;); Member b = em.find(Member.class, \u0026#34;member1\u0026#34;); a == b // true em.find(Member.class, \u0026quot;member1\u0026quot;); 을 반복 호출 해도, 1차 캐시에 있는 같은 엔티티 인스턴스를 반환한다. JPA는 1차 캐시를 통해 반복 가능한 읽기(REPEATABLE READ) 등급의 트랜잭션 격리 수준을 DB가 아닌 App 차원에서 제공한다는 장점이 있다.\n3.4.2 엔티티 등록 엔티티 매니저는 트랜잭션을 커밋하기 직전까지 데이터베이스에 엔티티를 저장하지 않고, 내부 쿼리 저장소에 INSERT SQL을 차곡차곡 모아둔다.\n트랜잭션을 커밋할 때 모아둔 쿼리를 데이터베이스에 보낸다.\n이것을 트랜잭션을 지원하는 쓰기 지연 transactional write-behind이라 한다. 트랜잭션을 커밋하면 엔티티 매니저는 우선 영속성 컨텍스트를 플러시한다.\n플러시는 영속성 컨텍스트의 변경 내용을 데이터베이스에 동기화하는 작업\n이때 등록, 수정, 삭제한 엔티티를 데이터베이스에 반영한다. 쓰기 지연 SQL 저장소에 모인 쿼리를 데이터베이스에 보낸다. 이렇게 영속성 컨텍스트의 변경 내용을 데이터베이스에 동기화한 후에 실제 데이터베이스 트랜잭션을 커밋한다. 트랜잭션을 지원하는 쓰기 지연이 가능한 이유 데이터베이스에 전달해도 트랜잭션을 커밋하지 않으면 아무 소용이 없다. 어떻게든 커밋 직전에만 데이터베이스에 SOL을 전달하면 된다. 이것이 트랜잭션을 지원하는 쓰기 지연이 가능한 이유 이를 활용해, 모아둔 등록 쿼리를 데이터베이스에 한 번에 전달해서 성능을 최적화할 수 있다. 3.4.3 엔티티 수정 JPA로 엔티티를 수정할 때는 단순히 엔티티를 조회해서 데이터만 변경하면 된다. 트랜잭션 커밋 직전에 주석으로 처리된 em.update() 메소드를 실행해야 할 것 같지만 이런 메소드는 없다. 엔티티의 변경사항을 데이터베이스에 자동으로 반영하는 기능을 변경 감지(dirty checking) 라 한다. JPA는 엔티티를 영속성 컨텍스트에 보관할 때. 최초 상태를 복사해서 저장해두는데 이것을 스냅샷이라 한다. 그리고 플러시 시점에 스냅샷과 엔티티를 비교해서 변경된 엔티티를 찾는다. 변경된 엔티티가 있으면 수정 쿼리를 생성해서 쓰기 지연 SQL 저장소에 보내고, 이후 등록 과정이 진행된다. 변경 감지는 영속성 컨텍스트가 관리하는 영속 상태의 엔티티에만 적용된다.\nJPA의 기본 전략은 엔티티의 모든 필드를 업데이트한다.\n모든 필드를 사용하면 수정 쿼리가 항상 같다(물론 바인딩되는 데이터는 다르다). 따라서 애플리케이션 로딩 시점에 수정 쿼리를 미리 생성해두고 재사용할 수 있다. 데이터베이스에 동일한 쿼리를 보내면 데이터베이스는 이전에 한 번 파싱된 쿼리를 재사용할 수 있다. org.hibernate.annotations.Dynamicupdate 어노테이션으로 수정된 데이터만 사용해서 동적으로 UPDATE SQL을 생성할 수 도 있다.\n3.4.4 엔티티 삭제 엔티티 삭제하려면 삭제 대상 엔티티를 조회(find) 해야 한다. 삭제 과정은 엔티티 등록 과정과 비슷하다 삭제된 엔티티는 재사용 하지 말고, GC의 대상이 두는 것이 좋다. 3.5 플러시 플러시;flush() 는 영속성 컨텍스트의 변경 내용을 데이터베이스에 반영, 동기화한다.\n플러시를 실행하면 일어나는 일 변경 감지가 동작해서 영속성 컨텍스트에 있는 모든 엔티티를 스냅샷과 비교해서 수정된 엔티티를 찾는다.\n수정된 엔티티는 수정 쿼리를 만들어 쓰기 지연 SQL 저장소에 등록 쓰기 지연 SQL 저장소의 쿼리를 데이터베이스에 전송한다 (등록, 수정, 삭제 쿼리)\n영속성 컨텍스트를 플러시하는 방법 em.flush() 를 직접 호출한다.\n테스트때 에만 주로 사용 트랜잭션 커밋 시, 플러시가 자동 호출 된다.\n커밋만 하고, SQL을 하지 않으면 DB에 데이터 갱신이 일어나지 않는다.\n이 문제 예방하기 위해 커밋할 때 플러시를 자동 호출\nJPQL 쿼리 실행 시, 플러시가 자동 호출 된다.\n​\t변경 내용을 DB에 반영해야 JPQL으로 엔티티 조회가 가능하다.\n참고로 식별자를 기준으로 조회하는 find() 메서드를 호출할 때는 플러시가 실행되지 않는다.\n3.5.1 플러시 모드 옵션 FlushModeType.AUTO: 커밋이나 쿼리를 실행할 때 플러시 (기본값) FlushModeType.COMMIT: 커밋할 때만 플러시 데이터베이스와 동기화를 최대한 늦추는 것이 가능한 이유는 트랜잭션이라는 작업 단위가 있기 때문이다.\n트랜잭션 커밋 직전에만 변경 내용을 데이터베이스에 보내 동기화하면 된다.\n3.6 준영속 준영속 상태의 엔티티는 영속성 컨텍스트가 제공하는 기능을 사용할 수 없다.\n엔티티를 준영속 상태로 만드는 방법 em.detach(entity): 특정 엔티티만 준영속 상태로 전환한다. em.clear(): 영속성 컨텍스트를 완전히 초기화한다. em.close(): 영속성 컨텍스트를 종료한다. 병합; merge() = 준영속에서 다시 영속상태로 변경 병합(merge)은 준영속, 비영속을 신경 쓰지 않는다.\n식별자 값으로 엔티티를 조회할 수 있으면 불러서 병합하고 조회할 수 없으면 새로 엔티티를 생성해서 병합한다.\n따라서 병합은 save or update 기능을 수행한다.\nReference 자바 ORM 표준 JPA 프로그래밍 (김영한) https://product.kyobobook.co.kr/detail/S000001766367 ","permalink":"https://2taezeat.github.io/posts/jpa/%EC%9E%90%EB%B0%94-orm-%ED%91%9C%EC%A4%80-jpa-ch03.-%EC%98%81%EC%86%8D%EC%84%B1-%EA%B4%80%EB%A6%AC/","summary":"3.1 엔티티 매니저 팩토리와 엔티티 매니저 엔티티 매니저는 엔티티와 관련된 모든 일을 처리 (CRUD 등) 개발자 입장에서는 엔티티 매니저를 가상의 DB라고 생각하면 된다 엔티티 매니저 팩토리는 여러 스레드가 동시에 접근해도 안전하므로 서로 다른 스레드 간에 공유해도 된다 엔티티 매니저는 여러 스레드가 동시에 접근하면 동시성 문제가 발생하므로 스레드 간에 절대 공유하면 안 된다. 엔티티 매니저는 데이터베이스 연결(connection)은 트랜잭션을 시작할 때 획득 3.2 영속성 컨텍스트란? 영속성 컨텍스트(persistence context) 는 엔티티를 영구 저장하는 환경 이다.","title":"[자바 ORM 표준 JPA] ch03. 영속성 관리"},{"content":"2.4 객체 매핑 시작 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 package ~~~ import javax.persistence.*; @Entity @Table(name = \u0026#34;MEMBER\u0026#34;) public class Member { @ID @Column(name = \u0026#34;ID\u0026#34;) private String id; @Column (name = \u0026#34;NAME\u0026#34;) private String username; // 매핑 정보가 없는 필드 private Integer age; } @Entitiy\n이 클래스를 테이블과 매핑한다고 JPA에게 알려줌 @Entitiy가 사용된 클래스를 엔티티 클래스라 한다. @Table\n엔티티 클래스에 매핑할 테이블 정보를 알려준다. 이 어노테이션을 생략하면, 클래스 이름을 테이블 이름으로 매핑한다. @Id\n엔티티 클래스의 필드를 테이블의 기본 키(Primary Key) 에 매핑 @Id 가 사용된 필드를 식별자 필드라 한다. @Column\n필드를 컬럼에 매핑 매핑 정보가 없는 필드\n매핑 어노테이션을 생략하면 필드명을 사용해서 컬럼명으로 매핑한다. 2.5 속성 설정 주로 사용하는 속성 Spring Boot에서 JPA를 사용하는 경우, persistence.xml 파일은 꼭 필요하지 않습니다. Spring Boot는 persistence.xml 파일 없이도 애플리케이션을 설정하고 동작할 수 있도록 자동 설정 기능을 제공합니다.\n대신, Spring Boot에서는 애플리케이션 속성 파일(application.properties 또는 application.yml)을 사용하여 JPA 관련 설정을 수행합니다.\nSpring Boot는 @SpringBootApplication 애노테이션을 통해 자동으로 JPA 관련 설정을 감지하고, 별도의 persistence.xml 파일 없이도 애플리케이션을 구성합니다\npersistence.xml이 필요한 경우 일반적으로 Spring Boot와 JPA를 사용할 때 persistence.xml은 필요하지 않지만, 다음과 같은 특정한 경우에는 사용할 수 있습니다\n기존의 전통적인 JPA 설정을 그대로 유지해야 할 때 복잡한 JPA 설정이나 여러 개의 영속성 유닛을 설정해야 할 때 Spring Boot의 자동 설정을 우회하여 특정 설정을 수동으로 처리해야 할 때 2.5.1 데이터베이스 방언 JPA는 특정 데이터베이스에 종속되지 않는다.\n다른 데이터베이스로 쉽게 교체 가능 하지만, 각 데이터베이스가 제공하는 SQL 문법과 함수가 다를 수 있다. SQL 표준을 지키지 않거나 특정 데이터베이스만의 고유한 기능을 JPA에서는 방언(Dialect) 이라 한다.\nJPA 구현체들은 다양한 데이터베이스 방언 클래스를 제공한다.\n2.6 애플리케이션 개발 2.6.1 엔티티 매니저 설정 엔티티 매니저 팩토리 설정 JPA를 시작하려면 설정 정보를 사용해서 엔티티 매니저 팩토리를 생성해야 한다. 설정 정보를 읽어서 JPA를 동작시키기 위한 기반 객체를 만들고 JPA 구현체에 따라서는 데이터베이스 커넥션 풀도 생성 따라서, 엔티티 매니저 팩토리를 생성하는 비용은 아주 크다. 엔티티 매니저 팩토리는 애플리케이션 전체에서 딱 한 번만 생성하고 공유해서 사용해야 한다. val emf = Persistence.createEntityManagerFactory(\u0026quot;~~~\u0026quot;) 엔티티 매니저 생성 엔티티 매니저 팩토리에서 엔티티 매니저를 생성한다. JPA의 기능 대부분은 이 엔티티 매니저가 제공한다. 대표적으로 엔티티 매니저를 사용해서 엔티티를 데이터베이스에 등록/수정/삭제/조회할 수 있다. 엔티티 매니저는 내부에 데이터베이스 커넥션를 유지하면서 데이터베이스와 통신한다. 따라서 애플리케이션 개발자는 엔티티 매니저를 가상의 데이터베이스로 생각할 수 있다. val em = emf.ceateEntityManager() 종료 사용이 끝난 엔티티 매니저는 반드시 종료해야 한다.\nem.close() App이 종료할 때 엔티티 매니저 팩토리도 종료해야 한다.\nemf.close() 2.6.2 트랜잭션 관리 JPA를 사용하면 항상 트랜잭션 안에서 데이터를 변경해야 한다. 트랜잭션 없이 데이터를 변경하면 예외가 발생한다. 트랜잭션을 시작하려면 엔티티 매니저에서 트랜잭션 API를 받아와야 한다. 2.6.3 비즈니스 로직과 JPQL JPA를 사용하면 애플리케이션 개발자는 엔티티 객체를 중심으로 개발하고 데이터베이스에 대한 처리는 JPA에 맡겨야 한다.\n등록, 수정, 삭제, 한 건 조회는, SQL을 전혀 사용하지 않아도 된다.\n문제는 검색 쿼리다. JPA는 엔티티 객체를 중심으로 개발하므로 검색을 할 때도 테이블이 아닌 엔티티 객체를 대상으로 검색해야 한다.\n그런데 테이블이 아닌 엔티티 객체를 대상으로 검색하려면 데이터베이스의 모든 데이터를 애플리케이션으로 불러와서 엔티티 객체로 변경한 다음 검색해야 하는데, 이는 사실상 불가능하다.\n결국 검색 조건이 포함된 SQL을 사용해야 한다. JPA는 JPQL(Java Persistence Query Language) 이라는 쿼리 언어로 이를 해결한다.\nJPA는 SQL을 추상화한 JPQL이라는 객체지향 퀴리 언어를 제공\nJPQL은 엔티티 객체를 대상으로 쿼리한다. 쉽게 이야기해서 클래스와 필드를 대상으로 쿼리한다.\nselect m from Member m 이 바로 JPQL 이다.\nfrom Member는 MEMBER 테이블이 아니라, Member 엔티티 객체를 말한다.\nJPQL은 데이터베이스 테이블을 전혀 알지 못한다.\nJPA는 JPQL을 분석해서 다음과 같은 적절한 SQL을 만들어 데이터베이스에서 데이터를 조회한다.\nSELECT M.ID, M.NAME, M.AGE FROM MEMBER M Reference 자바 ORM 표준 JPA 프로그래밍 (김영한) https://product.kyobobook.co.kr/detail/S000001766367 ","permalink":"https://2taezeat.github.io/posts/jpa/%EC%9E%90%EB%B0%94-orm-%ED%91%9C%EC%A4%80-jpa-ch02.-jpa-%EC%8B%9C%EC%9E%91/","summary":"2.4 객체 매핑 시작 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 package ~~~ import javax.persistence.*; @Entity @Table(name = \u0026#34;MEMBER\u0026#34;) public class Member { @ID @Column(name = \u0026#34;ID\u0026#34;) private String id; @Column (name = \u0026#34;NAME\u0026#34;) private String username; // 매핑 정보가 없는 필드 private Integer age; } @Entitiy\n이 클래스를 테이블과 매핑한다고 JPA에게 알려줌 @Entitiy가 사용된 클래스를 엔티티 클래스라 한다. @Table\n엔티티 클래스에 매핑할 테이블 정보를 알려준다.","title":"[자바 ORM 표준 JPA] ch02. JPA 시작"},{"content":"1.1 SQL을 직접 다룰 때 발생하는 문제점 1.1.1 반복 데이터베이스는 객체 구조와는 다른 데이터 중심의 구조를 가짐, 개발자가 객체지향 App과 DB 중간에서 SQL과 JDBC API를 사용해서 변환 작업을 해야 함 테이블에 비례해서 SQL를 개발자가 작성해야 함, 지루하고 반복적인 일 1.1.2 SQL에 의존적인 개발 App에서 문제가 생기면, DAO를 열어서 어떤 SQL이 실행되는지 확인해야 함, 계층 분할이 어려움 어떤 SQL이 실행되고 어떤 객체들이 함께 조회되는지 일일이 확인해야 함. 엔티티를 신뢰할 수 없음 1.1.3 JPA와 문제 해결 JPA가 제공하는 API로, JPA가 자동으로 생성하는 적절한 SQL로 SQL을 직접 다룰 때 발생하는 문제점를 해결 1.2 패러다임의 불일치 OOP는 추상화, 캡슐화, 정보은닉, 상속, 다형성 등 시스템의 복잡성을 제어할 수 있는 다양한 장치들을 제공한다.\n비즈니스 요구사항을 정의한 도메인 모델도/객체로 모델링하면 객체지향 언어가 가진 장점들을 활용할 수 있다.\n문제는 이렇게 정의한 도메인 모델을저장할 때발생한다.\n예를 들어, 특정 유저가 시스템에 회원 가입하면 회원이라는 객체 인스턴스를 생성한 후에 이 객체를 메모리가 아닌 어딘가에 영구 보관해야 한다. RDBMS에 객체를 저장하는 것인데, RDBMS는 데이터 중심으로 구조화되어 있고, 집합적인 사고를 요구한다.\n객체지향에서 이야기하는 추상화, 상속, 다형성 같은 개념이 없다. 객체와 관계형 데이터베이스는 지향하는 목적서로 다르므로 둘의 기능과 표현 방법도 다르다.\n이것을 객체와 관계형 데이터베이스의 패러다임 불일치 문제라한다. 따라서 객체 구조를 테이블 구조에 저장하는 데는 한계가 있다. 1.2.1 JPA와 상속 JPA는 상속과 관련된 패러다임의 불일치 문제를 개발자 대신 해결해준다. 개발자는 마치 자바 컬렉션에 객체를 저장하듯이 JPA에게 객체를 저장하면 된다. 1.2.2 연관관계 객체는 참조를 사용해서 다른 객체와 연관관계를 가지고 참조에 접근해서 연관된 객체를 조회한다. 객체는 참조가 있는 방향으로만 조회 가능 반면에 테이블은 외래 키를 사용해서 다른 테이블과 연관관계를가지고 조인을 사용해서 연관된 테이블을 조회한다. 테이블은 외래 키 하나로 모든 테이블 조회 가능 1.2.3 객체 그래프 탐색 객체에서 회원이 소속된 팀을 조회할 때는 다음처럼 참조를 사용해서 연관된 팀을 찾으면 되는데, 이것을 객체 그래프 탐색이라 한다.\nval team = member.team // kotlin 코드 객체는 마음껏 객체 그래프를 탐색할 수 있어야 한다. SQL을 직접 다루면 처음 실행하는 SQL에 따라 객체 그래프를 어디까지 탐색할 수 있는지 정해진다.\n이것은 객체지향 개발자에겐 너무 큰 제약이다.\n왜냐하면 비즈니스 로직에 따라 사용하는 객체 그래프가 다른데, 언제 끊어질지 모를 객체 그래프를 함부로 탐색할 수는 없기 때문이다.\nDAO(데이터 접근 계층) 을 열어서 SQL을 직접 확인해야 한다.\n엔티티가 SQL에 논리적으로 종속되어서 발생하는 문제\nJPA와 객체 그래프 탐색 JPA는 연관된 객체를 사용하는 시점에 적절한 SELECT SQL 을 실행한다. 따라서 JPA를 사용하 면 연관된 객체를 신뢰하고 마음껏 조회할 수 있다. 이 기능은 실제 객체를 사용하는 시점까지 데이터베이스 조회를 미룬다고 해서 지연 로딩이라 한다. JPA는 지연 로딩을 투명(transparent) 하게 처리 JPA와 관련된 또 다른 코드를 심을 필요가 없다. 1.2.4 비교 데이터베이스는 기본 키의 값으로 각 row를 구분한다.\n반면에 객체는 동일성(identity) 비교와 동등성(equality) 비교라는 두 가지 비교 방법이 있다.\n따라서 테이블의 로우를 구분하는 방법과 객체를 구분하는 방법에는 차이가 있다.\n이런 패러다임의 불일치 문제를 해결하기 위해 데이터베이스의 같은 로우를 조회할 때마다 같은 인스턴스를 반환하도록 구현하는 것은 쉽지 않다. 여기에 여러트랜잭션이 동시에 실행되는 상황까지 고려하면 문제는 더 어려워진다. JPA와 비교 JPA는 같은 트랜잭션일 때 같은 객체가 조회되는 것을 보장한다. 1.3 JPA란 무엇인가? ORM(Object-Relational Mapping) 이란 이름 그대로 객체와 관계형 데이터베이스를 매핑한다는 뜻\nORM 프레임워크는 패러다임의 불일치 문제를 개발자 대신 해결해준다.\n예를 들어 ORM을 사용하면 객체를 데이터베이스에 저장할 때 INSERT SQL을 직접 작성하는 것이 아니라 객체를 마치 자바 컬렉션에 저장하듯이 ORM 프레임워크에 저장하면 된다. 그러면 ORM 프레임워크가 적절한 INSERT SQL을 생성해서 데이터베이스에 객체를 저장해준다. ORM 프레임워크는 단순히 SQL을 개발자 대신 생성해서 RDBMS에 전달 해주는 것뿐만 아니라, 다양한 패러다임의 불일치 문제들도 해결해준다.\n따라서 객체 측면에서는 정교한 객체 모델링을 할 수 있고 관계형 데이터베 이스는 데이터베이스에 맞도록 모델링하면 된다.\n둘을 어떻게 매핑해야 하는지 매핑 방법만 ORM 프레임워크에게 알려주면 된다. 덕분에 개발자는 데이터중심인 관계형 데이터베이스를 사용해도 객체지향 애플리케이션 개발에 집중할수 있다. 자바 진영에도 다양한 ORM 프레임워크들이 있는데 그중에 하이버네이트 프레임워크가 가장 많이 사용된다.\n하이버네이트는 거의 대부분의 패러다임 불일치문제를 해결해주는 성숙한 ORM 프레임워크다. 1.3.1 JPA 소개 JPA는 자바 ORM 기술에 대한 API 표준 명세, 인터페이스를 모아 둔 것 JPA 표준은 일반적이고 공통적인 기능의 모음 표준 덕분에 특정 구현 기술에 대한 의존도를 줄일 수 있음, 다른 구현으로 쉽게 이동 가능 JPA를 사용하려면, JPA를 구현한 ORM 프레임워크를 선택해야 한다 하이버네이트가 가장 대중적 1.3.2 왜 JPA를 사용해야 하는가? 생산성\n복잡한 SQL와 JDBC API를 다루는 일을 대신 해줌\n데이터 중심 -\u0026gt; 객체 중심으로 역전 가능\n유지보수\nJDBC API 코드를 대신 처리\n유연한 도메인 모델을 편리하게 설계가능\n패러다임의 불일치 해결\n성능\n트랜잭션 안에서 두 번 조회할 때, 조회한 객체 재사용 가능하기에 SELECT SQL 를 한 번만 데이터베이스에 전달 데이터 접근 추상화와 벤더 독립성\nApp과 DB 사이에 추상화된 데이터 접근 계층을 제공\n데이터베이스 특정 기술에 종속되지 않게 됨\n표준\nJPA는 자바 진영 ORM의 기술 표준이다. 표준 덕분에 특정 구현 기술에 대한 의존도를 줄일 수 있음, 다른 구현으로 쉽게 이동 가능 Reference 자바 ORM 표준 JPA 프로그래밍 (김영한) https://product.kyobobook.co.kr/detail/S000001766367 ","permalink":"https://2taezeat.github.io/posts/jpa/%EC%9E%90%EB%B0%94-orm-%ED%91%9C%EC%A4%80-jpa-ch01.-jpa-%EC%86%8C%EA%B0%9C/","summary":"1.1 SQL을 직접 다룰 때 발생하는 문제점 1.1.1 반복 데이터베이스는 객체 구조와는 다른 데이터 중심의 구조를 가짐, 개발자가 객체지향 App과 DB 중간에서 SQL과 JDBC API를 사용해서 변환 작업을 해야 함 테이블에 비례해서 SQL를 개발자가 작성해야 함, 지루하고 반복적인 일 1.1.2 SQL에 의존적인 개발 App에서 문제가 생기면, DAO를 열어서 어떤 SQL이 실행되는지 확인해야 함, 계층 분할이 어려움 어떤 SQL이 실행되고 어떤 객체들이 함께 조회되는지 일일이 확인해야 함. 엔티티를 신뢰할 수 없음 1.","title":"[자바 ORM 표준 JPA] ch01. JPA 소개"},{"content":"5. 책임 할당하기 책임 주도 설계를 향해 데이터 중심 =\u0026gt; 책임 중심 데이터보다 행동을 먼저 결정하라 협력이라는 문맥 안에서 책임을 결정하라 협력이라는 문맥 안에서 책임을 결정하라 책임은 객체의 입장이 아니라 객체가 참여하는 협력에 적합해야 한다. 메시지를 전송하는 클라이언트의 의도에 적합한 책임을 할당해야 한다 메시지가 객체를 선택하게 해야 한다 클래스 기반 설계에서 메시지 기반 설계로 전환해야 한다 \u0026ldquo;이 클래스가 무엇을 해야 하지?\u0026rdquo; =\u0026gt; \u0026ldquo;메시지를 전송해야 하는데 누구에게 전송해야 하지\u0026rdquo; 메시지를 전송하기 때문에 객체를 갖게 된다 메시지를 수신하기로 결정된 객체는 메시지를 처리할 책임을 할당 받게 된다 메시지를 먼저 결정하기에, 메시지 전송자의 관점에서 수신자가 깔끔하게 캡슐화 된다 책임 할당을 위한 GRASP 패턴 General Responsibility Assignment Software Pattern: 크레이크 라만이 패턴 형식으로 제안 도메인 개념에서 출발하기 도메인 개념들을 책임 할당의 대상으로 사용하면 코드에 도메인의 모습을 투영하기가 좀 더 수월해진다. 도메인 개념을 정리하는 데 너무 많은 시간을 들이지 말고 빠르게 설계와 구현을 진행하라 올바른 도메인 모델이란 존재하지 않는다 정보 전문가에게 책임을 할당하라 책임을 전송된 메시지로 간주하고, 메시지를 책임질 첫 번째 객체를 선택하는 것으로 설계를 시한다\nEx) 애플리케이션은 영화를 예매할 책임이 있다. 첫 번째 질문: 메시지를 전송할 객체는 무엇을 원하는가?\n메시지의 이름으로 \u0026ldquo;예매하라\u0026rdquo; 가 적절하다 두 번째 질문: 메시지를 수신할 적합한 객체는 누구인가?\n책임을 수행할 정보를 알고 있는 객체에게 책임을 할당=\u0026gt; 정보 전문가(Information Expert) 패턴\n가장 기본적인 책임 할당 원칙\n책임을 수행하는 데 필요한 정보를 가지고 있는 객체에게 할당하라\n정보 전문가는 정보를 알고 있지만, 그 정보를 꼭 데이터로 저장하고 있을 필요는 없다\n높은 응집도와 낮은 결합도 객체에 책임을 할당할 때 다양한 대안이 존재한다면 높은 응집도와 낮은 결합도 측면에서 생각해라 Low Coupling, High Cohesion 패턴이라고 한다 Low Coupling 의존성을 낮추고 변화의 영향을 줄이며 재사용성을 증가시킬 수 있는 방법 설계의 전체적인 결합도가 낮게 유지되도록 책임을 할당하라 Movie와 DiscountCondition은 이미 결합돼 있다. Screening과 DiscountCondition이 협력 할 경우 새로운 결합도가 생성된다. 따라서 Movie와 DiscountCondition이 렵력하는 것이 더 나은 설계 대안이다. High Cohesion 어떻게 복잡성을 관리할 수 있는 수준으로 유지하는 법: 높은 응집도를 유지할 수 있게 책임을 할당해라 Screening과 DiscountCondition이 협력 할 경우 Screening은 영화 요금 계산과 관련된 책임 일부를 떠안아야 한다. 예매 요금을 계산하는 방식이 변경될 경우 Screening도 함께 변경되어야 한다 서로 다른 이유로 변경되는 책임을 짊어지게 되므로 응집도 낮아짐 창조자에게 객체 생성 책임을 할당하라 영화 예매 협력의 최종 결과물은 Reservation 인스턴스를 반환하는 것 Creator(창조자) 패턴은 객체를 생성할 책임을 어떤 객체에게 할당하지에 대한 지침을 제공 객체 A가, 아래 조건을 최대한 만족하는 B에게 객체 생성 책임을 할당해라 B가 A 객체를 포함하거나 참조한다. B가 A 객체를 기록한다 B가 A 객체를 긴밀하게 사용한다 B가 A 객체를 초기화하는 데 필요한 데이터를 가지고 있다 (B는 A에 대한 전문가다) 이미 결합돼 있는 객체에게 생성 책임을 할당하는 것은 설계의 전체적인 결합도에 영향을 미치지 않는다. 이미 존재하는 객체 사이의 관계를 이용하기에 낮은 결합도를 유지할 수 있다. 구현을 통한 검증 DiscountCondition 개선하기 DiscountCondition 은 서로 다른 세 가지 이유로 변경될 수 있다.\n새로운 할인 조건 추가 순번 조건을 판단하는 로직 변경 기간 조건을 판단하는 로직이 변경되는 경우 DiscountCondition 은 하나 이상의 변경 이유를 가지기 때문에 응집도가 낮다\n변경에 이유에 따라 클래스를 분리해야 한다 코드를 통해 변경의 이유를 파악할 수 있는 방법\n변경 이유가 하나 이상의 이유로 변경돼야 한다면 응집도가 낮은 것\n인스턴스 변수가 초기화되는 시점을 살펴보는 것\n응집도가 높은 클래스는 인스턴스를 생성할 때 모든 속성을 함께 초기화한다 메서드들이 인스턴스 변수를 사용하는 방식\n모든 메서드가 객체의 모든 속성을 사용한다면 클래스의 응집도는 높다고 볼 수 있다 타입 분리하기 DiscountCondition 을 순번 조건과 기간 조건이라는 두 개의 독립적인 타입으로 변경 응집도가 높아지지만, 캡슐화라는 관점에서 설계 품질이 나빠졌음 다형성을 통해 분리하기 객체의 암시적인 타입에 따라 행동을 분기해야 한다면 암시적인 타입을 명시적인 클래스로 정의하고 행동을 나눔으로써 응집도 문제를 해결할 수 있다 DiscountCondition 이라는 인터페이스를 구현하는 형식으로 변경 타입을 분리하고 변화하는 행동을 각 타입의 책임으로 할당해라 Polymoorphism(다형성) 패턴 객체의 타입을 검사해서 타입에 따라 대안들을 수행하는 조건적인 논리를 사용하지말고, 다형성을 이용해 변화를 다루기 쉽게 확장해라 변경으로부터 보호하기 Movie의 관점에서 DiscountCondition 의 타입이 캡슐화된다는 것은 새로운 DiscountCondition 타입이 추가되더라도 Movie가 영향을 받지 않는다는 것을 의미 오직 DiscountCondition 인터페이스를 실체화하는 클래스를 추가하는 것으로 할인 조건의 종류를 확장할 수 있다. 캡슐화하도록 책임을 할당하는 것을 Protected Variations(변경 보호) 패턴 이라 한다. 변경될 가능성이 높으면, 캡슐화 하라 Movie 클래스 개선하기 도메인의 구조가 코드의 구조를 이끈다 변경 역시 도메인 모델의 일부이다. 도메인 모델에는 도메인 안에서 변하는 개념과 이들 사이의 관계가 투영돼 있어야 한다. 변경과 유연성 설게를 주도하는 것은 변경이다; 개발자로서 변경에 대비할 수 있는 방법 두 가지\n이해하고 수정하기 쉽게 최대한 단순하게 설계 코드를 유연하게 만드는 것 상속 대신 합성을 사용하면, 새로운 정책이 추가될 때 마다 유연한 설계가 가능하다\n도메인 모델은 단순히 도메인의 개념과 관계를 모아 놓은 것이 아니다.\n도메인 모델은 구현과 밀접한 관계를 맺어야 한다. 책임 주도 설계의 대안 수정하기 쉬운 소프트웨어로 개선하기 위해 겉으로 보이는 동작은 바꾸지 않은 채 내부 구조를 변경하는 것을 리팩토링 이라 한다.\n겉으로 드러나는 동작이 바꿔서는 안된다\n캡슐화, 응집도, 결합도 관점에서 개선하고 동작은 그대로 유지해야 한다\n메서드 응집도 몬스터 메서드(monster method): 코드를 재사용하는 유일한 방법이 원하는 부분을 복사 붙여넣는 것 뿐인, 변경하기 어려운 긴 메서드 클래스의 응집도와 마찬가지로 응집도가 높은 메서드는 변경되는 이유가 단 하나이다. 작은 메서드들로 조합된 메서드는 마치 주석들을 나열한 것처럼 보이기에 코드를 이해하기 쉽다. 객체를 자율적으로 만들자 메서드를 다른 클래스로 이동시킬 때는 인자에 정의된 클래스 중 하나로 이동하는 경우가 일반적이다. Reference 오브젝트 (조영호) https://product.kyobobook.co.kr/detail/S000001766367 ","permalink":"https://2taezeat.github.io/posts/%EC%98%A4%EB%B8%8C%EC%A0%9D%ED%8A%B8/%EC%98%A4%EB%B8%8C%EC%A0%9D%ED%8A%B8-ch05.-%EC%B1%85%EC%9E%84-%ED%95%A0%EB%8B%B9%ED%95%98%EA%B8%B0/","summary":"5. 책임 할당하기 책임 주도 설계를 향해 데이터 중심 =\u0026gt; 책임 중심 데이터보다 행동을 먼저 결정하라 협력이라는 문맥 안에서 책임을 결정하라 협력이라는 문맥 안에서 책임을 결정하라 책임은 객체의 입장이 아니라 객체가 참여하는 협력에 적합해야 한다. 메시지를 전송하는 클라이언트의 의도에 적합한 책임을 할당해야 한다 메시지가 객체를 선택하게 해야 한다 클래스 기반 설계에서 메시지 기반 설계로 전환해야 한다 \u0026ldquo;이 클래스가 무엇을 해야 하지?\u0026rdquo; =\u0026gt; \u0026ldquo;메시지를 전송해야 하는데 누구에게 전송해야 하지\u0026rdquo; 메시지를 전송하기 때문에 객체를 갖게 된다 메시지를 수신하기로 결정된 객체는 메시지를 처리할 책임을 할당 받게 된다 메시지를 먼저 결정하기에, 메시지 전송자의 관점에서 수신자가 깔끔하게 캡슐화 된다 책임 할당을 위한 GRASP 패턴 General Responsibility Assignment Software Pattern: 크레이크 라만이 패턴 형식으로 제안 도메인 개념에서 출발하기 도메인 개념들을 책임 할당의 대상으로 사용하면 코드에 도메인의 모습을 투영하기가 좀 더 수월해진다.","title":"[오브젝트] ch05. 책임 할당하기"},{"content":"4. 설계 품질과 트레이드오프 객체지향 설계는 상태(데이터), 책임 으로 분할의 중심축을 삶는 두 가지 방법이 존재\n훌륭한 설계는 데이터가 아니라 책임에 초점을 맞춰야 한다. 상태는 구현에 속한다. 구현은 불안정하기 때문에 변하기 쉽다. 책임은 인터페이스에 속한다. 상태를 캡슐화함으로써, 구현 변경에 대한 파장이 외부로 퍼져나가는 것을 방지한다. 이번 장(ch4) 는 차이를 느끼기 위해 일부러, 데이터의 중심으로 설계해보자\n데이터를 준비하자 가장 큰 차이는 discountConditions 이 인스턴스 변수로 Movie 안에 직접 포함돼 있다는 것 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 class Screening(private val movie: Movie, private val sequence: Int, private val whenScreened: LocalDateTime) { fun getStartTime() = whenScreened fun isSequence(sequence: Int) = this.sequence == sequence fun getMovieFee() = movie.fee fun calculateFee(audienceCount: Int): Money { when (movie.movieType) { MovieType.AMOUNT_DISCOUNT -\u0026gt; if (movie.isDiscountable(whenScreened, sequence)) return movie.calculateAmountDiscountedFee().times(audienceCount.toDouble()) MovieType.PERCENT_DISCOUNT -\u0026gt; if (movie.isDiscountable(whenScreened, sequence)) return movie.calculatePercentDiscountedFee().times(audienceCount.toDouble()) MovieType.NONE_DISCOUNT -\u0026gt; return movie.calculateNoneDiscountedFee().times(audienceCount.toDouble()) } return movie.calculateNoneDiscountedFee().times(audienceCount.toDouble()) } } class Money(private val amount: BigDecimal) { companion object { val ZERO = wons(0) fun wons(amount: Long) = Money(BigDecimal.valueOf(amount)) fun wons(amount: Double) = Money(BigDecimal.valueOf(amount)) } fun plus(amount: Money) = Money(this.amount.add(amount.amount)) fun minus(amount: Money) = Money(this.amount.subtract(amount.amount)) fun times(percent: Double) = Money(this.amount.multiply(BigDecimal.valueOf(percent))) fun isLessThan(other: Money) = amount \u0026lt; other.amount fun isGreaterThan(other: Money) = amount \u0026gt;= other.amount } class DisCountCondition( val discountConditionType: DiscountConditionType, val sequence: Int, val dayOfWeek: DayOfWeek, val startTime: LocalTime, val endTime: LocalTime ) { fun isDiscountable(dayOfWeek: DayOfWeek, time: LocalTime): Boolean { if (discountConditionType != DiscountConditionType.PERIOD) { throw IllegalArgumentException() } return this.dayOfWeek == dayOfWeek \u0026amp;\u0026amp; startTime \u0026lt;= time \u0026amp;\u0026amp; endTime \u0026gt;= time } fun isDiscountable(sequence: Int): Boolean { if (discountConditionType != DiscountConditionType.SEQUENCE) { throw IllegalArgumentException() } return this.sequence == sequence } } enum class MovieType { AMOUNT_DISCOUNT, PERCENT_DISCOUNT, NONE_DISCOUNT } enum class DiscountConditionType { SEQUENCE, PERIOD } data class Movie( val title: String, val runningTime: Duration, val fee: Money, val discountConditions: List\u0026lt;DisCountCondition\u0026gt;, val movieType: MovieType, val discountAmount: Money, val discountPercent: Double, ) { fun calculateAmountDiscountedFee(): Money { if (movieType != MovieType.AMOUNT_DISCOUNT) { throw IllegalArgumentException() } return fee.minus(discountAmount) } fun calculatePercentDiscountedFee(): Money { if (movieType != MovieType.PERCENT_DISCOUNT) { throw IllegalArgumentException() } return fee.minus(fee.times(discountPercent)) } fun calculateNoneDiscountedFee(): Money { if (movieType != MovieType.NONE_DISCOUNT) { throw IllegalArgumentException() } return fee } fun isDiscountable(whenScreened: LocalDateTime, sequence: Int): Boolean { for (condition in discountConditions) { if (condition.discountConditionType == DiscountConditionType.PERIOD) { if (condition.isDiscountable(whenScreened.dayOfWeek, whenScreened.toLocalTime())) { return true } } else if (condition.isDiscountable(sequence)) { return true } } return false } } data class Reservation( val customer: Customer, val screening: Screening, val fee: Money, val audienceCount: Int ) class ReservationAgency { fun reserve(screening: Screening, customer: Customer, audienceCount: Int): Reservation { val fee = screening.calculateFee(audienceCount) return Reservation(customer, screening, fee, audienceCount) } } class Customer() 설계 트레이드오프 캡슐화 상태와 행동을 하나의 객체 안에 모으는 이유는 객체의 내부 구현을 외부로부터 감추기 위해서이다.\n구현: 변경될 가능성이 높은 것 인터페이스: 상대적으로 안정적인 부분, 변경 가능성이 적은 부분 객체지향 설계의 가장 중요한 원리: 불안정한 구현 세부사항을 안정적인 인터페이스 뒤로 캡슐화 하는 것\n복잡성 =\u0026gt; 추상화 =\u0026gt; 캡슐화\n캡슐화란 변경 가능성이 높은 부분을 객체 내부로 숨기는 추상화 기법\n변경 될 수 있는 어떤 것이라도 캡슐화 해야 한다 유지보수성 이란\n두려움, 주저함, 저항감 없이 코드를 변경할 수 있는 능력 이때, 캡슐화가 가장 중요한 동료 캡슐화를 위반하는 경우 과도한 접근자와 수정자를 가지게 된다.\n접근자, 수정자 =\u0026gt; 자바의 public get~, public set~ 함수\n사용될 문맥을 추측 할 수밖에 없는 경우 개발자는 어떤 상황에서도 해당 객체가 사용될 수 있게 많은 접근자 메서드를 추가하게 됨\n접근자와 수정자에 과도하게 의존하는 설계 방식: 추측에 의한 설계(design-by-guessing strategy)\n내부 상태를 드러내는 메서드를 최대한 많이 추가할 수 밖에 없어짐, 내부 구현이 퍼블릭 인터페이스에 그대로 노출됨\n응집도와 결합도 높은 응집도와 낮은 결합도를 추구해야 하는 이유는 설계를 변경하기 쉽게 만들기 위함\n결합도가 높아도 상관 없는 경우 변경될 확률이 매우 적은 안정적인 모듈에 의존하는 것\n표준 라이브러리에 포함된 모듈, Ex) String, List 성숙 단계에 포함된 프레임워크 응집도는 모듈에 포함된 내부 요소들이 연관돼 잇는 정도\n객체지향 관점에서 응집도는 객체 또는 클래스에 얼마나 관련 높은 책임을 할당했는지를 나타낸다 응집도는 변경이 발생할 때 모듈 내부에서 발생하는 변경의 정도로 측정 가능하다 하나의 변경을 수용하기 위해 모듈 전체가 함께 변경된다면 응집도가 높은것 하나의 변경에 대해 다수의 모듈이 함께 변경돼야 한다면 응집도가 낮은것 결합도는 다른 모듈에 대해 얼마나 많은 지식을 갖고 있는지를 나타내는 척도\n의존성의 정도를 나타냄 한 모듈이 변경되기 위해서 다른 모듈의 변경을 요구하는 정도로 측정 가능하다 내부 구현을 변경했을 때 이것이 다른 모듈에 영향을 미치는 경우 두 모듈 사이의 결합도가 높다고 한다 데이터 중심 설계에서는 시스템의 어떤 변경도 ReseravtionAgency의 변경을 유발함, 높은 결합도\n많은 요구사항 수정사항에 대해 ReseravtionAgency 을 변경해야 함\n할인 정책 추가 할인 조건 추가 할인 요금 계산 방법 변경 예매 요금 계산 방법 변경 로버트 마틴의, 단일 책임 원칙 (SRP)\n클래스는 단 한가지의 변경 이유만 가져야 한다는 것 주의 할점 단일 \u0026lsquo;책임\u0026rsquo; 원칙 에서의 \u0026lsquo;책임\u0026rsquo;은 \u0026lsquo;변경의 이유\u0026rsquo; 라는 의미로 사용된다 역할, \u0026lsquo;책임\u0026rsquo;, 협력에서 이야기하는 \u0026lsquo;책임\u0026rsquo;과는 다르며 변경과 관련된 더 큰 개념을 가리킴 자율적인 객체를 향해 캡슐화를 지켜라 Rectangle 클래스는 Int 타입의 top, left, right, bootm 이라는 인스턴스 변수의 존재 사실을 인터페이스를 통해 외부에 노출시킴 접근자와 수정자는 내부 구현을 인터페이스의 일부로 만들기 때문이다. 결과적으로 right, bottom 대신, length, height를 이용해서 사각형을 표현하도록 수정한다면, 기존의 접근자 메서드(getter, setter) 를 사용하던 모든 코드에 영향을 미침 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Rectangle_Bad(var left: Int, var top: Int, var right: Int, var bottom: Int) { // 캡슐화 X } class Rectangle_Good(var left: Int, var top: Int, var right: Int, var bottom: Int) { // 캡슐화 O // 너비와 높이를 조절하는 로직을 캡슐화하여 Rectangle 스스로 증가시키도록, \u0026#39;책임을 이동\u0026#39; fun enlarge(multiple: Int) { right *= multiple bottom *= multiple } } class AnyClass() { fun anyMethodForBad(rectangle: Rectangle_Bad, multiple: Int) { rectangle.right *= multiple rectangle.bottom *= multiple } fun anyMethodForGood(rectangle: Rectangle_Good, multiple: Int) { rectangle.enlarge(multiple) } } 스스로 자신의 데이터를 책임지는 객체 객체를 설계할 때 데이터에 대해 두 가지 질문이 필요 이 객체가 어떤 데이터를 포함해야 하는가? 이 객체가 데이터에 대해 수행해야 하는 오퍼레이션은 무엇인가? 캡슐화 위반 DiscountCondition 의 isDiscountable 함수의 파라미터를 보면, 인스턴스 변수로 DayOfWeek 타입의 변수가 있는 것\n시간 정보가 인스턴스 변수로 포함돼 있다느 사실을 외부에 노출함 DiscountCondition 의 속성을 변경하면, isDiscountable 함수와 이를 사용하는 클라이어도 함께 수정되어야 함\n내부 구현의 변경이 외부로 퍼져나가는 파급 효과(ripple effect) 는 캡슐화가 부족하다는 증거 Movie의 내부 구현을 인터페이스에 노출시키고 있다.\ncalculateAmountDiscountedFee,calculatePercentDiscountedFee, calculateNoneDiscountedFee 이 함수들은 할인 정책에는 금액, 비율, 미적용 세 가지가 존재한다는 사실을 만천하에 드러낸다. 캡슐화는 단순히 객체 내부의 데이터를 외부로 부터 감추는 것 이상의 의미를 가진다\n캡슐화는 변경될 수 있는 어떤 것이라도 감추는 것 속성의 타입이건, 할인 정책의 종류건 상관 없이 내부 구현의 변경으로 인해 외부의 객체가 영향을 받는 다면 캡슐화를 위반한 것 설계에서 변하는 것이 무엇인지 고려하고 변하는 개념을 캡슐화해야 한다. 높은 결합도, 낮은 응집도 DiscountCondition의 구현을 변경이, 이를 의존하는 Movie 변경으로 이어진다. Screening에서 Movie의 isDiscountable 메서드를 호출하는 부분도 함께 변경해야 한다. 모두 캡슐화를 위반했기 때문이다. 데이터 중심 설계의 문제점 변경에 취약\n본질적으로 너무 이른 시기에 데이터에 관해 결정하도록 강요 협력이라는 문맥을 고려하지 않고 객체를 고립시킨 채 오퍼레이션을 결정한다. 처음부터 데이터에 관해 결정하도록 강요하기에 너무 이른 시기에 내부 구현에 초점을 맞추게 됨\n데이터는 구현의 일부이다. Reference 오브젝트 (조영호) https://product.kyobobook.co.kr/detail/S000001766367 ","permalink":"https://2taezeat.github.io/posts/%EC%98%A4%EB%B8%8C%EC%A0%9D%ED%8A%B8/%EC%98%A4%EB%B8%8C%EC%A0%9D%ED%8A%B8-ch04.-%EC%84%A4%EA%B3%84-%ED%92%88%EC%A7%88%EA%B3%BC-%ED%8A%B8%EB%A0%88%EC%9D%B4%EB%93%9C%EC%98%A4%ED%94%84/","summary":"4. 설계 품질과 트레이드오프 객체지향 설계는 상태(데이터), 책임 으로 분할의 중심축을 삶는 두 가지 방법이 존재\n훌륭한 설계는 데이터가 아니라 책임에 초점을 맞춰야 한다. 상태는 구현에 속한다. 구현은 불안정하기 때문에 변하기 쉽다. 책임은 인터페이스에 속한다. 상태를 캡슐화함으로써, 구현 변경에 대한 파장이 외부로 퍼져나가는 것을 방지한다. 이번 장(ch4) 는 차이를 느끼기 위해 일부러, 데이터의 중심으로 설계해보자\n데이터를 준비하자 가장 큰 차이는 discountConditions 이 인스턴스 변수로 Movie 안에 직접 포함돼 있다는 것 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 class Screening(private val movie: Movie, private val sequence: Int, private val whenScreened: LocalDateTime) { fun getStartTime() = whenScreened fun isSequence(sequence: Int) = this.","title":"[오브젝트] ch04. 설계 품질과 트레이드오프"},{"content":"3. 역할, 책임, 협력 협력: 객체들이 앺ㄹ리케이션의 기능을 구현하기 위해 수행하는 상호작용 책임: 객체가 협력에 참여하기 위해 수행하는 로직 객체들이 협력 안에서 수행하는 책임들이 모여 객체가 수행하는 역할을 구성한다. 협력 메시지 전송(message sending) 은 협력을 위해 사용할 수 있는 유일한 커뮤니케이션 수단\n객체가 스스로 메시지를 처리할 방법(메서드)을 자율적으로 선택\n자율적인 객체가 되기 위해서는 자신이 할 수 없는 일을 다른 객체에게 위임하면 협력에서 전체적인 자율성이 향상\n가장 기본적인 방법은 캡슐화 이다. 협력이 설계를 위한 문맥을 결정한다 객체의 행동을 결정하는 것은 객체가 참여하고 있는 협력이다.\n협력은 객체가 필요한 이유와 객체가 수행하는 행동의 동기를 제공한다.\nMovie의 행동을 결정하는 것은 영화 예매를 위한 협력이다.\n협력이라는 문맥을 고려하지 않고 Moive의 행동을 결정하는 것은 아무런 의미가 없다. 상태는 객체가 행동하는 데 필요한 정보에 의해 결정되고 행동은 협력 안에서 객체가 처리할 메시지로 결정 된다.\n객체가 참여하는 협력이 객체를 구성하는 상태와 행동 모두를 결정한다.\n협력은 설계에 필요한 context(문맥) 을 제공한다. 책임 책임이란 객체에 의해 정의되는 응집도 있는 행위의 집합 객체의 책임은 \u0026lsquo;무엇을 알고 있는가(knowing)\u0026rsquo;, \u0026lsquo;무엇을 할 수 있는가(doing)\u0026rsquo; 으로 구성 된다. 두 개는 밀접하게 연관되어 있다. 객체는 책임을 수행하는 데 필요한 정보를 알고 있을 책임 할 수 없는 작업을 도와줄 객체를 알고 있을 책임 그 책임을 수행하는 데 필요한 정보도 알아야할 책임 책임은 메시지 보다 추상적이면서 개념적으로 더 크다. 책임은 객체지향 설계의 핵심, 책임을 능숙하게 소프트웨어 객체에게 할당하는 것은 매우 중요하다. 객체의 구현 방법은 책임보다 상대적으로 덜 중요하고 책임 이후에 고민해도 늦지 않다. 책임 할당 자율적인 객체를 만드는 가장 기본적인 방법은 책임을 수행하는 데 필요한 정보를 잘 알고 있는 전문가에게 그 책임을 할당하는 것\n정보 전문가 패턴(Information Expert) 이라 한다. 객체에게 책임을 할당하기 위해서는 협력이라는 문맥을 정의해야 한다.\n협력을 설계하는 출발점은 시스템이 사용자에게 제공하는 기능을 시스템이 담당할 하나의 책임으로 바라보는 것\n객체지향 설계는 필요한 더 작은 책임을 찾아내고,이를 객체들에게 할당하는 반복적인 과정 객체가 책임을 수행하게 하는 유일한 방법은 메시지 전송 이므로, 책임을 할당한다는 것은 메시지의 이름을 결정하는 것과 같다.\n이렇게 결정된 메시지가 객체의 퍼블릭 인터페이스를 구성한다. 협력을 설계하면서 객체의 책임을 식별해 나가는 과정에서 최종적으로 얻게 되는 결과물은 시스템을 구성하는 객체들의 인터페이스와 오퍼레이션 목록이다.\n책임 주도 설계(RDD): 책임을 찾고 책임을 수행할 적절한 객체를 찾아 할당하는 방식으로 협력을 설계하는 방법\n시스템이 사용자에게 제공해야 하는 기능인 시스템 책임을 파악 시스템 채김을 더 작은 책임으로 분할 분할된 책임을 수행할 수 있는 적절한 객체 or 역할을 찾아 책임 할당 책임을 수행하는 도중 다른 객체의 도움이 필요한 경우 이를 책임질 적잘한 객체 또는 역할을 찾음 객체 or 역할에게 책임을 할당함으로써 두 객체가 협력하게 함 메시지가 객체를 결정한다 객체가 메시지를 결정하는 것이 아니라, 메시지가 객체를 선택하게 했다\n객체가 최소한의 인터페이스를 가질 수 있게 된다. 객체는 충분히 추상적인 인터페이스를 가질 수 있게 된다. 인터페이스는 what(무엇)을 하는 지 표현해야 하지만, how(어떻게) 수행하는지는 노출하면 안 된다. 메시지(예매하라)를 선텍하는 것으로 설계를 시작 그리고, 그 메시지를 수신할 객체를 선택(Screening)\n행동이 상태를 결정한다 객체의 행동은 객체가 협력에 참여할 수 있는 유일한 방법\n협력에 얼마나 적합한지 결정하는 것은 상태(데이터) 가 아니라 행동이다. 객체의 내부 구현에 초점을 맞춘 설계 방법은 데이터-주도 설계(Data-Driven Design) 이라 한다.\n상태는 단지 객체가 행동을 정상적으로 수행하기 위해 필요한 재료일 뿐이다.\n역할 객체는 협력이라는 문맥 안에서 특정한 목적을 갖게 된다.\n목적은 협력 안에서 객체가 맡게 되는 책임의 집합(=역할) 으로 표시 역할은 다른 것으로 교체할 수 있는 책임의 집합이다.\n역할은 구체적인 객체를 포괄하는 추상화 이다.\n추상적인 이름을 부여해야 한다. (Ex. DiscountPolicy) 책임을 수행하는 역할을 기반으로 두 개의 협력을 하나로 통합할 수 있다.\n역할을 이용하면 불필요한 중복 코드를 제거할 수 있다. \u0026lsquo;새로운 할인 정책을 추가하기 위해 새로운 협력을 추가할 필요가 없어짐\u0026rsquo; 역할을 구현하는 가장 일반적인 방법은 추상 클래스와 인터페이스를 사용하는 것\n추상 클래스는 책임의 일부를 구현해 놓은것 인터페이스는 구현 없이 책임의 집합만을 나열 역할이 다양한 종류의 객체를 수용할 수 있는 슬롯이자 구체적인 객체들의 타입을 캡슐화하는 추상화 이다.\n협력 안에서 역할이 어떤 책임을 수행해야 하는지 결정하는 것이 중요 객체 대 역할 협력에 참여하는 후보가 여러 종류의 객체에 의해 수행될 필요가 있다면 그 후보는 역할\n단지 한 종류의 객체만이 협력에 참여할 필요가 있다면 후보는 객체\n역할은 서로 다른 방법으로 실행할 수 있는 책임의 집합\n역할을 객체들에 대한 별칭이라고 정의하기도 한다.\n객체는 클래스를 이용해 구현되고 생성 협력 -reference-\u0026gt; 역할 -select from-\u0026gt; 객체 -instance of-\u0026gt; 클래스\n초기 설계에는 책임과 협력의 큰 그림을 탐색하는게 중요, 역할과 객체를 명확하게 구분하는 것은 그렇게 중요하지 않다.\n배우와 배역 연극: 협력\n배우: 협력 안에서 역할을 수행하는 객체\n극본: 코드\n객체의 페르소나: 역할\n역할은 모양이나 구조에 의해 정의될 수 없으며 오직 시스템의 문맥 에서만 정의될 수 있다.\n배우가 여러 연극에 참여해 여러 배역을 연기할 수 있듯이, 객체는 다양한 역할 수행\n특정한 협력 안에서는 일시적으로 오직 하나의 역할만이 보여짐 참여하는 특정 협력은 객체의 한 가지 역할만 바라 볼 수 있다. 배우는 연극이 끝나면 배역을 잊고 원래의 자기 자신을 되찾는다\nReference 오브젝트 (조영호) https://product.kyobobook.co.kr/detail/S000001766367 ","permalink":"https://2taezeat.github.io/posts/%EC%98%A4%EB%B8%8C%EC%A0%9D%ED%8A%B8/%EC%98%A4%EB%B8%8C%EC%A0%9D%ED%8A%B8-ch03.-%EC%97%AD%ED%95%A0-%EC%B1%85%EC%9E%84-%ED%98%91%EB%A0%A5/","summary":"3. 역할, 책임, 협력 협력: 객체들이 앺ㄹ리케이션의 기능을 구현하기 위해 수행하는 상호작용 책임: 객체가 협력에 참여하기 위해 수행하는 로직 객체들이 협력 안에서 수행하는 책임들이 모여 객체가 수행하는 역할을 구성한다. 협력 메시지 전송(message sending) 은 협력을 위해 사용할 수 있는 유일한 커뮤니케이션 수단\n객체가 스스로 메시지를 처리할 방법(메서드)을 자율적으로 선택\n자율적인 객체가 되기 위해서는 자신이 할 수 없는 일을 다른 객체에게 위임하면 협력에서 전체적인 자율성이 향상\n가장 기본적인 방법은 캡슐화 이다. 협력이 설계를 위한 문맥을 결정한다 객체의 행동을 결정하는 것은 객체가 참여하고 있는 협력이다.","title":"[오브젝트] ch03. 역할, 책임, 협력"},{"content":"2. 객체지향 프로그래밍 객체지향 패러다임에서 집중 해야 하는 두 가지\n클래스 보다는 어떤 객체가 필요한지 고민하라 객체를 독립적인 존재가 아니라 기능을 구현하기 위해 협력하는 공동체의 일원으로 봐야 한다. 도메인(domain): 문제를 해결하기 위해 사용자가 프로그램을 사용하는 분야\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 class Screening(private val movie: Movie, private val sequence: Int, private val whenScreened: LocalDateTime) { fun getStartTime() = whenScreened fun isSequence(sequence: Int) = this.sequence == sequence fun getMovieFee() = movie.fee fun reserve(customer: Customer, audienceCount: Int) = Reservation(customer, this, calculateFee(audienceCount), audienceCount) private fun calculateFee(audienceCount: Int) = movie.calculateMovieFee(this).times(audienceCount.toDouble()) } class Money(private val amount: BigDecimal) { companion object { val ZERO = wons(0) fun wons(amount: Long) = Money(BigDecimal.valueOf(amount)) fun wons(amount: Double) = Money(BigDecimal.valueOf(amount)) } fun plus(amount: Money) = Money(this.amount.add(amount.amount)) fun minus(amount: Money) = Money(this.amount.subtract(amount.amount)) fun times(percent: Double) = Money(this.amount.multiply(BigDecimal.valueOf(percent))) fun isLessThan(other: Money) = amount \u0026lt; other.amount fun isGreaterThan(other: Money) = amount \u0026gt;= other.amount } interface DiscountPolicy { fun calculateDiscountAmount(screening: Screening): Money } abstract class DefaultDiscountPolicy(vararg conditions: DisCountCondition) : DiscountPolicy { private val conditions: MutableList\u0026lt;DisCountCondition\u0026gt; = conditions.toMutableList() override fun calculateDiscountAmount(screening: Screening): Money { conditions.forEach { if (it.isSatisfiedBy(screening)) { return getDiscountAmount(screening) } } return Money.ZERO } abstract fun getDiscountAmount(screening: Screening): Money } class AmountDiscountPolicy( private val discountMoney: Money, vararg conditions: DisCountCondition ) : DefaultDiscountPolicy() { override fun getDiscountAmount(screening: Screening) = discountMoney } class PercentDiscountPolicy( private val percent: Double, vararg conditions: DisCountCondition ) : DefaultDiscountPolicy() { override fun getDiscountAmount(screening: Screening) = screening.getMovieFee().times(percent) } interface DisCountCondition { fun isSatisfiedBy(screening: Screening): Boolean } class SequenceCondition(private val sequence: Int) : DisCountCondition { override fun isSatisfiedBy(screening: Screening) = screening.isSequence(sequence) } class PeriodCondition( private val dayOfWeek: DayOfWeek, private val startTime: LocalTime, private val endTime: LocalTime ) : DisCountCondition { override fun isSatisfiedBy(screening: Screening) = screening.getStartTime().dayOfWeek.equals(dayOfWeek) \u0026amp;\u0026amp; startTime \u0026lt;= screening.getStartTime() .toLocalTime() \u0026amp;\u0026amp; endTime \u0026gt;= screening.getStartTime().toLocalTime() } class NoneDisCountPolicy() : DiscountPolicy { override fun calculateDiscountAmount(screening: Screening) = Money.ZERO } data class Movie( val title: String, val runningTime: Duration, val fee: Money, val discountPolicy: DiscountPolicy ) { fun calculateMovieFee(screening: Screening) = fee.minus(discountPolicy.calculateDiscountAmount(screening)) fun changeDiscountPolicy(discountPolicy: DiscountPolicy) = this.copy(discountPolicy = discountPolicy) } data class Reservation( val customer: Customer, val screening: Screening, val fee: Money, val audienceCount: Int ) class Customer() ///////////////////////// fun main() { var avatar = Movie(\u0026#34;아바타\u0026#34;, 210.minutes, Money.wons(10000), NoneDisCountPolicy()) println(avatar.discountPolicy) avatar = avatar.changeDiscountPolicy(PercentDiscountPolicy(0.1, SequenceCondition(1), SequenceCondition(6))) println(avatar.discountPolicy) } 자율적인 객체 객체는 상태(State) 와 행동(Behavior) 을 함께 가진 복합적인 존재 객체는 스스로 판단하고 행동하는 자율적인 존재 캡슐화: 데이터와 기능을 객체 내부로 함께 묶는 것\nOOP 언어들은 접근 수정자를 통해, 외부에서의 접근을 통제할 수 있는 접근 제어 매커니즘 을 제공\n캡슐화와 접근 제어는 객체를 두 부분으로 나눈다.\n퍼블릭 인터페이스: 외부에서 접근가능한 부분 구현(implementation): 외부에서 접근 불가능하고 오직 내부에서만 접근 가능한 부분 설계가 필요한 이유는 변경을 관리하기 위함이다.\nOOP는 의존성을 적절히 관리해서, 변경에 대한 파급효과를 제어할 수 있는 다양한 방법 제공, 대표적으로 접근 제어 협력하는 객체들의 공동체 OOP의 장점은 객체를 이용해 도메인의 의미를 풍부하게 표현 할 수 있다는 것 의미를 좀 더 명시적이고 분명하게 표현할 수 있다면 객체를 사용해라 그 개념이 비록 하나의 인스턴스 변수만 포함하더라도 개념을 명시적으로 표현하는 것은 설계의 명확성과 유연성을 높히는 첫 걸음이다. 협력에 관한 짧은 이야기 객체는 다른 객체의 인터페이스에 공개된 행동을 수행하도록 request(요청) 한다. 요청 받은 객체는 자율적인 방법에 따라 요청을 처리하고 response(응답) 한다. 객체가 다른 객체와 상호작용할 수 있는 유일한 방법은 메시지를 전송(send) 하는 것뿐이다. 다른 객체에게 요청이 도달할 때 해당 객체가 메시지를 수신(receive) 했다고 이야기 한다. 수신된 메시지를 처리하기 위한 자신만의 방법을 메서드(method) 라고 한다. 메시지와 메서드의 구분에서부터 다형성(polymorphism) 개념이 시작한다. 컴파일 시간 의존성과 런타임 의존성 코드 의존성(컴파일 의존성)과 런타임 의존성이 서로 다를 수 있다.\n클래스 사이의 의존성과 객체 사이의 의존성은 다를 수 있다. 두 개가 다를수록 코드를 이해하기 어려워진다. 두 개가 다를수록 코드는 더 유연해지고 확장 가능하다 설계는 트레이드오프의 산물이다. 설계가 유연해질수록 코드를 이해하고 디버깅하기는 점점 더 어려워진다. (트레이드 오프)\n반대로, 유연성을 억제하면, 재사용성과 확장 가능성은 낮아진다. 훌륭한 객체지향 설계자는 항상 유연성과 가독성이에서 고민해야 한다. 차이에 의한 프로그래밍 차이에 의한 프로그래밍(progamming by difference): 부모 클래스와 다른 부분만을 추가해서 새로운 클래스를 쉽고 빠르게 만드는 방법 상속과 인터페이스 상속이 가치 있는 이유는 재사용도 있지만, 부모 클래스가 제공하는 모든 인터페이스를 자식 클래스가 물려받을 수 있기 때문이다. 인터페이스는 객체가 이해할 수 있는 메시지의 목록을 정의한다. 외부 객체는 자식 크래스를 부모 클래스와 동일한 타입으로 간주 할 수 있다. 자식 클래스가 부모 클래스를 대신하는 것을 업캐스팅(upcasting) 이라 한다. 다형성 동일한 메시지를 전송하지만 실제로 어떤 메서드가 실행될 것인지는 메시지를 수신하는 객체의 클래스가 무엇이냐에 따라 달라지는 것 다형성이라 한다.\n다형성은 컴파일 시간 의존성과 런타임 시간 의존성이 다를 수 있다는 사실에 기반으로 한다.\n다형성이란 동일한 메시지를 수신했을 때 객체에 타입에 따라 다르게 응답할 수 있는 능력\n다형적인 협력에 참여할 수 있는 이유는 객체가 동일한 인터페이스를 물려 받았기 때문 다형성을 구현하는 방법은 매우 다양하지만, 메시지에 대한 실행 메서드를 컴파일이 아니라 런타임에 결정한다는 공통점이 있다.\n지연(lazy) 바인딩, 동적(dynamic) 바인딩 이라 한다. 컴파일에 결정하는 것을 초기(early) 바인딩, 정적(static) 바인딩 이라한다. 다형성은 추상적인 개념이며, 구현 할 수 있는 방법이 상속 말고도 다양하다. 구현 상속: 서브클래싱(subclassing)\n순수하게 코드를 재사용하기 위해서 상속하는 것 변경에 취약할 수 있다 인터페이스 상속: 서브타이핑(subtyping)\n다형적인 협력을 위해 부모, 자식이 인터페이스를 공유할 수 있도록 상속하는 것 상속은 인터페이스 상속을 위해 사용해야 한다 추상화의 힘 추상화의 장점\n요구사항의 정책을 높은 수준에서 서술할 수 있다. (협력 흐름을 기술한다.) 세부적인 내용을 무시한 채 상위 정채을 쉽고 간단하게 표현 가능 표현의 수준을 조정하는 것을 가능하게 한다. Ex) \u0026ldquo;영화 예매 요금은 최대 하나의 \u0026lsquo;할인 정책\u0026rsquo;과 다수의 \u0026lsquo;할인 조건\u0026rsquo;을 이용해 계산할 수 있다.\u0026rdquo; 설계가 좀 더 유연해진다. 설계가 구체적인 상황(가령, 예외 케이스)에 결합되는 것을 방지하기 때문 디자인 패턴이나 프레임워크 모두 추상화를 이용해 상위정책을 정의하는 객체지향 메커니즘을 활용한다.\n유연한 설계 항상 예외 케이스를 최소화하고 일관성을 유지할 수 있는 방법을 선택해야 한다.\n일관성 있는 협력 방식이 무너지게 하지 않게 해라 결론: 유연성이 필요한 곳에 추상화를 사용하라.\n코드 재사용, 상속, 합성 코드 재사용을 위해서는 상속보다 합성(composition) 이 더 좋은 방법\nMovie가 DiscountPolicy의 인터페이스를 통해 코드를 재사용하는 방법이 바로 합성 인터페이스에 정의된 메시지를 통해서만 코드를 재사용하는 방법을 합성이라 한다. 상속은 캡슐화를 위반하고, 설계를 유연하지 못하기에 설계에 안 좋은 영향을 미친다.\n상속하기 위해서는 부모 클래스 구조를 잘 알고 있어야 한다. 부모의 내부 구현이 자식에게 노출된다. 캡슐화가 약해짐 상속은 부모, 자식 관계를 컴파일 시점에 결정 =\u0026gt; 설계가 유연해지 못하게 됨\n상속보다 인스턴스 변수로 관계를 연결한 설계가 더 유연하다.\nchangeDiscountPolicy 함수 추가 Reference 오브젝트 (조영호) https://product.kyobobook.co.kr/detail/S000001766367 ","permalink":"https://2taezeat.github.io/posts/%EC%98%A4%EB%B8%8C%EC%A0%9D%ED%8A%B8/%EC%98%A4%EB%B8%8C%EC%A0%9D%ED%8A%B8-ch02.-%EA%B0%9D%EC%B2%B4%EC%A7%80%ED%96%A5-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D/","summary":"2. 객체지향 프로그래밍 객체지향 패러다임에서 집중 해야 하는 두 가지\n클래스 보다는 어떤 객체가 필요한지 고민하라 객체를 독립적인 존재가 아니라 기능을 구현하기 위해 협력하는 공동체의 일원으로 봐야 한다. 도메인(domain): 문제를 해결하기 위해 사용자가 프로그램을 사용하는 분야\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 class Screening(private val movie: Movie, private val sequence: Int, private val whenScreened: LocalDateTime) { fun getStartTime() = whenScreened fun isSequence(sequence: Int) = this.","title":"[오브젝트] ch02. 객체지향 프로그래밍"},{"content":"1. 객체, 설계 프로그래밍에서는 이론 보다 실무가 더 빠르게 탄생하고, 중요하다\n모듈이 크기에 상관 없는, 프로그램을 구성하는 임의의 요소라 할 때, 중요한 것은 - by 로버트 마틴\n실행 중 제대로 동작 변경에 용이 읽는 사람이 이해하기 쉬워야 함 이해 가능한 코드란 그 동작이 우리의 예상(직관)에서 크게 벗어나지 않은 코드\nA 클래스가 B 클래스의 내부에 대해 더 많이 알면 알 수록 변경하기 어려워진다.\n객체 사이의 의존성(dependency) 의존성이라는 말 속에는 어떤 객체가 변경될 때 그 객체에게 의존하는 다른 객체도 함께 변경될 수 있다는 사실이 내포되어 있음 최소한의 의존서만 유지하고 불필요한 의존성을 제거해야 함. 의존성이 과한 경우를 결합도(coupling) 이 높다고 한다.\n캡슐화: 객체 내부의 세부적인 사항을 감추는 것\n캡슐화의 목적은 변경하기 쉬운 객체를 만드는 것 밀접하게 연관된 작업만을 수행하고 연관성 없는 작업은 다른 객체에게 위임하는 객체를 응집도(cohesion) 가 높다고 한다.\n프로세스(Process)와 데이터(Data)를 별도의 모듈에 위치시키는 방식을 절차적(Procedural) 프로그래밍\n우리의 직관에 벗어남, 개발자들의 의사소통이 어려워짐\n수동적인 객체가 많이 생겨남\n데이터의 변경으로 인한 영향을 지역적으로 고립시키기 어려움\n프로세스가 필요한 모든 데이터에 의존해야 한다는 근본적인 문제가 발생하여 변경에 취약\nTheater의 enter 메서드가 프로세스, 나머지는 데이터\n책임이 Theater에 집중\n데이터와 데이터를 사용하는 프로세스가 별도의 객체 안에 위치\n데이터와 프로세스가 동일한 모듈에 위치하도록 프로그래밍 하는 방식 =\u0026gt; OOP\n데이터를 사용하는 프로세스가 데이터를 소유하고 있는 Audience과 TickerSeller 내부로 옮겨짐 필요한 책임이 분산됨 각 객체는 자신을 스스로 책임진다. 객체지향 어플리케이션은 스스로 책임을 수행하는 자율적인 객체들의 공동체를 구성한다. 데이터와 데이터를 사용하는 프로세스가 동일한 객체 안에 위치 책임의 이동(shift of responsibility)\n책임은 기능을 가리키는 객체지향 세계의 용어 의인화(anthropomorphism): 현실에서 수동적인 존재라고 하더라도 객체지향 세계에서 능동적이고 자율적인 존재로 객체를 설계하는 원칙\n변경을 수용할 수 있는 설계가 중요한 이유\n요구사항은 자주 변경 =\u0026gt; 코드 수정 초래 =\u0026gt; 버그 발생 가능성 높임 버그의 가장 큰 문제점은 코드 수정 의지를 꺽는다는 점 절차지향 코드 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 class Invitation { lateinit var _when: LocalDateTime } class Ticket { var fee: Int = 0 } class Bag(val invitation: Invitation?, var amount: Int) { var ticket: Ticket? = Ticket() fun hasInvitation() = invitation != null fun hasTicket() = ticket != null fun minusAmount(amount: Int) { this.amount -= amount } fun plusAmount(amount: Int) { this.amount += amount } } class Audience(val bag: Bag) { } class TicketOffice(private var amount: Int, vararg tickets: Ticket) { private val tickets: MutableList\u0026lt;Ticket\u0026gt; = mutableListOf() init { this.tickets.addAll(tickets.toList()) } val ticket: Ticket get() = tickets.removeAt(0) fun minusAmount(amount: Int) { this.amount -= amount } fun plusAmount(amount: Int) { this.amount += amount } } class TicketSeller(val ticketOffice: TicketOffice) { } class Theater(val ticketSeller: TicketSeller) { fun enter(audience: Audience) { if (audience.bag.hasInvitation()) { val ticket = ticketSeller.ticketOffice.ticket audience.bag.ticket = ticket } else { val ticket = ticketSeller.ticketOffice.ticket audience.bag.minusAmount(ticket.fee) ticketSeller.ticketOffice.plusAmount(ticket.fee) audience.bag.ticket = ticket } } } 객체지향 코드 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 class Invitation { lateinit var _when: LocalDateTime } class Ticket { var fee: Int = 0 } class Bag(val invitation: Invitation?, var amount: Int) { private var ticket: Ticket? = Ticket() private fun hasInvitation() = invitation != null private fun hasTicket() = ticket != null private fun minusAmount(amount: Int) { this.amount -= amount } private fun plusAmount(amount: Int) { this.amount += amount } fun hold(ticket: Ticket): Int { if (hasInvitation()) { this.ticket = ticket return 0 } else { this.ticket = ticket minusAmount(ticket.fee) return ticket.fee } } } class Audience(private val bag: Bag) { fun buy(ticket: Ticket): Int { return bag.hold(ticket) } } class TicketOffice(private var amount: Int, vararg tickets: Ticket) { private val tickets: MutableList\u0026lt;Ticket\u0026gt; = mutableListOf() init { this.tickets.addAll(tickets.toList()) } private val ticket: Ticket get() = tickets.removeAt(0) private fun minusAmount(amount: Int) { this.amount -= amount } private fun plusAmount(amount: Int) { this.amount += amount } fun sellTicketTo(audience: Audience) { plusAmount(audience.buy(ticket)) } } class TicketSeller(private val ticketOffice: TicketOffice) { fun sellTo(audience: Audience) { ticketOffice.sellTicketTo(audience) } } class Theater(private val ticketSeller: TicketSeller) { fun enter(audience: Audience) { ticketSeller.sellTo(audience) } } Reference 오브젝트 (조영호) https://product.kyobobook.co.kr/detail/S000001766367 ","permalink":"https://2taezeat.github.io/posts/%EC%98%A4%EB%B8%8C%EC%A0%9D%ED%8A%B8/%EC%98%A4%EB%B8%8C%EC%A0%9D%ED%8A%B8-ch01.-%EA%B0%9D%EC%B2%B4-%EC%84%A4%EA%B3%84/","summary":"1. 객체, 설계 프로그래밍에서는 이론 보다 실무가 더 빠르게 탄생하고, 중요하다\n모듈이 크기에 상관 없는, 프로그램을 구성하는 임의의 요소라 할 때, 중요한 것은 - by 로버트 마틴\n실행 중 제대로 동작 변경에 용이 읽는 사람이 이해하기 쉬워야 함 이해 가능한 코드란 그 동작이 우리의 예상(직관)에서 크게 벗어나지 않은 코드\nA 클래스가 B 클래스의 내부에 대해 더 많이 알면 알 수록 변경하기 어려워진다.\n객체 사이의 의존성(dependency) 의존성이라는 말 속에는 어떤 객체가 변경될 때 그 객체에게 의존하는 다른 객체도 함께 변경될 수 있다는 사실이 내포되어 있음 최소한의 의존서만 유지하고 불필요한 의존성을 제거해야 함.","title":"[오브젝트] ch01. 객체, 설계"},{"content":"15.1 파일과 디렉터리 15.1.1 파일 컴퓨터를 이용할 때는 파일 단위로 이용한다.\n파일; file: 보조기억장치에 저장된 관련 정보의 집합을 의미\n의미 있고 관련 있는 정보를 모은 논리적 단위 파일을 이루는 정보\n이름 파일을 실행하기 위한 정보 파일 관련 부가 정보: 속성(attribute) 또는 메타데이터(metadata) 파일 속성 중 파일 유형은 운영체제가 인식하는 파일 종류를 나타냄.\n확장자; extension을 사용해서 파일 이름 뒤에 붙어서 파일 유형을 알려줌 파일 연산을 위한 시스템 콜\n파일을 다루는 모든 작업은 운영체제에 의해서만 이뤄짐, 운영체제가 아래 연산을 위한 시스템 콜을 제공\n파일 생성, 삭제, 열기, 닫기, 읽기, 쓰기\n15.1.2 디렉터리 파일들을 일목요연하게 관리하기 위해 디렉터리; directory를 이용할 수 있다. 윈도우에서는 디렉터리를 폴더; folder 라 부름 컴퓨터 용량이 커지니, 저장할 수 있는 파일도 많아지고, 1단계 디렉터리로는 많은 파일을 관리하기가 어렵기 때문에\n여러 계층을 가진 트리 구조 디렉터리가 생겨남. 자연스레 생긴 개념이 바로 경로(Path) 이다, 디렉터리를 이용해 파일 위치, 나아가 파일 이름을 특정 짓는 정보\n절대 경로: 루트 디렉터리(/)부터 시작하는 경로 상대 경로: 현재 디렉터리부터 시작하는 경로 디렉터리 연산을 위한 시스템 콜\n파일 연산을 위해서 운영체제가 시스템 콜을 제공하는 것 처럼, 디렉터리 연산을 위해서도 시스템 콜 제공 디렉터리 생성, 삭제, 열기, 닫기, 읽기 많은 운영체제에서는 디렉터리를 그저 \u0026lsquo;특별한 형태의 파일\u0026rsquo;로 간주 즉, 디렉터리도 파일입니다. 단지 포함된 정보가 조금 특별할 뿐 디렉터리는 내부에 해당 디렉터리에 담겨 있는 대상과 관련된 정보를 담고 있다. 이 정보는 보통 테이블(표) 형태로 구성됩니다. 즉, 디렉터리는 보조기억장치에 테이블 형태의 정보로 저장 디렉터리에 포함된 대상의 이름과 그 대상이 보조기억장치 내에 저장된 위치를 유추할 수 있는 정보가 담긴다 디렉터리 엔트리만 보아도 해당 디렉터리에 무엇이 담겨 있는지, 그것들은 보조기억장치의 어디에 있는지를 직간접적으로 알수 있다. 15.2 파일 시스템 파일 시스템: 파일과 디렉터리를 보조기억장치에 일목요연하게 저장, 접근할 수 있게 하는 운영체제 내부 프로그램 15.2.1 파티셔닝과 포매팅 보조기억장치를 사용하려면 파티션을 나누는 작업(파티셔닝)과 포맷 작업(포매팅) 을 거쳐야 한다. 파티셔닝pirtioning은 저장 장치의 논리적인 영역을 구획하는 작업을 의미 칸막이로 영역을 나누는 작업이 바로 파티셔닝 용량이 큰 저장 장치를 하나 이상의 논리적인 단위로 구획 파티셔닝 작업을 통해 나누어진 영역 하나하나를 파티션; partion 포매팅; fomating: 파일 시스템을 설정하여 어떤 방식으로 파일을 저장 및 관리할 것인지를 결정하고, 새로운 데이터를 쓸 준비를 하는 작업 즉, 어떤 종류의 파일 시스템을 사용할지는 바로 이때 결정 포매팅의 종류에는 엄밀히 말하면 저수준 포매팅과 논리적 포매팅이 있습니다. 저수준 포매팅: 저장 장치를 생성할 당시 공장에서 수행되는 물리적인 포매팅 고수준 포매팅: 파일 시스템을 생성하는 포매팅 여기서 설명하는 포매팅은 고수준 포매팅 15.2.2 파일 할당 방법 운영체제는 파일과 디렉터리를 블록; block 단위로 읽고 쓴다. 즉, 하나의 파일이 보조기억장치에 저장될 때는 하나 이상의 블록에 걸쳐 저장 하드 디스크의 가장 작은 저장 단위는 섹터이지만, 운영체제는 하나 이상의 섹터를 블록이라는 단위로 묶은 뒤 블록 단위로 파일과 디렉터리를 관리 파일 시스템이 모든 섹터를 관리하기에는 개수가 너무 많고 크기도 작기 때문 블록 안에 적힌 번호는 블록의 위치를 식별하는 주소 크기가 작은 파일은 적은 수의 블록에 걸쳐 저장될 것이고, 크기가 큰 파일은 여러 블록에 걸쳐 저장 15.2.2.1 연속 할당, contiguous allocation 연속적인 블록에 파일을 할당하는 방식 외부 단편화 야기 15.2.2.1 연결 할당, linked allocation 연속 할당의 문제를 해결할 수 있는 방식 연결 할당은 각 블록 일부에 다음 블록의 주소를 저장하여 각 블록이 다음 블록을 가리키는 형태로 할당하는 방식 파일을 이루는 데이터를 연결 리스트로 관리 연결 할당은 불연속 할당의 일종이기에 파일이여러 블록에 흩어져 저장되어도 무방 \u0026lsquo;어떤 블록의 주소를 저장한다\u0026rsquo;는 말은 \u0026lsquo;그 블록을 가리킨다\u0026rsquo;는 말과 같다. 어떤 블록의 주소를 알면 해당 블든지 접근할 수 있기 때문 C언어의 포인터와 같은 개념 단점 1. 반드시 첫 번째 블록부터 하나씩 차례대로 읽어야 한다.\n파일의 중간 부분부터 접근하고 싶어도, 반드시 파일의 첫 번째 블록부터 접근하여 하나씩 차례대로 읽어야 한다. 파일 내의 임의 접근; random access 속도가 매우 느림 단점 2. 하드웨어 고장이나 오류 발생 시 해당 블록 이후 블록은 접근할 수 없다.\n하나의 블록 안에 파일 데이터와 다음 블록 주소가 모두 포함되어 있다 보니,\n블록에 하나라도 문제가 발생하면, 그 블록 이후의 블록에 접근할 수 없다는 것\n연결 할당을 변형한 것이 오늘날까지도 많이 사용하는 FAT 파일 시스템 이다.\n15.2.2.3 색인 할당, indexed allocation 색인 할당은 파일의 모든 블록 주소를 색인 블록; index block 이라는 하나의 블록에 모아 관리하는 방식 색인 할당은 연결 할당과는 달리 파일 내 임의의 위치에 접근하기 쉽다. 파일의 i번째 데이터 블록에 접근하고 싶다면 색인 블록의 i번째 항목이 가리키는 블록에 접근하면 되기 때문 색인 할당 파일 시스템에서는 디렉터리 엔트리에 파일 이름과 더불어 색인 블록 주소를 명시 색인 할당을 기반으로 만든 파일 시스템이 유닉스 파일 시스템 이다. 15.2.3 파일 시스템 살펴보기 다양한 파일 시스템이 있지만 여러 전공서에서 공통으로 소개하는 파일 시스템은 크게 두 가지 하나는 USB 메모리, SD 카드 등의 저용량 저장 장치에서 사용되는 FAT 파일 시스템 다른 하나는 유닉스 계열 운영체제에서 사용되는 유닉스 파일 시스템 15.2.3.1 FAT 파일 시스템 각 블록에 포함된 다음 블록의 주소들을 한데 모아 테이블 형태로 관리하면 연결 할당 방식의 단점 해소 이러한 테이블을 파일 할당 테이블 FAT; File Allocation Table, FAT 라고 한다. 15.2.3.2 유닉스 파일 시스템 색인 할당은 색인 블록을 기반으로 파일의 데이터 블록들을 찾는 방식이라고 소개했습니다. 유닉스 파일 시스템에서는 이 색인 블록을 i-node; index-node 라 한다. i-node에는 파일 속성 정보와 열다섯 개의 블록 주소가 저장될 수 있다. 유닉스 파일 시스템에서 파일 속성 정보는 i-node에 표현 유닉스 파일 시스템에는 파일마다 이러한 i-node가 있고, i-node마다 번호가 부여되어 있다. i-node들은 다음과 같이 파티션 내 특정 영역에 모여 있다. i-node 영역에 i-node들이 있고, 데이터 영역에 디렉터리와 파일들이 있다. i-node 하나는 열다섯 개의 블록을 차지하는 파일까지 가리킬 수 있다. 하지만 블록을 20개, 30개, 그 이상 차지하는 큰 파일도 존재한다. i-node 하나만으로는 파일의 데이터 블록을 모두 가리킬 수 없다. 유닉스 파일 시스템은 이러한 문제를 해결 첫째, 블록 주소 중 열두 개에는 직접 블록 주소를 저장합니다. 직접 블록; direct block: 파일 데이터가 저장된 블록 둘째, \u0026lsquo;첫째\u0026rsquo; 내용으로 충분하지 않다면 열세 번째 주소에 단일 간접 블록 주소를 저장 단일 간접 블록 single indirect block: 파일 데이터를 저장한 블록 주소가 저장된 블록 셋째, \u0026lsquo;둘째\u0026rsquo; 내용으로 충분하지 않다면 열네 번째 주소에 이중 간접 블록 주소를 저장 이중 간접 블록; double indirect block:란 데이터 블록 주소를 저장하는 블록 주소가 저장된 블록을 의미 넷째, \u0026lsquo;셋째\u0026rsquo; 내용으로 충분하지 않다면 열다섯 번째 주소에 삼중 간접 블록 주소를 저장 파일 시스템을 아우르는 개념은 방대 파일 시스템만을 다루는 전공서도 많다. 윈도우 운영체제에서 사용되는 NT 파일 시스템(NTFS) 리눅스 운영체제에서 사용되는 ext 파일 시스템 15.3 저널링 파일 시스템 15.4 마운트 \u0026lsquo;저장 장치를 마운트한다\u0026rsquo; 한 저장 장치의 파일 시스템에서 다른 저장 장치의 파일 시스템에 접근할 수 있도록 파일 시스템을 편입시키는 작업을 의미 Reference 혼자 공부하는 컴퓨터구조+운영체제 (강민철, 한빛미디어) https://product.kyobobook.co.kr/detail/S000061584886 ","permalink":"https://2taezeat.github.io/posts/os/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0-+-%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C-ch15.-%ED%8C%8C%EC%9D%BC-%EC%8B%9C%EC%8A%A4%ED%85%9C/","summary":"15.1 파일과 디렉터리 15.1.1 파일 컴퓨터를 이용할 때는 파일 단위로 이용한다.\n파일; file: 보조기억장치에 저장된 관련 정보의 집합을 의미\n의미 있고 관련 있는 정보를 모은 논리적 단위 파일을 이루는 정보\n이름 파일을 실행하기 위한 정보 파일 관련 부가 정보: 속성(attribute) 또는 메타데이터(metadata) 파일 속성 중 파일 유형은 운영체제가 인식하는 파일 종류를 나타냄.\n확장자; extension을 사용해서 파일 이름 뒤에 붙어서 파일 유형을 알려줌 파일 연산을 위한 시스템 콜\n파일을 다루는 모든 작업은 운영체제에 의해서만 이뤄짐, 운영체제가 아래 연산을 위한 시스템 콜을 제공","title":"[컴퓨터구조 + 운영체제] ch15. 파일 시스템"},{"content":"14.1 연속 메모리 할당 연속 메모리 할당 방식: 프로세스에 연속적인 메모리 공간을 할당하는 방식 14.1.1 스와핑 메모리에 적재된 프로세스들 중에는 현재 실행되지 않는 프로세스가 존재 입출력 작업의 요구로 대기 상태가 된 프로세스 오랫동안 사용되지 않은 프로세스 스와핑; swapping: 이러한 프로세스들을 임시로 보조기억장치 일부 영역으로 쫓아내고, 그렇게 해서 생긴 메 모리상의 빈 공간에 또 다른 프로세스를 적재하여 실행하는 방식 스왑 영역; swap space: 프로세스들이 쫓겨나는 보조기억장치의 일부 영역 스왑 아웃; swap-out: 현재 실행되지 않는 프로세스가 메모리에서 스왑 영역으로 옮겨지는 것 스왑 인; swap-in: 반대로스왑 영역에 있던 프로세스가 다시 메모리로 옮겨오는 것 스왑 아웃되었던 프로세스가 다시 스왑 인될 때는 스왑 아웃되기 전의 물리 주소와는 다른 주소에 적재될 수 있다 스와핑을 이용하면 프로세스들이 요구하는 메모리 주소 공간의 크기가 실제 메모리 크기보다 큰 경우에도 프로세스들을 동시 실행 가능 프로세스 A, B, C, D의 크기를 합하면 메모리의 크기보다 크지만, 스와핑을 통해 네 개의 프로세스를 동시에 실행 가능 14.1.2 메모리 할당 프로세스는 메모리 내의 빈 공간에 적재되어야 한다.\n여기에는 세 가지 방식이 존재 14.1.2.1 최초 적합, first fit 최초 적합은 운영체제가 메모리 내의 빈 공간을 순서대로 검색하다가 적재할 수 있는 공간을 발견하면 그 공간에 바로 프로세스를 배치하는 방식\n최초 적합 방식은 프로세스가 적재될 수 있는 공간을 발견하는 즉시 메모리를 할당하는 방식이므로 검색을 최소화 및 빠른 할당이 가능\n14.1.2.2 최적 적합, best fit 최적 적합 운영체제가 빈 공간을 모두 검색해 본 후, 프로세스가 적재될 수 있는 공간 중 가장 작은 공간에 프로세스를 배치하는 방식 최적 적합 방식으로 메모리를 할당하면 프로세스는 빈공간 C에 할당됩니다. 14.1.2.3 최악 접합, worst fit 최악 적합은 운영체제가 빈 공간을 모두 검색해 본 후, 프로세스가 적재될 수 있는 공간 중 가장 큰 공간에 프로세스를 배치하는 방식 최악 적합 방식으로 메모리를 할당하면 프로세스는 빈공간 B에 할당됩니다. 14.1.3 외부 단편화 연속 메모리 할당은 언뜻 들으면 당연하게 느껴질 수 있지만, 사실 이는 메모리를 효율적으로 사용하는 방법이 아니다.\n왜냐하면 외부단편화; external fragmentation 라는 문제를 내포하고 있기 때문\n프로세스들이 메모리에 연속적으로 할당되는 환경에서는 실행되고 종료되기를 반복하며 메모리 사이 사이에 빈 공간들이 생긴다.\n프로세스 바깥에 생기는 이러한 빈 공간들은 분명 빈 공간이지만 그 공간보다 큰 프로세스를 적재하기 어려운 상황을 초래하고, 결국 메모리 낭비로 이어짐\n이러한 현상을 외부단편화; external fragmentation 라 한다.\n외부 단편화: 프로세스를 할당하기 어려울 만큼 작은 메모리 공간들로 인해 메모리가 낭비되는 현상\n외부 단편화를 해결할 수 있는 대표적인 방안으로 메모리를 압축; compaction(메모리 조각 모음) 하는 방법이 존재\n흩어져 있는 빈 공간들을 하나로 모으는 방식으로 프로세스를 재배치시켜 흩어져 있는 작은 빈 공간들을 하나의 큰 빈 공간으로 만드는 방법 압축 방식은 여러 단점 존재\n작은 빈 공간들을 하나로 모으는 동안 시스템은 하던 일을 중지해야 하고,\n메모리에 있는 내용을 옮기는 작업은 많은 오버헤드를 야기하며,\n어떤 프로세스를 어떻게 움직여야 오버헤드를 최소화하며 압축할 수 있는지에 대한 명확한 방법을 결정하기 어려움\n이에 외부 단편화를 없앨 수 있는 또 다른 해결 방안 - 오늘날까지도 사용되는 가상 메모리 기법, 그 중에서도 페이징 기법\n14.2 페이징을 통한 가상 메모리 관리 프로세스를 메모리에 연속적으로 할당하는 방식은 두 가지 문제를 내포\n외부 단편화\n물리 메모리보다 큰 프로세스를 실행할 수 없다는 점\n가상 메모리 virtual memory는 실행하고자 하는 프로그램을 일부만 메모리에 적재하여 실제 물리 메모리 크기보다 더 큰 프로세스를 실행할 수 있게 하는 기술\n가상 메모리 관리 기법에는 크게 페이징과 세그멘테이션이 존재 페이징 기법을 이용하면 물리 메모리보다 큰 프로세스를 실행할 수 있을 뿐만아니라, 앞선 절에서 배운 외부 단편화 문제도 해결할 수 있다. 현대 대부분의 운영체제가 사용 14.2.1 페이징이란 외부 단편화가 생긴 근본적인 이유는 각기 다른 크기의 프로세스가 메모리에 연속적으로 할당되었기 때문 페이징은 메모리의 물리 주소 공간을 프레임; frame 단위로 자르고, 프로세스의 논리 주소 공간을 페이지; page 단위로 자른 뒤, 각 페이지(page, 논리) 를 프레임(frame, 물리) 에 할당하는 가상 메모리 관리 기법 페이징에서도 스와핑을 사용할 수 있다. 페이징을 사용하는 시스템에서는 프로세스 전체가 스왑 아웃/스왑 인되는 것이 아닌, 페이지 단위로 스왑 아웃/스왑 인 된다. 즉, 메모리에 적재될 필요가 없는 페이지들은 보조기억장치로 스왑 아웃(페이지 아웃) 되고, 실행에 필요한 페이지들은 메모리로 스왑 인(페이지 인) 되는 것 한 프로세스를 실행하기 위해 프로세스 전체가 메모리에 적재될 필요가 없다는 말과 같다. 프로세스를 이루는 페이지 중 실행에 필요한 일부 페이지만을 메모리에 적재하고, 당장 실행에 필요하지 않은 페이지들은 보조기억장치에 남겨둘 수 있다. 이와 같은 방식을 통해 물리 메모리보다 더 큰 프로세스를 실행할 수 있다 14.2.1.1 페이징의 이점 - 쓰기 시 복사 운영체제에서 fork 시스템 호출을 하면 부모 프로세스의 복사본이 자식 프로세서로서 만들어짐.\n복사 작업은 프로세스 생성 시간을 늦출 뿐만 아니라 불필요한 메모리 낭비를 야기\n부모 프로세스 혹은 자식 프로세스 둘 중 하나가 페이지에 쓰기 작업을 하면, 그 순간 해당 페이지가 별도의 공간으로 복제\n각 프로세스는 자신의 고유한 페이지가 할당된 프레임을 가리키킴, 이것이 쓰기 시 복사; copy on write 이다. 프로세스 생성 시간을 줄이는 것은 물론 메모리 공간 절약도 가능 14.2.1.2 계층적 페이징 페이지 테이블의 크기는 작지 않다. 프로세스를 이루는 모든 페이지 테이블 엔트리를 메모리에 두는 것은 큰 메모리 낭비 이에 프로세스를 이루는 모든 페이지 테이블 엔트리를 항상 메모리에 유지하지 않을 수 있는 방법이 등장 계층적 페이징; hierarchical Paging 계층적 페이징은 페이지 테이블을 페이징하여 여러 단계의 페이지를 두는 방식 여러 단계의 페이지를 둔다는 점에서 다단계 페이지 테이블; multilevel page table 기법으로 불린다. 페이지 테이블을 여러 개의 페이지로 자르고, 바깥쪽에 페이지 테이블을 하나 더 두어 잘린 페이지 테이블의 페이지들을 가리키게 하는 방식 페이지 테이블을 이렇게 계층적으로 구성하면 모든 페이지 테이블을 항상 메모리에 유지할 필요가 없다. 페이지 테이블들 중 몇 개는 보조기억장치에 있어도 무방하며, 추후 해당 페이지 테이블을 참조해야 할 때가 있으면 그때 메모리에 적재 다만 CPU와 가장 가까이 위치한 페이지 테이블(Outer 페이지 테이블)은 항상 메모리에 유지해야 한다. 계층적 페이징을 이용하는 환경에서의 논리 주소는 아래와 같은 형태로 만들어짐. 바깥 페이지 번호에 해당하는 항목은 CPU와 근접한 곳에 위치한 (바깥에 위치한) 페이지 테이블 엔트리를 가리키고 안쪽 페이지 번호는 첫 번째 페이지 테이블 바깥에 위치한 두 번째 페이지 테이블, 즉 페이지 테이블의 페이지 번호를 가리킴 논리 주소를 토대로 주소 변환은 다음과 같이 이루어짐 바깥 페이지 번호를 통해, 페이지 테이블의 페이지를 찾기 페이지 테이블의 페이지를 통해 프레임 번호를 찾고 변위를 더함으로서 물리 주소 얻기 페이지 테이블의 계층이 늘어날수록 페이지 폴트가 발생했을 경우 메모리 참조 횟수가 많아짐. 계층이 많다고 해서 반드시 좋다고 볼 수는 없다. 14.2.2 페이지 테이블 여기서 문제가 있다. 프로세스가 메모리에 불연속적으로 배치되어 있다면 CPU 입장에서 이를 순차적으로 실행할 수가 없다. 프로세스를 이루는 페이지가 어느 프레임에 적재되어 있는지 CPU가 모두 알고 있기란 어렵기 때문입 즉, 프로세스가 메모리에 불연속적으로 배치되면 CPU 입장에서 \u0026lsquo;다음에 실행할 명령어 위치\u0026rsquo; 를 찾기가 어려움 이를 해결하기 위해 페이징 시스템은 프로세스가 비록 (실제 메모리 내의 주소인) 물리 주소에 불연속적으로 배치되더라도 (CPU가 바라보는 주소인) 논리 주소에는 연속적으로 배치되도록 페이지 테이블; page table을 이용 페이지 테이블은 페이지 번호와 프레임 번호를 짝지어 줌 (매핑) CPU로 하여금 페이지 번호만 보고 해당 페이지가 적재된 프레임을 찾을 수 있게 한다. 페이지 테이블은 현재 어떤 페이지가 어떤 프레임에 할당되었는지를 알려줌. 프로세스마다 각자의 페이지 테이블을 가지고 있고 각 프로세스의 페이지 테이블들은 메모리에 적재되어 있다. CPU 내의 Page Table Base Register; PTBR는 각 프로세스의 페이지 테이블이 적재된 주소를 가리킴 이러한 각 프로세스들의 페이지 테이블 정보들은 각 프로세스의 PCB에 기록\n프로세스의 문맥 교환이 일어날 때 다른 레지스터와 마찬가지로 함께 변경\n페이지 테이블을 메모리에 두면 문제가 발생 - 두 번의 메모리 접근이 필요하게 됨 메모리에 있는 페이지 테이블을 보기 위해 한 번 그렇게 알게 된 프레임에 접근하기위해 한 번 이 문제를 해결하기 위해, CPU 곁에 (MMU 내에) TLB; Translation Lookaside Buffer라는 페이지 테이블의 캐시 메모리를 둔다. CPU 곁에는 TLB가 있다. TLB는 페이지 테이블의 캐시이기 때문에 페이지 테이블의 일부 내용을 저장 참조 지역성에 근거해 주로 최근에 사용된 페이지 위주로 가져와 저장 CPU가 발생한 논리 주소에 대한 페이지 번호가 TLB에 있을 경우 이를 TLB hit 라 한다.\n페이지가 적재된 프레임을 알기 위해 메모리에 접근할 필요가 없다. 그렇기에 메모리 접근을 한 번만 하면 됩니다. 페이지 번호가 TLB에 없을 경우, 어쩔 수 없이 페이지가 적재된 프레임을 알기 위해 메모리 내의 페이지 테이블에 접근하는 수 밖에 없다. - TLB miss\n14.2.3 내부 단편화 페이징은 외부 단편화 문제를 해결할 수 있지만, 내부 단편화(internal fragmentation) 문제를 야기할 수 있다.\n페이징은 프로세스의 논리 주소 공간을 페이지라는 일정한 크기 단위로 자름 그런데 모든 프로세스가 페이지 크기에 딱 맞게 잘리는 것은 아니다, 모든 프로세스 크기가 페이지의 배수는 아니다. 가령 페이지 크기가 10 KB인데, 프로세스의 크기가 108 KB 인 경우, 마지막 페이지는 2(=110-108) KB 만큼의 크기가 남음 이러한 메모리 낭비를 내부 단편화라고 합니다.\n내부 단편화는 하나의 페이지 크기보다 작은 크기로 발생\n하나의 페이지 크기가 작다면 발생하는 내부 단편화의 크기는 작아질 것으로 기대할 수 있다.\n하지만 하나의 페이지 크기를 너무 작게 설정하면, 그만큼 페이지 테이블의 크기도 커지기 때문에 페이지 테이블이 차지하는 공간이 낭비\n그렇기에 내부 단편화를 적당히 방지하면서 너무 크지 않은 페이지 테이블이 만들어지도록 페이지의 크기를 조정하는 것이 중요\n일부 운영체제에서는 기본적으로 설정된 페이지 크기보다 더 큰 크기의 페이지; 대형 페이지(huge page) 도 일부 허용하며 메모리에 유지하는 경우도 있다. 14.2.4 페이징에서의 주소 변환 하나의 페이지 혹은 프레임은 여러 주소를 포괄, 그렇기에 특정 주소에 접근하려면 아래와 같은 두 가지 정보가 필요\n어떤 페이지 혹은 프레임에 접근하고 싶은지 (페이지 번호) 접근하려는 주소가 그 페이지 혹은 프레임으로부터 얼마나 떨어져 있는지(offset) 그렇기에 페이징 시스템에서는 모든 논리 주소 페이지 번호 page number와 변위; offset로 이루어져 있습니다. 가령 CPU가 32비트 주소를 내보냈다면, 이 중 N비트는 페이지 번호, 32-N 비트는 변위 페이지 번호: 말 그대로 접근하고자 하는 페이지 번호 페이지 테이블에서 해당 페이지 번호를 찾으면 페이지가 어떤 프레임에 할당되었는지를 알 수 있음 변위는 접근하려는 주소가 프레임의 시작 번지로부터 얼만큼 떨어져 있는지를 알기 위한 정보 즉, 논리 주소 [페이지 번호, 변위] 는 페이지 테이블을 통해 물리 주소 [프레임 번호, 변위] 로 변환 14.2.5 페이지 테이블 엔트리 페이지 테이블 엔트리PTE; Page Table Enty: 페이지 테이블의 각각의 행들 14.2.5.1 유효 비트; valid bit 유효 비트 현재 해당 페이지에 접근 가능한지 여부를 알려줌 (중요한 정보)\n일반적으로 프로세스를 이루는 모든 페이지가 메모리에 있지 않는다. (스와핑 때문)\n일부 페이지는 보조기억장치(스왑 영역) 에 있는 경우가 많다. 유효 비트는 현재 페이지가 메모리에 적재되어 있는지(=1) 아니면 보조기억장치에 있는지를 알려주는 비트(=0)\n만일 CPU가 유효 비트가 0인 메모리에 적재되어 있지 않은 페이지로 접근하려고 하면, 페이지 폴트; Page fault 라는 예외(Exception)가 발생\nCPU가 페이지 폴트를 처리하는 과정은 하드웨어 인터럽트를 처리하는 과정과 유사\nCPU는 기존의 작업 내역을 백업 페이지 폴트 처리 루틴을 실행 페이지 처리 루틴은 원하는 페이지를 메모리로 가져온 뒤 유효 비트를 1로 변경해 준다. 페이지 폴트를 처리했다면, CPU는 해당 페이지에 접근 가능 14.2.5.2 보호 비트; protection bit 보호 비트는 페이지 보호 기능을 위해 존재하는 비트입니다. 보호 비트를 통해 해당 페이지가 읽고 쓰기가 모두 가능한 페이지인지, 혹은 읽기만 가능한 페이지인지를 나타낼 수 있다. 보호 비트는 읽기(Read, r), 쓰기(Write, w), 실행(eXecute, x)의 조합으로 읽기, 쓰기, 실행하기 권한의 나타낸다. 보호 비트가 100인 페이지의 경우 1은 1, w와 x는 0이므로 이 페이지는 읽기만 가능 보호 비트가 110인 페이지의 경우 이 페이지는 읽고 쓰기만 가능하고 실행은 불가능 보호 비트가 111인페이지는 읽기, 쓰기, 실행이 모두 가능 14.2.5.3 참조 비트; reference bit 참조 비트 CPU가 이 페이지에 접근한 적이 있는지 여부를 나타냄. 적재 이후 CPU가 읽거나 쓴 페이지는 참조 비트가 1로 세팅되고, 적재 이후 읽거나 쓴 적이 없는 페이지는 0으로 유지 14.2.5.4 수정 비트; modified bit, dirty bit 수정 비트는 해당 페이지에 데이터를 쓴 적(write) 이 있는지 없는지 수정 여부를 알려줌.\n이 비트가 1이면 변경된 적이 있는 페이지, 0이면 변경된 적이 없는 페이지(한 번도 접근한 적 없거나, read만 했던 페이지)임을 나타냄.\n수정 비트는 페이지가 메모리에서 사라질 때, 보조기억장치에 쓰기 작업을 해야 하는지, 할 필요가 없는지를 판단하기 위해 존재\n이렇게 수정된 적이 있는 페이지가 스왑 아웃될 경우 변경된 값을 보조기억장치에 기록하는 작업이 추가되어야 함. 페이지 테이블 엔트리에 수정 비트를 통해 이 작업 필요성을 판단 14.3 페이지 교체와 프레임 할당 14.3.1 요구 페이징 요구 페이징; demand paging: 프로세스를 메모리에 적재할 때 처음부터 모든 페이지를 적재하지 않고 필요한 페이지만을 메모리에 적재하는 기법 요구 페이징의 기본적인 양상 CPU가 특정 페이지에 접근하는 명령어를 실행한다. 해당 페이지가 현재 메모리에 있을 경우 (유효 비트가 1일 경우) CPU는 페이지가 적재된 프레임에 접근한다. 해당 페이지가 현재 메모리에 없을 경우 (유효 비트가 0일 경우) 페이지 폴트가 발생한다. 페이지 폴트 처리 루틴은 해당 페이지를 메모리로 적재하고 유효 비트를 1로 설정한다. 다시 1번을 수행한다. 14.3.2 페이지 교체 알고리즘 요구 페이징 기법으로 페이지들을 적재하다 보면 언젠가 메모리가 가득 참\n이때는 당장 실행에 필요한 페이지를 적재하기 위해 메모리에 적재된 페이지를 보조기억장치로 내보내야 한다. 페이지 교체 알고리즘: 메모리에 적재된 많고 많은 페이지 중 어떤 페이지를 내보내는 것이 최선인지 결정하는 방법\n쫓아낼 페이지를 결정하는 방법 좋은 페이지 교체 알고리즘\n일반적으로 페이지 폴트를 가장 적게 일으키는 알고리즘 어떤 알고리즘을 통해 고른 페이지를 스왑 아웃시켜도 페이지 폴트가 자주 발생하지 않는다면 이는 성능 저하를 방지하는 좋은 알고리즘 페이지 폴트가 일어나면 보조기억장치로부터 페이지를 가져와야 하기에 메모리에 적재된 페이지를 가져오는 것보다 느려지기 때문 한 알고리즘을 통해 고른 페이지를 스왑 아웃시켰을 때 페이지 폴트가 자주 발생하면 이는 좋은 알고리즘이 아님.\n내보내면 안 되는 페이지를 보조기억장치로 내보냈기 때문 페이지 교체 알고리즘을 이해하려면 페이지 폴트 횟수를 알 아야 한다.\n페이지 폴트 횟수는 페이지 참조열; page reference sting을 통해 알 수 있다. 페이지 참조열; page reference sting: CPU가 참조하는 페이지들 중 연속된 페이지를 생략한 페이지열\n연속된 페이지를 생략하는 이유는 중복된 페이지를 참조하는 행위는 페이지 폴트를 발생시키지 않기 때문 14.3.2.1 FIFO, 페이지 교체 알고리즘 First-in First-Out 이름 그대로 메모리에 가장 먼저 올라온 페이지부터 내쫓는 방식 \u0026ldquo;\u0026ldquo;오래 머물렀다면 나가라\u0026quot;는 알고리즘 장점: 아이디어와 구현이 간단 단점: 실행 초기에 적재된 페이지 속에는 프로그램 실행 내내 사용될 내용을 포함하고 있을 수도 있다. 이런 페이지는메모리에 먼저 적재되었다고 해서 내쫓아내는 것은 비효율 14.3.2.1 Optimal(최적), 페이지 교체 알고리즘 앞으로의 사용 빈도가 가장 낮은 페이지를 교체하는 알고리즘\nCPU에 의해 참조되는 횟수를 고려\n잘 생각해 보면 메모리에 오랫동안 남아야 할 페이지는 자주 사용될 페이지 보조기억장치로 내보내야 할 페이지는 앞으로 사용 빈도가 가장 낮은 페이지 장점: 타 페이지 교체 알고리즘에 비해 페이지 폴트 발생 빈도가 가장 낮다.\n단점: 최적 페이지 교체 알고리즘은 실제 구현이 어려움: \u0026lsquo;앞으로 오랫동안 사용되지 않을 페이지\u0026rsquo;를 예측하기란 어렵다.\n프로세스가 앞으로 메모리 어느 부분을 어떻게 참조할지 미리 알아야 하는데, 이는 현실적으로 불가능 다른 페이지 교체 알고리즘의 이론상 성능을 평가하기 위한 목적으로 사용\n최적 페이지 교체 알고리즘(하한선)에 비해 얼만큼 페이지 폴트 횟수가 발생하느냐를 통해 페이지 교체 알고리즘을 평가하기 위해 사용 14.3.2.1 LRU, 페이지 교체 알고리즘 가장 오랫동안 사용되지 \u0026lsquo;않은\u0026rsquo; 페이지를 교체하는 알고리즘은 구현이 가능, Least Recenty Used \u0026lsquo;최근에 사용되지 않은 페이지는 앞으로도 사용되지 않을 것\u0026rsquo;이라는 아이디어를 토대로 만들어짐 페이지마다 마지막으로 사용한 시간을 토대로 최근에 가장 사용이 적었던 페이지를 교체 14.3.3 스래싱과 프레임 할당 페이지 폴트가 자주 발생하는 이유에 나쁜 페이지 교체 알고리즘만 있는 건 아니다. 프로세스가 사용할 수 있는 프레임 수가 적어도 페이지 폴트는 자주 발생 사실 이것이 더 근본적인 이유라고 볼 수 있다. 이처럼 프레임이 부족하면 CPU는 페이지 폴트가 자주 발생할 수밖에 없다. 실행의 맥이 탁 탁끊기고, 결과적으로 CPU의 이용률도 떨어짐 페이지 교체에 너무 많은 시간을 쏟으면 당연히 성능에도 큰 악영향 프로세스가 실제 실행되는 시간보다 페이징에 더 많은 시간을 소요하여 성능이 저해되는 것을 스래싱; thrashling 이라 한다. 가로축인 멀티프로그래밍의 정도를 통해 메모리에 올라와 있는 프로세스의 수를 알 수 있다.\n멀티프로그래밍의 정도: 메모리에서 동시 실행되는 프로세스의 수 멀티프로그래밍의 정도가 높다면 현재 메모리에는 많은 프로세스가 동시에 실행 중이라는 이야기 동시에 실행되는 프로세스의 수 (멀티프로그래밍의 정도)를 늘린다고 해서 CPU 이용률이 비례해서 증가하는 것이 아님\n필요 이상으로 늘리면 각 프로세스들이 사용할 수 있는 프레임 수가 적어지기 때문에 페이지 폴트가 지나치게 빈번히 발생\n스래싱이 발생하는 근본적인 원인은 각 프로세스가 필요로 하는 최소한의 프레임 수가 보장되지 않았기 때문\n균등 할당; equal allocation: 모든 프로세스에 균등하게 프레임을 제공하는 방식\n실행되는 프로세스들의 크기는각기 다른데, 천편일률적으로 동일한 프레임 개수를 할당하는 것은 비합리적 가장 단순한 형태의 프레임 할당 방식 비례 할당; proportional allocation: 프로세스의 크기가 크면 프레임을 많이 할당하고 크기가 작으면 프레임을 적게 나눠주는 방식\n프로세스의 크기와 프레임이 필요한 경우의 수는 비례하지 않을 수 있다. 한계점: 프로세스가 실제로 얼마나 많은 프레임이 필요할지는 결국 실행해 봐야 아는 경우가 많다. 균등 할당과 비례 할당 방식은 프로세스의 실행 과정을 고려하지 않고 단순히 프로세스의 크기와 물리 메모리의 크기만을 고려한 방식이라는 점에서 정적 할당 방식 이라 한다.\n프로세스를 실행하는 과정에서 배분할 프레임을 결정하는 방식 (동적 할당 방식) 작업 집합 모델; working set model 을 사용하는 방식 페이지 폴트 빈도 PPF; Page-Fault Frequency를 사용하는 방식 이 두 개 방식은 프로세스의 실행을 보고 할당할 프레임 수를 결정한다는 점에서 동적 할당 방식 이라 한다. 작업 집합; working set: 실행 중인 프로세스가 일정 시간 동안 참조한 페이지의 집합 작업 집합 모델 기반 프레임 할당 방식은 \u0026lsquo;프로세스가 일정 기간 동안 참조한 페이지 집합\u0026rsquo;을 기억하여 빈번한 페이지 교체를 방지 CPU가 메모리를 참조할 때에는 참조 지역성의 원리에 의거해 주로 비슷한 구역을 집중적으로 참조 만약 CPU가 어떤 프로세스를 실행하는 동안 3초에 20개의 페이지를 집중적으로 참조했다면 운영체제는 그 프로세스를 위해 그 순간만큼은 최소 20개의 프레임을 할당하면 된다. 페이지 폴트 기반, 두 개의 가정에서 생겨난 아이디어\n페이지 폴트율이 너무 높으면 그 프로세스는 너무 적은 프레임을 갖고 있다. 페이지 폴트율이 너무 낮으면 그 프로세스가 너무 많은 프레임을 갖고 있다. 만일 페이지 폴트율이 상한선보다 더 높아지면 그 프로세스는 너무 적은 프레임을 갖고 있다고 볼 수있다.\n이 경우 프레임을 더 할당해 주면 됩니다. 반대로 페이지 폴트율이 하한선보다 더 낮아지면 그 프로세스는 너무 많은 프레임을 갖고 있다고 볼 수 있다.\n이 경우 다른 프로세스에 할당하기 위해 프레임을 회수합니다. 페이지 폴트 빈도 기반 프레임 할당 방식은 페이지 폴트율 에 상한선과 하한선을 정하고, 이 범위 안에서만 프레임을 할당\nReference 혼자 공부하는 컴퓨터구조+운영체제 (강민철, 한빛미디어) https://product.kyobobook.co.kr/detail/S000061584886 ","permalink":"https://2taezeat.github.io/posts/os/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0-+-%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C-ch14.-%EA%B0%80%EC%83%81-%EB%A9%94%EB%AA%A8%EB%A6%AC/","summary":"14.1 연속 메모리 할당 연속 메모리 할당 방식: 프로세스에 연속적인 메모리 공간을 할당하는 방식 14.1.1 스와핑 메모리에 적재된 프로세스들 중에는 현재 실행되지 않는 프로세스가 존재 입출력 작업의 요구로 대기 상태가 된 프로세스 오랫동안 사용되지 않은 프로세스 스와핑; swapping: 이러한 프로세스들을 임시로 보조기억장치 일부 영역으로 쫓아내고, 그렇게 해서 생긴 메 모리상의 빈 공간에 또 다른 프로세스를 적재하여 실행하는 방식 스왑 영역; swap space: 프로세스들이 쫓겨나는 보조기억장치의 일부 영역 스왑 아웃; swap-out: 현재 실행되지 않는 프로세스가 메모리에서 스왑 영역으로 옮겨지는 것 스왑 인; swap-in: 반대로스왑 영역에 있던 프로세스가 다시 메모리로 옮겨오는 것 스왑 아웃되었던 프로세스가 다시 스왑 인될 때는 스왑 아웃되기 전의 물리 주소와는 다른 주소에 적재될 수 있다 스와핑을 이용하면 프로세스들이 요구하는 메모리 주소 공간의 크기가 실제 메모리 크기보다 큰 경우에도 프로세스들을 동시 실행 가능 프로세스 A, B, C, D의 크기를 합하면 메모리의 크기보다 크지만, 스와핑을 통해 네 개의 프로세스를 동시에 실행 가능 14.","title":"[컴퓨터구조 + 운영체제] ch14. 가상 메모리"},{"content":"13.1 교착 상태란 13.1.1 식사하는 철학자 문제 식사하는 철학자 문제; dining philosophers problem 는 교착 상태(dead lock) 상황을 설명하기 위한 고전적인 문제 상황 모든 철학자가 동시에 포크를 집어 식사를 하면 어떤 철학자도 식사를 할 수 없고 영원히 생각만 하는 상황이 발생 모든 철학자가 왼쪽 포크를 집어들면 모두가 오른쪽 포크를 집어들 수 없기 때문 다시 말해 모든 철학자는 다른 철학자가 포크를 내려놓을 때까지 기다림 포크-임계 구역 or 자원 철학자-프로세스 or 스레드 생각하는 행위-자원을 기다리는 것 교착 상태; deadlock: 영원히 일어나지 않을 사건을 기다리며, 진행이 멈춰 버리는 현상 프로세스A는 임계 구역 진입 전 lock1을 잠그고 (lock1 = true), 프로세스B는 임계 구역 진입 전 lock2를 잠갔다고 (lock2 = true) 가정 만일 프로세스 A는 lock2가 false가 되길 기다리고, 프로세스 B는 lock1이 false가 되길 기다린다면 교착 상태가 발생 13.1.2 자원 할당 그래프 교착 상태는 자원 할당 그래프 resource-allocation graph 를 통해 단순하게 표현 가능 교착 상태가 발생한 상황은 자원 할당 그래프가 원의 형태를 띈다 13.1.3 교착 상태 발생 조건 아래 조건 중 하나라도 만족하지 않는다면 교착 상태 발생 X\n아래 조건이 모두 만족될 때 교착 상태 발생 O\n13.1.3.1 상호 배제, mutual exclusion 식사하는 철학자 문제에서 하나의 포크를 여러 명이 동시에 사용할 수 있었다면 교착 상태는 발생하지 않음 프로세스도 한 프로세스가 사용하는 자원을 다른 프로세스가 사용할 수 없을 때, 즉, 상호 배제 mutual exclusion 상황에서 교착 상태가 발생 가능 13.1.3.2 점유와 대기, hold and wait 어떠한 자원을 할당받은 상태에서 다른 자원을 할당받기를 기다린다면 교착 상태가 발생할 수 있습니다. 이렇게 \u0026lsquo;자원을 할당받은 상태에서 다른 자원을 할당받기를 기다리는 상태\u0026lsquo;를 점유와 대기라 한다. 13.1.3.3 비선점, nonpreemptive 만일 철학자들 중 누군가가 다른 철학자의 포크를 강제로 빼앗을 수 있었다면 교착 상태는 발생하지 않음\n프로세스가 자원을 비선점 nonpreemptive 하고 있었기 때문.\n비선점 자원은 그 자원을 이용하는 프로세스의 작업이 끝나야만 비로소 이용할 수 있다.\n즉, 어떤 프로세스도 다른 프로세스의 자원을 강제로 빼앗지 못했기 때문에 교착 상태가 발생\n13.1.3.4 원형 대기, circular wait 프로세스들과 프로세스가 요청 및 할당받은 자원이 원의 형태를 이루었기 때문입니다. 프로세스들이 원의 형태로 자원을 대기하는 것을 원형 대기 circular wait 라고 합니다. 자원 할당 그래프가 원의 형태로 그려지면 교착 상태가 발생할 \u0026lsquo;수\u0026rsquo; 있다고 표현한 이유가 있다. 자원 할당 그래프가 원의 형태를 띄지 않는다면 교착 상태는 발생하지 않으나, 원의 형태를 띈다고 해서 반드시 교착 상태가 발생하는 것은 아닙니다. 13.2 교착 상태 해결 방법 운영체제는 애초에 교착 상태가 일어나지 않도록 교착 상태 발생 조건에 부합하지 않게 자원을 분배하여 교착 상태를 예방 가능\n교착 상태가 발생하지 않을 정도로 조금씩 자원을 할당하다가 교착 상태의 위험이 있다면 자원을 할당하지 않는 방식으로 교착 상태를 회피 가능\n자원을 제약 없이 할당하다가 교착 상태가 검출되면 교착 상태를 회복 가능\n13.2.1 교착 상태 예방 프로세스들에 자원을 할당할 때 상호 배제, 점유와 대기, 비선점, 원형 대기 중 하나의 조건이라도 만족시키지 않게 할당\n상호 배제 없애기\n모든 자원을 공유 가능하게 만든다는 말 교착 상태는 없앨 수 있지만, 모든 자원의 상호 배제를 없애기는 현실적으로 어려움 점유와 대기 없애기\n철학자들로 하여금 한 손에 포크를 들고 다른 포크를 기다리지 못하게 금지하는 것과 같다. 포크를 두 개 동시에 들게 하거나, 아니면 아예 들지 못하게 하는 것 점유와 대기를 없애면 운영체제는 특정 프로세스에 자원을 모두 할당하거나, 아예 할당하지않는 방식으로 배분 이론적으로는 교착 상태를 해결할 수 있지만, 단점도 존재 자원의 활용률이 낮아질 우려 존재 점유와 대기를 금지하면 한 프로세스에 필요한 자원들을 몰아주고, 그 다음에 다른 프로세스에 필요한 자원들을 몰아줘야 함 이는 당장 자원이 필요해도 기다릴 수밖에 없는 프로세스와 사용되지 않으면서 오랫동안 할당되는 자원을 다수 양산하기 때문에 자원의 활용률이 낮아짐 많은 자원을 사용하는 프로세스가 불리 자원을 많이 사용하는 프로세스는 적게 사용하는 프로세스에 비해 동시에 자원을 사용할 타이밍을 확보하기 어렵기 때문 결국 많은 자원을 필요로 하는 프로세스가 무한정 기다리게 되는 기아 현상을 야기할 우려 비선점 조건 없애기\n비선점 조건을 없애면 자원을 이용 중인 프로세스로부터 해당 자원을 빼앗을 수 있음 이 방식은 선점하여 사용할 수 있는 일부 자원에 대해서는 효과적 가령 CPU는 프로세스들이 선점할 수 있는 대표적인 자원 한 프로세스가 CPU를 이용하다가 일정 시간이 지나면 아직 작업이 모두 끝나지 않았다고 할지라도 다른 프로세스가 CPU를 할당받아 사용할 수 있기 때문 하지만 모든 자원이 이렇게 선점 가능한 것은 아님 한 프로세스의 작업이 끝날 때까지 다른 프로세스가 기다려야 하는 자원도 얼마든지 존재 예를 들어 한 번에 하나의 프로세스만 이용 가능한 프린터 자원 한 프로세스가 이 프린터를 이용하는 도중에, 다른 프로세스가 프린터 자원을 빼앗아 사용하기 어려움 그렇기에 비선점 조건을 없애 모든 자원을 빼앗을 수 있도록 하는 것은 다소 범용성이 떨어지는 방안 원형 대기 조건 없애기\n모든 자원에 번호를 붙이고, 오름차순으로 자원을 할당하면 원형 대기는 발생하지 않음 예를 들어, 식사하는 철학자 문제에서 모든 포크에 1번부터 5번까지 번호를 붙이고, 철학자들로 하여금 번호가 낮은 포크에서 높은 포크 순으로 집어들게 한다면 원형 대기는 발생하지 않음 5번 포크를 집어들고 1번 포크를 집어들 수 없기 때문 원형 대기를 없앰으로써 교착 상태를 예방하는 방식은 비교적 현실적이고 실용적인 방식이지만, 역시 단점 존재 모든 컴퓨터 시스템 내에 존재하는 수많은 자원에 번호를 붙이는 일은 간단한 작업이 아니거니와 각 자원에 어떤 번호를 붙이는지에 따라 특정 자원의 활용률이 떨어질 수 있음 이렇듯 발생 조건을 원천적으로 제거하여 교착 상태를 사전에 방지하는 예방 방식은 교착 상태가 발생하지 않음을 보장할 수는 있지만 여러 부작용이 존재\n13.2.2 교착 상태 회피 교착 상태 회피는 교착 상태가 발생하지 않을 정도로만 조심 조심 자원을 할당하는 방식\n항시 \u0026lsquo;안전 상태\u0026rsquo;를 유지하도록 자원을 할당하는 방식 교착 상태 회피 방식에서는 교착 상태를 한정된 자원의 무분별한 할당으로 인해 발생하는 문제로 간주\n포크가 100개, 1,000개 있는 상태에서 철학자들이 한두 개 의 포크를 요구하면 교착 상태는 발생 X 반면 포크의 양이 충분하지 않은 상태에서 모두 자신이 요구할 수 있는 최대의 포크 (두 개)를 요구하면 교착 상태가 발생 안전 상태; safe state: 교착 상태가 발생하지 않고, 모든 프로세스가 정상적으로 자원을 할당받고 종료될 수 있는 상태\n안전 순서열이 있어서 교착 상태가 발생하지 않는 상태를 안전 상태 라 한다. 불안전 상태; unsafe state: 교착 상태가 발생할 수도 있는 상황\n안전 순서열이 없는 상태, 교착 상태가 발생할 위험이 있음 안전 순서열; safe sequence: 교착 상태 없이 안전하게 프로세스들에 자원을 할당할 수 있는 순서\n예를 들어 웹 브라우저, 메모장, 게임 프로세스가 동시에 운영체제에 자원을 요청한 상황에서 웹 브라우저-메모장-게임 프로세스 순서대로 자원을 할당하면 교착 상태가 발생하지 않는다고 가정 이 경우 웹 브라우저 -\u0026gt; 메모장 \u0026gt; 게임이 안전 순서열이 됩니다. 프로세스와 스레드는 자원을 사용하기 위해\n우선 자원을 운영체제에게 요청 운영체제로부터 자원을 할당받아 사용 자원의 사용이 끝났다면 자원을 반환 안전 상태 예시 ​\t​\t불안전 상태 예시\n​\t13.2.3 교착 상태 검출 후 회복 교착 상태 예방과 회피는 교착 상태 발생을 막기 위한 노력이었다면, 교착 상태 검출 후 회복은 교착 상태 발생을 인정하고 사후에 조치하는 방식 검출 후 회복 방식에서 운영체제는 프로세스들이 자원을 요구할 때마다 그때그때 모두 할당 교착 상태 발생 여부를 주기적으로 검사하고, 검출되면 그때 회복 13.2.3.1 선점(독점 불가)을 통한 회복 교착 상태가 해결될 때까지 한 프로세스씩 자원을 몰아주는 방식 교착 상태가 해결될 때까지 다른 프로세스로부터 자원을 강제로 빼앗고 한 프로세스에 할당하는 방식 13.2.3.2 프로세스 강제 종료를 통한 회복 프로세스 강제 종료를 통한 회복은 가장 단순하면서 확실한 방식\n운영체제는 교착 상태에 놓인 프로세스를 모두 강제 종료할 수도 있고,\n가장 확실한 방식이지만 그만큼 많은 프로세스들이 작업 내역을 잃게 될 가능성이 존재 교착 상태가 없어질 때까지 한 프로세스씩 강제 종료할 수도 있다.\n작업 내역을 잃는 프로세스는 최대한 줄일수 있지만 교착 상태가 없어졌는지 여부를 확인 오버헤드를 야기 실은 교착 상태를 아예 무시하는 방법도 존재\n타조(ostrich) 알고리즘: 드물게 발생하는 잠재적 문제를 무시로 대처하는 방식 완벽을 추구하는 과학자나 수학자 입장에서는 납득할 수 없는 방식일지 모르나 문제 발생의 빈도나 심각성에 따라 최대 효율을 추구하는 엔지니어 입장에서는 때때로 이 방식이 적합할 때도 있다. Reference 혼자 공부하는 컴퓨터구조+운영체제 (강민철, 한빛미디어) https://product.kyobobook.co.kr/detail/S000061584886 ","permalink":"https://2taezeat.github.io/posts/os/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0-+-%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C-ch13.-%EA%B5%90%EC%B0%A9-%EC%83%81%ED%83%9C/","summary":"13.1 교착 상태란 13.1.1 식사하는 철학자 문제 식사하는 철학자 문제; dining philosophers problem 는 교착 상태(dead lock) 상황을 설명하기 위한 고전적인 문제 상황 모든 철학자가 동시에 포크를 집어 식사를 하면 어떤 철학자도 식사를 할 수 없고 영원히 생각만 하는 상황이 발생 모든 철학자가 왼쪽 포크를 집어들면 모두가 오른쪽 포크를 집어들 수 없기 때문 다시 말해 모든 철학자는 다른 철학자가 포크를 내려놓을 때까지 기다림 포크-임계 구역 or 자원 철학자-프로세스 or 스레드 생각하는 행위-자원을 기다리는 것 교착 상태; deadlock: 영원히 일어나지 않을 사건을 기다리며, 진행이 멈춰 버리는 현상 프로세스A는 임계 구역 진입 전 lock1을 잠그고 (lock1 = true), 프로세스B는 임계 구역 진입 전 lock2를 잠갔다고 (lock2 = true) 가정 만일 프로세스 A는 lock2가 false가 되길 기다리고, 프로세스 B는 lock1이 false가 되길 기다린다면 교착 상태가 발생 13.","title":"[컴퓨터구조 + 운영체제] ch13. 교착 상태"},{"content":"12.1 동기화란 협력하여 실행되는 프로세스들은 실행 순서와 자원의 일관성을 보장하기 위해 동기화(synchronization) 되어야 한다 12.1.1 동기화의 의미 프로세스 동기화: 프로세스들 사이의 수행 시기를 맞추는 것 실행 순서 제어: 프로세스를 올바른 순서대로 실행하기 상호 배제(mutual exclusion): 동시에 접근해서는 안 되는 자원에 하나의 프로세스만 접근하게 하기 프로세스뿐만 아니라 스레드도 동기화 대상 정확히 말하면 실행의 흐름을 갖는 모든 것은 동기화의 대상 다만 이 책에서는 대부분의 전공서 표현에 따라 \u0026lsquo;프로세스 동기화\u0026rsquo;라고 칭함 실행 순서 제어를 위한 동기화\nReader 프로세스는 Writer 프로세스 실행이 끝나야 비로소 실행할 수 있어야 한다 Writer 가 Book.txt에 값을 저장하기도 전에 Reader 가 Book.txt를 읽는 것은 올바른 실행 순서가 아니다. Reader 는 \u0026lsquo;Book.txt 안에 값이 존재한다\u0026rsquo;는 특정 조건이 만족되어야만 실행을 이어나갈수 있다 프로세스를 올바른 순서대로 실행하는 것 상호 배제(mutual exclusion)를 위한 동기화\n동시에 접근해서는 안 되는 자원에 동시에 접근하지 못하게 하는 것\n두 개 이상의 프로세스가 임계 구역에 동시에 접근하지 못하도록 관리하는 것\n![image-20240501130315938.png](/images/before/image-20240501130315938.png) 프로세스 A와 B가 동시에 실행되었다고 가정\n17만원이 계좌에 남을 거라고 유저는 기대\nA와 B는 \u0026lsquo;잔액\u0026rsquo;이라는 데이터를 동시에 사용하는데, A가 끝나기도 전에 B가 잔액을 읽어 버렸기 때문에 엉뚱한 결과가 나옴\nA와 B를 올바르게 실행하기 위해서는 한 프로세스가 잔액에 접근했을 때 다른 프로세스는 기다려야 한다\n​\t​\n​\n​\t12.1.2 생산자와 소비자 문제 상호 배제를 위한 동기화에 관련된 고전적이고 유명한 문제로 생산자와 소비자 문제가 있다.\n물건을 계속해서 생산하는 프로세스인 생산자\n물건을 계속해서 소비하는 프로세스인 소비자\n생산자와 소비자는 동시에 실행되는 스레드가 될 수도 있다.\n생산자를 100,000번, 소비자를 100,000번 동시에 실행\n유저는 총합 변수가 계속 10개로 머물러 있을 것으로 기대\n하지만 결과는 다름: 생산자 프로세스와 소비자 프로세스가 제대로 동기화되지 않았기 때문에 발생한 문제\n생산자와 소비자는 \u0026lsquo;총합\u0026rsquo;이라는 데이터를 동시에 사용하는데, 생산자가 소비자의 작업이 끝나기도 전에 총합을 수정해서때문에 엉뚱한 결과가 발생\n한 마디로 동시에 접근해서는 안 되는 자원에 동시에 접근했기에 발생한 문제\n12.1.3 공유 자원과 임계 구역 계좌 잔액 문제와 생산자 소비자 문제의 동시에 실행되는 프로세스들은 전역 변수 \u0026lsquo;잔액\u0026rsquo;, \u0026lsquo;총합\u0026rsquo;이라는 공동의 자원을 두고 작업을 했습니다.\n이러한 자원을 공유 자원; shared resource 이라 한다.\n공유 자원은 전역 변수, 파일, 입출력장치, 보조기억장치가 될 수도 있다.\n임계 구역; critical section: 동시에 실행하면 문제가 발생하는 자원에 접근하는 코드 영역\n임계 구역은 두 개 이상의 프로세스가 동시에 실행되면 안 되는 영역 두 개이 상의 프로세스가 임계 구역에 진입하고자 하면 둘 중 한는 대기해야 한다. 경쟁 상태; Race condition: 여러 프로세스가 동시 다발적으로 \u0026lsquo;\u0026lsquo;임계 구역\u0026rsquo;\u0026lsquo;의 코드를 실행하여 문제가 발생하는 경우\n데이터 일관성이 깨지는 문제 발생 컴퓨터는 고급 언어가 아닌 저급 언어를 실행하기 때문에 여러 줄의 저급 언어로 변환된 고급 언어한 줄을 실행하는 과정에서 문맥 교환이 일어남. 저급 언어를 실행하는 과정에서 문맥교환이 일어난다면 아래와 같은 문제가 발생 \u0026lsquo;상호 배제를 위한 동기화\u0026rsquo; 를 위해서는 세 가지 원칙이 반드시 지켜져야만 한다.\n상호 배제; mutual exclusion: 한 프로세스가 임계 구역에 진입했다면, 다른 프로세스는 임계 구역에 들어올 수 없다. 진행; progress: 임계 구역에 어떤 프로세스도 진입하지 않았다면, 임계 구역에 진입하고자 하는 프로세스는 들어갈 수 있어야 한다. 유한 대기; bounded waiting: 한 프로세스가 임계 구역에 진입하고 싶다면 그 프로세스는 언젠가는 임계 구역에 들어올 수 있어야 한다 (임계 구역에 들어오기 위해 무한정 대기해서는 안 된다). 12.2 동기화 기법 12.2.1 뮤텍스 락 옷 가게의 탈의실을 이용하는 것에 비유\n손님-프로세스, 탈의실-임계 구역\n자물쇠가 걸려 있지 않다면 탈의실을 이용하면 된다, 걸려 있다면 대기\n뮤텍스 락; MUTual EXclusion Lock: 이 자물쇠 기능을 코드로 구현한 것\n상호 배제를 위한 동기화 도구\n임계 구역에 진입하는 프로세스는 \u0026lsquo;내가 지금 임계 구역에 있음\u0026rsquo;을 알리기 위해 뮤텍스 락을 이용해 임계 구역에 자물쇠를 걸어둘 수 있고\n다른 프로세스는 임계 구역이 잠겨 있다면 기다리고, 잠겨 있지 않다면 임계 구역에 진입할 수 있다.\n뮤텍스 락의 단순한 형태는 하나의 전역 변수와 두 개의 함수로 구현 가능\n자물쇠 역할: 프로세스들이 공유하는 전역 변수 lock 임계 구역을 잠그는 역할: acquire 함수 임계 구역의 잠금을 해제하는 역할: release 함수 acquire 함수는 프로세스가 임계 구역에 진입하기 전에 호출하는 함수\n만일 임계 구역이 잠겨 있다면 임계 구역이 열릴 때까지 (lock이 false가 될 때까지) 임계 구역을 반복적으로 확인하고, 마치 탈의실 문이 잠겨 있는지 쉴 새 없이 반복하며 확인해 보는 것과 같다. 이런 대기 방식을 바쁜 대기; busy wait 이라 한다. 임계 구역이 열려 있다면 임계 구역을 잠그는 (lock을 true로 바꾸는) 함수 release 함수는 임계 구역에서의 작업이 끝나고 호출하는 함수\n현재 잠긴 임계 구역을 열어주는 (lock을 false로 바꾸는) 함수 이렇게 되면 프로세스는\n락을 획득할 수 없다면 (임계 구역에 진입할 수 없다면) 무작정 기다리고, 락을 획득할 수 있다면 (임계 구역에 진입할 수 있다면) 임계 구역을 잠근 뒤 임계 구역에서의 작업을 진행하고, 임계 구역에서 빠져나올 때엔 다시 임계 구역의 잠금을 해제함으로써 임계 구역을 보호할 수 있다. 12.2.2 세마포 세마포; semaphore는 뮤텍스 락과 비슷하지만, 조금 더 일반화된 방식의 동기화 도구\n엄밀히 말하면 세마포의 종류에도 이진 세마포(binary)와 카운팅 세마포(counting)가 존재 이진 세마포는 뮤텍스 락과 비슷한 개념이므로 여기서는 여러 공유 자원을 다룰 수 있는 카운팅 세마포를 다룬다 탈의실이 여러 개 있는 상황처럼 공유 자원이 여러 개 있을 경우 (각 공유 자원에는 하나의 프로세스만 진입이 가능할지라도) 여러 개의 프로세스가 각각 공유 자원에 접근이 가능해야 한다.\n한 번에 하나의 프로세스만 이용할 수 있는 프린터 세 대가 있는 상황에서 하나의 프린터를 사용할 수 있는 프로세스는 하나이지만, 총 세 개의 프로세스가 공유 자원 (세 대의 프린터) 을 이용할 수 있다. 세마포는 공유 자원이 여러 개 있는 상황에서도 적용이 가능한 동기화 도구\n세마포는 뮤텍스 락과 비슷하게 하나의 변수와 두 개의 함수로 단순하게 구현할 수 있다.\n전역변수 S: 임계 구역에 진입할 수 있는 프로세스의 개수(사용 가능한 공유 자원의 개수) wait 함수: 임계 구역에 들어가도 좋은지, 기다려야 할지를 알려주는 함수 signal 함수: 임계 구역 앞에서 기다리는 프로세스에 \u0026lsquo;이제 가도 좋다\u0026rsquo;고 신호를 주는 함수 여기에서 세마포 변수와 함수 이름을 각각 S, wait, signal로 나타내지만, 변수, 함수 이름은 전공서마다 다를 수 있다. 일부에서는 세마포를 처음 개발한 다익스트라에 근거해 wait와 signal 함수를 P, V로 명명 일부에서는 철도 신호기에 근거해 down, up으로 명명 다만 변수와 함수를 어떻게 지칭하든지 원리와 작동 방식은 모두 동일 wait 함수\n만일 임계 구역에 진입할 수 있는 프로세스 개수가 0 이하라면 사용할 수 있는 자원이 있는지 반복적으로 확인하고, 임계 구역에 진입할 수 있는 프로세스 개수가 하나 이상이면 S를 1 감소시키고 임계 구역 진입한다. signal 함수\n임계 구역에서의 작업을 마친 뒤 S를 1 증가 여기서 한 가지 문제가 있습니다.\n이는 뮤텍스 락에도 해당되는 문제 사용할 수 있는 공유 자원이 없는 경우 프로세스는 무작정 무한히 반복하며 전역 변수 S를 확인해야 합니다. 이렇게 바쁜 대기(busy wait) 를 반복하며 확인할 시간에 CPU는 더 생산성 있는 작업을 할 수 있을 텐데, CPU 주기를 낭비한다는 점에서 손해 그래서 실제로 세마포는 다른 더 좋은 방법을 사용\nwait 는 만일 사용할 수 있는 자원이 없을 경우 해당 프로세스 상태를 대기 상태로 만들고, 그 프로세스의 PCB를 세마포를 위한 대기 큐에 집어 넣음 다른 프로세스가 임계 구역에서의 작업이 끝나고 signal 를 호출하면 signal 는 대기 중인 프로세스를 대기 큐에서 제거하고, 프로세스 상태를 준비 상태로 변경한 뒤 준비 큐로 옮겨줌. 지금까지는 상호 배제를 위한 동기화 기법 아래는, 세마포를 이용해 실행 순서 제어를 위한 동기화(프로세스의 순서를 제어하는 방법) 에 대해 설명 세마포를 이용하면 동시에 실행되는 프로세스의 실행 순서도 원하는 대로 제어할 수 있다. 세마포의 변수 S를 0으로 두고 먼저 실행할 프로세스 뒤에 signal 함수, 다음에 실행할 프로세스 앞에 wait 함수를 붙이면 됩니다. P1이 먼저 실행되면 P1이 임계 구역에 먼저 진입하는 것은 자명 P2가 먼저 실행 되더라도 P2는 wait 함수를 만나므로 P1이 임계 구역에 진입 그리고 P1이 임계 구역의 실행을 끝내고 signal을 호출하면 그제서야 P2가 임계 구역에 진입 즉, P1이 먼저 실행되든 P2가 먼저 실행되든 반드시 P1 =\u0026gt; P2 순서대로 실행된다. 12.2.3 모니터 세마포는 그 자체로 매우 훌륭한 프로세스 동기화 도구이지만, 사용하기가 조금 불편한 면이 있다. 매번 임계 구역에 앞뒤로 일일이 wait와 signal 함수를 명시하는 것은 번거로운 일 더군다나 자칫 아래처럼 잘못된 코드로 인해 예기치 못한 결과를 얻을 수도 있다. 최근에 등장한 동기화 도구가 모니터; montor 모니터는 공유 자원과 공유 자원에 접근하기 위한 인터페이스(통로)를 묶어 관리 프로세스는 반드시 인터페이스를 통해서만 공유 자원에 접근 모니터를 통해 공유 자원에 접근하고자 하는 프로세스를 큐에 삽입하고,\n큐에 삽입된 순서대로 하나씩 공유 자원을 이용하도록 합니다.\n즉, 모니터는 공유 자원을 다루는 인터페이스에 접근하기 위한 큐(모니터에 진입하기 위한 큐) 를 만들고,\n모니터 안에 항상 하나의 프로세스만 들어오도록하여 상호 배제를 위한 동기화를 제공\n모니터는 세마포와 마찬가지로 실행 순서 제어를 위한 동기화도 제공합니다.\n특정 조건을 바탕으로 프로세스를 실행, 일시 중단하기 위해 조건 변수; condition variable를 사용하는데, 조건 변수는 프로세스나 스레드의 실행 순서를 제어하기 위해 사용하는 특별한 변수입니다. 모니터가 조건 변수를 사용한다고는 하지만 조건 변수와 모니터는 별개의 개념 조건 변수로는 wait와 signal 연산을 수행할 수 있다.\nwait는 호출한 프로세스의 상태를 대기 상태로 전환하고 일시적으로 조건 변수에 대한 대기 큐에 삽입하는 연산\n여기서 헷갈리면 안 되는 점\n모니터에 진입하기 위해 삽입되는 큐(상호 배제를 위한 큐) 와 모니터에 한 번에 하나의 프로세스만 진입하도록 하기 위해 만들어진 큐 wait가 호출되어 실행이 중단된 프로세스들이 삽입되는 큐 (조건 변수에 대한 큐) 는 다르다 모니터에 이미 진입한 프로세스의 실행 조건이 만족될 때까지 잠시 실행이 중단되어 기다리기 위해 만들어진 큐 모니터에 진입한 어떤 프로세스가 x.wait() 를 통해 조건 변수 x에 대한 wait를 호출했다고 가정 그 프로세스는 다음 그림처럼 조건 변수 x에 대한 큐에 삽입되므로 모니터는 다시 비게됩니다. 그렇기에 다른 프로세스가 모니터 안에 들어올 수 있다. wait 연산으로 일시 중지된 프로세스는, 다른 프로세스의 signal 연산을 통해 실행이 재개\n즉, signal은 wait를 호출하여 큐에 삽입된 프로세스의 실행을 재개하는 연산입니다.\n가령 어떤 프로세스가 x.signal을 통해 조건 변수 x에 대한 signal을 호출했다고 가정\n이를 통해 조건 변수 x에 대해 대기 상태에 있던 프로세스가 깨어나 모니터 안으로 다시 들어옴\n모니터 안에는 하나의 프로세스만이 있다. 따라서 wait를 호출했던 프로세스는 signal을 호출한 프로세스가 모니터를 떠난 뒤에 실행되거나, signal을 호출한 프로세스의 실행을 일시 중단하고, 자신이 실행된 뒤 다시 signal을 호출한 프로세스의 수행을 재개 중요한 점은 모니터는 조건 변수를 이용하여 프로세스 실행 순서 제어를 위한 동기화를 제공 특정 프로세스가 아직 실행될 조건이 되지 않았을 때에는, wait를 통해 실행을 중단 특정 프로세스가 실행될 조건이 충족되었을 때에는, signal을 통해 실행을 재개 Reference 혼자 공부하는 컴퓨터구조+운영체제 (강민철, 한빛미디어) https://product.kyobobook.co.kr/detail/S000061584886 ","permalink":"https://2taezeat.github.io/posts/os/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0-+-%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C-ch12.-%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4-%EB%8F%99%EA%B8%B0%ED%99%94/","summary":"12.1 동기화란 협력하여 실행되는 프로세스들은 실행 순서와 자원의 일관성을 보장하기 위해 동기화(synchronization) 되어야 한다 12.1.1 동기화의 의미 프로세스 동기화: 프로세스들 사이의 수행 시기를 맞추는 것 실행 순서 제어: 프로세스를 올바른 순서대로 실행하기 상호 배제(mutual exclusion): 동시에 접근해서는 안 되는 자원에 하나의 프로세스만 접근하게 하기 프로세스뿐만 아니라 스레드도 동기화 대상 정확히 말하면 실행의 흐름을 갖는 모든 것은 동기화의 대상 다만 이 책에서는 대부분의 전공서 표현에 따라 \u0026lsquo;프로세스 동기화\u0026rsquo;라고 칭함 실행 순서 제어를 위한 동기화","title":"[컴퓨터구조 + 운영체제] ch12. 프로세스 동기화"},{"content":"11.1 CPU 스케쥴링 개요 CPU 스케쥴링: 운영체제가 프로세스들에게 공정하고 합리적으로 CPU 자원을 배분 하는 것 11.1.1 프로세스 우선순위 프로세스들에게 공정하게 CPU를 배분하려면 어떻게 해야 할까?\n프로세스마다 우선순위가 다 다르다.\n우선순위가 높은 프로세스: 빨리 처리해야 하는 프로세스\n우선순위가 높은 프로세스에는 대표적은 I/O가 많은 프로세스\n대부분의 프로세스는 CPU와 입출력장치를 모두 사용하며 실행\nrunning(실행) 상태와 대기(waiting) 상태를 반복하며 실행 프로세스 종류마다 입출력장치를 이용하는 시간과 CPU를 이용하는 시간의 양에는 차이가 존재\nI/O bound process 입출력 집중 프로세스\n비디오 재생이나 디스크 백업 작업을 담당하는 프로세스와 같이 입출력 작업이 많은 프로세스 실행 상태보다는 입출력을 위한 대기 상태에 더 많이 머무르게 됩니다. I/O burst가 많은 프로세스 I/O burst: 입출력장치를 기다리는 작업 CPU bound process CPU 집중 프로세스\n복잡한 수학 연산, 컴파일, 그래픽 처리 작업을 담당하는 프로세스와 같이 CPU 작업이 많은 프로세스 반대로 CPU 집중 프로세스는 대기 상태보다는 실행 상태에 더 많이 머무름 CPU burst가 많은 프로레스 CPU burst: CPU를 이용하는 작업을 CPU 집중 프로세스와 입출력 집중 프로세스가 모두 동일한 빈도로 CPU를 사용하는 것은 비합리적\nCPU 집중 프로세스와 입출력 집중 프로세스가 동시에 CPU 자원을 요구했다고 가정\n입출력 집중 프로세스를 가능한 한 빨리 실행시켜 입출력장치를 끊임없이 작동시키고 그 다음 CPU 집중 프로세스에 집중적으로 CPU를 할당하는 것이 더 효율적 입출력장치가 입출력 작업을 완료하기 전까지는, 입출력 집중 프로세스는 어차피 대기 상태가 될 예정이기 때문에 입출력 집중 프로세스를 얼른 먼저 처리해 버리면 다른 프로세스가 CPU를 사용할 수 있기 때문입니다. I/O bound process의 대기 시간을 줄이자 모든 프로세스가 CPU를 차례대로 돌아가며 사용하는 것보다, 각각의 상황에 맞게 CPU를 배분하는 것이 더 효율적\n상황에 맞게, 중요도에 맞게 CPU를 이용할 수 있도록 하기 위해 운영체제는 프로세스마다 우선순위 priority를 부여\n운영체제는 각 프로세스의 PCB에 우선순위를 명시, PCB에 적힌 우선순위를 기준으로 먼저 처리할 프로세스를 결정\n우선순위가 높은 프로세스는 더 빨리, 더 자주 실행 11.1.2 스케쥴링 큐 운영체제가 매번 일일이 모든 PCB를 검사하여, 먼저 자원을 이용할 프로세스를 결정하는일은 매우 비효율적\n그래서 운영체제는 프로세스들에 \u0026lsquo;줄을 서서 기다릴 것\u0026lsquo;을 요구\nCPU를 사용하고 싶은 프로세스들 메모리에 적재되고 싶은 프로세스들 특정 입출력장치를 사용하고 싶은 프로세스들 이 프로세스들을 모두 줄세움 운영체제는 이 줄을 스케줄링 큐; scheduing queue로 구현하고 관리, 큐에 삽입하여 줄을 세움\n큐는 선입선출(First In First Out) 자료 구조이지만, 스케줄링에서 이야기하는 큐는 반드시 선입선출 방식일 필요는 없다.\n운영체제가 관리하는 대부분의 자원은 이렇듯 큐로 관리\n운영체제가 관리하는 줄(큐)에는 다양한 종류가 존재 준비 큐; ready queue는 CPU를 이용하고 싶은 프로세스들이 서는 줄을 의미\n대기 큐; wating queue는 입출력장치를 이용하기 위해 대기 상태에 접어든 프로세스들이 서는 줄을 의미\n운영체제는 PCB들이 큐에 삽입된 순서대로 프로세스를 하나씩 실행하되, 그중 우선순위가 높은 프로세스를 먼저 실행\n우선순위가 낮은 프로세스들이 먼저 큐에 삽입되어도, 우선순위가 높은 프로세스는 그들보다 먼저 처리될 수 있다.\n이런 점에서 봤을 때 높은 우선순위를 가진 프로세스는 마치 VIP와도 같다. 입출력이 완료되어, 완료 인터럽트가 발생하면 운영체제는 대기 큐에서 작업이 완료된 PCB를 찾고\n이 PCB를 준비 상태로 변경한 뒤 대기 큐에서 제거합니다. 당연히 해당 PCB는 준비 큐로 이동합니다.\n11.1.3 선점형과 비선점형 스케쥴링 선점형 preemptive 스케쥴링\n프로세스가 CPU를 비롯한 자원을 사용하고 있더라도, 운영체제가 프로세스로부터 자원을 강제로 빼앗아 다른 프로세스에 할당할 수 있는 스케줄링 방식\n어느 하나의 프로세스가 자원 사용을 \u0026lsquo;독점할 수 없는\u0026rsquo; 스케줄링 방식\n프로세스마다 정해진 시간만큼 CPU를 사용하고, 정해진 시간을 모두 소비하여 타이머 인터럽트가 발생하면,\n운영체제가 해당 프로세스로부터 CPU 자원을 빼앗아 다음 프로세스에 할당하는 방식\n현재 대부분의 운영체제가 사용\n장점: 더 급한 프로세스가 언제든 끼어들어 사용할 수 있는 방식이므로 자원 독점을 막고 프로세스들에 골고루 자원을 배분 가능\n단점: 문맥 교환 과정에서 오버헤드가 발생\n비선점형 non-prremptive 스케쥴링\n하나의 프로세스가 자원을 사용하고 있다면 그 프로세스가 종료되거나 스스로 대기 상태에 접어들기 전까진, 다른 프로세스가 끼어들 수 없는 스케줄링 방식 하나의 프로세스가 자원 사용을 독점할 수 있는 스케줄링 방식 만약 비선점형 스케줄링 방식으로 자원을 이용하는 프로세스가 있다면 다른 프로세스들은 그 프로세스의 사용이 모두 끝날 때까지 기다려야 한다. 장점: 문맥 교환의 횟수가 선점형 스케줄링보다 적기 때문에 문맥 교환에서 발생 하는 오버헤드가 적다 단점: 하나의 프로세스가 자원을 사용 중이라면 당장 자원을 사용해야 하는 상황에서도 무작정 기다려야만 한다. (기아 현상) 모든 프로세스가 골고루 자원을 사용할 수 없다 11.2 CPU 스케쥴링 알고리즘 11.2.1 스케쥴링 알고리즘의 종류 FCFS 스케쥴링\nFCFS; First Come First Served Scheduling, 선입 선처리 준비 큐에 삽입된 순서대로 프로세스들을 처리하는 비선점형 스케쥴링 프로세스들이 기다리는 시간이 매우 길어질 수 있다 호위 효과 convoy effect 발생 앞선 프로세스가 실행시간이 길다면 실행시간이 짧은 프로세스들이 실행되지 못해 마치 부하처럼 뒤따라서 기다리고 있다는 것을 가리키는 효과이다. SJF 스케쥴링\nShortest Job First, 최단 작업 우선 호위 효과 방지 준비 큐에 삽입된 프로세스들 중 CPU 이용 시간의 길이(CPU burst) 가 가장 짧은 프로세스부터 실행 비선점형 스케쥴링으로 분류 되지만, 선점형으로 구현될 수 도 있다. 선점형 SJF가 \u0026lsquo;최소 잔여 시간 우선 스케쥴링(SRT)\u0026rsquo; 이다. SJF가 가장 효율적인 CPU 스케줄링 방법 같지만, 비현실적이다. 왜냐하면 프로세스의 CPU 점유 시간(Burst time) 을 알 수 없다. 한 프로세스가 실행 중에는 많은 변수가 존재하기에, CPU 점유 시간을 알려면 실제로 수행하여 측정하는 수밖에 없다. 실제 측정한 시간으로 예측하여 SJF를 사용할 수도 있지만, 이는 오버헤드가 매우 큰 작업으로 잘 사용되지 않는다. ​\nRound Robin 스케쥴링\nFCFS에 타임 슬라이스(Time Quantum, Time Slice) 라는 개념이 더해진 방식 타임 슬라이스란 각 프로세스가 CPU를 사용할 수 있는 정해진 시간을 의미 정해진 타임 슬라이스만큼의 시간 동안 돌아가며 CPU를 이용하는 선점형 스케줄링 타임 슬라이스 크기가 매우 중요 타임 슬라이스가 크면 사실상 선입 선처리 스케줄링과 다를 바 없어 호위 효과가 생길 여지가 있고, 타임 슬라이스가 작으면 문맥 교환에 발생하는 비용이 커 CPU는 프로세스를 처리하는 일보다 프로세스를 전환하는 데에 온 힘을 다 쓸 여지가 있기 때문 시분할 시스템의 성질을 활용한 방법 SRT 스케쥴링\n최소 잔여 시간 우선 스케쥴링\n프로세스들은 정해진 타임 슬라이스만큼 CPU를 사용하되, 다음 프로세스로는 남아있는 작업 시간이 가장 적은 프로세스가 선택됨.\nSJF, Round Robin 을 합친 방식 우선순위 스케쥴링\n프로세스들에 우선순위를 부여하고, 가장 높은 우선순위를 가진 프로세스부터 실행 SJF, SRT 모두 우선순위 스케쥴링의 일종으로 볼 수 있다. 기아 현상, 근본적인 문제 우선순위가 높은 프로세스들에 의해 실행이 계속되어 연기됨 이를 방지하기 위한 대표적인 기법으로 에이징; aging이 있다. 오랫동안 대기한 프로세스의 우선순위를 점차 높이는 방식입니다. 말하자면 대기 중인 프로세스의 우선순위를 마치 나이 먹듯 점차 증가시키는 방법 Multi-level Queue 스케쥴링\n다단계 큐 스케쥴링 우선순위별로 준비 큐를 여러 개 사용하는 스케쥴링 프로세스들이 큐 사이를 이동할 수 없다. 기아 현상이 발생 할 수 있다. 이렇게 큐를 여러 개 두면 프로세스 유형별로 우선순위를 구분하여 실행하는 것이 편리해집니다. 가령 어떤 큐에는 우선순위가 비교적 높아야 하는 I/O bound 프로세스가 삽입될 수 있고, 어떤 큐에는 우선순위가 비교적 낮아도 상관없는 CPU bound 프로세스가 삽입될 수 있다. 또 어떤 큐에는 (우선순위가 비교적 높아야 하는) 백그라운드 프로세스들을 삽입할 수 있고, 어떤 큐에는 (우선순위가 비교적 낮아도 무방한) 사용자와의 상호작용이 잦은 프로세스들을 삽입할 수 있다. 큐별로 타임 슬라이스를 여러 개 지정할 수도 있고, 큐마다 다른 스케줄링 알고리즘을 사용할수도 있다. Multilevel Feedback Queue 스케쥴링\n다단계 피드백 큐 스케줄링 다단계 큐 스케쥴링의 발전된 형태 구현 복잡하지만, 가장 일반적인 CPU 스케쥴링 알고리즘 동작 방식 다단계 피드백 큐 스케줄링에서 새로 준비 상태가 된 프로세스가 있다면 우선순위가 가장 높은 우선순위 큐에 삽입되고 타임 슬라이스 동안 실행 만약 새로운 프로세스가 해당 큐에서 실행이 끝나지 않는다면 다음 우선순위 큐에 삽입되어 실행 그리고 또 해당 큐에서 실행이 끝나지 않는다면 프로세스는 또 다음 우선순위 큐에 삽입되고, 결국 CPU를 오래 사용해야 하는 프로세스는 점차 우선순위가 낮아짐 프로세스들이 큐 사이를 이동할 수 있다 낮은 우선순위 큐에서 너무 오래 기다리고 있는 프로세스가 있다면 에이징 기법을 적용하여 기아 현상을 예방 ​\tReference 혼자 공부하는 컴퓨터구조+운영체제 (강민철, 한빛미디어) https://product.kyobobook.co.kr/detail/S000061584886 ","permalink":"https://2taezeat.github.io/posts/os/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0-+-%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C-ch11.-cpu-%EC%8A%A4%EC%BC%80%EC%A5%B4%EB%A7%81/","summary":"11.1 CPU 스케쥴링 개요 CPU 스케쥴링: 운영체제가 프로세스들에게 공정하고 합리적으로 CPU 자원을 배분 하는 것 11.1.1 프로세스 우선순위 프로세스들에게 공정하게 CPU를 배분하려면 어떻게 해야 할까?\n프로세스마다 우선순위가 다 다르다.\n우선순위가 높은 프로세스: 빨리 처리해야 하는 프로세스\n우선순위가 높은 프로세스에는 대표적은 I/O가 많은 프로세스\n대부분의 프로세스는 CPU와 입출력장치를 모두 사용하며 실행\nrunning(실행) 상태와 대기(waiting) 상태를 반복하며 실행 프로세스 종류마다 입출력장치를 이용하는 시간과 CPU를 이용하는 시간의 양에는 차이가 존재\nI/O bound process 입출력 집중 프로세스","title":"[컴퓨터구조 + 운영체제] ch11. CPU 스케쥴링"},{"content":"10.1 프로세스 개요 실행 중인 프로그램, 이 프로그램을 프로세스 라고 한다\n프로그램은 실행되기 전까지 보조기억장치에 있는 데이터 덩어리지만\n메모리에 적재하고 실행하는 순간 프로그램은 프로세스가 된다\n이 과정을 \u0026lsquo;프로세스를 생성한다\u0026rsquo; 라고 한다\n(보조기억장치에서) 메모리에 적재되고, CPU의 자원을 받은 실행 중인 프로그램\n10.1.1 프로세스 직접 확인하기 포그라운드 프로세스: 사용자가 볼 수 있는 공간에서 실행되는 프로세스 백그라운드 프로세스: 사용자가 볼 수 없는 공간에서 실행되는 프로세스 데몬(daemon) or 서비스(service): 사용자와 상호작용하지 않고 그저 묵묵히 정해진 일만 수행하는 백그라운드 프로세스 10.1.2 프로세스 제어 블록 (PCB) CPU는 자원은 한정 되 어 있기에, 모든 프로세스가 동시에 CPU를 사용할 수 없다.\n프로세스들은 차례대로 돌아가며 한정된 시간 만큼 CPU를 이용하고,\n시간이 끝났음 알리는 인터럽트(타이머 인터럽트)가 발생하면 자신의 차례를 양보하고 기다린다.\n타이머 인터럽트는 클럭 신호를 발생시키는 장치에 의해 주기적으로 발생하는 하드웨어 인터럽트 타임아웃 인터럽트라고도 부른다. 프로세스에 CPU를 비롯한 자원을 배분하기 위해 운영체제는 Process Control Block(PCB) 를 이용한다.\nPCB는 프로세스와 관련된 정보를 저장하는 자료 구조이다.\n상품에 달린 태그와 비슷 운영체제 종류마다 담기는 정보에 차이가 있다 PCB는 커널 영역에 생성된다.\n\u0026lsquo;새로운 프로세스가 생성되었다\u0026rsquo;는 말은 \u0026lsquo;운영체제가 PCB를 생성했다\u0026rsquo;는 말과 같고,\n프로세스가 종료되었다\u0026rsquo;는 말은 \u0026lsquo;운영체제가 해당 PCB를 폐기했다\u0026rsquo;는 말과 같다.\n10.1.2.1 PCB에 담기는 대표적인 정보 프로세스 ID Process ID(PID): 프로세스를 식별하기 위해 부여하는 고유한 번호 같은 일을 수행하는 프로그램이라 할지라도 두 번 실행하면 PID가 다른 두 개의 프로세스가 생성 레지스터 값 프로세스는 자신의 실행 차례가 돌아오면 이전까지 사용했던 레지스터의 중간값들을 모두 복원 PCB 안에는 해당 프로세스가 실행하며 사용했던 프로그램 카운터(PC) 를 비롯한 레지스터 값들이 담깁니다. 프로세스 상태 프로세스가 현재 어떤 상태인지 기록 CPU 스케쥴링 정보 프로세스가 언제, 어떤 순서로 CPU를 할당받을지에 대한 정보도 PCB에 기록 메모리 관리 정보 프로세스마다 메모리에 저장된 위치가 다름 그래서 PCB에는 프로세스가 어느 주소에 저장되어 있는지에 대한 정보가 있어야 함 PCB에는 베이스 레지스터, 한계 레지스터 값과 같은 정보들이 담김 또한 프로세스의 주소를 알기 위한 중요 정보 중 하나인 페이지 테이블 정보도 PCB에 담김 사용할 파일 프로세스가 실행 과정에서 특정 입출력 장치나 파일을 사용하면 PCB에 해당 내용이 명시된다. 즉, 어떤 파일들을 열었는지에 대한 정보들이 PCB에 기록 사용한 입출력 장치 목록 어떤 입출력장치가 이 프로세스에 할당되었는지 기록 10.1.3 문맥 교환 (Context Switching) 하나의 프로세스 수행을 재개하기 위해 기억해야 할 정보를 문맥(context) 이라 한다. 하나의 프로세스 문맥은 해당 프로세스의 PCB에 표현되어 있다. PCB에 기록되는 정보들을 문맥이라고 봐도 무방 실행 문맥을 기억해 두면 언제든 해당 프로세스의 실행을 재개 가능하기 때문에, 인터럽트가 발생하면 운영체제는 해당 프로세스의 PCB에 문맥을 백업합니다. 그리고 뒤이어 실행할 프로세스 B의 문맥을 PCB로 부터 복구 하여 새로운 프로새스를 실행, 프로세스 전환 이를 문맥 교환(conext swiching) 이라 한다. 문맥 교환은 여러 프로세스가 끊임없이 빠르게 번갈아 가며 실행되는 원리이다. 문맥 교환이 자주 일어나면 프로세스는 그만큼 빨리 번갈아 가며 수행되기 때문에 사용자는 프로세스들이 동시에 실행되는 것처럼 인식한다 하지만, 문맥 교환이 많이 일어나면 오버헤드가 발생할 수 있기에 반드시 좋은 것만은 아니다. 10.1.4 프로세스의 메모리 영역 Code Segment, 코드 영역\nText Segment, 텍스트 영역이라고도 부른다.\n말 그대로 실핼할 수 있는 코드, 즉 기계어로 이루어진 명령어가 저장\n읽기 전용 read-only 공간, 쓰기 불가\n정적 할당 영역 - 프로그램을 구성하는 명령어는 중간에 변경되지 않는다.\nData Segment, 데이터 영역\n프로그램이 실행되는 동안 유지할 데이터(전역 변수가 대표적)가 저장되는 공간 정적 할당 영역 - 프로그램이 샐행되는 동안에만 유지된다. Heap Segment, 힙 영역\n프로그래머가 직접 할당할 수 있는 저장 공간 프로그래밍 과정에서 힙 영역에 메모리 공간을 할당했다면 언젠가는 해당 공간을 반환해야 한다. 반환한다는 의미는 \u0026lsquo;더 이상 해당 메모리 공간을 사용하지 않겠다\u0026rsquo;라고 운영체제에 말해주는 것 메모리 공간을 반환하지 않는다면 할당한 공간은 메모리 내에 계속 남아 메모리 낭비를 초래 이런 문제를 메모리 누수 (memory leak) 라 한다. 동적 할당 영역 - 크기가 실시간으로 변할 수 있음 힙 영역은 메모리의 낮은 주소에서 높은 주소로 할당 (0 =\u0026gt; 100) Stack Segment, 스택 영역\n스택 영역은 데이터를 일시적으로 저장하는 공간 데이터 영역에 담기는 값(전역 변수)과는 달리 잠깐 쓰다가 말 값들이 저장되는 공간 이런 데이터로는 함수의 실행이 끝나면 사라지는 매개 변수, 지역 변수가 대표적입니다. 동적 할당 영역 저장할 데이터는 스택 영역에 PUSH, 필요하지 않는 데이터는 POP 됨으로써 스택 영역에서 사라짐 스택 영역은 높은 주소에서 낮은 주소로 할당 (100 =\u0026gt; 0) 힙 영역과 스택 영역에 데이터가 쌓여도 새롭게 할당되는 주소가 겹칠 일이 없게됨. ​\n10.2. 프로세스 상태와 계층 구조 10.2.1 프로세스 상태 프로세스는 생성, 준비, 실행, 대기, 종료 상태를 거치며 실행된다.\n운영체제는 프로세스의 상태를 PCB에 기록, 인식하며 프로세스들을 관리\n생성 상태, New\n프로세스를 생성 중인 상태\n이제 막 메모리에 적재되어 PCB를 할당 받은 상태\n생성 상태를 거쳐 실행할 준비가 완료된 프로세스는 곧바로 실행되지 않고 준비 상태가 되어 CPU의 할당을 기다림\n준비 상태, Ready\n준비 상태(ready)는 당장이라도 CPU를 할당받아 실행할 수 있지만, 아직 자신의 차례가 아니기에 기다리고 있는 상태\n준비 상태인 프로세스가 실행 상태로 전환되는 것을 디스패치(dispatch) 라고 한다.\n실행 상태, Running\n실행 상태(running)는 CPU를 할당받아 실행 중인 상태를 의미 실행 상태인 프로세스는 할당된 일정 시간 동안만 CPU를 사용할 수 있습니다. 이때 프로세스가 할당된 시간을 모두 사용한다면 (타이머 인터럽트가 발생) 다시 준비 상태가 된다. 실행 도중 입출력장치를 사용하여 I/O가 끝날 때까지 기다려야 한다면 대기 상태(blocked, waiting) 가 된다. 대기 상태, Blocked, Waiting\nI/O는 CPU에 비해 처리 속도가 느리기에, I/O를 요청한 프로세스는 입출력(I/O) 완료 인터럽트를 받을 때까지 기다려야 한다. 이렇게 입출력장치의 작업(I/O)을 기다리는 상태를 대기 상태(blocked, waiting) 라고 한다. 입출력 작업이 완료되면 해당 프로세스는 다시 준비 상태(ready) 로 CPU 할당을 기다립니다. 종료 상태, Terminated\n종료 상태 (terminated)는 프로세스가 종료된 상태 프로세스가 종료되면 운영체제는 PCB와 프로세스가 사용한 메모리를 정리 [대기 상태의 일반적인 정의]\n프로세스가 대기 상태가 되는 이유에 입출력 작업만 있는 것은 아니다 조금 더 일반적으로 표현하자면 특정 이벤트가 일어나길 기다릴 때 프로세스는 대기 상태가 된다. 다만, 대부분의 원인이 입출력 작업이기 때문에 \u0026lsquo;프로세스가 입출력 작업을 하면 대기 상태가 된다\u0026rsquo;고 생각해도 무방 10.2.2 프로세스 계층 구조 프로세스는 실행 도중 시스템 호출을 통해 다른 프로세스를 생성할 수 있ek. 부모(Parent) 프로세스: 새 프로세스를 생성한 프로세스 자식(Chlid) 프로세스: 부모 프로세스에 의해 생성된 프로세스 부모 프로세스와 자식 프로세스는 엄연히 다른 프로세스이기에 각기 다른 PID를 가진다. 일부 운영체제에서는 자식 프로세스의 PCB에 부모 프로세스의 PID인 PPID (Parent PID) 가 기록된다. 프로세스가 프로세스를 낳는 계층적인 구조로써 프로세스들을 관리하고 이는 트리 구조를 띄는다. 이를 프로세스 계층 구조이다. 최초의 프로세스는 운영체제 별로 유닉스 - init, 리눅스 - systemd, macOS - launchd 이다. 최초의 프로세스(부팅 될 때 처음 실행되는 프로세스) PID는 항상 1번이며, 모든 프로세스 최상단에 있는 부모 프로세스이다. 10.2.3 프로세스 생성 기법 부모 프로세스는 fork를 통해 자신의 복사본을 자식 프로세스로 생성해내고,\n만들어진 복사본(자식 프로세스)은 exec를 통해 자신의 메모리 공간을 다른 프로그램으로 교체\nfork: 자기 자신 프로세스의 복사본을 만드는 시스템 콜\n자식 프로세스는 부모 프로세스의 자원들 (메모리 내의 내용, 열린 파일의 목록 등)이 자식 프로세스에 상속된다. 복사된 자식 프로세스라 할지라도 PID 값이나 저장된 메모리 위치는 다름 exec: 자신의 메모리 공간을 새로운 프로그램으로 덮어쓰는 시스템 콜\nfork를 통해 복사본이 만들어진 뒤에 자식 프로세스는 exec을 통해 새로운 프로그램으로 전환 새로운 프로그램 내용으로 전환하여 실행하는 시스템 콜입니다. 메모리 공간에 새로운 프로그램 내용이 덮어 써진다는 점에서 자식 프로세스가 새로운 옷으로 갈아입었다고도 볼 수 있다.\nexec를 호출하면 코드 영역과 데이터 영역의 내용이 실행할 프로그램의 내용으로 바뀌고, 나머지 영역은 초기화됩니다.\n예를 들어, 사용자가 bash 셸에서 Is라는 명령어를 쳤다고 가정\n셸 프로세스는 fork를 통해 자신과 동일한 프로세스를 생성 그로부터 탄생한 자식 프로세스(셸의 복제)는 exec를 통해 Is 명령어를 실행하기 위한 프로세스로 전환되어 실행 그렇게 셸의 복사본으로 탄생한 자식 프로세스는 Is 명령어를 실행하기 위한 프로세스로 바뀌고, 메모리 공간에는 Is 명령어를 실행하기 위한 내용들이 채워진다. 정리하면, 부모가 자식 프로세스를 실행하며 프로세스 계층 구조를 이루는 과정은 fork과 exec가 반복되는 과정\n쉽게 말해, 부모 프로세스로부터 자식이 복사되고, 자식은 새로운 프로그램으로 옷을 갈아입고, 또 그 자식 프로세스로부터 자식이 복사되고, 옷을 갈아입는 방식으로 여러 프로세스가 계층적으로 실행된다. 부모 프로세스가 자식 프로세스를 fork한 뒤에 부모, 자식 누구도 exec를 호출하지 않는 경우도 있다.\n이 경우 부모 프로세스와 자식 프로세스는 같은 코드를 병행하여 실행하는 프로세스가 된다. 10.3 스레드, Thread (소프트웨어적) 스레드(Thread)란 프로세스를 구성하는 독자적인 실행의 흐름 단위 하나의 프로세스는 여러 개의 스레드를 가질 수 있다. 스레드를 이용하면 하나의 프로세스에서 여러 부분을 동시에 실행할 수 있음 10.3.1 프로세스와 스레드 \u0026lsquo;실행의 흐름 단위가 하나\u0026rsquo;인 프로세스들은 단일 스레드 프로세스 이다. 스레드라는 개념이 도입되면서, 하나의 프로세스가 한 번에 여러 일을 동시에 처리할 수 있게 됨. 즉, 프로세스를 구성하는 여러 명령어를 동시에 실행할 수 있게 됨 스레드는 프로세스 내에서 각기 다른 스레드 ID, 프로그램 카운터 값을 비롯한 레지스터 값, 스택 으로 구성\n독자적인 스택이 있어 스레드마다 각기 다른 코드 또는 함수를 실행 가능 스레드들은 실행에 필요한 최소한의 정보만을 유지한 채 프로세스 자원(힙, 데이터, 코드 영역)을 공유\n최근 많은 운영체제는 CPU에 처리할 작업을 전달할 때 프로세스가 아닌 스레드 단위로 전달합니다.\n많은 운영체제가 프로세스와 스레드를 구분하지만, 리눅스는 프로세스와 스레드 간에 명확한 구분을 짓지 않음 리눅스는 프로세스와 스레드 모두 실행의 문맥(context of execution) 이라는 점에서 동등하다고 간주 프로세스와 스레드라는 말 대신 태스크(task) 라는 이름으로 통일하여 명명 10.3.2 멀티프로세스와 멀티스레드 멀티프로세스 (multiprocess): 여러 프로세스를 동시에 실행하는 것 멀티스레드 (multithread): 여러 스레드로 프로세스를 동시에 실행하는 것 동일한 작업을 수행하는 단일 스레드 프로세스 여러 개를 실행하는 것(멀티프로세스) 과 하나의 프로세스를 여러 스레드로 실행하는 것(멀티스레드) 은 무엇이 다를까?\n프로세스끼리는 기본적으로 자원을 공유하지 않지만, 스레드끼리는같은 프로세스 내의 자원을 공유 프로세스를 fork하여 같은 작업을 하는 동일한 프로세스 두 개를 동시에 실행하면 모든 자원이 복제되어 메모리에 적재 한 마디로 PID, 저장된 메모리 주소를 제외하면 모든 것이 동일한 프로세스 두 개가 통째로 메모리에 적재 =\u0026gt; 낭비, 중복 존재 스레드는 프로세스가 가진 자원을 공유 메모리를 더 효율적으로 사용 가능 협력과 통신에 유리 ​\t멀티프로세스 환경에서는 하나의 프로세스에 문제가 생겨도 다른 프로세스에는 지장이 적거나 없다. 하지만, 멀티스레드 환경에서는 하나의 스레드에 문제가 생기면 프로세스 전체에 문제가 생길 수 있다. 모든 스레드는 프로세스의 자원을 공유, 하나의 스레드에 문제가 생기면 다른 스레드도 영향을 받기 때문 10.4 IPC, 프로세스 간 통신 프로세스끼리는 \u0026lsquo;기본적으로\u0026rsquo; 자원을 공유하지 않지만, 프로세스끼리도 충분히 자원을 공유하고 데이터를 주고 받을 수 있다. 프로세스 간의 자원을 공유하고 데이터를 주고받는 것을 IPC; Inter-Process Communication 라 한다. 공유 메모리 (Shared Memory)\n커널 의존성이 낮아 속도가 빠르며, 유저 레벨에서 IPC가 가능해서 통신이 자유로움\n자원과 데이터를 공유하기 때문에 동기화 이슈가 발생\n문맥전환 관점 : 공유 메모리 모델에서의 IPC 는 해당 프로세스가 CPU를 사용하는 행위이며, IPC를 많이 한다고 문맥전환이 많이 일어나지 않음\n동기화 관점 : 메모리 영역에 대한 동시적인 접근을 제어하기 위한 방법이 필요, locking이나 세마포어 도입\n메시지 교환(message passing)\n커널(OS) 내부에 buffer를 두고, 요청된 메시지를 이 buffer 에 복사해 뒀다가 memory protection을 통해 대리 전달해주는 기능.\n시스템 콜을 사용으로 인한 오버헤드가 크고, 비교적 느리다는 단점, 구현은 쉽다는 장점\n문맥 전환 관점 : 메시지 전달 모델에서의 IPC는 해당 프로세스 입장에서 일종의 I/O 로 볼 수 있으며 문맥전환이 많이 일어난다.\n동기화 관점 : send와 receive에 대해서 커널이 동기화를 제공\nex) 파이프, 시그널, 메시지 큐, 소켓\n파이프(Pipe)\n1:1 통신이며, 보내진 순서대로만 받음\n프로세스에 속하는 자원이 아니라 fork를 통한 복사가 불가능\n부모 프로세스와 자식 프로세스 간에 통신함\n시그널(Signal)\npid를 아는 특정 프로세스에게 커널을 통해 이벤트를 전달\n인터럽트라고 부르기도 함\n전달할 수 있는 메시지의 양이 적으며, 실제 데이터를 넘기지 못하기 때문에 실제 데이터를 보내려면 다른 전달 방법을 사용해야함.\n비동기적인 동작으로 스케쥴링이 이루어져야 신호에 대한 처리가 가능하므로 커널 서비스 루틴이 길어질 수 있음\n메시지 큐\n고정된 크기를 갖는 메시지의 연결 리스트를 이용하여 통신\n동기화 필요\nn 대 n 통신 가능\n다른 공유 방식에 비해 사용방법이 매우 직관적이고 간단함\n메시지 큐를 사용하기 위해서는 ID를 알아야하는데 일반적으로 메시지 큐 ID를 알기는 어려움.\n소켓\n네트워크 통신 기법으로 많이 사용되며, 양쪽 PC에서 각각 임의의 포트를 정하고 해당 포트간의 대화를 통해 데이터를 주고 받음. n 대 n 통신이 가능함 운영체제가 제공하는 포트라는 추상화를 여러 프로세스를 사용 할 수 있도록 함 소켓은 상대방의 프로세스의 포트번호만 알면 되어 사용하기가 쉽다. 프로세스의 위치에 독립적이며 local 또는 remote 가능 ( 다른 IPC는 local만 가능 ) local 인 경우 포트 번호만으로 상대 프로세스를 식별 가능 remote인 경우 IP 주소 + 포트번호의 조합으로 상대 프로세스를 식별 가능 Reference 혼자 공부하는 컴퓨터구조+운영체제 (강민철, 한빛미디어) https://product.kyobobook.co.kr/detail/S000061584886 ","permalink":"https://2taezeat.github.io/posts/os/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0-+-%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C-ch10.-%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4%EC%99%80-%EC%8A%A4%EB%A0%88%EB%93%9C/","summary":"10.1 프로세스 개요 실행 중인 프로그램, 이 프로그램을 프로세스 라고 한다\n프로그램은 실행되기 전까지 보조기억장치에 있는 데이터 덩어리지만\n메모리에 적재하고 실행하는 순간 프로그램은 프로세스가 된다\n이 과정을 \u0026lsquo;프로세스를 생성한다\u0026rsquo; 라고 한다\n(보조기억장치에서) 메모리에 적재되고, CPU의 자원을 받은 실행 중인 프로그램\n10.1.1 프로세스 직접 확인하기 포그라운드 프로세스: 사용자가 볼 수 있는 공간에서 실행되는 프로세스 백그라운드 프로세스: 사용자가 볼 수 없는 공간에서 실행되는 프로세스 데몬(daemon) or 서비스(service): 사용자와 상호작용하지 않고 그저 묵묵히 정해진 일만 수행하는 백그라운드 프로세스 10.","title":"[컴퓨터구조 + 운영체제] ch10. 프로세스와 스레드"},{"content":"9.1 운영체제를 알아야 하는 이유 9.1.1 운영체제란 시스템 자원, 자원: 프로그램 실행에 마땅히 필요한 요소\n모든 프로그램은 하드웨어를 필요 운영체제: 프로그램에 필요한 자원을 할당, 프로그램이 올바르게 실행되도록 돕는 특별한 프로그램\n운영체제 또한 메모리에 적재되어야 한다.\n컴퓨터가 부팅될 때 메모리 내 \u0026lsquo;커널 영역\u0026rsquo; 이라는 공간에 따로 적재됨\n사용자가 이용하는 응용 프로그램이 적재되는 영역을 사용자 영역이라 한다.\n운영체제는 실행할 프로그램을 메모리에 적재하고, 더 이상 실행되지 않는 프로그램을 메모리에 삭제하며, 지속적으로 메모리 자원 관리\n응용 프로그램이 실행되려면 반드시 CPU가 필요\n운영체제는 최대한 공정하게 여러 프로그램에 CPU 자원 할당 9.1.2 운영체제를 알아야 하는 이유 운영체제가 없다면 하드웨어를 조작하는 코드를 모두 개발자가 직접 작성해야 한다. 다행히, 운영체제의 도움을 받아 간편하게 개발 가능 하드웨어를 조작하는 프로그램인 운영체제는 하드웨어 상의 문제를 사용자에게 알려주고, 이것이 문제 해결의 실마리가 된다. 대다수의 오류 메시지의 근원은 운영체제이다. 9.2 운영체제의 큰 그림 9.2.1 운영체제의 심장, 커널 운영체제 서비스: 운영체제가 응용 프로그램(App SW)에 제공하는 기능들 운영체제 핵심 서비스 자원에 접근하고 조작하는 기능 프로그램이 올바르게 안전하게 실행되는 기능 커널: 운영체제의 핵심 서비스를 담당하는 부분 운영체제가 제공하는 서비스 중에 커널에 포함되지 않는 서비스 중 대표적으로 사용자 인터페이스(UI) 가 있다. UI는 운영체제가 제공하는 서비스이지만, 그저 컴퓨터와 상호작용하기 위한 통로일 뿐, 커널에 속한 기능은 아니다. UI의 종류 GUI: Graohical User Interface, 마우스, 터치 CLI, Command Line Interface, 명령어 입력 9.2.2 이중 모드와 시스템 호출 운영체제는 App SW가 자원에 접근하려 할 때, 오직 자신을 통해서만 접근하도록 하여 자원을 보호한다. 운영체제에 도움을 요청 === 운영체제 코드를 실행 App SW의 요청을 받은 운영체제는 App SW 대신 자원에 접근하여 요청한 작업을 수행 이러한 운영체제의 문지기 역할은 이중 모드(dual mode) 로 구현된다.\n이중 모드: CPU가 명령어를 실행하는 모드를 크게 사용자 모드, 커널 모드로 구분하는 방식\n사용자 모드(user mode): 운영체제 서비스를 제공받을 수 없는 실행 모드\n커널 영역의 코드를 실행할 수 없는 모드 App SW는 기본적으로 사용자 모드로 실행된다. 사용자 모드로 실행되는 일반적인 App SW는 자원에 접근할 수 없다. 커널 모드(kernel mode): 운영체제 서비스를 제공받을 수 있는 실행 모드\n커널 영역의 코드를 실행할 수 있는 모드 CPU가 커널 모드로 명령어를 실행하면 자원에 접근하는 비롯한 모든 명령어를 실행할 수 있다. 사용자 모드로 실행되는 프로그램이 자원에 접근하는 운영체제 서비스를 제공받으려면 운영체제에 요청을 보내 커널 모드로 전환되어야 한다. 이때, 운영체제 서비스를 제공 받기 위한 요청을 시스템 호출, 콜(System Call) 이라 한다. 시스템 콜은 소프트웨어적인 인터럽트이다.\n인터럽트는 입출력 장치(하드웨어) 에 의해 발생하기도 하지만 인터럽트를 발생시키는 특정 명령어에 의해 발생하기도 한다. 이를 소프트웨어 인터럽트 라 한다. CPU가 시스템 호출을 처리하는 순서는 인터럽트 처리 순서와 유사하다.\n시스템 호출을 발생시키는 명령어가 실행되면 CPU는 지금까지의 작업을 백업하고, 커널 영역 내에 시스템 호출을 수행하는 코드 (인터럽트 서비스 루틴) 를 실행한 뒤 다시 기존에 실행하던 응용 프로그램으로 복귀하여 실행을 계속해 나간다. App SW는 실행 과정에서 운영체제 서비스들을 매우 빈번하게 이용합니다. 빈번하게 시스템 콜을 발생시키고 사용자 모드와 커널 모드를 오가며 실행된다. 9.2.3 운영체제의 핵심 서비스 9.2.3.1 프로세스 관리 실행 중인 프로그램을 프로세스라 한다. 일반적으로 하나의 CPU는 한 번에 하나의 프로세스만 실행할 수 있다. CPU는 이 프로세스를 조금씩 번갈아 가며 실행 다시 말해 CPU는 한 프로세스를 실행하다가 다른 프로세스로 실행을 전환하고 그 프로세스를 실행하다가 또 다른 프로세스로 실행을 전환하는 것을 반복합니다. 이때 각 프로세스는 상태, 사용하고자 하는 자원도 다양하다. 운영체제는 다양한 프로세스를 일목요연하게 관리 및 실행할 수 있어야 한다. 추가로, 여러 프로세스가 동시에 실행되는 환경에서는 프로세스 동기화가 필수적 프로세스의 교착 상태를 해결해야 함 9.2.3.2 자원 접근 및 할당 모든 프로세스는 실행을 위해 자원(시스템 자원) 을 필요로 한다.\nCPU 자원\n일반적으로 메모리에는 여러 프로세스가 적재되고, 하나의 CPU는 한 번에 하나의 프로세스만 실행 그래서 하나의 프로세스가 CPU를 이용하고 있다면 다른 프로세스는 기다림 프로세스들에 공정하게 CPU를 할당하기 위해 어떤 프로세스부터 CPU를 이용하게 할 것인지, 얼마나 오래 CPU를 이용하게 할지를 결정할 수 있어야 한다. 이를 CPU 스케줄링이라 한다. 메모리 자원\n메모리에 적재된 프로세스들은 크기, 주소 모두 가지각색 같은 프로세스라 할지라도 실행될 때마다 적재되는 주소가 달라짐 따라서, 프로세스가 적재될 때 마다, 어느 주소에 적재해야 할지를 결정해야 한다. 때로는 메모리가 이미 꽉 차 있어 꼭 실행해야 할 프로세스를 적재할 공간이 없는 경우도 있고, 메모리에 공간이 남았는 데도 불구하고 프로세스를 적재하지 못하는 상황도 발생 입출력 장치 자원\n인터럽트 서비스 루틴은 운영체제가 제공하는 기능으로 커널 영역에 있다. 입출력 장치가 발생하는 하드웨어 인터럽트 도 마찬가지 운영체제는 인터럽트를 처리하는 프로그램, 즉 인터럽트 서비스 루틴을 제공함으로써 입출력 작업을 수행 9.2.3.3 파일 시스템 관리 컴퓨터를 사용할 때는 여러 파일을 열고, 생성하고, 삭제한다\n그리고 이 파일들을 한데 묶어 디렉터리(폴더)로 관리한다. 당연해 보이는 이런 파일 시스템(file system) 도 운영체제가 지원하는 핵심 서비스 이다.\n9.3 가상 머신과 이중 모드의 발전 가상 머신이란 이름 그대로 소프트웨어적으로 만들어낸 가상 컴퓨터이다.\n가상 머신을 통한 가상화를 지원하는 현대 CPU는 커널, 유저 모드 이상을 지원한다. 컴퓨터에 설치된 운영체제에서 가상 머신을 실행한다면, 그 가상 머신 또한 응용 프로그램이다.\n그래서 사용자 모드로 작동한다. 마찬가지로 가상 머신상에 설치된 운영체제 또한 사용자 모드로 작동한다.\n가상 머신에 설치된 운영체제도 사용자 모드로 작동한다면, 운영체제 서비스를 제공 받기 어렵다.\n그래서 가상화를 지원하는 CPU는 가상 머신을 위한 모드인 하이퍼 바이저 모드를 따로 둔다.\n이로써 가상 머신 상에서 작동하는 App SW들은 하이퍼 바이저 모드로써 가상 머신에 설치된 운영체제로부터 운영체제 서비스를 받을 수 있습니다. 9.4 시스템 콜, 호출의 종류 개발자가 작성하는 프로그래밍 언어들은 내부적으로 위와 같은 시스템 콜을 통해 실행된다. Reference 혼자 공부하는 컴퓨터구조+운영체제 (강민철, 한빛미디어) https://product.kyobobook.co.kr/detail/S000061584886 ","permalink":"https://2taezeat.github.io/posts/os/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0-+-%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C-ch09.-%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C-%EC%8B%9C%EC%9E%91%ED%95%98%EA%B8%B0/","summary":"9.1 운영체제를 알아야 하는 이유 9.1.1 운영체제란 시스템 자원, 자원: 프로그램 실행에 마땅히 필요한 요소\n모든 프로그램은 하드웨어를 필요 운영체제: 프로그램에 필요한 자원을 할당, 프로그램이 올바르게 실행되도록 돕는 특별한 프로그램\n운영체제 또한 메모리에 적재되어야 한다.\n컴퓨터가 부팅될 때 메모리 내 \u0026lsquo;커널 영역\u0026rsquo; 이라는 공간에 따로 적재됨\n사용자가 이용하는 응용 프로그램이 적재되는 영역을 사용자 영역이라 한다.\n운영체제는 실행할 프로그램을 메모리에 적재하고, 더 이상 실행되지 않는 프로그램을 메모리에 삭제하며, 지속적으로 메모리 자원 관리","title":"[컴퓨터구조 + 운영체제] ch09. 운영체제 시작하기"},{"content":"SharedFlow SharedFlow를 통해 메시지를 보내면, 대기하고 있는 모든 코루틴이 수신하게 된다. 브로드캐스트 Channel과 비슷하다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 suspend fun main(): Unit = coroutineScope { val mutableSharedFlow = MutableSharedFlow\u0026lt;String\u0026gt;(replay = 0) // or MutableSharedFlow\u0026lt;String\u0026gt;() launch { mutableSharedFlow.collect { println(\u0026#34;#1 received $it\u0026#34;) } } launch { mutableSharedFlow.collect { println(\u0026#34;#2 received $it\u0026#34;) } } delay(1000) mutableSharedFlow.emit(\u0026#34;Message1\u0026#34;) mutableSharedFlow.emit(\u0026#34;Message2\u0026#34;) } // (1 sec) // #1 received Message1 // #2 received Message1 // #1 received Message2 // #2 received Message2 // (program never ends) 위 프로그램은 coroutineScope의 자식 코루틴이 launch로 시작된 뒤 MutableSharedFlow를 감지하고 있는 상태 임으로 종료되지 않는다. 프로그램을 종료하려면 전체 스코프를 취소해야 한다.\nMutabledSharedFlow는 메시지 보내는 작업을 유지 할 수도 있다. 기본값이 0인 replay 인자를 설정하면 마지막으로 전송한 값들이 정해진 수 만큼 저장된다. 코루틴이 감지를 시작하면 저장된 값들을 먼저 받게 된다. resetReplayCache를 사용하면 값을 저장한 캐시를 초기화 할 수 있다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 suspend fun main(): Unit = coroutineScope { val mutableSharedFlow = MutableSharedFlow\u0026lt;String\u0026gt;( replay = 2, ) mutableSharedFlow.emit(\u0026#34;Message1\u0026#34;) mutableSharedFlow.emit(\u0026#34;Message2\u0026#34;) mutableSharedFlow.emit(\u0026#34;Message3\u0026#34;) println(mutableSharedFlow.replayCache) // [Message2, Message3] launch { mutableSharedFlow.collect { println(\u0026#34;#1 received $it\u0026#34;) } // #1 received Message2 // #1 received Message3 } delay(100) mutableSharedFlow.resetReplayCache() println(mutableSharedFlow.replayCache) // [] } 코틀린에서는 감지만 하는 인터페이스와 변경하는 인터페이스를 구분하는 것이 관행이다.\n예시, SendChannel, ReceiveChannel, Channel로 구분 하는 것 같은 법칙으로 MutableSharedFlow는 SharedFlow와 FlowCollector 모두를 상속한다. SharedFlow: Flow를 상속하고, 감지하는 목적 (collect) FlowCollector: 값을 내보내는 목적 (emit) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 suspend fun main(): Unit = coroutineScope { val mutableSharedFlow = MutableSharedFlow\u0026lt;String\u0026gt;() val sharedFlow: SharedFlow\u0026lt;String\u0026gt; = mutableSharedFlow val collector: FlowCollector\u0026lt;String\u0026gt; = mutableSharedFlow launch { mutableSharedFlow.collect { println(\u0026#34;#1 received $it\u0026#34;) } } launch { sharedFlow.collect { println(\u0026#34;#2 received $it\u0026#34;) } } delay(1000) mutableSharedFlow.emit(\u0026#34;Message1\u0026#34;) collector.emit(\u0026#34;Message2\u0026#34;) } // (1 sec) // #1 received Message1 // #2 received Message1 // #1 received Message2 // #2 received Message2 안드로이드에서 SharedFlow를 사용하는 예시\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class UserProfileViewModel { private val _userChanges = MutableSharedFlow\u0026lt;UserChange\u0026gt;() val userChanges: SharedFlow\u0026lt;UserChange\u0026gt; = _userChanges fun onCreate() { viewModelScope.launch { userChanges.collect(::applyUserChange) } } fun onNameChanged(newName: String) { // ... _userChanges.emit(NameChange(newName)) } fun onPublicKeyChanged(newPublicKey: String) { // ... _userChanges.emit(PublicKeyChange(newPublicKey)) } } shareIn 플로우는 변화를 감지할 때 주로 사용 된다. 다양한 클래스가 변화를 감지하는 상황에서 하나의 플로우로 여러 개의 플로우를 만들고 싶다면, SharedFlow가 해결책이다. Flow를 SharedFlow로 바꾸는 쉬운 방법은 shareIn 함수를 사용하는 것이다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 suspend fun main(): Unit = coroutineScope { val flow = flowOf(\u0026#34;A\u0026#34;, \u0026#34;B\u0026#34;, \u0026#34;C\u0026#34;) .onEach { delay(1000) } val sharedFlow: SharedFlow\u0026lt;String\u0026gt; = flow.shareIn( scope = this, started = SharingStarted.Eagerly, // replay = 0 (default) ) delay(500) launch { sharedFlow.collect { println(\u0026#34;#1 $it\u0026#34;) } } delay(1000) launch { sharedFlow.collect { println(\u0026#34;#2 $it\u0026#34;) } } delay(1000) launch { sharedFlow.collect { println(\u0026#34;#3 $it\u0026#34;) } } } // (1 sec) // #1 A // (1 sec) // #1 B // #2 B // (1 sec) // #1 C // #2 C // #3 C shareIn 함수는 SharedFlow를 만들고 Flow의 원소를 보낸다. 플로우의 원소를 모으는 코루틴을 시작하므로 shareIn 함수는 첫 번째 인자로 코루틴 스코프를 받는다. 세 번째 인자는 기본값이 0인 replay 값이다. 두 번째 인자인 started는 리스너의 수에 따라 값을 언제부터 감지할지 결정한다. SharingStarted.Eagerly: 즉시 값을 감지하기 시작하고 플로우로 값을 전송한다. SharingStarted.Lazily: 첫 번째 구독자가 나올 때 감지하기 시작한다. 모든 구독자가 사라져도 업스트림(데이터를 방출하는) 플로우는 Active 상태이지지만, 구독자가 없으면 replay 수 만큼 가장 최근의 값들을 캐싱한다. WhileSubscribed(): 첫 번째 구독자가 나올때 감지하기 시작하며, 마지막 구독자가 사라지면 플로우도 멈춘다. SharingStarted 인터페이스를 구현하여 커스텀도 가능하다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 suspend fun main(): Unit = coroutineScope { val flow = flowOf(\u0026#34;A\u0026#34;, \u0026#34;B\u0026#34;, \u0026#34;C\u0026#34;) val sharedFlow: SharedFlow\u0026lt;String\u0026gt; = flow.shareIn( scope = this, started = SharingStarted.Eagerly, ) delay(100) launch { sharedFlow.collect { println(\u0026#34;#1 $it\u0026#34;) } } print(\u0026#34;Done\u0026#34;) } // (0.1 sec) // Done 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 suspend fun main(): Unit = coroutineScope { val flow1 = flowOf(\u0026#34;A\u0026#34;, \u0026#34;B\u0026#34;, \u0026#34;C\u0026#34;) val flow2 = flowOf(\u0026#34;D\u0026#34;) .onEach { delay(1000) } val sharedFlow = merge(flow1, flow2).shareIn( scope = this, started = SharingStarted.Lazily, ) delay(100) launch { sharedFlow.collect { println(\u0026#34;#1 $it\u0026#34;) } } delay(1000) launch { sharedFlow.collect { println(\u0026#34;#2 $it\u0026#34;) } } } // (0.1 sec) // #1 A // #1 B // #1 C // (1 sec) // #2 D // #1 D 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 suspend fun main(): Unit = coroutineScope { val flow = flowOf(\u0026#34;A\u0026#34;, \u0026#34;B\u0026#34;, \u0026#34;C\u0026#34;, \u0026#34;D\u0026#34;) .onStart { println(\u0026#34;Started\u0026#34;) } .onCompletion { println(\u0026#34;Finished\u0026#34;) } .onEach { delay(1000) } val sharedFlow = flow.shareIn( scope = this, started = SharingStarted.WhileSubscribed(), ) delay(3000) launch { println(\u0026#34;#1 ${sharedFlow.first()}\u0026#34;) } launch { println(\u0026#34;#2 ${sharedFlow.take(2).toList()}\u0026#34;) } delay(3000) launch { println(\u0026#34;#3 ${sharedFlow.first()}\u0026#34;) } } // (3 sec) // Started // (1 sec) // #1 A // (1 sec) // #2 [A, B] // Finished // (1 sec) // Started // (1 sec) // #3 A // Finished 동일한 변화를 감지하려고 하는 서비스가 여러 개일 때, shareIn 을 사용하면 된다. 다양한 서비스가 location 에 의존하고 있다면, 각 서비스가 데이터베이스를 독자적으로 감지하는 건 최적화된 방법이 아니다. 대신 이런 변화를 SharedFlow를 통해 감지된 변화를 공유하는 것이 좋다. replay = 1: 구독자가 location 의 마지막 목록을 즉시 받기 원할 때 replay = 0: 구독 후의 변경에만 반응할 때 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 @Dao interface LocationDao { @Insert(onConflict = OnConflictStrategy.IGNORE) suspend fun insertLocation(location: Location) @Query(\u0026#34;DELETE FROM location_table\u0026#34;) suspend fun deleteLocations() @Query(\u0026#34;SELECT * FROM location_table ORDER BY time\u0026#34;) fun observeLocations(): Flow\u0026lt;List\u0026lt;Location\u0026gt;\u0026gt; } class LocationService( locationDao: LocationDao, scope: CoroutineScope ) { private val locations = locationDao.observeLocations() .shareIn( scope = scope, started = SharingStarted.WhileSubscribed(), ) fun observeLocations(): Flow\u0026lt;List\u0026lt;Location\u0026gt;\u0026gt; = locations } 호출 할 때마다 새로운 SharedFlow를 만들면 안되고, SharedFlow를 만든 뒤 프로퍼티로 저장하자.\nStateFlow StateFlow 는 SharedFlow의 개념을 확장 시킨 것으로, replay 값이 1인 SharedFlow와 비슷하게 작동한다. StateFlow 는 value 프로퍼티로 접근 가능한 값 하나를 항상 가지고 있다. 초기 값은 생성자를 통해 전달되어야 한다. value 프로퍼티로 값을 얻어 올 수도 있고, 설정 할 수도 있다. MutableStateFlow는 값을 감지할 수 있는 보관소 이다. 1 2 3 4 5 6 7 8 9 10 11 interface StateFlow\u0026lt;out T\u0026gt; : SharedFlow\u0026lt;T\u0026gt; { val value: T } interface MutableStateFlow\u0026lt;T\u0026gt; : StateFlow\u0026lt;T\u0026gt;, MutableSharedFlow\u0026lt;T\u0026gt; { override var value: T fun compareAndSet(expect: T, update: T): Boolean } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 suspend fun main() = coroutineScope { val state = MutableStateFlow(\u0026#34;A\u0026#34;) println(state.value) // A launch { state.collect { println(\u0026#34;Value changed to $it\u0026#34;) } // Value changed to A } delay(1000) state.value = \u0026#34;B\u0026#34; // Value changed to B delay(1000) launch { state.collect { println(\u0026#34;and now it is $it\u0026#34;) } // and now it is B } delay(1000) state.value = \u0026#34;C\u0026#34; // Value changed to C and now it is C } 안드로이드에서 StateFlow는 LiveData를 대체하는 최신 방식으로 사용되고 있다. 코루틴을 완벽하게 지원한다. 초기 값을 가지고 있기 때문에 null일 필요가 없다. StateFlow 는 주로 ViewModel의 상태를 나타낼 때 주로 사용된다. StateFlow 는 상태를 감지할 수 있으며, 감지된 상태에 따라 View가 보여주고 갱신된다. 1 2 3 4 5 6 7 8 9 10 11 12 class LatestNewsViewModel( private val newsRepository: NewsRepository ) : ViewModel() { private val _uiState = MutableStateFlow\u0026lt;NewsState\u0026gt;(LoadingNews) val uiState: StateFlow\u0026lt;NewsState\u0026gt; = _uiState fun onCreate() { scope.launch { _uiState.value = NewsLoaded(newsRepository.getNews()) } } } StateFlow 는 데이터가 덮어 씌워지기 때문에, observe가 느린 경우, 상태의 중간 변화를 받을 수 없는 경우도 있다. 모든 이벤트를 다 받으려면, StateFlow가 아니라, SharedFlow를 사용해야 한다. StateFlow는 현재 상태만 나타내기 때문에, StateFlow의 이전 상태는 아무도 관심이 없다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 suspend fun main(): Unit = coroutineScope { val state = MutableStateFlow(\u0026#39;X\u0026#39;) launch { for (c in \u0026#39;A\u0026#39;..\u0026#39;E\u0026#39;) { delay(300) state.value = c // or state.emit(c) } } state.collect { delay(1000) println(it) } } // X // C // E stateIn stateIn 는 Flow\u0026lt;T\u0026gt;를 StateFlow\u0026lt;T\u0026gt; 로 변환하는 함수이다. 스코프에서만 호출 가능하지만, 중단 함수 이기도 하다. StateFlow는 항상 값을 가져야 하기에, 값을 명시하지 않았을 때는 첫 번째 값이 계산될 때까지 기다려야 한다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 suspend fun main() = coroutineScope { val flow = flowOf(\u0026#34;A\u0026#34;, \u0026#34;B\u0026#34;, \u0026#34;C\u0026#34;) .onEach { delay(1000) } .onEach { println(\u0026#34;Produced $it\u0026#34;) } val stateFlow: StateFlow\u0026lt;String\u0026gt; = flow.stateIn(this) println(\u0026#34;Listening\u0026#34;) println(stateFlow.value) stateFlow.collect { println(\u0026#34;Received $it\u0026#34;) } } // (1 sec) // Produced A // Listening // A // Received A // (1 sec) // Produced B // Received B // (1 sec) // Produced C // Received C stateIn의 두 번째 형태는 중단 함수가 아니지만, 초기 값과 started 모드를 지정해야 한다. started 모드는 shareIn과 같은 옵션을 가진다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 suspend fun main() = coroutineScope { val flow = flowOf(\u0026#34;A\u0026#34;, \u0026#34;B\u0026#34;) .onEach { delay(1000) } .onEach { println(\u0026#34;Produced $it\u0026#34;) } val stateFlow: StateFlow\u0026lt;String\u0026gt; = flow.stateIn( scope = this, started = SharingStarted.Lazily, initialValue = \u0026#34;Empty\u0026#34; ) println(stateFlow.value) delay(2000) stateFlow.collect { println(\u0026#34;Received $it\u0026#34;) } } // Empty // (2 sec) // Received Empty // (1 sec) // Produced A // Received A // (1 sec) // Produced B // Received B 하나의 데이터 소스에서 값이 변경된 걸 감지하는 경우에 주로 stateIn 함수를 사용한다. StateFlow로 상태를 변경할 수 있으며, 결국엔 View가 변화를 감지 할 수 있게 된다. 1 2 3 4 5 6 7 8 9 10 11 class LocationsViewModel(locationService: LocationService) : ViewModel() { private val location = locationService.observeLocations() .map { it.toLocationsDisplay() } .stateIn( scope = viewModelScope, started = SharingStarted.Lazily, initialValue = LocationsDisplay.Loading, ) // ... } Reference https://kotlinlang.org/docs/coroutines-guide.html 코틀린 코루틴 Kotlin Coroutines: Deep Dive (Marcin Moskała, 인사이트) ","permalink":"https://2taezeat.github.io/posts/%EC%BD%94%EB%A3%A8%ED%8B%B4-%EC%BD%94%EB%A3%A8%ED%8B%B4/%EC%BD%94%ED%8B%80%EB%A6%B0-%EC%BD%94%EB%A3%A8%ED%8B%B4-ch24.-sharedflow-stateflow/","summary":"SharedFlow SharedFlow를 통해 메시지를 보내면, 대기하고 있는 모든 코루틴이 수신하게 된다. 브로드캐스트 Channel과 비슷하다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 suspend fun main(): Unit = coroutineScope { val mutableSharedFlow = MutableSharedFlow\u0026lt;String\u0026gt;(replay = 0) // or MutableSharedFlow\u0026lt;String\u0026gt;() launch { mutableSharedFlow.collect { println(\u0026#34;#1 received $it\u0026#34;) } } launch { mutableSharedFlow.collect { println(\u0026#34;#2 received $it\u0026#34;) } } delay(1000) mutableSharedFlow.","title":"[코틀린 코루틴] ch24. SharedFlow, StateFlow"},{"content":"플로우 처리 플로우 생성과 최종 연산 사이의 값을 변경하는 연산들을 플로우 처리(flow processing) 이라고 한다. 플로우는 값이 흐르기 때문에 제외하고, 곱하고, 변형하거나, 합치는 등의 여러 가지 방법으로 변경 가능하다. 컬렉션 처리는 어떻게 작동할까? flow 빌더와 람다식을 가진 collect 만으로 구현 가능하다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 suspend fun main() { flowOf(\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;) .map { it.uppercase() } .collect { print(it) } // AB } fun \u0026lt;T, R\u0026gt; Flow\u0026lt;T\u0026gt;.map( transform: suspend (value: T) -\u0026gt; R ): Flow\u0026lt;R\u0026gt; = flow { collect { value -\u0026gt; emit(transform(value)) } } fun \u0026lt;T\u0026gt; flowOf(vararg elements: T): Flow\u0026lt;T\u0026gt; = flow { for (element in elements) { emit(element) } } suspend fun main() { flow map@{ // 1 flow flowOf@{ // 2 for (element in arrayOf(\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;)) { // 3 this@flowOf.emit(element) // 4 } }.collect { value -\u0026gt; // 5 this@map.emit(value.uppercase()) // 6 } }.collect { // 7 print(it) // 8 } } 1에서 플로우 시작, 7에서 원소들을 모은다. 모으기 시작할 때, 1에서 시작하는 @map 람다식을 수행하며, 이 람다식은 2에서 또 다른 빌더를 호출하고, 5에서 원소들을 모은다. 원소 들을 모을 때, 2에서 시작하는 @flowOf 람다식을 시작한다. 2의 람다식은 \u0026lsquo;a\u0026rsquo;, \u0026lsquo;b\u0026rsquo;를 가진 배열을 탐색한다. 첫 번째 값인 \u0026lsquo;a\u0026rsquo;를 4에서 내보내며, 5 람다식이 호출된다. 5의 람다식은 갑을 \u0026lsquo;A\u0026rsquo;로 변경하며 @map 플로우로 내보낸 뒤, 7의 람다식이 호출 된다. 값이 출력된 후 7의 람다식이 종료되고 6에서 람다식이 재개 된다. 람다식이 끝났기 때문에 4의 @flowOf가 재개되며, 탐색이 다시 시작되어 4에서 \u0026lsquo;b\u0026rsquo;를 내보낸다. 5에서 람다식이 호출되고, \u0026lsquo;B\u0026rsquo;로 값을 변형한 뒤 6에서 @map 플로우로 내보낸다. 값은 7에서 모이며 8에서 출력된다. 7의 람다식이 종료되므로 6의 람다식이 재개 된다. 이 람다식도 종료되었기 때문에 4의 @flowOf 람다식이 다시 시작된다. 4도 종료되었기 때문에 5의 collect에서 @map이 재개된다. 더 이상 남은 것이 없기 때문에 @map의 마지막 부분에 도달한다. 7의 collect에서 다시 시작하면 main 함수의 끝에 도달한다. map 플로우의 각 원소를 변환 함수에 따라 변환하는 map 함수. 1 2 3 4 5 6 7 fun \u0026lt;T, R\u0026gt; Flow\u0026lt;T\u0026gt;.map( transform: suspend (value: T) -\u0026gt; R ): Flow\u0026lt;R\u0026gt; = flow { // here we create a new flow collect { value -\u0026gt; // here we collect from receiver emit(transform(value)) } } filter 원래 플로우에서 주어진 조건에 맞는 값들만 가진 플로우를 반환한다. 관심 없는 원소를 제거할 때 주로 사용 1 2 3 4 5 6 7 8 suspend fun main() { (1..10).asFlow() // [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] .filter { it \u0026lt;= 5 } // [1, 2, 3, 4, 5] .filter { isEven(it) } // [2, 4] .collect { print(it) } // 24 } fun isEven(num: Int): Boolean = num % 2 == 0 take 특정 수의 원소만 통과시킬 때 사용 1 2 3 4 5 suspend fun main() { (\u0026#39;A\u0026#39;..\u0026#39;Z\u0026#39;).asFlow() .take(5) // [A, B, C, D, E] .collect { print(it) } // ABCDE } drop 특정 수의 원소를 무시할 때 사용 1 2 3 4 5 suspend fun main() { (\u0026#39;A\u0026#39;..\u0026#39;Z\u0026#39;).asFlow() .drop(20) // [U, V, W, X, Y, Z] .collect { print(it) } // UVWXYZ } merge 두 개의 플로우를 하나의 플로우로 합칠 때 사용되는 함수 =\u0026gt; merge, zip, combine merge: 두 개의 플로우에서 생성된 원소들을 하나로 합칠 때 사용 merge를 사용하면 한 플로우의 원소가 다른 플로우를 기다리지 않는다는 것이 중요하다. 첫 번째 플로우의 원소 생성이 지연된다고 해서, 두 번째 플로우의 원소 생성이 중단되지 않는다. 여러 개의 이벤트들을 똑같은 방법으로 처리할 때 merge를 사용한다. 1 2 3 4 5 6 7 8 9 10 11 suspend fun main() { val ints: Flow\u0026lt;Int\u0026gt; = flowOf(1, 2, 3) val doubles: Flow\u0026lt;Double\u0026gt; = flowOf(0.1, 0.2, 0.3) val together: Flow\u0026lt;Number\u0026gt; = merge(ints, doubles) print(together.toList()) // [1, 0.1, 0.2, 0.3, 2, 3] // or [1, 0.1, 0.2, 0.3, 2, 3] // or [0.1, 1, 2, 3, 0.2, 0.3] // or any other combination } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 suspend fun main() { val ints: Flow\u0026lt;Int\u0026gt; = flowOf(1, 2, 3) .onEach { delay(1000) } val doubles: Flow\u0026lt;Double\u0026gt; = flowOf(0.1, 0.2, 0.3) val together: Flow\u0026lt;Number\u0026gt; = merge(ints, doubles) together.collect { println(it) } } // 0.1 // 0.2 // 0.3 // (1 sec) // 1 // (1 sec) // 2 // (1 sec) // 3 zip 두 플로우로 부터 쌍을 만들때 사용한다. 원소가 쌍을 이루는 방법을 정하는 함수도 필요하다. 각 원소는 한 쌍의 일부가 되므로 쌍이 될 원소를 기다려야 한다. 쌍을 이루지 못하고 남은 원소는 유실되므로 한 플로우에서 zipping이 완료되면 생성되는 플로우 또한 완료된다. zip은 쌍을 필요로 하기 때문에 첫 번째 플로우가 닫히면 함수 또한 끝나게 된다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 suspend fun main() { val flow1 = flowOf(\u0026#34;A\u0026#34;, \u0026#34;B\u0026#34;, \u0026#34;C\u0026#34;) .onEach { delay(400) } val flow2 = flowOf(1, 2, 3, 4) .onEach { delay(1000) } flow1.zip(flow2) { f1, f2 -\u0026gt; \u0026#34;${f1}_${f2}\u0026#34; } .collect { println(it) } } // (1 sec) // A_1 // (1 sec) // B_2 // (1 sec) // C_3 combine combine을 사용하면 모든 새로운 원소가 전임자를 대체 하게 된다. zip의 경우 느린 플로우를 기다려야 한다. 첫 번째 쌍이 이미 만들어졌다면 다른 플로우의 이전 원소와 함께 새로운 쌍이 만들어진다. combine은 두 플로우 모두 닫힐 때까지 원소를 내보낸다. combine은 두 데이터 소스의 변화를 능동적으로 감지할 때 주로 사용된다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 suspend fun main() { val flow1 = flowOf(\u0026#34;A\u0026#34;, \u0026#34;B\u0026#34;, \u0026#34;C\u0026#34;) .onEach { delay(400) } val flow2 = flowOf(1, 2, 3, 4) .onEach { delay(1000) } flow1.combine(flow2) { f1, f2 -\u0026gt; \u0026#34;${f1}_${f2}\u0026#34; } .collect { println(it) } } // (1 sec) // B_1 // (0.2 sec) // C_1 // (0.8 sec) // C_2 // (1 sec) // C_3 // (1 sec) // C_4 변화가 발생할 때마다 원소가 내보내지길 원한다면 합쳐질 각 플로우에 초기 값을 더하면 된다. Ex. View가 감지 가능한 원소 두 가지 중에 하나라도 변경될 때 반응해야 하는 경우 combine을 주로 사용한다. 1 2 3 4 5 userUpdateFlow.onStart { emit(currentUser) } AFlow.combine(BFlow) { a, b -\u0026gt; updateView(a, b) }.collect fold 초기 값부터 시작하여 주어진 원소 각각에 대해 두 개의 값을 하나로 합치는 연산을 적용하여 컬렉션의 모든 값을 하나로 합칠때 사용 fold는 최종 연산이고, 플로우에서도 사용할 수 있으며, collect 처럼 플로우가 완료될 때까지 중단(suspend) 된다. 1 2 3 4 5 6 7 8 suspend fun main() { val list = flowOf(1, 2, 3, 4) .onEach { delay(1000) } val res = list.fold(0) { acc, i -\u0026gt; acc + i } println(res) } // (4 sec) // 10 scan scan은 누적되는 과정의 모든 값을 생성하는 중간 연산이다. scan은 이전 단계에서 값을 받은 즉시 새로운 값을 만들기 만든다. flatMapConcat 컬렉션의 경우 flatMap은 map 과 비슷하지만 변환 함수가 평탄화된 컬렉션 을 반환해야 한다는 점이 다르다. 플로우의 경우 변환 함수가 평탄화된 플로우를 반환한다고 생각하는게 직관적이다. 문제는 플로우 원소가 나오는 시간이 다르다는 점이다. 이러한 이유로 플로우에는 flatMap 함수가 없으며, 대신 flatMapConcat, flatMapMerge, flatMapLatest와 같은 함수가 존재한다. flatMapConcat 함수는 생성된 플로우를 하나씩 처리한다. 그래서 두 번째 플로우는 첫 번째 플로우가 완료되었을 때 시작할 수 있다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 fun flowFrom(elem: String) = flowOf(1, 2, 3) .onEach { delay(1000) } .map { \u0026#34;${it}_${elem} \u0026#34; } suspend fun main() { flowOf(\u0026#34;A\u0026#34;, \u0026#34;B\u0026#34;, \u0026#34;C\u0026#34;) .flatMapConcat { flowFrom(it) } .collect { println(it) } } // (1 sec) // 1_A // (1 sec) // 2_A // (1 sec) // 3_A // (1 sec) // 1_B // (1 sec) // 2_B // (1 sec) // 3_B // (1 sec) // 1_C // (1 sec) // 2_C // (1 sec) // 3_C flatMapMerge 특징: 만들어진 플로우를 동시에 처리한다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 fun flowFrom(elem: String) = flowOf(1, 2, 3) .onEach { delay(1000) } .map { \u0026#34;${it}_${elem} \u0026#34; } suspend fun main() { flowOf(\u0026#34;A\u0026#34;, \u0026#34;B\u0026#34;, \u0026#34;C\u0026#34;) .flatMapMerge { flowFrom(it) } .collect { println(it) } } // (1 sec) // 1_A // 1_B // 1_C // (1 sec) // 2_A // 2_B // 2_C // (1 sec) // 3_A // 3_B // 3_C concurreny 인자를 사용해 동시에 처리할 수 있는 플로우의 수를 설정할 수 있다. 기본값은 16이지만, 변경 가능하다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 fun flowFrom(elem: String) = flowOf(1, 2, 3) .onEach { delay(1000) } .map { \u0026#34;${it}_${elem} \u0026#34; } suspend fun main() { flowOf(\u0026#34;A\u0026#34;, \u0026#34;B\u0026#34;, \u0026#34;C\u0026#34;) .flatMapMerge(concurrency = 2) { flowFrom(it) } .collect { println(it) } } // (1 sec) // 1_A // 1_B // (1 sec) // 2_A // 2_B // (1 sec) // 3_A // 3_B // (1 sec) // 1_C // (1 sec) // 2_C // (1 sec) // 3_C flatMapMerge는 플로우의 각 원소에 대한 데이터를 요청할 때 주로 사용된다. 예를 들어 종류를 목록으로 가지고 있다면, 종류별로 요청을 보내야 한다. async 함수 대신, 플로우와 함께 flatMapMerge를 사용하면 두 가지 이점이 있다. 동시성 인자를 제어하고(같은 시간에 수백 개의 요청을 보내는 걸 피하기 위해) 같은 시간에 얼마만큼의 종류를 처리할지 결정할 수 있다. Flow를 반환하여 데이터가 생성될 때마다, 다음 원소를 보낼 수 있다. 함수를 사용하는 측면에서 보면, 데이터를 즉시 처리할 수 있다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 suspend fun getOffers( categories: List\u0026lt;Category\u0026gt; ): List\u0026lt;Offer\u0026gt; = coroutineScope { categories .map { async { api.requestOffers(it) } } .flatMap { it.await() } } // 더 나은 방법 이다. suspend fun getOffers( categories: List\u0026lt;Category\u0026gt; ): Flow\u0026lt;Offer\u0026gt; = categories .asFlow() .flatMapMerge(concurrency = 20) { suspend { api.requestOffers(it) }.asFlow() // or flow { emit(api.requestOffers(it)) } } flatMapLatest 특징: 새로운 플로우가 나타나면 이전에 처리하던 플로우를 잊어버린다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 fun flowFrom(elem: String) = flowOf(1, 2, 3) .onEach { delay(1000) } .map { \u0026#34;${it}_${elem} \u0026#34; } suspend fun main() { flowOf(\u0026#34;A\u0026#34;, \u0026#34;B\u0026#34;, \u0026#34;C\u0026#34;) .flatMapLatest { flowFrom(it) } .collect { println(it) } } // (1 sec) // 1_C // (1 sec) // 2_C // (1 sec) // 3_C 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 fun flowFrom(elem: String) = flowOf(1, 2, 3) .onEach { delay(1000) } .map { \u0026#34;${it}_${elem} \u0026#34; } suspend fun main() { flowOf(\u0026#34;A\u0026#34;, \u0026#34;B\u0026#34;, \u0026#34;C\u0026#34;) .onEach { delay(1200) } .flatMapLatest { flowFrom(it) } .collect { println(it) } } // (2.2 sec) // 1_A // (1.2 sec) // 1_B // (1.2 sec) // 1_C // (1 sec) // 2_C // (1 sec) // 3_C retry(재시도) 예외는 플로우를 따라 흐르면서 각 단계를 하나씩 종료한다. 종료된 단계는 비활성화되기 때문에, 예외가 발생한 뒤 메시지를 보내는 건 불가능하지만, 각 단계가 이전 단계에 대한 참조를 가지고 있으며, 플로우를 다시 시작하기 위해 참조를 사용할 수 있다. 이 원리에 기반하여, 코틀린은 retry와 retryWhen 함수를 제공한다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 fun \u0026lt;T\u0026gt; Flow\u0026lt;T\u0026gt;.retryWhen( predicate: suspend FlowCollector\u0026lt;T\u0026gt;.( cause: Throwable, attempt: Long, ) -\u0026gt; Boolean, ): Flow\u0026lt;T\u0026gt; = flow { var attempt = 0L do { val shallRetry = try { collect { emit(it) } false } catch (e: Throwable) { predicate(e, attempt++) .also { if (!it) throw e } } } while (shallRetry) } 1 2 3 4 5 6 7 8 9 10 11 fun \u0026lt;T\u0026gt; Flow\u0026lt;T\u0026gt;.retry( retries: Long = Long.MAX_VALUE, predicate: suspend (cause: Throwable) -\u0026gt; Boolean = { true } ): Flow\u0026lt;T\u0026gt; { require(retries \u0026gt; 0) { \u0026#34;Expected positive amount of retries, but had $retries\u0026#34; } return retryWhen { cause, attempt -\u0026gt; attempt \u0026lt; retries \u0026amp;\u0026amp; predicate(cause) } } retryWhen 은 플로우의 이전 단계에서 예외가 발생할 때마다 조건자(predicate) 를 확인한다. 몇 번까지 재시도할지와 특정 예외 클래스가 발생했을 때만 처리할지를 명시한다. 1 2 3 4 5 6 7 8 9 10 11 suspend fun main() { flow { emit(1) emit(2) error(\u0026#34;E\u0026#34;) emit(3) }.retry(3) { print(it.message) true }.collect { print(it) } // 12E12E12E12(exception thrown) } 어떤 예외든지 항상 재시도 하는 경우, log를 남기고 새로운 연결 맺는 걸 시도할 때 시간 간격을 주기 위해 predict(조건자) 를 정의한다. 1 2 3 4 5 6 7 fun makeConnection(config: ConnectionConfig) = api .startConnection(config) .retry { e -\u0026gt; delay(1000) log.error(e) { \u0026#34;Error for $config\u0026#34; } true } 연결을 계속해서 재시도할 때 시간 간격을 점진적으로 증가시키는 방법도 자주 사용된다. 예외가 특정 타입일 때 재시도하는 조건자를 구현할 수 도 있다. 1 2 3 4 5 6 7 fun makeConnection(config: ConnectionConfig) = api .startConnection(config) .retryWhen { e, attempt -\u0026gt; delay(100 * attempt) log.error(e) { \u0026#34;Error for $config\u0026#34; } e is ApiException \u0026amp;\u0026amp; e.code !in 400..499 } 최종 연산 플로우를 처리를 끝내는 연산 =\u0026gt; 최종 연산 이라고 부른다. 기본적인 collect 외에도, Collection(컬렉션)과 Sequence 가 제공하는 것과 비슷한 count, first, firstOrNull, fold, reduce 또한 최종 연산이다. 최종 연산은 중단 가능(suspend) 가능하며, 플로우가 완료되었을 때 또는 최종 연산 자체가 플로우를 완료 시켰을 때 값을 반환한다. collect 메서드를 사용해서 또 다른 최종 연산을 얼마든지 구현할 수 도 있다. 1 2 3 4 5 6 7 8 9 10 suspend fun main() { val flow = flowOf(1, 2, 3, 4) // [1, 2, 3, 4] .map { it * it } // [1, 4, 9, 16] println(flow.first()) // 1 println(flow.count()) // 4 println(flow.reduce { acc, value -\u0026gt; acc * value }) // 576 println(flow.fold(0) { acc, value -\u0026gt; acc + value }) // 30 } Reference https://kotlinlang.org/docs/coroutines-guide.html 코틀린 코루틴 Kotlin Coroutines: Deep Dive (Marcin Moskała, 인사이트) ","permalink":"https://2taezeat.github.io/posts/%EC%BD%94%EB%A3%A8%ED%8B%B4-%EC%BD%94%EB%A3%A8%ED%8B%B4/%EC%BD%94%ED%8B%80%EB%A6%B0-%EC%BD%94%EB%A3%A8%ED%8B%B4-ch23.-flow-%EC%B2%98%EB%A6%ACprocessing/","summary":"플로우 처리 플로우 생성과 최종 연산 사이의 값을 변경하는 연산들을 플로우 처리(flow processing) 이라고 한다. 플로우는 값이 흐르기 때문에 제외하고, 곱하고, 변형하거나, 합치는 등의 여러 가지 방법으로 변경 가능하다. 컬렉션 처리는 어떻게 작동할까? flow 빌더와 람다식을 가진 collect 만으로 구현 가능하다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 suspend fun main() { flowOf(\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;) .","title":"[코루틴 코루틴] ch23. Flow 처리(Processing)"},{"content":"플로우 생명주기 함수 플로우는 요청이 한쪽 방향으로 흐르고, 요청에 의해 생성된 값이 다른 방향으로 흐르는 파이프라 생각할 수 있다. 플로우가 완료되거나 예외가 발생했을 때, 이러한 정보가 전달되어 중간 단계가 종료된다. 모든 정보가 플로우로 전달되므로 값, 예외, 시작, 완료 같은 다른 이벤트를 감지할 수 있다. onEach 플로우의 값을 하나씩 받기 위해 onEach 함수를 사용한다.\nonEach 람다식은 중단 함수이며, 원소는 순서대로 처리(동기) 된다.\nonStart onStart 함수는 최종 연산이 호출될 때와 같이, 플로우가 시작되는 경우에 호출되는 리스너를 설정한다. onStart 는 첫 번째 원소를 \u0026lsquo;요청\u0026rsquo; 했을 때 호출되는 함수이다. onStart는 첫 번째 원소가 생성되는 걸 기다렸다 호출되는 게 아니다. onStart 에서도 원소를 내보낼 수 있다. 원소들은 onStart 부터 아래로 흐르게 된다. 1 2 3 4 5 6 7 8 9 10 11 suspend fun main() { flowOf(1, 2) .onEach { delay(1000) } .onStart { println(\u0026#34;Before\u0026#34;) } .collect { println(it) } } // Before // (1 sec) // 1 // (1 sec) // 2 onCompletion 플로우를 완료할 수 있는, 가장 흔한 방법이다. 플로우 빌더가 끝났을 때 사용된다. 예를 들면, 마지막 원소가 전송되었을 때 onCompleteion 메서드를 사용해 플로우가 완료되었을 때 호출되는 리스너를 추가할 수 있다. 안드로이드 에서 네트워크 응답을 기다리고 있는 척도인 Progress Bar를 보여주기 위해, onStart를 사용하며, 가리기 위해서는 onCompletion을 사용한다. onEmpty 플로우는 예기치 않은 이벤트가 발생하면 값을 내보내기 전에 완료될 수 있다.\nonEmpty 함수 는 원소를 내보내기 전에 플로우가 완료되면 실행된다.\nonEmpty 기본 값을 내보내기 위한 목적으로 사용될 수 있다.\ncatch 플로우를 만들거나 처리하는 도중에 예외가 발생할 수 있다.\n이러한 예외는 아래로 흐르면서 처리하는 단계를 하나씩 닫는다. 하지만 예외를 잡고 관리 할 수도 있다.\n리스너는 예외 인자로 받고 정리를 위한 연산을 수행할 수 있다.\ncatch 함수는 예외를 잡아 전파되는 걸 멈춘다.\n이전 단계는 이미 완료된 상태지만, catch는 새로운 값을 여전히 내보낼 수 있어 남은 플로우를 지속할 수 있다. catch 함수는 윗부분에서 던진 예외에만 반응한다.\n예외는 아래로 흐를 때 잡는다고 생각하면 된다. 1 2 3 4 5 6 7 8 9 10 11 12 13 class MyError : Throwable(\u0026#34;My error\u0026#34;) val flow = flow { emit(\u0026#34;Message1\u0026#34;) throw MyError() } suspend fun main(): Unit { flow.catch { emit(\u0026#34;Error\u0026#34;) } .collect { println(\u0026#34;Collected $it\u0026#34;) } } // Collected Message1 // Collected Error 잡히지 않은 예외 플로우에서 잡히지 않은 예외는 플로우를 즉시 취소하며, collect는 예외를 다시 던진다. 중단 함수, coroutineScope 모두 같은 방식으로 예외를 처리한다. catch를 사용하는 건(마지막 연산 뒤에 catch가 올 수 없기 때문에) 최종 연산에서 발생한 예외를 처리하는 데 전혀 도움이 되지 않는다. 따라서 collect에서 예외가 발생하면 예외를 잡지 못하게 되어 블록 밖으로 예외가 전달된다. 그러므로, collect의 연산을 onEach로 옮기고 catch 이전에 두는 방법이 자주 사용된다. collect의 연산을 옮긴다면 catch가 모든 예외를 잡을 거라고 확신할 수 있다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class MyError : Throwable(\u0026#34;My error\u0026#34;) val flow = flow { emit(\u0026#34;Message1\u0026#34;) emit(\u0026#34;Message2\u0026#34;) } suspend fun main(): Unit { flow.onStart { println(\u0026#34;Before\u0026#34;) } .catch { println(\u0026#34;Caught $it\u0026#34;) } .collect { throw MyError() } } // Before // Exception in thread \u0026#34;...\u0026#34; MyError: My error 1 2 3 4 5 6 7 8 9 10 11 12 13 val flow = flow { emit(\u0026#34;Message1\u0026#34;) emit(\u0026#34;Message2\u0026#34;) } suspend fun main(): Unit { flow.onStart { println(\u0026#34;Before\u0026#34;) } .onEach { throw MyError() } .catch { println(\u0026#34;Caught $it\u0026#34;) } .collect() } // Before // Caught MyError: My error flowOn onEach, onStart, onCompletiom과 같은 플로우 연산과 flow나 channelFlow와 같은 플로우 빌더의 인자로 사용되는 람다식은 모두 중단 함수이다.\n중단 함수는 context가 필요하며(구조화된 동시성을 위해) 부모와 관계를 유지한다. 플로우의 함수들은 collect가 호출되는 곳의 context에서 context를 얻는다. flowOn 함수로 context를 변경할 수 있다.\nflowOn은 플로우에서 윗부분에 있는 함수에서만 작동한다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 suspend fun present(place: String, message: String) { val ctx = coroutineContext val name = ctx[CoroutineName]?.name println(\u0026#34;[$name] $message on $place\u0026#34;) } fun messagesFlow(): Flow\u0026lt;String\u0026gt; = flow { present(\u0026#34;flow builder\u0026#34;, \u0026#34;Message\u0026#34;) emit(\u0026#34;Message\u0026#34;) } suspend fun main() { val users = messagesFlow() withContext(CoroutineName(\u0026#34;Name1\u0026#34;)) { users .flowOn(CoroutineName(\u0026#34;Name3\u0026#34;)) .onEach { present(\u0026#34;onEach\u0026#34;, it) } .flowOn(CoroutineName(\u0026#34;Name2\u0026#34;)) .collect { present(\u0026#34;collect\u0026#34;, it) } } } // [Name3] Message on flow builder // [Name2] Message on onEach // [Name1] Message on collect launchIn collect는 플로우가 완료될 때 까지 코루틴을 **중단(연기, suspend)**하는 중단 연산이다. launch 빌더로 collect를 래핑하면 플로우를 다른 코루틴에서 처리할 수 있다. 플로우의 확장 함수인 launchIn을 사용하면 유일한 인자로 Scope를 받아 collect를 새로운 코루틴에서 시작할 수 있다. 별도의 코루틴에서 플로우를 시작하기 위해 launchIn을 주로 사용한다. 1 2 3 4 5 6 7 8 9 10 11 12 fun \u0026lt;T\u0026gt; Flow\u0026lt;T\u0026gt;.launchIn(scope: CoroutineScope): Job = scope.launch { collect() } suspend fun main(): Unit = coroutineScope { flowOf(\u0026#34;User1\u0026#34;, \u0026#34;User2\u0026#34;) .onStart { println(\u0026#34;Users:\u0026#34;) } .onEach { println(it) } .launchIn(this) } // Users: // User1 // User2 Reference https://kotlinlang.org/docs/coroutines-guide.html 코틀린 코루틴 Kotlin Coroutines: Deep Dive (Marcin Moskała, 인사이트) ","permalink":"https://2taezeat.github.io/posts/%EC%BD%94%EB%A3%A8%ED%8B%B4-%EC%BD%94%EB%A3%A8%ED%8B%B4/%EC%BD%94%ED%8B%80%EB%A6%B0-%EC%BD%94%EB%A3%A8%ED%8B%B4-ch22.-flow-%EC%83%9D%EB%AA%85%EC%A3%BC%EA%B8%B0-%ED%95%A8%EC%88%98/","summary":"플로우 생명주기 함수 플로우는 요청이 한쪽 방향으로 흐르고, 요청에 의해 생성된 값이 다른 방향으로 흐르는 파이프라 생각할 수 있다. 플로우가 완료되거나 예외가 발생했을 때, 이러한 정보가 전달되어 중간 단계가 종료된다. 모든 정보가 플로우로 전달되므로 값, 예외, 시작, 완료 같은 다른 이벤트를 감지할 수 있다. onEach 플로우의 값을 하나씩 받기 위해 onEach 함수를 사용한다.\nonEach 람다식은 중단 함수이며, 원소는 순서대로 처리(동기) 된다.\nonStart onStart 함수는 최종 연산이 호출될 때와 같이, 플로우가 시작되는 경우에 호출되는 리스너를 설정한다.","title":"[코루틴 코루틴] ch22. Flow 생명주기 함수"},{"content":"플로우 만들기 원시값을 가지는 플로우 플로우를 만드는 가장 간단한 방법은 플로우가 어떤 값을 가져야 하는지 정의하는 flowOf 함수를 사용하는 것이다. 리스트의 listOf 함수와 비슷하다. 값이 없는 플로우는 emptyFlow() 함수를 사용한다. 컨버터 asFlow 함수를 사용해서 Iterable, Iterator, Sequence를 Flow로 바꿀 수 있다. asFlow 함수는 즉시 사용 가능한 원소들의 플로우를 만든다. 플로우 처리 함수를 사용해 처리 가능한 원소들의 플로우를 시작할때 유용하다. 1 2 3 4 5 6 7 suspend fun main() { listOf(1, 2, 3, 4, 5) // or setOf(1, 2, 3, 4, 5) // or sequenceOf(1, 2, 3, 4, 5) .asFlow() .collect { print(it) } // 12345 } 함수를 플로우로 바꾸기 플로우는 RxJava의 Single 처럼 시간상 지연되는 하나의 값을 나타낼 때 자주 사용된다. 따라서 중단 함수를 플로우로 변환하는 것 또한 가능하다. 이때 중단 함수의 결과가 플로우의 유일한 값이 된다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 suspend fun main() { val function = suspend { // this is suspending lambda expression delay(1000) \u0026#34;UserName\u0026#34; } function.asFlow() .collect { println(it) } } // (1 sec) // UserName suspend fun getUserName(): String { delay(1000) return \u0026#34;UserName\u0026#34; } suspend fun main() { ::getUserName .asFlow() .collect { println(it) } } // (1 sec) // UserName 플로우 빌더 플로우를 만들 때 가장 많이 사용되는 방법인 flow 빌더는 시퀀스를 만드는 sequence 빌더나 채널을 만드는 produce 빌더와 비슷하게 작동한다. 빌더는 flow 함수를 호출하고, 람다식 내부에서 emit 함수를 사용해 다음 값을 방출한다. Channel이나 Flow에서 모든 값을 방출하려면 emitAll 를 사용할 수 있다. emitAll(flow) 는 flow.collect { emit(it) }과 같다. 1 2 3 4 5 6 7 8 9 fun allUsersFlow( api: UserApi ): Flow\u0026lt;User\u0026gt; = flow { var page = 0 do { val users = api.takePage(page++) // suspending emitAll(users) } while (!users.isNullOrEmpty()) } 플로우 빌더 이해하기 1 2 3 4 5 public fun \u0026lt;T\u0026gt; flowOf(vararg elements: T): Flow\u0026lt;T\u0026gt; = flow { for (element in elements) { emit(element) } } flow 빌더는 간단하다. collect 메서드 내부에서 block 함수(action)를 호출하는 Flow 인터페이스를 구현한다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 fun \u0026lt;T\u0026gt; flow( block: suspend FlowCollector\u0026lt;T\u0026gt;.() -\u0026gt; Unit ): Flow\u0026lt;T\u0026gt; = object : Flow\u0026lt;T\u0026gt;() { override suspend fun collect(collector: FlowCollector\u0026lt;T\u0026gt;) { collector.block() } } interface Flow\u0026lt;out T\u0026gt; { suspend fun collect(collector: FlowCollector\u0026lt;T\u0026gt;) } fun interface FlowCollector\u0026lt;in T\u0026gt; { suspend fun emit(value: T) } fun main() = runBlocking { // 예제 flow { // 1 this.emit(\u0026#34;A\u0026#34;) // this는 FlowCollector 이다, this 생략 가능 emit(\u0026#34;B\u0026#34;) }.collect { value -\u0026gt; println(value) // 2 } } // A // B flow 빌더를 호출하면 단지 객체를 만들 뿐이다. 반면 collect를 호출하면 collector 인터페이스의 block 함수를 호출하게 된다. (예제의 1에 정의된 람다식) 리시버는 2에서 정의된 람다식인 collect 이다. FlowCollector 와 같이 fun interface 으로 정의하면, 람다식의 본체는 함수형 인터페이스의 함수 본체로 사용된다. (여기서는 emit) 그러므로 emit 함수의 본체는 println(value) 가 된다. 따라서, collect를 호출하면 1에서 정의된 람다식을 실행하기 시작하고, emit을 호출 했을 때 정의된 람다식( println(\u0026quot;A\u0026quot;) )을 호출한다. Reference https://kotlinlang.org/docs/coroutines-guide.html 코틀린 코루틴 Kotlin Coroutines: Deep Dive (Marcin Moskała, 인사이트) ","permalink":"https://2taezeat.github.io/posts/%EC%BD%94%EB%A3%A8%ED%8B%B4-%EC%BD%94%EB%A3%A8%ED%8B%B4/%EC%BD%94%ED%8B%80%EB%A6%B0-%EC%BD%94%EB%A3%A8%ED%8B%B4-ch21.-flow-%EB%A7%8C%EB%93%A4%EA%B8%B0/","summary":"플로우 만들기 원시값을 가지는 플로우 플로우를 만드는 가장 간단한 방법은 플로우가 어떤 값을 가져야 하는지 정의하는 flowOf 함수를 사용하는 것이다. 리스트의 listOf 함수와 비슷하다. 값이 없는 플로우는 emptyFlow() 함수를 사용한다. 컨버터 asFlow 함수를 사용해서 Iterable, Iterator, Sequence를 Flow로 바꿀 수 있다. asFlow 함수는 즉시 사용 가능한 원소들의 플로우를 만든다. 플로우 처리 함수를 사용해 처리 가능한 원소들의 플로우를 시작할때 유용하다. 1 2 3 4 5 6 7 suspend fun main() { listOf(1, 2, 3, 4, 5) // or setOf(1, 2, 3, 4, 5) // or sequenceOf(1, 2, 3, 4, 5) .","title":"[코루틴 코루틴] ch21. Flow 만들기"},{"content":"플로우의 실제 구현 기본적으로 플로우는 어떤 연산을 실행할지 정의한 것 중단 가능한 람다식에 몇 가지 요소를 추가하였다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 interface MyFlow { suspend fun myCollect(collector: MyFlowCollector) } fun myFlowBuilder(actionBlock: suspend MyFlowCollector.() -\u0026gt; Unit) = object : MyFlow { override suspend fun myCollect(collector: MyFlowCollector) { collector.actionBlock() } } fun interface MyFlowCollector { // SAM 사용 suspend fun myEmit(value: String) } suspend fun main() { // SAM 사용 val f: MyFlow = myFlowBuilder { this.myEmit(\u0026#34;A\u0026#34;) // this = myFlowCollector, 생략 가능 myEmit(\u0026#34;B\u0026#34;) } f.myCollect { println(it) } } /////////////////////////////////////////////////////// interface MyFlowCollector { // SAM 미 사용 suspend fun myEmit(value: String) } suspend fun main() { // SAM 미 사용 val f: MyFlow = myFlowBuilder { this.myEmit(\u0026#34;A\u0026#34;) // this = myFlowCollector, 생략 가능 myEmit(\u0026#34;B\u0026#34;) } f.myCollect(object : MyFlowCollector { override suspend fun myEmit(value: String) { println(value) } }) } collect를 호출하면, flow 빌더를 호출 할 때 넣은 람다식이 실행된다.\n빌더의 람다식이 emit을 호출하면, collect가 호출되었을 때 명시된 람다식이 호출된다.\nFlow 처리 방식 플로우의 각 원소를 변환하는 map 함수 map 함수는 새로운 플로우를 만들기 때문에, flow 빌더를 사용한다. 플로우가 시작되면, 래핑하고 있는 플로우를 시작하게 되므로, 빌더 내부에서 collect 메소드를 호출한다. 원소를 받을 때마다, map은 원소를 변환하고 새로운 플로우로 방출한다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 fun \u0026lt;T, R\u0026gt; Flow\u0026lt;T\u0026gt;.map( transformation: suspend (T) -\u0026gt; R ): Flow\u0026lt;R\u0026gt; = flow { collect { emit(transformation(it)) } } suspend fun main() { flowOf(\u0026#34;A\u0026#34;, \u0026#34;B\u0026#34;, \u0026#34;C\u0026#34;).map { delay(1000) it.lowercase() }.collect { println(it) } } // (1 sec) // a // (1 sec) // b // (1 sec) // c 동기로 작동하는 Flow 플로우 또한 중단 함수 처럼 동기로 작동한다. 플로우가 완료될 때까지 collect 호출이 중단(suspend) 된다. 즉, 플로우는 새로운 코루틴을 시작하지 않는다. 중단 함수가 코루틴을 시작할 수 있는 것처럼, 플로우의 각 단계에서도 코루틴을 시작할 수 있지만 중단 함수의 기본 동작은 아니다. 플로우의 각각의 처리 단계는 동기로 실행되기 때문에, onEach 내부에 delay가 있으면 모든 원소가 처리되기 전이 아닌 원소 사이에 지연이 생긴다. 1 2 3 suspend fun main() { flowOf(\u0026#34;A\u0026#34;, \u0026#34;B\u0026#34;, \u0026#34;C\u0026#34;).onEach { delay(1000) }.collect { println(it) } } // (1 sec) // A // (1 sec) // B // (1 sec) // C 플로우와 공유 상태 커스텀한 플로우 처리 함수를 구현할 때, 플로우의 각 단계가 동기로 작동하기 때문에 동기화 없이도 플로우 내부에 변경 가능한 상태를 정의할 수 있다.\n플로우 단계 외부의 변수를 추출해서, 함수에서 사용하는 것이 흔히 저지르는 실수 중 하나이다.\n외부 변수는 같은 플로우가 모으는, 모든 코루틴이 공유하게 된다. 이런 경우 동기화가 필수이며, 플로우 컬렉션이 아니라 플로우에 종속되게 된다. 따라서 두 개의 코루틴이 병렬로 원소를 세게 된다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 fun Flow\u0026lt;*\u0026gt;.counter() = flow\u0026lt;Int\u0026gt; { var counter = 0 collect { counter++ // to make it busy for a while List(100) { Random.nextLong() }.shuffled().sorted() emit(counter) } } suspend fun main(): Unit = coroutineScope { val f1 = List(1000) { \u0026#34;$it\u0026#34; }.asFlow() val f2 = List(1000) { \u0026#34;$it\u0026#34; }.asFlow().counter() launch { println(f1.counter().last()) } // 1000 launch { println(f1.counter().last()) } // 1000 launch { println(f2.last()) } // 1000 launch { println(f2.last()) } // 1000 } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 fun Flow\u0026lt;*\u0026gt;.counter(): Flow\u0026lt;Int\u0026gt; { var counter = 0 return this.map { counter++ List(100) { Random.nextLong() }.shuffled().sorted() counter } } suspend fun main(): Unit = coroutineScope { val f1 = List(1000) { \u0026#34;$it\u0026#34; }.asFlow() val f2 = List(1000) { \u0026#34;$it\u0026#34; }.asFlow().counter() launch { println(f1.counter().last()) } // 1000 launch { println(f1.counter().last()) } // 1000 launch { println(f2.last()) } // less than 2000 launch { println(f2.last()) } // less than 2000 // 콘솔 결과 창에서, 4개 print 결과 중 2개는 1000, 나머지는 2개는 2000보다 작다. } 같은 변수를 사용하는 중단 함수들에서 동기화가 필요한 것처럼,\n플로우에서 사용하는 변수가 함수 외부, 클래스의 스코프, 최상위 레벨에서 정의되어 있으면 동기화가 필요하다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 var counter = 0 // 최상위 레벨 변수 fun Flow\u0026lt;*\u0026gt;.counter(): Flow\u0026lt;Int\u0026gt; = this.map { counter++ List(100) { Random.nextLong() }.shuffled().sorted() counter } suspend fun main(): Unit = coroutineScope { val f1 = List(1000) { \u0026#34;$it\u0026#34; }.asFlow() val f2 = List(1000) { \u0026#34;$it\u0026#34; }.asFlow().counter() launch { println(f1.counter().last()) } // 3496, less than 4000 launch { println(f1.counter().last()) } // 3735 launch { println(f2.last()) } // 3870 launch { println(f2.last()) } // 3933 } Reference https://kotlinlang.org/docs/coroutines-guide.html 코틀린 코루틴 Kotlin Coroutines: Deep Dive (Marcin Moskała, 인사이트) ","permalink":"https://2taezeat.github.io/posts/%EC%BD%94%EB%A3%A8%ED%8B%B4-%EC%BD%94%EB%A3%A8%ED%8B%B4/%EC%BD%94%ED%8B%80%EB%A6%B0-%EC%BD%94%EB%A3%A8%ED%8B%B4-ch20.-flow%EC%9D%98-%EC%8B%A4%EC%A0%9C-%EA%B5%AC%ED%98%84/","summary":"플로우의 실제 구현 기본적으로 플로우는 어떤 연산을 실행할지 정의한 것 중단 가능한 람다식에 몇 가지 요소를 추가하였다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 interface MyFlow { suspend fun myCollect(collector: MyFlowCollector) } fun myFlowBuilder(actionBlock: suspend MyFlowCollector.() -\u0026gt; Unit) = object : MyFlow { override suspend fun myCollect(collector: MyFlowCollector) { collector.","title":"[코루틴 코루틴] ch20. Flow의 실제 구현"},{"content":"플로우란 무엇인가? 플로우(flow)는 비동기적으로 계산해야 할 값의 스트림을 나타낸다. 플로우는 시퀀스와 달리 코루틴을 지원하며, 비동기적으로 계산되는 값을 나타낸다. Flow 인터페이스 자체는 떠다니는 원소들을 모으는 역할을 하며, 플로우의 끝에 도달할 때까지 각 값을 처리하는 것 의미한다. Flow의 collect 는 컬렉션의 forEach와 비슷하다. Flow의 유일한 멤버 함수는 collect(최종 연산) 이다. 다른 함수는 확장 함수로 정의되어 있다. 1 2 3 interface Flow\u0026lt;out T\u0026gt; { suspend fun collect(collector: FlowCollector\u0026lt;T\u0026gt;) } 시퀀스(Sequence)의 최종 연산은 중단 함수가 아니기 때문에, 시퀀스 빌더 내부에 중단점이 있다면 값을 기다리는 스레드가 블로킹 된다. 따라서 sequencee 빌더의 스코프에서는 yield, yieldAll 외에 다른 중단 함수를 사용할 수 없다. Sequence의 iterator가 중단 함수가 아니기 때문에, 시퀀스의 원소를 소비할 때 블로킹이 되는 것이 문제가 된다. 1 2 3 4 5 6 7 8 9 10 11 // Don\u0026#39;t do that, we should use Flow instead of Sequence fun allUsersSequence( api: UserApi ): Sequence\u0026lt;User\u0026gt; = sequence { var page = 0 do { val users = api.takePage(page++) //suspend 함수 임으로, so compilation error yieldAll(users) } while (!users.isNullOrEmpty()) } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 // 하나의 코루틴이 다른 코루틴을 블로킹하게 된다. // 같은 스레드에서 launch로 시작된 코루틴이 대기 하게 된다. fun getSequence(): Sequence\u0026lt;String\u0026gt; = sequence { repeat(3) { Thread.sleep(1000) // the same result as if there were delay(1000) here yield(\u0026#34;User$it\u0026#34;) } } suspend fun main() { withContext(newSingleThreadContext(\u0026#34;main\u0026#34;)) { launch { repeat(3) { delay(100) println(\u0026#34;Processing on coroutine\u0026#34;) } } val list = getSequence() list.forEach { println(it) } } } // (1 sec) // User0 // (1 sec) // User1 // (1 sec) // User2 // Processing on coroutine // (0.1 sec) // Processing on coroutine // (0.1 sec) // Processing on coroutine Sequence를 사용했기 때문에 forEach가 블로킹 연산이 된다.\n따라서 같은 스레드에서 launch로 시작된 코루틴이 대기하게 되며, 하나의 코루틴이 다른 코루틴을 블로킹하게 된다. 이런 상황에서 Sequence 대신 Flow를 사용해야 한다.\n플로우를 사용하면 코루틴이 연산을 수행하는 데 필요한 기능을 전부 사용할 수 있다.\n플로우의 빌더와 연산은 중단 함수(suspend) 이며, 구조화된 동시성과 적절한 예외 처리를 지원한다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 fun getFlow(): Flow\u0026lt;String\u0026gt; = flow { repeat(3) { delay(1000) emit(\u0026#34;User$it\u0026#34;) } } suspend fun main() { withContext(newSingleThreadContext(\u0026#34;main\u0026#34;)) { launch { repeat(3) { delay(100) println(\u0026#34;Processing on coroutine\u0026#34;) } } val list = getFlow() list.collect { println(it) } } } // (0.1 sec) // Processing on coroutine // (0.1 sec) // Processing on coroutine // (0.1 sec) // Processing on coroutine // (1 - 3 * 0.1 = 0.7 sec) // User0 // (1 sec) // User1 // (1 sec) // User2 플로우의 특징 collect(중단 함수)와 같은 플로우의 최종 연산은 스레드를 블로킹하는 대신 코루틴을 중단시킨다. 플로우는 Coroutine Context 를 활용하고, 예외를 처리하는 등의 코루틴 기능도 제공한다. 플로우 처리는 취소(cancel) 가능하며, 구조화된 동시성을 갖추고 있다. flow 빌더는 중단 함수가 아니며, 어떠한 스코프도 필요하지 않다. 플로우의 최종 연산은 중단 가능하며, 연산이 실행될 때, 부모 코루틴과의 관계가 정립된다. (coroutineScope 함수와 비슷) launch 를 취소하면, 플로우 처리도 적절하게 취소된다. 플로우 명명법 플로우는 어딘가에서 시작 되어야 한다. (플로우 빌더, 다른 객체에서의 변환 또는 헬퍼 함수로 시작된다.)\n플로우의 마지막 연산은 최종 연산이라고 불리며, 중단 가능하거나 스코프를 필요로 하는 유일한 연산이다.\n최종 연산은 주로 람다 표현식을 가지거나 가지지 않는 collect 가 된다. 시작 연산과 최종 연산 사이에 플로우를 변경하는 중간 연산(intermediate operation)을 가질 수 있다.\n플로우 사용 예시 주로 이벤트를 감지해야 할 필요가 있을 때, 사용 서버가 보낸 이벤트를 통해 전달된 메시지를 받는 경우 텍스트 입력 또는 클릭과 같은 사용자 액션이 감지된 경우 센서 또는 위치나 지도와 같은 기기의 정보 변경을 받는 경우 데이터베이스의 변경을 감지하는 경우 플로우는 이 밖의 경우에도 동시성 처리 를 위해 유용하게 사용 될 수 있다.\n1 2 3 4 5 6 7 8 9 suspend fun getOffers( sellers: List\u0026lt;Seller\u0026gt; ): List\u0026lt;Offer\u0026gt; = coroutineScope { sellers .map { seller -\u0026gt; async { api.requestOffers(seller.id) } } .flatMap { it.await() } } 컬렉션 처리 내부에서 async를 사용하면 동시 처리를 할 수 있지만,\n많은 요청을 한번에 보내면 client 뿐 아니라 server 모두에게 좋지 않다.\n1 2 3 4 5 6 7 8 suspend fun getOffers( sellers: List\u0026lt;Seller\u0026gt; ): List\u0026lt;Offer\u0026gt; = sellers .asFlow() .flatMapMerge(concurrency = 20) { seller -\u0026gt; suspend { api.requestOffers(seller.id) }.asFlow() } .toList() 컬렉션 대신 플로우로 처리하면 동시 처리, 컨텍스트, 예외를 조절할 수 있다.\nReference https://kotlinlang.org/docs/coroutines-guide.html 코틀린 코루틴 Kotlin Coroutines: Deep Dive (Marcin Moskała, 인사이트) ","permalink":"https://2taezeat.github.io/posts/%EC%BD%94%EB%A3%A8%ED%8B%B4-%EC%BD%94%EB%A3%A8%ED%8B%B4/%EC%BD%94%ED%8B%80%EB%A6%B0-%EC%BD%94%EB%A3%A8%ED%8B%B4-ch19.-flow%EB%9E%80-%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80/","summary":"플로우란 무엇인가? 플로우(flow)는 비동기적으로 계산해야 할 값의 스트림을 나타낸다. 플로우는 시퀀스와 달리 코루틴을 지원하며, 비동기적으로 계산되는 값을 나타낸다. Flow 인터페이스 자체는 떠다니는 원소들을 모으는 역할을 하며, 플로우의 끝에 도달할 때까지 각 값을 처리하는 것 의미한다. Flow의 collect 는 컬렉션의 forEach와 비슷하다. Flow의 유일한 멤버 함수는 collect(최종 연산) 이다. 다른 함수는 확장 함수로 정의되어 있다. 1 2 3 interface Flow\u0026lt;out T\u0026gt; { suspend fun collect(collector: FlowCollector\u0026lt;T\u0026gt;) } 시퀀스(Sequence)의 최종 연산은 중단 함수가 아니기 때문에, 시퀀스 빌더 내부에 중단점이 있다면 값을 기다리는 스레드가 블로킹 된다.","title":"[코루틴 코루틴] ch19. Flow란 무엇인가?"},{"content":"Hot stream, Cold stream Hot : 컬렉션(List, Set) / Channel\nCold : Flow, Sequence, RxJava 스트림\nHot data stream 은 열정적(eager)이라 데이터를 소비하는 것과 무관하게 원소를 생성\nHot data stream의 빌더와 연산은 즉각 실행된다.\n항상 사용 가능한 상태\n각 연산이 최종 연산이 될 수 있다.\n여러 번 사용됬을 때 매번 결과를 다시 계산할 필요가 없다.\n가능한 빨리 원소를 만들고 저장하며, 원소가 소비되는 것과 무관하게 생성한다.\nCold data stream 은 게을러서(lazy) 요청이 있을 때만 작업을 수행하며, 아무것도 저장하지 않습니다.\n원소가 필요할 때 까지 연산이 실행되지 않는다. 무한할 수 있다. 원소를 어떻게 계산할지 정의할 것에 불과 최소한의 연산만 수행 중간에 생성되는 값을 저장하지 않기 때문에, 메모리를 적게 사용 최종 연산이 모든 작업을 실행 최종 연산에서 값이 필요할 때가 되어서야 처리한다. 중간 연산 이전에 만든 시퀀스에 새로운 연산을 첨가할 뿐 중간 과정의 모든 함수는 무엇을 해야 할지만 정의한 것. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 fun m(i: Int): Int { print(\u0026#34;m$i \u0026#34;) return i * i } fun f(i: Int): Boolean { print(\u0026#34;f$i \u0026#34;) return i \u0026gt;= 10 } fun main() { listOf(1, 2, 3, 4, 5, 6, 7, 8, 9, 10) .map { m(it) } .find { f(it) } .let { print(it) } // m1 m2 m3 m4 m5 m6 m7 m8 m9 m10 f1 f4 f9 f16 16 sequenceOf(1, 2, 3, 4, 5, 6, 7, 8, 9, 10) .map { m(it) } .find { f(it) } .let { print(it) } // m1 f1 m2 f4 m3 f9 m4 f16 16 } Hot Channel, Cold Flow Channel은 Hot 이라 값을 곧바로 계산, 소비되는 것과 상관없이 값을 생성한 뒤에 가지게 된다.\n수신자가 얼마나 많은지에 대해선 신경쓰지 않는다. 각 원소는 단 한번만 받을 수 있기 때문에, 첫 번째 수신자가 모든 원소를 소비하고 나면 두 번째 소비자는 채널이 비어 있으며, 어떤 원소도 받을 수 없다. Flow는 Cold data source 이기 때문에 값이 필요할 때만 생성, flow 빌더 자체는 어떤 연산을 하지 않는다.\nflow 는 단지 최종 연산 (collect와 같은) 이 호출될 때 원소가 어떻게 생성되어야 하는지 정의한 것에 불과 따라서, flow 빌더는 CoroutineScope 가 필요하지 않는다. flow 빌더는 빌더를 호출한 최종 연산의 스코프에서 실행된다. 플로우의 각 최종 연산은 처음부터 데이터를 처리하기 시작한다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 private fun CoroutineScope.makeChannel() = produce { println(\u0026#34;Channel started\u0026#34;) for (i in 1..3) { delay(1000) send(i) } } suspend fun main() = coroutineScope { val channel = makeChannel() delay(1000) println(\u0026#34;Calling channel...\u0026#34;) for (value in channel) { println(value) } println(\u0026#34;Consuming again...\u0026#34;) for (value in channel) { println(value) } } // Channel started // (1 sec) // Calling channel... // 1 // (1 sec) // 2 // (1 sec) // 3 // Consuming again... 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 private fun makeFlow() = flow { println(\u0026#34;Flow started\u0026#34;) for (i in 1..3) { delay(1000) emit(i) } } suspend fun main() = coroutineScope { val flow = makeFlow() delay(1000) println(\u0026#34;Calling flow...\u0026#34;) flow.collect { value -\u0026gt; println(value) } println(\u0026#34;Consuming again...\u0026#34;) flow.collect { value -\u0026gt; println(value) } } // (1 sec) // Calling flow... // Flow started // (1 sec) // 1 // (1 sec) // 2 // (1 sec) // 3 // Consuming again... // Flow started // (1 sec) // 1 // (1 sec) // 2 // (1 sec) // 3 Reference https://kotlinlang.org/docs/coroutines-guide.html 코틀린 코루틴 Kotlin Coroutines: Deep Dive (Marcin Moskała, 인사이트) ","permalink":"https://2taezeat.github.io/posts/%EC%BD%94%EB%A3%A8%ED%8B%B4-%EC%BD%94%EB%A3%A8%ED%8B%B4/%EC%BD%94%ED%8B%80%EB%A6%B0-%EC%BD%94%EB%A3%A8%ED%8B%B4-ch18.-hot-vs-cold/","summary":"Hot stream, Cold stream Hot : 컬렉션(List, Set) / Channel\nCold : Flow, Sequence, RxJava 스트림\nHot data stream 은 열정적(eager)이라 데이터를 소비하는 것과 무관하게 원소를 생성\nHot data stream의 빌더와 연산은 즉각 실행된다.\n항상 사용 가능한 상태\n각 연산이 최종 연산이 될 수 있다.\n여러 번 사용됬을 때 매번 결과를 다시 계산할 필요가 없다.\n가능한 빨리 원소를 만들고 저장하며, 원소가 소비되는 것과 무관하게 생성한다.\nCold data stream 은 게을러서(lazy) 요청이 있을 때만 작업을 수행하며, 아무것도 저장하지 않습니다.","title":"[코루틴 코루틴] ch18. Hot vs Cold 데이터 소스"},{"content":"5. 코루틴: 언어 차원에서의 지원 vs 라이브러리 코루틴은 코틀린 언어 자체적을 지원하는 부분(컴파일러의 지원과 코틀린 기본 라이브러리의 요소)\n언어 차원은 자유도를 보장하기 위해 코루틴을 최소한으로 지원\n직접 다루기 어려움\n애플리케이션 개발자들보다는 라이브러리 개발자에게 적합\n코틀린 코루틴 라이브러리 (kotlinx.coroutines) 로 구성되어 있다.\n별도의 의존성을 추가해야 한다 이 라이브러리는 언어 차원에서 코루틴을 지원하기 위해 만들어짐. 사용하기 휠씬 쉬우며, 동시성을 명확하게 구현할 수 있게 해준다. 둘은 같은 것으로 취급 되곤 하지만, 실상은 다르다\nReference https://kotlinlang.org/docs/coroutines-guide.html 코틀린 코루틴 Kotlin Coroutines: Deep Dive (Marcin Moskała, 인사이트) ","permalink":"https://2taezeat.github.io/posts/%EC%BD%94%EB%A3%A8%ED%8B%B4-%EC%BD%94%EB%A3%A8%ED%8B%B4/%EC%BD%94%ED%8B%80%EB%A6%B0-%EC%BD%94%EB%A3%A8%ED%8B%B4-ch05.-%EC%BD%94%EB%A3%A8%ED%8B%B4---%EC%96%B8%EC%96%B4-%EC%B0%A8%EC%9B%90%EC%97%90%EC%84%9C%EC%9D%98-%EC%A7%80%EC%9B%90-vs-%EB%9D%BC%EC%9D%B4%EB%B8%8C%EB%9F%AC%EB%A6%AC/","summary":"5. 코루틴: 언어 차원에서의 지원 vs 라이브러리 코루틴은 코틀린 언어 자체적을 지원하는 부분(컴파일러의 지원과 코틀린 기본 라이브러리의 요소)\n언어 차원은 자유도를 보장하기 위해 코루틴을 최소한으로 지원\n직접 다루기 어려움\n애플리케이션 개발자들보다는 라이브러리 개발자에게 적합\n코틀린 코루틴 라이브러리 (kotlinx.coroutines) 로 구성되어 있다.\n별도의 의존성을 추가해야 한다 이 라이브러리는 언어 차원에서 코루틴을 지원하기 위해 만들어짐. 사용하기 휠씬 쉬우며, 동시성을 명확하게 구현할 수 있게 해준다. 둘은 같은 것으로 취급 되곤 하지만, 실상은 다르다","title":"[코루틴 코루틴] ch05. 코루틴 - 언어 차원에서의 지원 vs 라이브러리"},{"content":"4. 코루틴의 실제 구현 코틀린 중단 함수는 continuation-passing style(CPS) 로 구현되어 있다.\n여러 중단 함수 구현 방식 중 CPS를 선택하였다. Continuation 객체는 상태를 나타내는 숫자와 로컬 데이터를 가지고 있다.\nContinuation 은 함수 인자로 전달된다.\n중단 함수는 상태(state) 를 가지는 state machine 으로 볼 수 있다.\n중단 함수의 Continuation 객체가 이 함수를 부르는 다른 함수의 Continuation 객체를 decorate(장식) 한다.\n모든 Continuation 객체는 resume 하거나 함수가 완료 될때 사용되는 콜 스택으로 사용된다.\n1 2 3 4 5 6 7 8 suspend fun getUser(): User? suspend fun setUser(user: User) suspend fun checkAvailability(flight: Flight): Boolean // 내부 fun getUser(continuation: Continuation\u0026lt;*\u0026gt;): Any? fun setUser(user: User, continuation: Continuation\u0026lt;*\u0026gt;): Any fun checkAvailability(flight: Flight, continuation: Continuation\u0026lt;*\u0026gt;): Any 아주 간단한 중단 함수 알아보기 함수가 시작되는 지점은 함수의 시작점과 중단 이후 재개 시점(컨티뉴에이션이 resume을 호출할 때) 두 곳이다. 현재 상태를 저장에는 label 이라는 field 를 사용한다. (처음에는 0으로 설정) 이후에는 중단되기 전에 다음 상태로 설정되어 재개 될 시점을 알 수 있게 해준다. delay에 의해 중단된 경우 COROUTINE_SUSPENDED 를 반환 myFunction 을 호출한 함수부터 시작해 콜 스택에 있는 모든 함수도 똑 같다. 따라서, 중단이 일어나면 콜 스택에 있는 모든 함수가 종료된다 중단된 코루틴을 실행하던 스레드를 (다른 종류의 코루틴을 포함해) 실행 가능한 코드가 사용할 수 있게 된다. 1 2 3 4 5 6 7 8 suspend fun myFunction() { println(\u0026#34;Before\u0026#34;) var counter = 0 delay(1000) // suspending counter++ println(\u0026#34;Counter: $counter\u0026#34;) println(\u0026#34;After\u0026#34;) } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 // 중단 함수를의 바이트 코드를 자바로 디컴파일한 코드를 코틀린으로 표현한 코드 fun myFunction(continuation: Continuation\u0026lt;Unit\u0026gt;): Any { val continuation = continuation as? MyFunctionContinuation ?: MyFunctionContinuation(continuation) var counter = continuation.counter if (continuation.label == 0) { println(\u0026#34;Before\u0026#34;) counter = 0 continuation.counter = counter continuation.label = 1 if (delay(1000, continuation) == COROUTINE_SUSPENDED) { return COROUTINE_SUSPENDED } } if (continuation.label == 1) { counter = (counter as Int) + 1 println(\u0026#34;Counter: $counter\u0026#34;) println(\u0026#34;After\u0026#34;) return Unit } error(\u0026#34;Impossible\u0026#34;) } class MyFunctionContinuation( // 컨트뉴에이션 객체 val completion: Continuation\u0026lt;Unit\u0026gt; ) : Continuation\u0026lt;Unit\u0026gt; { override val context: CoroutineContext get() = completion.context var result: Result\u0026lt;Unit\u0026gt;? = null var label = 0 var counter = 0 override fun resumeWith(result: Result\u0026lt;Unit\u0026gt;) { this.result = result val res = try { val r = myFunction(this) if (r == COROUTINE_SUSPENDED) return Result.success(r as Unit) } catch (e: Throwable) { Result.failure(e) } completion.resumeWith(res) } } 상태를 가진 함수 함수가 중단된 후에 다시 사용할 지역 변수나 파라미터와 같은 상태를 가지고 있다면, 함수의 컨티뉴에이션 객체에 상태를 저장해야 한다. 함수 내에서 사용되던 값들은 중단되기 직전에 저장되고, 이후 함수가 재개될 때 복구된다. 값을 받아 재개되는 함수 중단 함수로 부터 값을 받아야 하는 경우 좀 더 복잡해짐 token은 상태 0과 1에서 사용 userId는 상태 1과 2에서 사욛 Result 타입인 result는 함수가 어떻게 재개되었는지 나타냄 함수가 값으로 재개 되면 결과는 Result.Success(result) 함수가 예외로 재개 되면 결과는 Result.Failure(exception) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 suspend fun printUser(token: String) { println(\u0026#34;Before\u0026#34;) val userId = getUserId(token) // 중단 함수 println(\u0026#34;Got userId: $userId\u0026#34;) val userName = getUserName(userId, token) // 중단 함수 println(User(userId, userName)) println(\u0026#34;After\u0026#34;) } fun printUser( token: String, continuation: Continuation\u0026lt;*\u0026gt; ): Any { val continuation = continuation as? PrintUserContinuation ?: PrintUserContinuation( continuation as Continuation\u0026lt;Unit\u0026gt;, token ) var result: Result\u0026lt;Any\u0026gt;? = continuation.result var userId: String? = continuation.userId val userName: String if (continuation.label == 0) { println(\u0026#34;Before\u0026#34;) continuation.label = 1 val res = getUserId(token, continuation) if (res == COROUTINE_SUSPENDED) { return COROUTINE_SUSPENDED } result = Result.success(res) } if (continuation.label == 1) { userId = result!!.getOrThrow() as String println(\u0026#34;Got userId: $userId\u0026#34;) continuation.label = 2\t// 다음 label을 설정 continuation.userId = userId\t// 컨티뉴에이션 객체에 상태를 저장 val res = getUserName(userId, continuation) // 중단 함수를 호출 if (res == COROUTINE_SUSPENDED) {\t// 중단 상태일 때 return COROUTINE_SUSPENDED } result = Result.success(res)\t// 중단되지 않았으면 결괏값을 설정 } if (continuation.label == 2) {\tresult!!.throwOnFailure()\t// 실패할 경우 에외를 던짐 userName = result.getOrNull as String\t// 결괏값을 읽음 println(User(userId as String, userName)) println(\u0026#34;After\u0026#34;) return Unit } error(\u0026#34;Impossible\u0026#34;) } class PrintUserContinuation( val completion: Continuation\u0026lt;Unit\u0026gt;, val token: String ) : Continuation\u0026lt;String\u0026gt; { override val context: CoroutineContext get() = completion.context var label = 0 var result: Result\u0026lt;Any\u0026gt;? = null var userId: String? = null override fun resumeWith(result: Result\u0026lt;String\u0026gt;) { this.result = result val res = try { val r = printUser(token, this) if (r == COROUTINE_SUSPENDED) return Result.success(r as Unit) } catch (e: Throwable) { Result.failure(e) } completion.resumeWith(res) } } 콜 스택 함수 a가 함수 b를 호출하면 가상 머신은 a의 상태와 b가 끝나면 실행이 될 지점을 콜 스택(call stack)이라는 자료 구조 에 저장한다.\n코루틴을 중단하면 스레드를 반환해 콜 스택에 있는 정보가 사라질 것이다.\n따라서 코루틴을 재개 할 때, 콜 스택을 사용할 수 없다. 대신 Continuation 객체가 콜 스택의 역할을 대신한다. Continuation 객체는 중단 되었을때 상태(label)와 함수의 지역 변수와 파라미터(필드), 중단 함수를 호출한 함수가 재개될 위치 정보를 가지고 있다.\n하나의 Continuation 객체는 다른 하나를 참조하는 식으로 동작한다. Continuation 객체가 재개 될 때, 각 Continuation 객체는 자신이 담당하는 함수를 호출하고, 그 함수의 실행이 끝나면, 자신을 호출한 함수의 Continuation 객체을 재개 합니다. complete.resumeWith(res) 이 과정은 스택의 끝에 다다를 때까지 반복된다. 중단된 함수가 재개했을 때 Continuation 객체로 부터 상태를 복원하고, 얻은 결과를 사용하거나 예외를 던진다.\n컨티뉴에이션 객체에 상태가 저장된며, 중단을 처리하기 위한 과정이 있어야 한다.\n중단된 함수가 재개했을 때 컨티뉴에이션 객체로부터 상태를 복원하고, 얻은 결과를 사용하거나 예외를 던져야 한다.\n예외를 던질 때도 비슷하다, 처리되지 못한 예외가 resumeWith 에서 잡히면 Result.failure(e)로 래핑되며, 예외를 던진 함수를 호출한 함수는 포장된 결과를 받는다.\n함수 c에서 중단된 상황을 예로 들면\n실행이 재개되면 c의 컨티뉴에이션 객체는 c 함수를 먼저 재개\n함수가 완료되면 c 컨티뉴에이션 객체는 b 함수를 호출하는 b 컨티뉴에이션 객체를 재개\nb 함수가 완료되면 b 컨티뉴에이션은 a 컨티뉴에이션을 재개하고 a 함수가 호출된다.\n중단 함수의 성능 함수를 상태로 나누는 것은 숫자를 비교하는 것만큼 쉬운 일이며 실행점이 변하는 비용 또한 거의 들지 않음 컨티뉴에이션 객체에 상태를 저장하는 것 또한 간단하다 지역 변수를 복사하지 않고 새로운 변수가 메모리 내 특정 값을 가리키게 한다. Reference https://kotlinlang.org/docs/coroutines-guide.html 코틀린 코루틴 Kotlin Coroutines: Deep Dive (Marcin Moskała, 인사이트) ","permalink":"https://2taezeat.github.io/posts/%EC%BD%94%EB%A3%A8%ED%8B%B4-%EC%BD%94%EB%A3%A8%ED%8B%B4/%EC%BD%94%ED%8B%80%EB%A6%B0-%EC%BD%94%EB%A3%A8%ED%8B%B4-ch04.-%EC%BD%94%EB%A3%A8%ED%8B%B4%EC%9D%98-%EC%8B%A4%EC%A0%9C-%EA%B5%AC%ED%98%84/","summary":"4. 코루틴의 실제 구현 코틀린 중단 함수는 continuation-passing style(CPS) 로 구현되어 있다.\n여러 중단 함수 구현 방식 중 CPS를 선택하였다. Continuation 객체는 상태를 나타내는 숫자와 로컬 데이터를 가지고 있다.\nContinuation 은 함수 인자로 전달된다.\n중단 함수는 상태(state) 를 가지는 state machine 으로 볼 수 있다.\n중단 함수의 Continuation 객체가 이 함수를 부르는 다른 함수의 Continuation 객체를 decorate(장식) 한다.\n모든 Continuation 객체는 resume 하거나 함수가 완료 될때 사용되는 콜 스택으로 사용된다.","title":"[코루틴 코루틴] ch04. 코루틴의 실제 구현"},{"content":"Suspend (중단) 스레드는 저장이 불가능하고 멈추는 것만 가능하지만, 코루틴은 중단하고 재개가 가능하다\n코루틴은 중단 되었을때, Continuation 객체를 반환한다.\nsuspend 함수(중단 함수) 는 코루틴을 중단할 수 있는 함수이다.\nsuspend 함수는 코루틴 또는 다른 suspend 함수에서 호출 되어야한다. suspend 함수는 중단할 수 있는 중단점이 필요하다. 1 2 3 4 5 6 suspend fun main() { println(\u0026#34;Before\u0026#34;) println(\u0026#34;After\u0026#34;) } // Before // After 1 2 3 4 5 6 suspend fun main() { println(\u0026#34;Before\u0026#34;) suspendCoroutine\u0026lt;Unit\u0026gt; { } println(\u0026#34;After\u0026#34;) } // Before 1 2 3 4 5 6 7 8 9 10 //3 suspend fun main() { println(\u0026#34;Before\u0026#34;) suspendCoroutine\u0026lt;Unit\u0026gt; { continuation -\u0026gt; println(\u0026#34;Before too\u0026#34;) } // 람다 표현식이 suspend 되기 전에 실행된다. println(\u0026#34;After\u0026#34;) } // Before // Before too Resume (재개) 중단된 코루틴은 Continuation 객체를 이용해 재개 가능하다. 다른 스레드에서 코루틴을 재개할 수 있다. 코루틴이 있으면 중단함과 동시에 \u0026ldquo;데이터를 받고 나면, 받은 데이터를 resume 함수를 통해 보내줘\u0026rdquo; 라고 Continuation 에 전달 코루틴에서는 값으로 재개 한다.(Continuation의 제네릭 타입 인자) 1 2 3 4 5 6 7 8 9 suspend fun main() { println(\u0026#34;Before\u0026#34;) suspendCoroutine\u0026lt;Unit\u0026gt; { continuation -\u0026gt; continuation.resume(Unit) } println(\u0026#34;After\u0026#34;) } // Before // After 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 suspend fun main() { println(\u0026#34;Before\u0026#34;) suspendCoroutine\u0026lt;Unit\u0026gt; { continuation -\u0026gt; thread { println(\u0026#34;Suspended\u0026#34;) Thread.sleep(1000) continuation.resume(Unit) println(\u0026#34;Resumed\u0026#34;) } } println(\u0026#34;After\u0026#34;) } // Before // Suspended // (1 second delay) // After // Resumed 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 fun requestUser(callback: (User) -\u0026gt; Unit) { thread { Thread.sleep(1000) callback.invoke(User(\u0026#34;Test\u0026#34;)) } } suspend fun main() { println(\u0026#34;Before\u0026#34;) val user = suspendCoroutine\u0026lt;User\u0026gt; { cont -\u0026gt; requestUser { user -\u0026gt; cont.resume(user) } } println(user) println(\u0026#34;After\u0026#34;) } // Before // (1 second delay) // User(name=Test) // After suspend 와 resume 을 통해, 스레드는 다른 일을 할 수 있고, 값 또는 데이터가 도착하면 스레드는 코루틴이 중단된 지점에서 재개 하게 됩니다.\n이때 resume 함수와 Continuation 객체를 통해 값을 얻을 수 있습니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 private val executor = Executors.newSingleThreadScheduledExecutor { Thread(it, \u0026#34;scheduler\u0026#34;).apply { isDaemon = true } } suspend fun delay(timeMillis: Long): Unit = suspendCancellableCoroutine { cont -\u0026gt; executor.schedule({ cont.resume(Unit) }, timeMillis, TimeUnit.MILLISECONDS) } suspend fun main() { println(\u0026#34;Before\u0026#34;) delay(1000) println(\u0026#34;After\u0026#34;) } 스레드를 생성하는 것 보다, \u0026lsquo;알람 시계\u0026rsquo;를 설정하는계 더 좋다 ScheduledExecutorService, 정해진 시간이 지나면 continuation.resume(Unit)을 호출하도록 알람 설정 excutor 는 delay 함수를 사용하는 모든 코루틴의 전용 스레드 값으로 재개 하기 1 val ret: Unit = suspendCoroutine\u0026lt;Unit\u0026gt; { cont: Continuation\u0026lt;Unit\u0026gt; -\u0026gt; cont.resume(Unit) } Unit은 함수의 리턴 타입이며, Continuation의 제네릭 타입 인자이다. resume을 통해 반환되는 값은 반드시 지정된 타입과 같은 타입이여야 한다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 suspend fun main() { val i: Int = suspendCancellableCoroutine\u0026lt;Int\u0026gt; { cont -\u0026gt; cont.resume(42) } println(i) // 42 val str: String = suspendCancellableCoroutine\u0026lt;String\u0026gt; { cont -\u0026gt; cont.resume(\u0026#34;Some text\u0026#34;) } println(str) // Some text val b: Boolean = suspendCancellableCoroutine\u0026lt;Boolean\u0026gt; { cont -\u0026gt; cont.resume(true) } println(b) // true } 코루틴이 있으면 중단함과 동시에 \u0026ldquo;데이터를 받고 나면, 받은 데이터를 resume 함수를 통해 보내줘\u0026rdquo; 라고 Continuation 에 전달 그러면 스레드는 다른 일을 할 수 있다. 데이터가 도착하면 스레드는 코루틴이 중단된 지점에서 재개 한다. 예외로 재개하기 서비스가 종료되거나 에러로 응답이 오는 경우, 코루틴이 중단된 곳에서 예외를 발생시키고, 이 예외로 재개하는 방법\n1 2 3 4 5 6 7 8 9 suspend fun main() { try { suspendCorotine\u0026lt;Unit\u0026gt; { cont -\u0026gt; cont.resumeWithException( MyException() ) } } catch (e: MyException) { println(\u0026#34;Caught!\u0026#34;) } } 함수가 아닌 코루틴을 중단시킨다 중단 함수는 코루틴 자체가 아니다. 중단 함수는 함수가 아닌, 코루틴을 중단할 수 있는 함수 이다. 다른 스레드나 다른 코루틴으로 재개하지 않으면 프로그램은 실행된 상태로 유지된다 Continuation.kt (code 중 일부) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 /** * Interface representing a continuation after a suspension point that returns a value of type `T`. */ public interface Continuation\u0026lt;in T\u0026gt; { /** * The context of the coroutine that corresponds to this continuation. */ public val context: CoroutineContext /** * Resumes the execution of the corresponding coroutine passing a successful or failed [result] as the * return value of the last suspension point. */ public fun resumeWith(result: Result\u0026lt;T\u0026gt;) } /** * Resumes the execution of the corresponding coroutine passing [value] as the return value of the last suspension point. */ public inline fun \u0026lt;T\u0026gt; Continuation\u0026lt;T\u0026gt;.resume(value: T): Unit = resumeWith(Result.success(value)) /** * Resumes the execution of the corresponding coroutine so that the [exception] is re-thrown right after the * last suspension point. */ public inline fun \u0026lt;T\u0026gt; Continuation\u0026lt;T\u0026gt;.resumeWithException(exception: Throwable): Unit = resumeWith(Result.failure(exception)) public suspend inline fun \u0026lt;T\u0026gt; suspendCoroutine(crossinline block: (Continuation\u0026lt;T\u0026gt;) -\u0026gt; Unit): T { contract { callsInPlace(block, InvocationKind.EXACTLY_ONCE) } return suspendCoroutineUninterceptedOrReturn { c: Continuation\u0026lt;T\u0026gt; -\u0026gt; val safe = SafeContinuation(c.intercepted()) block(safe) safe.getOrThrow() } } Reference https://kotlinlang.org/docs/coroutines-guide.html 코틀린 코루틴 Kotlin Coroutines: Deep Dive (Marcin Moskała, 인사이트) ","permalink":"https://2taezeat.github.io/posts/%EC%BD%94%EB%A3%A8%ED%8B%B4-%EC%BD%94%EB%A3%A8%ED%8B%B4/%EC%BD%94%ED%8B%80%EB%A6%B0-%EC%BD%94%EB%A3%A8%ED%8B%B4-ch03.-%EC%A4%91%EB%8B%A8%EC%9D%80-%EC%96%B4%EB%96%BB%EA%B2%8C-%EC%9E%91%EB%8F%99%ED%95%A0%EA%B9%8C/","summary":"Suspend (중단) 스레드는 저장이 불가능하고 멈추는 것만 가능하지만, 코루틴은 중단하고 재개가 가능하다\n코루틴은 중단 되었을때, Continuation 객체를 반환한다.\nsuspend 함수(중단 함수) 는 코루틴을 중단할 수 있는 함수이다.\nsuspend 함수는 코루틴 또는 다른 suspend 함수에서 호출 되어야한다. suspend 함수는 중단할 수 있는 중단점이 필요하다. 1 2 3 4 5 6 suspend fun main() { println(\u0026#34;Before\u0026#34;) println(\u0026#34;After\u0026#34;) } // Before // After 1 2 3 4 5 6 suspend fun main() { println(\u0026#34;Before\u0026#34;) suspendCoroutine\u0026lt;Unit\u0026gt; { } println(\u0026#34;After\u0026#34;) } // Before 1 2 3 4 5 6 7 8 9 10 //3 suspend fun main() { println(\u0026#34;Before\u0026#34;) suspendCoroutine\u0026lt;Unit\u0026gt; { continuation -\u0026gt; println(\u0026#34;Before too\u0026#34;) } // 람다 표현식이 suspend 되기 전에 실행된다.","title":"[코루틴 코루틴] ch03. 중단은 어떻게 작동할까?"},{"content":"2. 시퀀스 빌더 코틀린에서는 시퀀스를 생성할 때, 재너레이터 대신에 시퀀스 빌더; sequence { } 를 제공한다. 시퀀스의 특징 지연 계산 (Lazy Evaluation): 시퀀스의 요소는 실제로 필요할 때까지 계산되지 않으므로, 메모리 사용량을 줄이고 성능을 향상시킬 수 있습니다. yield 함수: yield 함수를 사용하여 시퀀스의 다음 요소를 생성합니다. 중간 연산 및 최종 연산: filter, map과 같은 중간 연산을 통해 시퀀스를 변환하고, toList, forEach와 같은 최종 연산을 통해 결과를 얻을 수 있습니다. 무한 시퀀스 생성 가능: generateSequence 함수를 사용하여 무한 시퀀스를 생성할 수 있습니다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 val seq = sequence { println(\u0026#34;first\u0026#34;) yield(1) println(\u0026#34;second\u0026#34;) yield(2) println(\u0026#34;third\u0026#34;) yield(3) } fun main() { for (num in seq) { println(\u0026#34;\\t, ${num}\u0026#34;) } } //first //\t, 1 //second //\t, 2 //third //\t, 3 중단이 가능하기 때문에 main 함수와 시퀀스 제너레이터가 번갈아가면서 실행된다.\n시퀀스 빌더는 내부적으로 중단 함수를 사용하여 지연 계산을 구현합니다.\npublic abstract suspend fun yield(value: T) sequence { ... } 블록 내부에서 yield 함수를 호출하면 해당 시퀀스는 일시 중단되고, 다음 요소가 필요할 때 다시 재개됩니다.\n시퀀스 빌더와 시퀀스가 작동하기 위해서는 중단(suspend)이 필요하다.\n시퀀스 주의 사항 시퀀스 빌더 내에서는 yield 함수 이외의 중단 함수는 사용할 수 없습니다. 즉, 시퀀스 빌더는 요소 생성과 소비가 동기적으로 이루어져야 합니다. 만약 시퀀스 빌더 내에서 비동기 작업을 처리해야 한다면 Flow를 사용하는 것이 좋습니다. Reference https://kotlinlang.org/docs/coroutines-guide.html 코틀린 코루틴 Kotlin Coroutines: Deep Dive (Marcin Moskała, 인사이트) ","permalink":"https://2taezeat.github.io/posts/%EC%BD%94%EB%A3%A8%ED%8B%B4-%EC%BD%94%EB%A3%A8%ED%8B%B4/%EC%BD%94%ED%8B%80%EB%A6%B0-%EC%BD%94%EB%A3%A8%ED%8B%B4-ch02.-%EC%8B%9C%ED%80%80%EC%8A%A4-%EB%B9%8C%EB%8D%94/","summary":"2. 시퀀스 빌더 코틀린에서는 시퀀스를 생성할 때, 재너레이터 대신에 시퀀스 빌더; sequence { } 를 제공한다. 시퀀스의 특징 지연 계산 (Lazy Evaluation): 시퀀스의 요소는 실제로 필요할 때까지 계산되지 않으므로, 메모리 사용량을 줄이고 성능을 향상시킬 수 있습니다. yield 함수: yield 함수를 사용하여 시퀀스의 다음 요소를 생성합니다. 중간 연산 및 최종 연산: filter, map과 같은 중간 연산을 통해 시퀀스를 변환하고, toList, forEach와 같은 최종 연산을 통해 결과를 얻을 수 있습니다. 무한 시퀀스 생성 가능: generateSequence 함수를 사용하여 무한 시퀀스를 생성할 수 있습니다.","title":"[코루틴 코루틴] ch02. 시퀀스 빌더"},{"content":"사전 정의 비동기(Asynchronous) : 작업의 요청과 그 결과가 순차적인 흐름을 따르지 않는 것\n현재 작업의 응답이 끝나지 않은 상태에서 다음 작업이 요청된다. 동시성(Concurrency) : 여러 작업이 같은 시간에 실행 되어 보이는 상태\n흔히 Single Core, Multi-Thread 환경에서 가능 Context-Switch 발생 시분할(time-sharing) 동기화 이슈 발생 병행성 이라고도 불림 병렬성(Parallelism) : 여러 작업이 같은 시간에 실제로 여러 개 실행되는 상태\n흔히 Multi Core, Multi-Thread 환경에서 가능 동기화 이슈 발생 Thread Blocking : 스레드가 일시 정지된 상태\nKotlin Coroutine 기본 정의 Coroutines are light-weight threads that allow you to write asynchronous non-blocking code.\nA coroutine is an instance of a suspendable computation.\n=\u0026gt; suspend 와 resume이 가능한 프로그래밍 모듈\n쓰임처 sequential code를 통해 asynchronous, non-blocking 프로그래밍을 할때 사용돤다.\n1 2 3 4 5 6 7 8 fun showNews() { viewModelScope.launch { val config = getConfigFromApi() val news = getNewsFromApi(config) val user = getUserFromApi() view.showNews(user, news) } } 대안 callback 1 2 3 4 5 6 fun onCreate() { getNewsFromApi { news -\u0026gt; val sortedNews = news.sorted() view.showNews(sortedNews) } } callback 함수가 많아지면 가독성이 떨어진다. (callback 지옥) 병렬 처리 매우 어렵다. cancel (취소) 가 어렵다. callback 함수가 많아지면, 작업의 순서를 개발자가 다루기 힘들어진다. thread 1 2 3 4 5 6 7 8 9 10 fun onCreate() { thread { val news = getNewsFromApi() val sortedNews = news.sorted() runOnUiThread { view.showNews(sortedNews) } } } 스레드가 실행된 이후 중단이 불가하다. 스레드는 생성 비용이 높다. 스레드를 자주 전환하면 관리하기 어렵고 복잡도가 증가한다. 가독성이 떨어진다. RxJava와 리액티브 스트림 1 2 3 4 5 6 7 8 9 10 11 fun onCreate() { disposables += getNewsFromApi() .subscribeOn(Schedulers.io()) .observeOn(AndroidSchedulers.mainThread()) .map { news -\u0026gt; news.sortedByDescending { it.publishedAt } } .subscribe { sortedNews -\u0026gt; view.showNews(sortedNews) } } 메모리 누수도 없고, 취소가 가능, 스레드를 적절히 사용 가능\n러닝 커브가 높다.\n객체를 반환하는 함수들은 Obseravle or Signle 클래스로 래핑(wrapping) 해야 한다.\n구현하기 복잡하다.\nend-point가 증가 할수록 더욱 복잡해진다. 특징 특정 thread에 종속되지 않는다\n하나의 Thread에서 suspend 되었다가 다른 Thread에서 resume 된다. suspend 시 스레드가 blocking 되지 않는다.\n대신 코루틴은 잠시 중단된다. 멈춰 있는 동안 해당 스레드는 다른 작업을 할 수 있다. 데이터가 준비되면 코루틴은 스레드를 받아 이전에 멈춘 지점부터 다시 시작한다. 스레드에 비해 light-weighted(경량) 하다.\n스레드는 명시적으로 생성 및 유지해야 하고, 메모리 또한 할당 되어야 한다. 비선점형 방식으로 동작\n실행 주체가 자신의 실행권을 자발적으로 내려 놓음 Reference https://kotlinlang.org/docs/coroutines-guide.html 코틀린 코루틴 Kotlin Coroutines: Deep Dive (Marcin Moskała, 인사이트) ","permalink":"https://2taezeat.github.io/posts/%EC%BD%94%EB%A3%A8%ED%8B%B4-%EC%BD%94%EB%A3%A8%ED%8B%B4/%EC%BD%94%ED%8B%80%EB%A6%B0-%EC%BD%94%EB%A3%A8%ED%8B%B4-ch01.-%EC%BD%94%ED%8B%80%EB%A6%B0-%EC%BD%94%EB%A3%A8%ED%8B%B4%EC%9D%84-%EB%B0%B0%EC%9B%8C%EC%95%BC-%ED%95%98%EB%8A%94-%EC%9D%B4%EC%9C%A0/","summary":"사전 정의 비동기(Asynchronous) : 작업의 요청과 그 결과가 순차적인 흐름을 따르지 않는 것\n현재 작업의 응답이 끝나지 않은 상태에서 다음 작업이 요청된다. 동시성(Concurrency) : 여러 작업이 같은 시간에 실행 되어 보이는 상태\n흔히 Single Core, Multi-Thread 환경에서 가능 Context-Switch 발생 시분할(time-sharing) 동기화 이슈 발생 병행성 이라고도 불림 병렬성(Parallelism) : 여러 작업이 같은 시간에 실제로 여러 개 실행되는 상태\n흔히 Multi Core, Multi-Thread 환경에서 가능 동기화 이슈 발생 Thread Blocking : 스레드가 일시 정지된 상태","title":"[코루틴 코루틴] ch01. 코틀린 코루틴을 배워야 하는 이유"},{"content":"32. 네트워크 유량 32.1 도입 경로 이외에도 그래프의 용량이라는 중요한 개념이 있다. 네트워크에서 전송받을 자료의 양이 많을 때 우리가 관심 있어 하는 부분은 서버의 패킷이 몇 밀리초 망네 도착하느냐가 아니라, 1초에 몇 MB의 자료를 전송받을 수 있느냐 이다. 네트워크를 구성하는 케이블들에는 일정한 대역폭이 있다. 최단 경로로 1초에 1MB를 전송받는 것 보다, 패킷을 여러 경로로 나누어 보내 그중 일부가 좀더 먼길을 돌아오더라도 초당 10MB 전송받는 게 이득이다. 네트워크 유량(network flow) 문제 각 간선이 용량을 갖는 그래프에서 두 정점 사이에 얼마나 많은 \u0026lsquo;흐름, 유량, flow\u0026rsquo; 을 보낼 수 있는지를 계산하는 문제 32.1.1 유량 네트워크 유량 네트워크(flow network): 각 간선에 용량(capacity) 이라는 추가 속성이 존재하는 방향 그래프 각 간선은 유량을 흘려보낼 수 있는 파이프 역할 c(u, v): u -\u0026gt; v 가는 간선의 용량 f(u, v): u -\u0026gt; v 로 가는 실제 흐르는 유량 네트워크 유량은 3가지 속성을 만족해야 한다. 용량 제한 속성: f(u, v) \u0026lt;= c(u, v) 유량의 대칭성: f(u, v) = -f(v, u) 유량의 보존: 모든 v에 대해, f(u, v)의 총합은 0 이다. 들어오는 유량과 나가는 유량의 양은 정확히 같아야 한다. 특수한 두 정점 소스, source: start node 싱크, sink: end node 이 두 정점에서 유량의 보전 속성은 성립 않함 소스에서 나온 모든 유량은 결국 싱크로 들어 가게 된다. 32.2 포드-풀커슨 알고리즘 유량 네트워크의 모든 간선의 유량을 0으로 두고 시작해, 소스에서 싱크로 유량을 더 보낼 수 있는 경로를 찾아 유량을 보내기를 반복 증가 경로(augmenting path): 유량을 보내는 경로 증가 경로를 통해 흘려 보낼 수 있는 유량의 최대량은, 포함된 간선의 잔여 용량 중 가장 작은 값이다 잔여 용량(residual capacity): 간선의 용량과 유량의 차이 r(u, v) = c(u, v) - f(u, v) 포드-풀커슨 알고리즘은 증가 경로 가 더 이상 존재하지 않을 때까지 그래프 탐색 알고리즘으로 증가 경로를 찾고, 보낼 수 있는 최대 유량을 해당 경로를 따라 보내는 작업을 반복 32.2.1 알고리즘의 구현 (python) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 from collections import deque # graph는 그래프. 간선의 비용 정보 # s는 시작 노드, t는 도착 노드, n은 노드의 개수 def fordFulkerson(graph, start, target, n): remain = [[0] * n for _ in range(n)] for i in range(n): for j in range(n): remain[i][j] = graph[i][j] maxFlow = 0 # 최대 유량 while True: # bfs visited = [False] * n visited[start] = True queue = deque([start]) path = [-1] * n # 경로. 부모 노드를 저장. 거슬러 올라가면 경로 구할 수 있음 path[start] = -1 # 처음 노드는 부모 노드가 없음 while queue: a = queue.popleft() for b in range(n): if not visited[b] and remain[a][b] \u0026gt; 0: # 방문하지 않았고 갈 수 있다면 queue.append(b) path[b] = a # 부모 노드 저장 visited[b] = True if not visited[target]: # 목적지로 가는 경로가 없다면 break # bfs 끝. 경로는 도착 노드인 t 부터 path를 보면서 부모 노드를 거슬러 올라가면 됨 b = target # 경로를 거슬러 올라가기 위한 변수 min_remain = float(\u0026#39;inf\u0026#39;) # 경로 간선들 중 가장 작은 용량을 구하기 위한 변수 while b != start: # 처음 노드에 도착할 때까지 a = path[b] min_remain = min(min_remain, remain[a][b]) b = a b = target while b != start: a = path[b] remain[a][b] -= min_remain remain[b][a] += min_remain b = a maxFlow += min_remain return maxFlow 32.8 이분 매칭 끝점을 공유하지 않는 간선의 집합를 그래프의 matching(매칭) 이라 한다. 가장 큰 매칭을 찾아내는 문제를 최대 매칭 문제 라고 한다. 프로그래밍 대회에서는 일반 그래프가 아니라, 이분 그래프 에서 최대 매칭을 찾는 문제가 나온다. 32.8.1 이분 매칭의 중요성 정점을 두 그룹으로 나눠서 모든 간선이 서로 다른 그룹의 정점들을 연결하도록 할 수 있는 그래프들을 이분 그래프 라고 한다. 이분 그래프는 두 집합 간의 대응 관계를 표현하기 위해 흔히 사용된다. 이분 매칭(bipartite matching): 이분 그래프에서 최대 매칭을 찾는 문제 32.8.2 네트워크 유량으로 이분 매칭 풀기 싱크와 소스를 이분 그래프에서 추가하면 네트워크 유량으로 이분 매칭을 쉽게 풀 수 있다. 모든 간선의 용량은 1로 한다. 최대 유량을 구한 뒤 유량이 흐르는 간선들을 모으면 최대 매칭이 된다. 네트워크의 최대 유량: O(V) BFS는 O(V)번만 하게 된다. 포드-풀커슨 알고리즘의 시간 복잡도는 O(VE) 32.8.3 이분 매칭 구현하기 (python) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 from collections import deque def odd_even(n): return 1 if n % 2 == 0 else -1 def bfs(current): level = 0 queue = deque([(current, level + 1)]) vi[current] = odd_even(level) # 깊이에 따라, 서로 다른 색상을 칠해준다. (인접한 정점 끼리는 같은 색상) while queue: now = queue.popleft() curNode, level = now for nxt in graph[curNode]: if not vi[nxt]: # 방문한 적이 없다면 두 색상 중 하나로 칠해준다. queue.append((nxt, level + 1)) vi[nxt] = odd_even(level) elif vi[nxt] == odd_even(level): # 방문한 적이 있고, 현재 칠하려는 색상과 같으면 pass continue elif vi[nxt] != odd_even(level): # 방문한 적이 있고, 현재 칠하려는 색상과 다르다면, 인접리스트가 아니다. return False return True result = [] vertex, edge = map(int, input().split()) graph = [[] for _ in range(vertex)] vi = [0] * (vertex) for _ in range(edge): u, v = map(int, input().split()) graph[u].append(v) graph[v].append(u) graph_list = [] # 그래프의 정점이 서로 이어지지 않았을 수 있음 (두개의 그래프 존재 가능성) for i in range(vertex): if not vi[i]: graph_list.append(bfs(i)) print(*result) Reference 프로그래밍 대회에서 배우는 알고리즘 문제 해결 전략 (구종만, 인사이트) https://www.algospot.com/ ","permalink":"https://2taezeat.github.io/posts/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EB%AC%B8%EC%A0%9C-%ED%95%B4%EA%B2%B0-%EC%A0%84%EB%9E%B5/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EB%AC%B8%EC%A0%9C-%ED%95%B4%EA%B2%B0-%EC%A0%84%EB%9E%B5-ch32.-%EA%B7%B8%EB%9E%98%ED%94%84/","summary":"32. 네트워크 유량 32.1 도입 경로 이외에도 그래프의 용량이라는 중요한 개념이 있다. 네트워크에서 전송받을 자료의 양이 많을 때 우리가 관심 있어 하는 부분은 서버의 패킷이 몇 밀리초 망네 도착하느냐가 아니라, 1초에 몇 MB의 자료를 전송받을 수 있느냐 이다. 네트워크를 구성하는 케이블들에는 일정한 대역폭이 있다. 최단 경로로 1초에 1MB를 전송받는 것 보다, 패킷을 여러 경로로 나누어 보내 그중 일부가 좀더 먼길을 돌아오더라도 초당 10MB 전송받는 게 이득이다. 네트워크 유량(network flow) 문제 각 간선이 용량을 갖는 그래프에서 두 정점 사이에 얼마나 많은 \u0026lsquo;흐름, 유량, flow\u0026rsquo; 을 보낼 수 있는지를 계산하는 문제 32.","title":"[알고리즘 문제 해결 전략] ch32. 그래프"},{"content":"31. 최소 스패닝 트리 31.1 도입 스패닝 트리: 원래 그래프의 정점 전부와 간선의 부분 집합으로 구선된 부분 그래프\n트리 형태로 전부 연결해야 한다. 간선들이 사이클을 이루지 않는다 정점들이 부모-자식 관계로서 연결될 필요는 없다 그래프의 스패닝 트리는 유일하지 않다. 여러개 가능 최소 스패닝 트리(MST): 스패닝 트리 중 가중치의 합이 가장 작은 트리\n그래프의 연결성을 그대로 유지하는 가장 저렴한 그래프를 찾는 문제 N개의 정점이 있으면 MST를 구성하는 간선의 개수는 항상 N - 1 개다.\n최소 스패닝 트리을 찾는 크루스칼, 프림 알고리즘 모두 탐욕적(Greedy) 알고리즘\n31.2 크루스칼의 최소 스패닝 트리 가중치가 가장 작은 간선과 가장 큰 간선 중 어느 쪽이 최소 스패닝 트리에 포함될 가능성이 높을까? 대부분의 경우 가중치가 가장 작은 간선이다. 이 아이디어에 착안한 알고리즘 간선을 가중치의 오름차순으로 정렬, 스패닝 트리에 하나씩 추가 물론, 가중치가 작다고 해서 무조건 간선에 추가하는 것은 아니다. 사이클이 생길 수 있기 때문이다. 사이클이 생기는 간선은 고려에서 제외해야 함. 모든 간선을 한 번씩 검사하고 나서 종료 31.2.1 자료구조의 선택 어떻게 사이클 판별을 효율적으로 할 것인가? 간선을 추가해서, 그래프에 사이클이 생기려면 간선의 양 끝점은 같은 컴포넌트에 속해 있어야 한다. 두 정점이 주어졌을 때, 이들이 같은 컴포넌트에 속하는지 확인하고, 그렇지 않다면 두 컴포넌트를 합치는 연산을 빠르게 한다. 여기서, 상호 배타적 집합 자료 구조, Union-find 가 사용된다. 이 자료구조에서 한 집합은 그래프의 한 컴포넌트를 표현한다. 새 간선을 추가해 사이클이 생기는지 확인하려면, 두 정점이 이미 같은 집합에 속해 있는지 확인하면 된다. 간선을 트리에 추가할 경우에는 이들이 포함된 두 집합을 합친다. 31.2.2 구현 (python 코드) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 from heapq import * def find(a): if a == parent[a]: return a else: parent[a] = find(parent[a]) return parent[a] def union(a, b): a, b = find(a), find(b) if a != b: parent[b] = a N, M = map(int, input().split()) parent, h = [0] * N, [] useEdge, totalCost = 0, 0 for i in range(N): parent[i] = i for i in range(M): s, e, w = map(int, input().split()) heappush(h, (w, s, e)) # (weight, start, end), 제일 앞 순서로 정렬되므로, 가중치를 제일 앞 순서로 함. while h: w, s, e = heappop(h) if find(s) != find(e): # find 연산 후, 부모노드 다르면 사이클 발생 X으므로 union 연산 수행 -\u0026gt; 최소 신장 트리에 포함! union(s, e) totalCost += w useEdge += 1 print(totalCost) 여기서, 상호 배타적 집합 자료 구조, Union-find 의 연산은 상수 시간 이 걸린다. 실제 트리를 만드는 for문의 시간 복잡도는 O(E) 전체 시간 복잡도는 간선 목록의 정렬에 걸리는 O(E lgE) 31.3 프림의 최소 스패닝 트리 다익스트라와 비슷\n하나의 시작점으로 구성된 트리에, 간선을 하나씩 추가하며 스패닝 트리가 될 때까지 키워 간다.\n중간 과정에서도 항상 연결된 트리를 이루게 된다. 크루스칼 알고리즘과 똑같이, 가중치가 가장 작은 간선을 선택한다.\n31.3.1 구현 (python 코드), 우선순위 큐 사용 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 from heapq import * def prim(graph): result, vi, start, h = [], set(), list(graph.keys())[0], [] vi.add(start) for end, cost in graph[start].items(): heappush(h, (cost, start, end)) while h: cost, s, e = heappop(h) if e not in vi: vi.add(e) result.append((s, e, cost)) for nxtNode, nCost in graph[e].items(): if nxtNode not in vi: heappush(h, (nCost, e, nxtNode)) return result prim(graph={ \u0026#39;A\u0026#39;: {\u0026#39;B\u0026#39;: 7, \u0026#39;D\u0026#39;: 5}, \u0026#39;B\u0026#39;: {\u0026#39;A\u0026#39;: 7, \u0026#39;C\u0026#39;: 8, \u0026#39;D\u0026#39;: 9, \u0026#39;E\u0026#39;: 7}, \u0026#39;C\u0026#39;: {\u0026#39;B\u0026#39;: 8, \u0026#39;E\u0026#39;: 5}, \u0026#39;D\u0026#39;: {\u0026#39;A\u0026#39;: 5, \u0026#39;B\u0026#39;: 9, \u0026#39;E\u0026#39;: 15, \u0026#39;F\u0026#39;: 6}, \u0026#39;E\u0026#39;: {\u0026#39;B\u0026#39;: 7, \u0026#39;C\u0026#39;: 5, \u0026#39;D\u0026#39;: 15, \u0026#39;F\u0026#39;: 8, \u0026#39;G\u0026#39;: 9}, \u0026#39;F\u0026#39;: {\u0026#39;D\u0026#39;: 6, \u0026#39;E\u0026#39;: 8, \u0026#39;G\u0026#39;: 11}, \u0026#39;G\u0026#39;: {\u0026#39;E\u0026#39;: 9, \u0026#39;F\u0026#39;: 11} }) 다익스트라 알고리즘 처럼 우선순위 큐(heap) 을 사용해서 구현하면 O(ElgV) 의 시간 이 걸린다. 우선순위 큐를 사용하지 않은 경우는 O(V^2 + E) 밀집 그래프의 경우 V^2 === E 임으로, 프림 알고리즘이 크루스칼 알고리즘 보다 빠르다. Reference 프로그래밍 대회에서 배우는 알고리즘 문제 해결 전략 (구종만, 인사이트) https://www.algospot.com/ ","permalink":"https://2taezeat.github.io/posts/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EB%AC%B8%EC%A0%9C-%ED%95%B4%EA%B2%B0-%EC%A0%84%EB%9E%B5/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EB%AC%B8%EC%A0%9C-%ED%95%B4%EA%B2%B0-%EC%A0%84%EB%9E%B5-ch31.-%EA%B7%B8%EB%9E%98%ED%94%84/","summary":"31. 최소 스패닝 트리 31.1 도입 스패닝 트리: 원래 그래프의 정점 전부와 간선의 부분 집합으로 구선된 부분 그래프\n트리 형태로 전부 연결해야 한다. 간선들이 사이클을 이루지 않는다 정점들이 부모-자식 관계로서 연결될 필요는 없다 그래프의 스패닝 트리는 유일하지 않다. 여러개 가능 최소 스패닝 트리(MST): 스패닝 트리 중 가중치의 합이 가장 작은 트리\n그래프의 연결성을 그대로 유지하는 가장 저렴한 그래프를 찾는 문제 N개의 정점이 있으면 MST를 구성하는 간선의 개수는 항상 N - 1 개다.","title":"[알고리즘 문제 해결 전략] ch31. 그래프"},{"content":"30. 최단 경로 알고리즘 30.1 도입 최단 경로 문제(shortest path problem)은 주어진 그래프에서 주어진 두 정점을 연결하는 가장 짧은 경로의 길이를 찾는 문제 가중치가 없는 그래프(가중치가 모두 1인)에 대한 최단 경로는 BFS로 찾을 수 있다. \u0026lsquo;최단 경로를 구성하는 정점들의 목록\u0026rsquo;을 구해 주는 것이 아니라 최단 경로의 길이를 찾아 줄 뿐이다. 실제 경로를 계산하기 위해서는 BFS에서 그랬듯이 탐색 과정에서 별도의 정보를 저장하고, 이것으로 실제 경로를 찾아내는 과정을 구현해야 한다. 다양한 그래프의 종류와 특성에 따라 최적화된 많은 최단 경로 알고리즘이 존재한다. 30.1.1 음수 간선의 중요성 음수 가중치를 갖는 간선(음수 간선) 이 있는지의 여부가 중요\n당연하지만, 음수 간선을 지나가면 전체 경로의 길이가 짧아 진다.\n가중치의 합이 음수인 사이클(음수 사이클) 이 등장할 수 있다.\n음수 사이클이 있는 경우 최단 경로 문제는 제대로 정의되지 않는다.\n음수 사이클이 있는 그래프에서는 어떤 최단 경로 알고리즘도 최단 경로를 정확하게 찾을 수 없다.\n알고리즘에 따라 음수 사이클이 있다는 것을 확인할 수 있다 (벨만-포드 알고리즘)\n30.1.2 단일 시작점과 모든 쌍 알고리즘 단일 시작점 알고리즘과 모든 쌍 알고리즘 으로 나뉜다.\n모든 쌍 알고리즘의 수행 결과는 V x V 크기의 2차원 배열이 된다.\n이 배열의 각 원소는 두 정점 사이의 최단 거리를 나타낸다.\n대표적인 플로이드-워셜 알고리즘이 있다.\n30.1.3 방향 그래프와 무방향 그래프 최단 거리 알고리즘들은 모두 방향 그래프를 기준으로 동작 무방향 그래프에서 최단 경로를 찾기 위해서는 양방향 간선을 두 개의 일반 통행 간선으로 쪼개서, 방향 그래프로 만들어야 한다 음수 가중치가 있는 무방향 그래프는 음수 사이클이 생겨서 불가능하다. 30.2 다익스트라의 최단 경로 알고리즘 다익스트라 알고리즘은 단일 시작점 최단 경로 알고리즘이다. 시작 정점 s 에서 다른 모든 정점들까지의 최단 거리를 계산한다. 30.2.1 우선순위 큐를 사용하는 너비 우선 탐색 핵심: 더 늦게 발견한 정점이라도 더 먼저 방문할 수 있어야 한다.\n큐 대신 우선순위 큐를 사용해서 이 문제를 해결 우선순위 큐에 정점의 번호와 함께 지금까지 찾아낸 해당 정점까지의 최단 거리를 쌍으로 넣는다.\n우선순위 큐는 최단 거리를 기준으로 정점을 배열함으로써, 아직 방문하지 않은 정점 중 시작점으로 거리가 가장 가까운 정점을 찾는 과정을 간단히 해준다.\n각 정점까지의 최단 거리를 저장하는 1차원 배열 dist[]를 유지하며, 정점을 방문할 때 마다 인접한 정점을 모두 검사\n각 정점까지의 최단 경로가 갱신될 수 있다.\n(9, c)는 dist[c]에 갱신하는 것은 간단하지만 이때, 이미 우선순위 큐에 들어있는 정보(12, c)는 어떻게 처리할까?\n우선순위 큐 내에서 (12, c)를 찾아내 (9, ㅊ)fh qkRnsek. (12, c)를 그대로 두고, (9, c)를 추가한 뒤, 나중에 큐에서 (12, c)가 꺼내지면 무시한다. 보통 2번의 방법을 많이 사용한다. 1번은 우선순위 큐에서 지원하지 않을 뿐더러 직접 구현하기 복잡하다..\n2번의 방법을 사용한다면, (12, c)를 무시해야 하는지 어떻게 알 수 있을까?\ndist[u]와 cost를 비교 dist[u] \u0026lt; cost라면, u까지 오는 cost보다 짧은 경로가 이미 발견됐다는 의미임으로 (cost, u) 쌍은 무시하면 된다. -\u0026gt; continue 문 다익스트라 알고리즘이 계산한 dist[] 1차원 배열에는 각 정점까지의 최단 거리가 들어가 있다.\nBFS 스패닝 트리와 마찬가지로, 이 트리의 루트에서 각 정점까지로 가는 경로는 원래 그래프에서의 최단 경로가 된다.\n모든 간선의 가중치가 0 이상일때, 다익스트라 알고리즘이 정당하다.\n음수 간선이 있는 그래프는 정답을 계산 못함 30.2.2 실제 구현 (python 코드) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 from heapq import * n, m = map(int, input().split()) INF = int(1e9) start = int(input()) graph = [[] for i in range(n)] distance = [float(\u0026#39;inf\u0026#39;) for _ in range(n)] for _ in range(m): a, b, c = map(int, input().split()) graph[a].append((b, c)) def dijkstra(startNode): q = [] heappush(q, (0, startNode)) distance[startNode] = 0 while q: # 큐가 비어 있지 않다면 curCost, node = heappop(q) if distance[node] \u0026lt; curCost: # 만약 지금 꺼낸 것보다 더 짧은 경로를 알고 있다면 지금 꺼낸 것을 무시 continue for nxt, weight in graph[node]: nCost = curCost + weight if nCost \u0026lt; distance[nxt]: # 더 짧은 경로를 발견하면, dist를 갱신하고 우선수위 큐에 넣는다. distance[nxt] = nCost heappush(q, (nCost, nxt)) 30.2.3 다익스트라 시간 복잡도 수행 시간은 크게 두 부분\n강 정점마다 인접한 간선들을 모두 검사하는 작업: O(E) 우선순위 큐에 원소를 넣고 삭제하는 작업: O(ElgE) 우선순위 큐에 최대 크기는 O(V)\n그러나 dist[]를 갱신할 때마다 원소를 우선순위 큐에 넣기 때문에 그보다 많은 원소들이 들어갈 수 있다. 최악의 경우, 그래프의 모든 간선이 검사될 때마다 dist[]가 갱신되고, 우선순위 큐에 정점의 번호가 추가되는 것 추가는 각 간선마다 최대 한번 일어나기 때문에, 추가되는 원소의 수는 최대 O(E)\n추가 삭제에 O(lgE)의 시간이 걸림 추가 삭제 전체 시간 복잡도: O(ElgE) 따라서, 1, 2번을 더하면 O(ElgE)d가 된다\n대게 E는 V^2보다 작기 때문에, O(lgE) === O(lgV) 따라서, 최종 시간복잡도는 O(ElgV) 가 된다. 30.2.4 실제 경로 찾기 다익스트라는 최단 거리만을 계산할 뿐, 실제 경로를 찾으려면, 그래프를 탐색하는 과정에서 스패닝 트리를 계산한 후, 스패닝 트리를 거슬러 올라겨며 경로를 찾는 함수를 작성해야 한다. 30.2.5 O(VlgV)에 다익스트라 구현하기 중복 원소를 우선순위 큐에 넣지 않도록 수정하면 O(VlgV) 에 동작하도록 구현할 수 있다. 그러나 실제로는 이런 식의 코드를 작성하지 않는다. 피보나치 힙이나, 이진 검색 트리를 이용해 우선순위 큐를 작성해야 하는데, 이 같은 자료 구조들은 시간복잡도를 줄여 주지만, 구현이 복잡하거나 실제로 작성해서 속도를 측정하면 더 느린 경우가 많기 때문이다. 30.2.6 우선순위 큐를 사용하지 않는 다익스트라의 구현 정점의 수가 작거나 간선의 수가 매우 많은 경우 우선순위 큐를 사용하지 않고 구현하는 방식이 빠른 경우가 있다. 다음 방문 정점을 큐에 보관하는 대신 매번 반복문을 이용해 방문하지 않는 정점 중 dist[]가 가장 작은 값을 찾는다. 방문해야 할 정점들의 목록을 저장하는 큐가 따로 없기 때문에, 각 정점을 방문했는지 여부는 별도의 visited[]를 통해 추적 이 경우 시간 복잡도: O(V^2 + E) 30.3, 30.4 신호 라우팅, ROUTING, 난이도: 하 간선 가중치의 합이 아니라 곱으로 정의된 문제\n0이 아니라 1.0으로 초기화하면 된다.\nlog는 순증가 함수\n30.5, 30.6 소방차, FIRETRUCKS, 난이도: 중 각 불난 위치에서 다익스트라, 각 소방서까지 거리 계산 각 소방서마다 다익스트라 실행, 각 불난 위치까지의 거리 계산 플로이드 알고리즘 사용해서 모든 쌍 거리 계산 3개 다 너무 시간이 오래 걸림 해법 각 소방서에서 다로 시작할 필요 없이 모든 소방서에서 동시에 다익스트라 수행하게 하자 가상의 시작점을 추가한뒤 이 시작점에서 다른 모든 소방서로 가중치 0인 간선을 연결 이 시작점에서 다익스트라 수행하면 모든 위치에 대해 가상의 소방서로 부터 최단 거리를 얻을 수 있다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 def dijkstra(start): q = [] heappush(q, (0, start)) distance[start] = 0 while q: cost, node = heappop(q) if distance[node] \u0026lt; cost: continue for (nxt, weight) in graph[node]: nxtCost = cost + weight if (nxtCost \u0026lt; distance[nxt]): distance[nxt] = nxtCost heappush(q, (nxtCost, nxt)) INF = float(\u0026#39;inf\u0026#39;) for _ in range(int(input())): v, e, n, m = map(int, input().split()) distance = [INF for _ in range(v + 1)] graph = [[] for _ in range(v + 1)] for _ in range(e): a, b, w = map(int, input().split()) graph[a].append((b, w)) graph[b].append((a, w)) fires = list(map(int, input().split())) starts = list(map(int, input().split())) for i in starts: graph[0].append((i, 0)) dijkstra(0) answer = 0 for i in fires: answer += distance[i] print(answer) 30.9 벨만-포드 최단 경로 알고리즘 다익스트라와 같은 단일 시작점 최단 경로 알고리즘이지만, 음수 간선이 있어도 최단 경로를 찾을 수 있다. 그래프에 음수 사이클이 있어서 최단 거리가 제대로 정의되지 않을 경우, 이것에 대해 알려줌 시작점에서 각 정점까지 가는 최단 거리의 상한을 적당히 예측한 뒤, 예측 값과 실제 최단 거리 사이의 오차를 반복적으로 줄여가는 방식으로 동작 BFS 기반으로 한 번에 하나씩 최단 거리를 확정해 나가는 다익스트라와 매우 다름 각 정점까지의 최단 거리의 상한을 담은 upper[] 1차원 배열을 유지 이 값은 알고리즘이 진행됨에 따라 점점 줄어들고, 종료될 때는 실제 최단 거리를 담게 된다. 30.9.1 벨만-포드 동작 과정 upper[start] = 0으로 초기화, 나머지 원소들은 INF로 초기화 최단 거리의 특성을 이용 dist[v] \u0026lt;= dist[u] + w(u, v) 이 속성을 이용하면 upper 값을 실제 최단 거리에 가깝게 보정 가능 upper[v]를 감소하는 작업을 (u, v)를 따라 완화(relax) 한다고 말한다. 완화가 성공할때마다, upper는 줄어들고, 최단 거리에 가깝게 된다. 30.9.2 종료 조건과 정당성의 증명 upper[u] = dist[u]가 될 수 있나? 모든 간선에 대해 완화를 시도하는 작업을 x번 반복하면 x개 이하의 간선을 사용하는 최단 경로들은 전부 찾을 수 있다 모든 간선이 전부 완화가 실패할 때까지 반복하면 모든 최단 경로를 찾을 수 있다 몇 번 완화를 반복해야 하는가? 최단 경로가 한 정점을 두 번 지나는 일은 없기때문에, 최단 경로가 포함하는 간선 수의 상한은 쉽게 알 수 있다. 최단 경로는 최대 V개의 정점과 V-1 개의 간선을 가질 수 있다. 따라서, 완화는 전체 V-1번 이면 된다. 30.9.3 음수 사이클의 판정 음수 사이클이 있으면 최단 거리 문제가 제대로 정의 되지 않는다.\n물론, 시잣점에서 음수 사이클로 가는 경로가 아예 없으면 상관 없다. 벨만-포드는 음수 사이클의 존재 여부를 판정할 수 있다.\n의미 없는 값을 반환하는 대신 음수 사이클이 존재한다는 오류를 반환할 수 있다. 음수 사이클이 존재 여부를 판정하려면 V-1 번 완화가 아니라, V번 완화를 시도하면 된다.\n그래프에 음수 사이클이 없다면 V-1번으로 모든 최단 거리를 찾을 수 있기 때문에, 마지막 반복의 완화는 전부 실패하게 된다.\n음수 사이클이 있으면 V번째 반복에서도 항상 완화가 한 번은 성공한다.\n30.9.4 실제 구현 (python 코드) 마지막 반복에서 완화가 성공하면(음수 사이클 존재) 텅 빈 배열을 반환 수행 시간은 모든 간선을 검사하는 중첩 반복문에 의 해 지배 가장 바깥의 for문은 V번 안의 두 for문은 모든 간선을 순회하므로 E번 수행 따라서, 전체 시간 복잡도는 O(VE) 이다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 V, E = map(int, input().split()) INF = float(\u0026#39;inf\u0026#39;) graph = [] upper = [INF] * (V) for i in range(E): s, e, w = map(int, input().split()) graph.append((s, e, w)) mCycle = False def bellmanFord(): global mCycle upper[0] = 0 for i in range(V - 1): # V-1 번 반복 updated = False for s, e, w in graph: if (upper[s] != INF) and (upper[e] \u0026gt; upper[s] + w): upper[e] = upper[s] + w updated = True if not updated: # 모든 간선에 대해 완화가 실패했을 경우 V-1번 돌 필요 없이 곧장 종료 break for s, e, w in graph: # 음수 사이클 판정 if (upper[s] != INF) and (upper[e] \u0026gt; upper[s] + w): mCycle = True if not mCycle: for i in range(1, V): if upper[i] != INF: print(upper[i]) else: print(-1) else: print(-1) 30.9.5 경로 계산하기 벨만-포드를 수행하는 과정에서 각 정점을 마지막으로 완화시킨 간선들을 모으면 스패닝 트리를 얻을 수 있다. 이 정점들은 항상 최단 경로 위에 있기 때문에, 각 정점에서부터 스패닝 트리의 루트인 시작점까지 거슬러 올라가는 경로는 항상 시작점에서 해단 경로까지의 최단 경로이다. BFS와 다익스트라와 같은 방식으로 실제 경로(정점의 목록)을 계산할 수 있다. 30.9.6 빠지기 쉬운 함정 u로 가는 경로가 존재하는지 확인하기 위해서는 적당히 큰 값 M에 대해 upper[u] \u0026lt; INF - M 인지를 확인해야 한다.\n30.10, 30.11 시간여행, TIMETRIP, 난이도: 중 최단 경로 구하기 간과하기 쉬운 부분은 그래프에 음수 사이클이 존재한다고 해서, 가중치가 음의 무한대인 경로가 항상 존재하지는 않는다 음수 사이클을 발견했을 때 시작점에서 이 사이클로 왔다가 다시 종착점으로 가는 경로가 있는지 확인해야 한다. reachable[][]: 모든 정점의 쌍에 대해 한 정점에서 다른 정점으로 가는 경로의 존재 여부를 저장 최장 경로 구하기 주어진 그래프의 가중치의 부호를 모두 바꾼 다음 최단 경로를 찾으면 된다. 이 문제는 일반적으로 이야기하는 최장 경로 문제와는 다르다 이 문제와 달리 최장 경로 문제에서는 사이클을 포함하지 않는 단순 경로를 찾기 요구한다. 실제로 임의의 문제에서 단순 최장 경로를 찾는 문제는 NP-Complete 문제이다 30.12 플로이드의 모든 쌍 최단 거리 알고리즘 다익스트라, 벨만-포드는 one start node에서 다른 모든 정점까지의 거리를 구해준다. 물론, 각 정점을 시작점으로 다익스트라를 반복해도 모든 정점 쌍 최단 거리를 구할 수 있다. 플로이드는 모든 정점 쌍에 대해 둘 사이의 최단 거리를 구해준다. 2차원 배열 dist[]은 모든 정점 쌍의 최단 거리를 저장 30.12.1 정점의 경유점 경유점: 경로가 거쳐가는 정점들 정점 집합 S에 포함된 정점들을 경유점으로 사용해 u -\u0026gt; v로 가는 최단 경로를 알고 있다고 할때, x 정점은 최단 경로를 경유하거나 경유하지 않는다. 경로가 x를 경유하지 않는다: 이 경로는 S - {x}에 포함된 정점들만을 경유점으로 사용 경로가 x를 경유한다: u-\u0026gt;x 가는 구간과 x-\u0026gt;v로 가는 구간으로 나눌 수 있다. 30.12.2 플로이드 알고리즘의 프로토타입 앞의 점화식을 고치면 모든 쌍에 대한 최단 거리 문제를 동적 계획법으로 풀 수 있다.\nC k의 모든 값은 C k-1에만 의존하기 때문에, 동적 계획법을 이용하면 쉽게 풀 수 있다.\n두 정점 사이의 간선이 없는 경우 아주 큰 값을 넣어 두면, 따로 처리하지 않아도 두 정점 사이의 경로가 존재하지 않은 것을 알 수 있다.\n자기 자신으로 가는 간선은 따로 없더라도 최단 거리는 항상 0이기 때문에 C[0][u][u]는 0으로 초기화\n전체 시간복잡도는 3중 for문이 지배, O(V^3)\n30.12.3 메모리 사용량 줄이기 구현이 간단, 반복문 내부가 단순해서 빠르게 수행된다.\n시간보다는 메모리 사용량이 문제가 된다.\n슬라이딩 윈도우 기법을 사용하면 사용하는 배열의 크기를 O(V^2) 로 줄일 수 있다.\nC k의 답은 C k-1만 있으면 계산할 수 있다.\nC k-2, C k-3 등은 가지고 있을 필요가 없다. C k(u, v)의 값을 C[k%2][u][v]에 저장한다. 별도의 배열을 사용하지 않고, 그래프의 가중치를 담는 인접 행렬 위에서 곧장 점화식의 결과를 계산\nC k-1 (u, k): 시작점 부터 k-1번 정점까지를 경유점으로 이용해 u -\u0026gt; k로 가는 최단 경로의 길이\nC k (u, k): 시작점 부터 k번 정점까지를 경유점으로 이용해 u -\u0026gt; k로 가는 최단 경로의 길이\n출발점이나 도착점이 k일 때, 사용 가능한 경유점의 목록에 k가 추가되는 것은 의미가 없다.\n\u0026lsquo;A를 들러 B에 가는 최단 경로\u0026rsquo;와 \u0026lsquo;A와 B를 들러 B로 가는 최단 경로\u0026rsquo;는 같다. Ck-1와 Ck의 값을 구분하지 않고 섞어서 써도 된다.\nC[k%2]와 C[(k-1)%2]를 구분할 필요가 없으며, 이들을 한 개의 2차원 배열에 섞어 써도 된다.\n시간 복잡도: O(V^3), 그대로\n공간 복잡도: O(V^2) 으로 줌\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 INF = float(\u0026#39;inf\u0026#39;) graph = [[INF] * N for _ in range(N)] for a in range(N): # 자기 자신에서 자기 자신으로 가는 비용 0으로 초기화 for b in range(N): if a == b: graph[a][b] = 0 for _ in range(M): # 각 간선에 대한 정보를 입력 받아, 그 값으로 초기화 a, b, c = map(int, input().split()) graph[a][b] = c for k in range(N): # 점화식에 따라 플로이드 워셜 알고리즘을 수행 for a in range(N): for b in range(N): graph[a][b] = min(graph[a][b], graph[a][k] + graph[k][b]) 30.12.4 실제 경로 계산하기 마지막으로 graph[u][v]을 갱신했을 때 사용한 k의 값을 저장 (따로 배열로 변수화 해서 저장) 이 정점의 번호를 w라고 하자 최단 경로가 w를 지난다는 의미 따라서, 재귀 호출을 이용해 u-\u0026gt;w로 가는 최단 경로를 찾고, w-\u0026gt; v로 가는 최단 경로를 찾은 뒤 이 둘을 합친다. Reference 프로그래밍 대회에서 배우는 알고리즘 문제 해결 전략 (구종만, 인사이트) https://www.algospot.com/ ","permalink":"https://2taezeat.github.io/posts/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EB%AC%B8%EC%A0%9C-%ED%95%B4%EA%B2%B0-%EC%A0%84%EB%9E%B5/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EB%AC%B8%EC%A0%9C-%ED%95%B4%EA%B2%B0-%EC%A0%84%EB%9E%B5-ch30.-%EA%B7%B8%EB%9E%98%ED%94%84/","summary":"30. 최단 경로 알고리즘 30.1 도입 최단 경로 문제(shortest path problem)은 주어진 그래프에서 주어진 두 정점을 연결하는 가장 짧은 경로의 길이를 찾는 문제 가중치가 없는 그래프(가중치가 모두 1인)에 대한 최단 경로는 BFS로 찾을 수 있다. \u0026lsquo;최단 경로를 구성하는 정점들의 목록\u0026rsquo;을 구해 주는 것이 아니라 최단 경로의 길이를 찾아 줄 뿐이다. 실제 경로를 계산하기 위해서는 BFS에서 그랬듯이 탐색 과정에서 별도의 정보를 저장하고, 이것으로 실제 경로를 찾아내는 과정을 구현해야 한다. 다양한 그래프의 종류와 특성에 따라 최적화된 많은 최단 경로 알고리즘이 존재한다.","title":"[알고리즘 문제 해결 전략] ch30. 그래프"},{"content":"29. 그래프의 너비 우선 탐색 29.1 도입 28.1.1 너비 우선 탐색(Breadth First Search) 너비 우선 탐색은 시작점에서 가까운 정점(Node)부터 순서대로 방문하는 탐색 알고리즘\n시작 노드에서 출발해 시작 노드를 기준으로 가까운 노드를 먼저 방문하면서 탐색하는 알고리즘\n각 정점을 방문할 때 마다 모든 인접 정점들을 검사\n이 중 처음 보는 정점을 발견하면, 이 정점을 방문 예정이라고 기록, 큐에 저장\n너비 우선 탐색의 방문 순서는 정점을 먼저 꺼내는지에 의해 결정\n이를 구현하는 방법은 목록에 먼저 넣은 정점을 항상 먼저 꺼내는 것\n정점 목록을 큐(queue) 를 사용하면 너비 우선 탐색의 조건을 만족시킬 수 있다.\n그래서 큐(queue) 를 쓰는 거다 그래프의 너비 우선 탐색 python 구현\nDFS의 visited[]가 각 정점의 방문 여부를 저장했던 것에 비해, BFS에서 discovered[]는 각 정점의 발견 여부를 저장한다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 discovered = [False for _ in range(N)] result = [] def bfs(startNode): q = deque([ [startNode] ]) discovered[startNode] = True while q: node = q.popleft() result.append(node) for nxt in graph[node]: if not discovered[nxt]: q.append(nxt) discovered[nxt] = True DFS와 달리 BFS에서는 발견(discover) 과 방문(visit) 이 같지 않다.\n모든 정점은 다음 3개의 상태를 순서대로 거쳐 간다.\n아직 발견되지 않은 상태 (visited = False) 발견되었지만 아직 방문되지 않은 상태 (in queue) 방문된 상태 (discoverd = True) BFS에서 새 정점을 발견하는데 사용했던 간선들을 모은 트리를 BFS 스패닝 트리(BFS Spanning Tree) 라고 한다.\n29.1.2 너비 우선 탐색의 시간 복잡도 DFS와 다를 게 없다. 모든 정점을 한 번씩 방문하며, 정점을 방문할 때마다 인접한 모든 간선을 검사한다 인접 리스트 인 경우: O(V+E) 인접 행렬 인 경우: O(V^2) 29.1.3 너비 우선 탐색과 최단 거리 그래프의 구조에 관한 다양한 문제를 푸는 데 사용되는 DFS와 달리, BFS는 대게 딱 하나의 용도로 사용된다. 바로 그래프의 최단 경로 문제를 풀 때 사용 BFS를 간단하게 변경해 모든 정점에 대해 시작점으로 부터의 거리 distance[]를 계산할 수 있기 때문이다. 시작점 부터 v까지의 최단 거리 distance[v]는 distance[u] + 1이다. 간선 (u, v)를 처음 발견해 큐에 넣었다고 가정할 때 시작점으로부터 다른 모든 정점까지의 최단 경로를 BFS 스패닝 트리 위에서 찾을 수 있다. 시작점으로 부터의 최단 경로는 \u0026lsquo;BFS 스패닝 트리에서 루트로 가는 경로\u0026rsquo; 29.1.4 모든 점의 발견 그래프 전체 구조에 관한 정보를 얻기 위해 사용되는 DFS와 달리, BFS는 대게 시작점으로부터 다른 정점들까지의 거리를 구하기 위해 사용된다. 따라서, DFS 처럼 모든 정점을 검사하면서 수행하는 작업 BFS는 잘하지 않는다. 29.2, 29.3 Sorting Game, SORTGAME, 난이도: 중 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 dic = defaultdict(lambda: -1) # { \u0026#34;1023\u0026#34;: 1, ... } def bfs(first, n, distance): q = deque() distance[first] = 0 dic[first] = 0 q.append(first) while q: here = q.popleft() cost = distance[here] for i in range(1, n): left = 0 for j in range(n - i, 0, -1): right = left + i A, B, C = here[0:left], here[left:right + 1][::-1], here[right + 1:] rev = A + B + C left += 1 if distance[rev] == -1: distance[rev] = cost + 1 dic[rev] = cost + 1 q.append(rev) def makeDic(): for n in range(1, 9): distance = defaultdict(lambda: -1) first = \u0026#34;012345678\u0026#34;[:n] bfs(first, n, distance) makeDic() for _ in range(int(input())): N = int(input()) L = list(map(int, input().split())) sorted_score = sorted(L) target = [sorted_score.index(s) for s in L] stringTarget = \u0026#39;\u0026#39;.join(str(s) for s in target) answer = dic[stringTarget] print(answer) 문제를 읽고, 그래프로 접근, 바꾸기 {3, 4, 1, 2} === {9, 100, 5, 6} 상대적 크기가 같음 모든 상태를 미리 BFS를 통해 계산 29.4, 29.5 어린이날, CHILDRENDAY, 난이도: 상 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 # 1. c \u0026gt;= n + m # 2. c mod n = m # 3. d에 포함된 digit들로만 구성 # 흰색: 0 ~ n # 회색: n ~ 2n-1 def bfs(): q = deque([(0, 0)]) while q: currentNode, tmpResult = q.popleft() if currentNode - n == m: # 회색이면서, 현재 노드 값이 m일때 return tmpResult for dn in d: cal = currentNode * 10 + dn if cal \u0026gt;= n: # 회색 nxtNode = (cal % n) + n else: # 흰색 nxtNode = (cal % n) if not discovered[nxtNode]: discovered[nxtNode] = True q.append([nxtNode, tmpResult * 10 + dn]) return -1 # 그래프를 만들고, 0 to m으로 가는 최단 경로를 찾는다. for _ in range(int(input())): d, n, m = input().split() n = int(n) m = int(m) d = sorted(map(int, list(d))) discovered = [False] * (2 * n) answer = bfs() if answer == -1: print(\u0026#34;IMPOSSIBLE\u0026#34;) else: print(answer) 여러 개의 조건이 있는 문제 일부 조건을 없앤 더 단순한 문제를 푼 후, 조건을 하나하나 추가 mod 연산, 법칙 사전순으로 가장 최단 경로 =\u0026gt; 임의의 순서 대신 번호가 증가하는 순서(오름 차순)으로 검사 조건 강제 29.6 (기본 BFS 말고) 최단 경로 전략 게임판의 상태를 그래프로 표현: 상태 공간(state space)\n15-퍼즐 문제는 그래프상의 최단 경로 문제로 변경 상태 공간을 전체 탐색하지 않고, 답을 찾는 데로 BFS를 종료하기 때문에 시간 복잡도를 다르게 계산해야 한다. 너브 우선 탐색이 방문하는 정점의 개수에 가장 직접적인 영향을 주는 요소는 최단 거리 d 이다. 방문하는 정점의 개수에 영향을 미치는 다른 요소는 탐색의 분기 수(branching factor) b 이다. 방문하는 정점의 수: O(b^d) 지수적으로 증가 29.6.1 양방향 탐색(bidirectional search) 시작 정점에서 시작하는 정방향 탐색과, 목표 정점에서 시작해 거꾸로 올라오는 역방향 탐색을 동시에 하면서, 이 둘이 가운데서 만나면 종료 정방향과 역방향 탐색에서 방문할 정점들을 모두 같은 큐에 넣음 최단 거리를 저장할 때는 정방향은 양수, 역방향은 음수로 저장 (구분하기 위해) 인접한 상태를 검사했는데, 서로 부호가 다르면, 가운데서 만났다는 의미 목표 상태에서 역방향으로 움직이기 쉬워야 가능 함 29.6.2 점점 깊어지는 탐색 양방향 탐색에서도 방문하는 정점 수는 최단 거리에 따라 지수적으로 증가, O(b^d/2)\n따라서, 규모가 큰 탐색 문제를 풀 때는 DFS를 기반으로 한 방법을 사용해야 함\nDFS는 방문할 정점의 목록을 유지하는 BFS와 달리 정점을 발견하는 즉시 방문 큐가 너무 많은 메모리를 차지하는 일이 발생하지 않음 그러나 최단 경로를 찾기 불가능\nDFS는 목표 상태를 찾아도 지금까지 찾은 경로가 최단 경로인지 확신할 수 없다. 각 정점을 방문하지 않으면 한 상태를 두 번 방문할 수 도 있고, 사이클에 빠져 탐색이 종료하지 않을 수 있다. IDS(Iteratively Deepening Search, 점점 깊어지는 탐색)이 이 문제를 해결하기 위해 고안됨\n임의의 깊이 제한 limit 보다 짧은 경로가 존재하는 DFS로 확인\n답을 찾으면 성공이니 반환 찾지 못하면, limit 을 늘려서 다시 시도 IDS는 조합 탐색(가지치기) 와 관계가 깊다.\n깊이 제한을 늘려가면서 DFS를 반복하면 한 정점을 두 번 이상 방문하는 낭비가 생겨난다. 방문하는 상태의 수 O(b^d) IDS는 큐를 사용하지 않기 때문에, 메모리는 스택만 사용함 최대 메모리 사용량은 탐색의 깊이에 비례하게 된다. O(d) 29.6.3 탐색 방법 선택하기 최단 경로 찾는 경우, BFS를 우선 고려 메모리 사용량, 탐색의 깊이 한계 확인 양방향 탐색 고려, 목표 상태에서 역방향으로 움직이기 쉬워야 함 IDS 고려 29.6.4 상태 객체의 구현 상태에 대한, 여러 연산을 가능한 한 효율적으로 구현 가능한 한 적은 메모리 사용 비트마스크 기법 일대일 대응 함수 현재 상태가 몇 번째인지 계산하는 일대일 함수를 작성하면, 현재 상태를 정수로 표현 가능 29.7, 29.8 하노이의 탑, HANOI4B, 난이도: 중 start state \u0026mdash;\u0026ndash;bfs for find 최단 경로\u0026mdash;-\u0026gt; end state 시작과 끝 상태가 유일하게 정해져 있음, 그래프가 양방향 그래프 이기 때문에 양방향 탐색ㅇ글 적용하기 용이하다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 def plus(x): if x \u0026gt; 0: return x + 1 elif x \u0026lt; 0: return x - 1 def judgeSign(x, y): if x * y \u0026lt; 0: return True return False def changeStr(ori, i, j, iNum, jNum): lo = list(ori) lo[i] = \u0026#34;0\u0026#34; if jNum == 0: lo[j] = str(iNum) else: lo[j + 1] = str(iNum) return \u0026#34;\u0026#34;.join(lo) def bfsWithBidir(): # 양방향 탐색 q = deque([(start, 1), (end, -1)]) while q: current, count = q.popleft() topIdx = [[(i * n), 0] for i in range(4)] for i in range(4, 0, -1): for j in range(1, n + 1): cIdx = i * n - j v = current[i * n - j] if v != \u0026#34;0\u0026#34;: topIdx[i - 1][0] = cIdx topIdx[i - 1][1] = int(v) break for i in range(0, 4): idx, iNum = topIdx[i] if iNum == 0: continue for j in range(0, 4): if (i == j): continue jNum = topIdx[j][1] if (jNum == 0 or iNum \u0026lt; jNum): # 옮길 수 있는 경우, 가능한 경우 change = changeStr(current, idx, topIdx[j][0], iNum, jNum) if (visited[change] == 0): # 방문하지 않은 경우 nc = plus(count) q.append((change, nc)) visited[change] = nc elif judgeSign(visited[change], visited[current]): # nxt Node가 방문되었고, 출발 방향이 다를때 =\u0026gt; 중간에서 만난 경우 return abs(visited[change]) + abs(visited[current]) - 1 for _ in range(int(input())): n = int(input()) start = [\u0026#34;0\u0026#34;] * n * 4 end = [\u0026#34;0\u0026#34;] * n * 4 for i in range(4): t1 = list(map(int, input().split())) for j in range(t1[0]): start[i * n + j] = str(t1[j + 1]) for i in range(4): t1 = list(map(int, input().split())) for j in range(t1[0]): end[i * n + j] = str(t1[j + 1]) start = \u0026#34;\u0026#34;.join(start) end = \u0026#34;\u0026#34;.join(end) if start == end: print(0) continue visited = defaultdict(lambda: 0) visited[start] = 1 visited[end] = -1 answer = bfsWithBidir() print(answer) Reference 프로그래밍 대회에서 배우는 알고리즘 문제 해결 전략 (구종만, 인사이트) https://www.algospot.com/ ","permalink":"https://2taezeat.github.io/posts/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EB%AC%B8%EC%A0%9C-%ED%95%B4%EA%B2%B0-%EC%A0%84%EB%9E%B5/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EB%AC%B8%EC%A0%9C-%ED%95%B4%EA%B2%B0-%EC%A0%84%EB%9E%B5-ch29.-%EA%B7%B8%EB%9E%98%ED%94%84/","summary":"29. 그래프의 너비 우선 탐색 29.1 도입 28.1.1 너비 우선 탐색(Breadth First Search) 너비 우선 탐색은 시작점에서 가까운 정점(Node)부터 순서대로 방문하는 탐색 알고리즘\n시작 노드에서 출발해 시작 노드를 기준으로 가까운 노드를 먼저 방문하면서 탐색하는 알고리즘\n각 정점을 방문할 때 마다 모든 인접 정점들을 검사\n이 중 처음 보는 정점을 발견하면, 이 정점을 방문 예정이라고 기록, 큐에 저장\n너비 우선 탐색의 방문 순서는 정점을 먼저 꺼내는지에 의해 결정\n이를 구현하는 방법은 목록에 먼저 넣은 정점을 항상 먼저 꺼내는 것","title":"[알고리즘 문제 해결 전략] ch29. 그래프"},{"content":"28. 그래프의 깊이 우선 탐색 28.1 도입 탐색(search) 알고리즘: 트리의 순회와 같이 그래프의 모든 정점들을 특정헌 순서에 따라 방문하는 알고리즘들 정점들을 정해진 순서대로 둘러보기 위한 알고리즘, 순회 알고리즘 탐색 과정에서 얻는 정보가 아주 중요 탐색 과정에서 어떤 간선이 사용되었는지, 또 어떤 순서로 정점들이 방문되었는지를 통해 그래프의 구조를 알 수 있다. 28.1.1 깊이 우선 탐색(depth-first search) 깊이 우선 탐색(depth-first search, DFS) 는 그래프의 모든 정점을 발견하는 가장 단순하고 고전적인 방법\n깊이 우선 탐색은 그래프의 시작 노드에서 출발하여 탐색할 한 쪽 분기를 정하여 최대 깊이까지 탐색을 마친 후, 다른 쪽 분기로 이동하여 다시 탐색을 수행하는 알고리즘.\n현재 정점과 인접한 간선들을 하나씩 검사하다가, 아직 방문하지 않은 정점으로 향하는 간선이 있다면 그 간선을 무조건 따라간다.\n이 과정에서 더이상 갈 곳이 없는 막힌 정점에 도달하면 포기하고, 마지막에 따라왔던 간선을 따라 뒤로 돌아간다.\n탐색의 각 과정에서 가능한 한 그래프 안으로 \u0026lsquo;깊이\u0026rsquo; 들어가려고 시도하며, 막힌 정점에 도달하지 않는 한 뒤로 돌아가지 않는다.\n더 따라갈 간선이 없을 경우 이전으로 돌아간다.\n지금까지 방문한 정점들을 모두 저장(기록) 해야 한다.\n재귀 호출을 이용하면 이와 같은 일을 간단히 할 수 있게 된다.\n\u0026lsquo;기본\u0026rsquo; 적인 재귀, dfs 코드\n얼마든지 문제에 따라 변형 할 수 있어야 한다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 N = 10 visited = [False for _ in range(N)] graph = [[] for _ in range(N)] result = [] # 방문 순서 def dfs(node): visited[node] = True nxtLst = graph[node] for nxt in nxtLst: if not visited[nxt]: dfs(nxt) # 더 이상 방문할 정점이 없으니, 재귀 호출을 종료하고 이전 정점으로 돌아간다. result.append(node) # 여기서 result는 전역 변수이고, mutable (list) 이다. def dfsAll(): for startNode in range(N): # 모든 정점을 순회하면서, 아직 방문한 적이 없으면 방문한다. if not visited[startNode]: dfs(startNode) dfsAll() \u0026lsquo;기본\u0026rsquo; 적인 반복문, dfs 코드 1 2 3 4 5 6 7 8 9 10 11 12 13 vi = set() path = [] def dfsLoop(startNode): stack = [startNode] while stack: nxt = stack.pop() if nxt not in vi: vi.add(nxt) path.append(nxt) for w in graph[nxt]: stack.append(w) 그래프에서는 모든 정점들이 간선을 통해 연결되어 있다는 보장이 없기 때문에, dfs() 만으로는 모든 정점을 순서대로 발견한다는 목적에 부합하지 않는다.\ndfsAll()로 모든 그래프 조각을 발견(탐색)한다.\n깊이 우선 탐색은 그래프 전체의 구조를 파악하기 위해 사용,\n그래프의 구조상 한 번에 모든 정점을 다 볼 수 없는 경우에도 모든 정점을 다 방문할 필요가 있다. =\u0026gt; dfsAll() 28.1.2 깊이 우선 탐색의 시간 복잡도 인접 리스트의 경우\ndfs()는 한 정점마다 수행되므로, 정확히 V번 호출\n모든 정점(V)에 대해 dfs()를 수행하고 나면 모든 간선(E)을 정확히 한 번(방향 그래프의 경우) 혹은 두 번(무향 그래프) 확인함\n따라서 깊이 우선 탐색의 시간 복잡도는 O(V+E)\n인접 행렬을 사용하는 경우에도 dfs()의 호출 횟수는 V번\n하지만, 인접 행렬을 사용할 때는 dfs() 내부에서 다른 모든 정점을 순회하며 두 정점 사이에 간선이 있는가를 확인해야 함 한 번의 dfs() 실행에 O(V)의 시간이 든다 따라서 인접 행렬의 경우 전체 시간 복잡도는 O(V^2) 이다. 28.1.3 위상 정렬 위상 정렬은 의존성이 있는 작업들이 주어질 때, 이들을 어떤 순서로 수행해야 하는지 계산해 준다.\n위상 정렬의 결과는 항상 같지 않다. 구현 방법에 따라 달라진다. 각 작업들을 정점으로 표현하고, 작업 간의 의존 관계를 간선으로 표현한 방향 그래프를 의존성 그래프(dependency graph) 라고 한다.\n의존성 그래프는 그래프에 사이클이 없다. 이 그래프는 사이클이 없는 방향 그래프(DAG) 가 된다. 의존성 그래프의 정점들을 일렬로 늘어놓고, 왼쪽에서부터 하나씩 수행한다고 하자\n이때 모든 의존성이 만족되려면 모든 간선이 왼쪽에서 오른쪽으로 가야 한다. 이렇게 DAG의 정점을 배열하는 문제를 위상 정렬(topological sort) 이라고 한다. 위상 정렬을 구현하는 방법은 dfsAll()을 수행하며 dfs()가 종료할 때마다 현재 정점의 번호를 기록하는 것\ndfsAll() 이 종료한 뒤 기록된 순서를 뒺비으면 위상 정렬 결과를 얻을 수 있다. dfs()가 늦게 종료한 정점일 수록 정렬 결과의 앞에 온다. dfs가 아닌 queue 를 이용한 위상 정렬\n입력 차수, 진입 차수 (In-degree): 방향 그래프에서 한 정점으로 들어오는 간선의 수 출력 차수, 진출 차수 (Out-degree): 방향 그래프에서 한 정점에서 나가는 간선의 수 차수 (degree): 한 정점에서 인접한 간선의 수 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 graph = [[] for _ in range(N)] # 인접 리스트 result = [] indegree = [0] * N # 진입 차수 리스트 q = deque() for i in range(M): S, E = map(int, input().split()) graph[S].append(E) indegree[E] += 1 # 진입 차수 데이터 저장 for i in range(N): if indegree[i] == 0: q.append(i) # 진입 차수 리스트의 값이 0인 노드를 큐에 삽입 while q: # 큐가 빌때 까지, 위상 정렬 수행 now = q.popleft() result.append(now) for nxt in graph[now]: indegree[nxt] -= 1 if indegree[nxt] == 0: q.append(nxt) print(result) 28.2, 28.3 고대어 사전, DICTIONARY, 난이도: 하 각 알파벳을 정점으로 표현, 한 알파벳이 다른 알파벳 앞에 와야 할 때 두 정점을 방향 간선으로 연결 우리가 원하는 알파벳 순서는 이 그래프를 위상 정렬 한 결과 인접한 단어들만 검사하더라도 그래프의 위상 정렬 결과는 모든 단어 쌍을 검사했을 때와 같다. 단어 A, B, C가 순서대로 등장한다면, (A, C)는 검사하지 않고, (A, B), (B, C)쌍 만 검사해도 된다. 그래프가 DAG면 빈 리스트 반환 / 아니면, 위상 정렬 결과 반환 28.7 이론적 배경과 응용 28.7.1 깊이 우선 탐색과 간선의 분류 DFS를 수행하면, 그 과정에서 그래프의 모든 간선을 한 번씩 만나게 된다.\n일부 간선은 처음 발견한 정점으로 따라가고, 나머지는 무시하게 된다.\n그러나 이 간선들을 무시하지 않고 이들에 대한 정보를 수집하면 그래프의 구조에 대해 많은 것을 알 수 있다. 탐색이 따라가는 간선들만 모아 보면 트리 형태를 띠게 된다.\n이런 트리를 주어진 그래프의 DFS 스패닝 트리(DFS Spanning Tree) 라고 부른다. DFS 스패닝 트리를 생성하면, 그래프 중 모든 간선을 네 가지 중 하나로 분류 할 수 있다. 간선 분류\n트리 간선(tree edge): 스패닝 트리에 포함된 간선\n순방향 간선(forward edge): 스패닝 트리의 선조에서 자손으로 연겨되지만 트리 간선이 아닌 간선\n역방향 간선(back edge): 스패닝 트리의 자손에서 선조로 연결되는 간선\n교차 간선(cross edge): 1.2.3번 3가지 를 제외한 나머지 간선들,\n교차 간선은 트리에서 선조와 자손 관계가 아닌 정점들 간에 연결된 간선들을 의미 그래프의 간선을 항상 4가지 중 하나로 분류해야 하는 것은 아니다.\n깊이 우선 탐색이 어느 순서대로 정점을 방문하느냐(실제 구현 방법)에 따라 서로 다른 트리가 생성될 수 있다.\n무향 그래프 간선의 분류\n무향 그래프는 교차 간선, 순방향, 역방향 간선의 구분이 있을 수 없다. 28.7.2 사이클 존재 여부 확인 간선 구분 의 사용 예시, 방향 그래프에 사이클이 존재하는지 여부를 판정 \u0026lsquo;사이클의 존재 여부\u0026rsquo;는 \u0026lsquo;역방향 간선 존재 여부\u0026rsquo; 와 동치 사이클에 포함된 정점 중 dfs 에서 처음 만나는 정점을 u라고 할 때, dfs(u)는 u에서 갈 수 있는 정점들을 모두 방문한 후에야 종료한다. 따라서, dfs는 사이클에서 u 이전에 있는 정점을 dfs(u)가 종료하기 전에 방문하게 되는데, 이 정점에서 u로가는 정점은 항상 역방향 간선이 된다. 28.7.3 간선 구분하는 방법 정점이 방문할 때 이 정점이 방문되었다는 사실 뿐만 아니라, 이 정점이 몇 번째로 발견되었는지도 동시에 기록\n탐색 과정에서 각 정점을 몇 번째로 발견했는지를 배열 discovered[] 에 저장\n(u, v)가 순방향 간선 이려면, v는 u의 자손, 따라서 v는 u보다 더 늦게 발견되어야 한다. (u, v)가 역방향 간선 이려면 v는 u의 선조, 따라서 v는 u보다 일찍 발견되어야 한다. (u, v)가 교차 간선 이려면, dfs(v)가 종류한 후 dfs(u)가 호출되어야 한다. 따라서 v는 u보다 일찍 발견되어야 한다. 이처럼 발견 순서 정보를 이용하면 해당 간선이 순방향 간선인지를 알아낼 수 있다.\n반면 v가 u보다 먼저 방문되었다면 v가 u의 부모인지 아닌지를 구분할 방법이 없다.\n이때 구분하는 한 가지 방법은 dfs(v)가 종료햇는지를 확인하는 것\ndfs(v)가 아직 종료하지 않았다면 v는 u의 선조 및 (u, v)는 역뱡향 간선\n아니면 교차 간선\n간선을 구분하는 깊이 우선 탐색 알고리즘 python 구현\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 N = 10 discovered = [-1 for _ in range(N)] # i번 정점의 발견 순서 finished = [False for _ in range(N)] # dfs가 종료했으면 True 아니면 False graph = [[] for _ in range(N)] result = dict() counter = 0 # 지금까지 발견한 정점의 수 def dfsForEdgesType(node): global counter counter += 1 discovered[node] = counter # 발견 순서 기록 nxtLst = graph[node] for nxt in nxtLst: if discovered[nxt] == -1: result[node] = \u0026#34;tree edge\u0026#34; dfsForEdgesType(nxt) elif discovered[node] \u0026lt; discovered[node]: result[node] = \u0026#34;forward edge\u0026#34; elif not finished[nxt]: result[node] = \u0026#34;backward edge\u0026#34; else: result[node] = \u0026#34;cross edge\u0026#34; finished[node] = True 28.7.3 예제: 절단점 찾기 알고리즘 그래프의 절단점(cut vertex) 를 찾는 문제 - DFS를 이용해서 풀 수 있는 응용 문제 중 하나\n무향 그래프의 절단점: 인접한 간선들을 모두 지웠을 때 해당 컴포넌트가 두 개 이상으로 나뉘어지는 정점을 말한다.\n1, 3, 5번이 절단점이 된다. 어떤 정점이 절단점인지 확인하는 간단한 방법은 해당 정점을 그래프에서 삭제한 뒤, 컴포넌트의 개수가 이전보다 늘어났는지를 확인하는 것\n모든 정점의 절단점 여부를 확인하려면, 깊이 우선 탐색을 V번 수행\n그러나 탐색 과정에서 얻는 정보를 잘 이용하면 한 번의 깊이 우선 탐색만으로 그래프의 모든 절단점을 찾을 수 있다.\n​\n임의의 정점에서 DFS를 수행해 DFS 스패닝 트리를 얻는다.\n어떤 정점 u 가 절단점인지 알 수 있는 방법\n그래프가 쪼개지지 않는 유일한 경우는 그림 처럼 u의 선조와 자손들이 전부 역뱡향 간선으로 연결되어 있을 때 뿐이다. 이것을 확인하는 방법은 DFS를 수행하는 dfs2()가 각 정점을 루트로 하는 서브트레엇 역뱡향 간선을 통해 갈 수 있는 정점의 최소 깊이를 반환하도록 하는 것 만약 u의 자손들이 모두 역방향 간선을 통해 u의 선조로 올라갈 수 있다면 u는 절단점이 아니다. u가 스패닝 트리의 루트라서 선조가 없다면 어떻게 될까?\nu는 무조건 절단점이라고 생각하기 쉽지만, 간과하기 쉬운 예외가 있다. 바로 자손이 하나도 없거나 하나밖에 없는 경우다. 이 경우 u가 없어져도 그래프는 쪼개지지 않는다. 따라서 u가 루트인 경우 둘 이상의 자손을 가질 때만 절단점이 된다. 실제로 이 알고리즘을 구현할 때는 각 정점의 깊이를 비굔하는 대신, 각 정점의 발견 순서를 비교하는 형태로 코드를 작성해 간단히 구현할 수 있다.\n알고 싶은 것은 해당 서브트리가 u의 조상 중 하나와 연결되어 있는지인데, u의 조상들은 항상 u보다 먼저 발견된다. 따라서, 깊이 우선 탐색 함수가 해당 정점을 루트로 하는 서브트리에서 역방향 간선을 통해 닿는 정점들의 최소 발견 순서를 반환하면 된다. 무향 그래프에서 절단점을 찾는 알고리즘 python 구현\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 N = 10 discovered = [-1 for _ in range(N)] # i번 정점의 발견 순서 finished = [False for _ in range(N)] # dfs가 종료했으면 True 아니면 False isCutVertex = [False for _ in range(N)] # True면 절단점 graph = [[] for _ in range(N)] result = dict() counter = 0 # 지금까지 발견한 정점의 수 # node를 루트로 하는 서브트리에 있는 절단점들을 찾는다 # 반환 값은 해당 서브트리에서 역방향 간선으로 갈 수 있는 정점 중, 가장 일찍 발견된 정점의 발견 시점 # 처음 호출 할때는 isRoot = True 로 둔다. def findCutVertex(node, isRoot): global counter counter += 1 discovered[node] = counter ret = discovered[node] children = 0 nxtLst = graph[node] for nxt in nxtLst: if discovered[nxt] == -1: children += 1 # 루트인 경우의 절단점 판정을 위해 자손 서브트리의 개수를 샌다. subTreeMaxNode = findCutVertex(nxt, False) # 서브 트리에서 갈 수 있는 가장 높은 정점의 번호 ret = min(ret, subTreeMaxNode) if not isRoot and subTreeMaxNode \u0026gt;= discovered[node]: # 그 노드가 자기 자신의 이하에 있다면 현재 위치는 절단점이다. isCutVertex[node] = True else: ret = min(ret, discovered[nxt]) if isRoot: isCutVertex[node] = (children \u0026gt;= 2) # 루트인 경우 절단점 판정은 서브트리의 개수 return ret 무향 그래프에서 절단점을 포함하지 않는 서브 그래프를 이중 결합 컴포넌트(biconnected component) 라고 부른다.\nReference 프로그래밍 대회에서 배우는 알고리즘 문제 해결 전략 (구종만, 인사이트) https://www.algospot.com/ ","permalink":"https://2taezeat.github.io/posts/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EB%AC%B8%EC%A0%9C-%ED%95%B4%EA%B2%B0-%EC%A0%84%EB%9E%B5/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EB%AC%B8%EC%A0%9C-%ED%95%B4%EA%B2%B0-%EC%A0%84%EB%9E%B5-ch28.-%EA%B7%B8%EB%9E%98%ED%94%84/","summary":"28. 그래프의 깊이 우선 탐색 28.1 도입 탐색(search) 알고리즘: 트리의 순회와 같이 그래프의 모든 정점들을 특정헌 순서에 따라 방문하는 알고리즘들 정점들을 정해진 순서대로 둘러보기 위한 알고리즘, 순회 알고리즘 탐색 과정에서 얻는 정보가 아주 중요 탐색 과정에서 어떤 간선이 사용되었는지, 또 어떤 순서로 정점들이 방문되었는지를 통해 그래프의 구조를 알 수 있다. 28.1.1 깊이 우선 탐색(depth-first search) 깊이 우선 탐색(depth-first search, DFS) 는 그래프의 모든 정점을 발견하는 가장 단순하고 고전적인 방법\n깊이 우선 탐색은 그래프의 시작 노드에서 출발하여 탐색할 한 쪽 분기를 정하여 최대 깊이까지 탐색을 마친 후, 다른 쪽 분기로 이동하여 다시 탐색을 수행하는 알고리즘.","title":"[알고리즘 문제 해결 전략] ch28. 그래프"},{"content":"27. 그래프의 표현과 정의 27.1 도입 그래프(graph)는 현실 세계의 사물이나 추상적인 개념 간의 연결 관계를 표현한다. 트리에 있었던 부모 자식 관계에 관한 제약이 없기 때문에 그래프는 트리보다 다양한 구조를 표현할 수 있다. 트리도 그래프 중 하나 27.1.1 그래프의 정의 그래프 G(V, E)는 어떤 자료나 개념을 표현하는 정점(vertex, node)의 집합 V와 이들을 연결하는 간선(edge)들의 집합 E로 구성된 자료구조 이다. 그래프는 정점들과 간선들로 정의되며, 정점의 위치 정보나 간선의 순서 등은 그래프의 정의에 포함되지 않는다. 아래 그래프들은 모두 같은 그래프를 표현한다. 27.1.2 그래프의 종류 방향 그래프(directed graph) or 유향 그래프\n방향 그래프에서는 각 간선이 방향이라는 새로운 속성을 갖는다. u -\u0026gt; v 와 v-\u0026gt; u 는 서로 다른 간선이다. 무향 그래프\n간선에 방향이 없는 그래프 가중치 그래프(weighted graph)\n각 각선에 가중치(weight)라고 불리는 실수 속성을 부여 다중 그래프(multigraph)\n두 정점 사이에 두 개 이상의 간선이 있을 수 있는 그래프 단순 그래프\n두 정점 사이에 최대 한 개의 간선만 있는 그래프 트리 or 루트 없는 트리(unrooted tree)\n부모 자식 관계가 없을 뿐, 간선 들의 연결 관계만 보면 트리와 같은 무향 그래프를 말한다. 간선들의 연결 관계가 트리와 같다는 말은, 간선을 통해 두 정점을 잇는 방법이 딱 하나밖에 없다는 의미 이분 그래프(bipartite graph)\n그래프의 정점들을 겹치지 않는 두 개의 그룹으로 나눠서 서로 다른 그룹에 속한 정점들 간에만 간선이 존재하도록 만들 수 있는 그래프 Ex) 남성과 여성 사이클 없는 방향 그래프(directed acyclic graph, DAG)\n방향 그래프인데, 한 점에서 출발해 자기 자신으로 돌아오는 경로(사이클) 가 존재하지 않는 경우 간선의 방향을 무시할 경우 DAG에는 사이클이 존재할 수도 있다. 27.1.3 그래프의 경로 경로(path): 끝과 끝이 서로 연결된 간선들을 순서대로 나열 한 것 주로, 거쳐 가는 정점의 번호만을 간단히 써서 표기함 (1, 2), (2, 4), (4, 5) === 1 -\u0026gt; 4 -\u0026gt; 5 방향 그래프의 경우 앞 간선의 끝점이 뒷 간선의 시작점과 만나야 한다 경로 중 한 정점을 최대 한 번만지나는 경로를 단순 경로(simple path) 라고 한다. 현대 그래프 이론에서는 \u0026lsquo;경로\u0026rsquo; 라고 하면 대부분은 \u0026lsquo;단순 경로\u0026lsquo;를 의미한다. 한 정점을 두 번 이상 지날 수 있는 경로를 이야기 할 대는 별도로 이 사실을 명시한다. 시작한 점에서 끝나는 경로를 사이클 라고 한다. 사이클(cycle): 시작점과 끝나는 점이 같은 경로 27.2 그래프의 사용 예 현실 세계의 수 많은 문제를 풀기 위해 그래프가 사용된다. 철도망의 안전성 분석 소셜 네트워크 분석 인터넷 전송 속도 계산 한 붓 그리기 주어진 그래프의 모든 간선을 한 번씩만 지나는 경로: 오일러 경로(Eulerian path) 외환 거래 27.3 암시적 그래프 구조들 현실 세계에서 그래프 같은 형태를 갖는 구조가 아니라도 그래프를 통해서 표현하면 쉽게 해결 할 수 있는 문제\n이 같은 그래프 구조를 암시적 그래프(implicit graph) 라고 한다. Ex) 2차원 board에서 미로 최단 경로 찾기 할 일 목록 정리\n위상 정렬(topological sorting), DFS를 응용 15-퍼즐\n게임판 덮기\n회의실 배정\n만족성 문제(satisfiability problem) 모든 사람이 두 선택지 중 하나를 선택해야 하는 문제: 2-SAT 문제 27.4 그래프의 표현 방법 많은 경우 그래프는 트리에 비해 정적인 용도로 사용된다. 보다 정적이라는 말은 새로운 정점이나 간선을 추가, 삭제 하는 일이 자주 일어나지 않는다는 의미 따라서 대부분의 그래프는 구조의 변경이 어렵더라도 좀 더 간단하고 메모리를 적게 차지하는 방법으로 구현된다. 그래프의 정점(node)들을 객체의 인스턴스로 표현하는 대신(트리 방식), 각 정점에 0부터 시작하는 번호를 붙이고, 배열에 각 정점의 정보를 저장하는 것 그래프의 표현 방식은 간선(edge)의 정보를 어떤 식으로 저장하는냐에 따라 크게 2가지로 나눈다. 이 두 가지 방법은 표현 방법은 메모리나 시간 사용 특성이 굉장히 다르다. 27.4.1 인접 리스트 (adjacency list) 표현 그래프의 각 정점 마다 해당 정점에서 나가는 간선의 목록을 저장해서 그래프를 표현\n각 정점(node)마다 하나의 연결 리스트를 갖는 방식으로 구현\n노드 중심\nadjacent[i]: 정점 i와 간선을 통해 연결된 정점들의 번호를 저장하는 연결 리스트\n실제로는 이 리스트에 정보를 추가, 삭제 할 일이 많지 않기 때문에 동적 배열을 사용해도 좋다 무방향 그래프(Undirected Graph)에서 (a, b) 간선은 두 번 저장된다.\n한 번은 a 정점에 인접한 간선을 저장하고 다른 한 번은 b에 인접한 간선을 저장한다. 정점의 수: N, 간선의 수: E인 무방향 그래프의 경우 N개의 리스트, N개의 배열, 2E개의 노드가 필요 0: 1 1: 2 2: 0, 3 3: 2 4: 6 5: 4 6: 5 장점\nO(V+E) 크기의 메모리 공간을 사용 어떤 노드에 인접한 노드들을 쉽게 찾을 수 있다. 단점\n간선 (u, v)가 존재하는 확인하기 위해서는 연결 리스트 (adjacent[i])를 처음 부터 읽어가면서 각 원소를 일일이 확인해야 한다 간선의 존재 여부와 정점의 차수: 정점 i의 리스트에 있는 노드의 수 즉, 정점 차수만큼의 시간이 필요 27.4.2 인접 행렬(adjacency matrix) 표현 인접 리스트 표현의 큰 단점은 두 정점이 주어질 때 이 정점이 연결되어 있는 지를 알기 위해서는 연결 리스트를 일일이 뒤져야 한다는 것\n이와 같은 연산의 속도를 높이기 위해 고안된 그래프 표현 방식이 인접 행렬이다.\n그래프의 인접 행렬은 이름에서 유추할 수 있듯이 |V|x|V| 크기의 행렬 (2차원 배열)을 이용해 간선의 정보를 저장한다.\nadjacent[i][j]: 정점 i에서 정점 j로 가는 간선이 있는지를 나타내는 boolean 값 변수\n가중치 그래프를 인접 행렬로 표현하려면 각 간선의 정보를 boolean 이 아니라, 정수, 실수(가중치 값)로 두면 된다.\n두 정점 사이에 간선이 없는 경우 -1 or inf 로 지정한다. 무방향 그래프를 인접 행렬로 표현한다면 이 행렬은 대칭 행렬(Symmetric Matrix) 이 된다.\n물론 방향 그래프는 대칭 행렬이 안 될 수도 있다 1 2 3 4 if (간선 (i, j)가 그래프에 존재): matrix[i][j] = 1; else matrix[i][j] = 0; 장점\n정점의 번호 u, v가 주어졌을 때, 두 정점을 잇는 간선이 있는지를 한 번의 배열 접근만으로 확인 가능 정점의 차수 는 O(V) 안에 알 수 있다: 인접 배열의 i번 째 행 또는 열을 모두 더한다. 단점\n실제의 간선의 개수와 관계없이 항상 O(V^2) 크기의 메모리 공간을 사용 어떤 노드에 인접한 노드들을 찾기 위해서는 모든 노드를 전부 순회해야 한다. 그래프에 존재하는 모든 간선의 수는 O(V^2) 안에 알 수 있다. : 인접 행렬 전체를 조사한다. 27.4.3 인접 행렬 vs 인접 리스트 서로 완전히 정반대의 특성을 가져서, 한 방식의 단점이 바로 다른 방식의 장점이다. 따라서, 알고리즘, 그래프의 종류에 따라서 2가지 중 적절히 선택해야 한다. 간선의 수가 V^2 에 비해 훨씬 적은 그래프를 희소 그래프(sparse graph) 라고 한다. 인접 리스트를 사용하는 것이 유리 반대로, 간선의 수가 거의 V^2에 비례하는 그래프를 밀집 그래프(dense graph) 라고 한다. 인접 행렬을 사용하는 것이 유리 27.4.4 에지 리스트(Edge List) 간선, edge를 중심으로 그래프를 표현 에지 리스트는 리스트에 출발 노드, 도착 노드를 저장하여 Edge를 표현 또는 출발 노드, 도착 노드, 가중치를 저장 MST, 벨만-포드, 크루스칼에 주로 사용 노드 중심 알고리즘에는 잘 사용하지 않음. edgeLst = [ (1,2,8), (1,3,3), (3,4,13), (2,4,4), (2,5,15), (4,5,2) ] # 출발, 도착, 가중치 27.4.5 암시적 그래프 표현 그래프를 이용해 푸는 문제라고 해서, 항상 그래프를 직접 메모리에 표현해야 하는 것은 아니다.\n암시적 그래프로 표현 가능\n2차원 board에서 미로 최단 경로 찾기 각 빈칸을 정수 일렬번호를 갖는 정점으로 표현하는 대신, 빈 칸의 위치 (y, x) 로 표현 할 수 있다 주어진 입력을 그래프로 변환하는 번거로운 과정을 거칠 필요 없이 BFS 가능 15-퍼즐 모든 상태(16!===20조) 를 그래프로 표현하는 것은 실용적인 방법이 아니다. 암시적 그래프 표현이 항상 더 좋은 것은 아니다.\n그래프 사용 알고리즘과 변환 과정이 합쳐지게 되면 더 복잡해 질 수 도 있다.\n번거롭더라도 입력을 미리 그래프 표현으로 바꿔 두는 것이 전체 코드를 더 간결하게 할 수 있다.\nReference 프로그래밍 대회에서 배우는 알고리즘 문제 해결 전략 (구종만, 인사이트) https://www.algospot.com/ ","permalink":"https://2taezeat.github.io/posts/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EB%AC%B8%EC%A0%9C-%ED%95%B4%EA%B2%B0-%EC%A0%84%EB%9E%B5/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EB%AC%B8%EC%A0%9C-%ED%95%B4%EA%B2%B0-%EC%A0%84%EB%9E%B5-ch27.-%EA%B7%B8%EB%9E%98%ED%94%84/","summary":"27. 그래프의 표현과 정의 27.1 도입 그래프(graph)는 현실 세계의 사물이나 추상적인 개념 간의 연결 관계를 표현한다. 트리에 있었던 부모 자식 관계에 관한 제약이 없기 때문에 그래프는 트리보다 다양한 구조를 표현할 수 있다. 트리도 그래프 중 하나 27.1.1 그래프의 정의 그래프 G(V, E)는 어떤 자료나 개념을 표현하는 정점(vertex, node)의 집합 V와 이들을 연결하는 간선(edge)들의 집합 E로 구성된 자료구조 이다. 그래프는 정점들과 간선들로 정의되며, 정점의 위치 정보나 간선의 순서 등은 그래프의 정의에 포함되지 않는다.","title":"[알고리즘 문제 해결 전략] ch27. 그래프"},{"content":"26. 트라이 26.1 도입 문자열 변수를 비교하는 데는 최악의 경우 문자열의 길이에 비례하는 시간이 걸릴 수 있다.\n탐색 자료 구조들도 시간이 너무 오래 걸릴 수 있다.\n이와 같은 문제를 해결하기 위해 고안된 문자열 특화 자료 구조: 트라이(Trie)\n집합 내에서 원하는 원소를 찾는 작업을 O(M), M은 문자열의 최대 길이\n트라이는 접두사들에 대응되는 노드들이 서로 연결된 트리\n한 접두사의 맨 뒤에 글자를 덧붙여 다른 접수사를 얻을 수 있을 때, 두 노드는 부모-자식 관계로 연결 트라이의 루트는 항상 길이 0인 문자열에 대응\n노드의 깊이가 깊어질 때마다 대응되는 문자열의 길이가 1씩 늘어난다.\n루트에서 한 노드까지 내려가는 경로에서 만나는 글자들을 모으면 해당 노드에 대응되는 접두사를 얻을 수 있다.\n트라이는 포함하는 문자열들의 모든 접두사에 대응되는 노드들을 가지고 있기 때문에,\n전체 문자열이 아닌 문자열의 첫 일부만을 가지고도 이 문자열로 시작하는 키가 있는지 쉽게 확인 가능 자동 완성을 구현할 때 유용 자손 노드들을 가리키는 포인터 목록을 동적 배열로 구현하는 것이 아니라, 고정 길이 배열로 구현\n알파벳 대문자로만 구성된 문자열을 저장하는 트라이의 각 노드는 각 노드가 26개짜리 포인터 배열을 가지고 있다.\n다음 노드를 찾는 과정에서 어떤 탐색도 필요하지 않다. (고정됨)\n대신, 트라이의 최대 문제는 필요로 하는 공간이 너무 크다는 것\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 class Node(object): def __init__(self, isEnd): self.isEnd = isEnd self.childNode = {} class Trie(object): def __init__(self): self.parent = Node(None) def insert(self, string): # 문자 삽입 nowNode = self.parent temp_length = 0 for char in string: if char not in nowNode.childNode: # 자식 Node들 미생성된 문자열이면 새로 생성 nowNode.childNode[char] = Node(char) nowNode = nowNode.childNode[char] # 자식 노드로 이동 temp_length += 1 if temp_length == len(string): nowNode.isEnd = True def search(self, string): # 문자열이 존재하는지 탐색 nowNode = self.parent temp_length = 0 for char in string: if char in nowNode.childNode: nowNode = nowNode.childNode[char] temp_length += 1 if temp_length == len(string) and nowNode.isEnd == True: return True else: return False else: return False N, M = map(int, input().split()) myTrie = Trie() for _ in range(N): word = input().strip() myTrie.insert(word) result = 0 for _ in range(M): word = input().strip() if myTrie.search(word): result += 1 print(result) 26.1.1 접미사 트리 문자열의 모든 부분 문자열은 결국 어떤 접미사의 접두사이다. 트라이는 저장된 문자열의 모든 접두사들을 저장한다. 접미사 트라이는 이 문자열의 모든 부분 문자열에 대응되는 노드를 가지고 있다. 따라서, 접미사 트라이에서의 검색을 이용하면 어떤 부분 문자열도 빠르게 찾을 수 있다. 접미사 \u0026lsquo;트라이\u0026rsquo; 는 메모리를 너무 많이 차지 한다. 접미사 트리(suffix tree) 는 이 문제를 해결하기 위해 고안됨 접미사 트라이의 많은 부분은 분기 없이 일자로 구성되어 있다는 것에 착안 각 간선이 문자열의 한 글자가 아니라 여러 글자에 대응되도록 한다. 실질적으로 트리 상 긴 일자 경로를 압축하는 효과 26.2, 26.3 안녕히, 그리고 물고기, SOLONG, 난이도: 중 Reference 프로그래밍 대회에서 배우는 알고리즘 문제 해결 전략 (구종만, 인사이트) https://www.algospot.com/ ","permalink":"https://2taezeat.github.io/posts/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EB%AC%B8%EC%A0%9C-%ED%95%B4%EA%B2%B0-%EC%A0%84%EB%9E%B5/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EB%AC%B8%EC%A0%9C-%ED%95%B4%EA%B2%B0-%EC%A0%84%EB%9E%B5-ch26.-%ED%8A%B8%EB%A6%AC/","summary":"26. 트라이 26.1 도입 문자열 변수를 비교하는 데는 최악의 경우 문자열의 길이에 비례하는 시간이 걸릴 수 있다.\n탐색 자료 구조들도 시간이 너무 오래 걸릴 수 있다.\n이와 같은 문제를 해결하기 위해 고안된 문자열 특화 자료 구조: 트라이(Trie)\n집합 내에서 원하는 원소를 찾는 작업을 O(M), M은 문자열의 최대 길이\n트라이는 접두사들에 대응되는 노드들이 서로 연결된 트리\n한 접두사의 맨 뒤에 글자를 덧붙여 다른 접수사를 얻을 수 있을 때, 두 노드는 부모-자식 관계로 연결 트라이의 루트는 항상 길이 0인 문자열에 대응","title":"[알고리즘 문제 해결 전략] ch26. 트리"},{"content":"25. 상호 배타적 집합 25.1 도입 유니온-파인드(Union-Find) 라는 트리 자료구조로 상호 배타적 집합(disjoint set)을 표현할 수 있다. 25.1.1 상호 배타적 집합 공통 원소가 없는, 상호 배타적인 부분 집합들로 나눠진 원소들에 대한 정보를 저장, 조작하는 자료구조가 유니온-파인드 자료구조 이다. 연산 초기화(init): n개의 원소가 각각의 집합에 포함되어 있도록 초기화 합치기(union): 두 원소 a,b 가 주어질 때 이들이 속한 두 집합을 하나로 합침 찾기(find): 어떤 원소 a가 주어질 때 이 원소가 속한 집합을 반환 25.1.2 배열로 상호 배타적 집합 표현 상호 배타적 집합을 표현하는 가장 간단한 방법: 1차원 배열 belongsTo[i] = i번 원소가 속하는 집합의 원소 문제 상황: 찾기 연산은 O(1)이지만, 합치기 연산은 O(N) 이다. 넣음찾기 연산이 조금 오래 걸리더라도, 합치기 연산을 빠르게 할 수 없을까? 25.1.3 트리를 이용한 상호 배타적 집합 표현 한 집합에 속하는 원소들을 하나의 트리로 묶어 준다.\n따라서, 상호 배타적 집합 자료구조는 트리들의 집합으로 표현된다.\n이때, 두 원소가 같은 트리에 속해 있는 지 확인하는 직관적인 방법은 원소가 포함된 트리의 루트를 찾은 뒤 이들이 같은지 비교하는 것\n트리와 루트는 항상 1:1 대응되기 때문에, 루트가 같다면 두 노드가 같은 트리에 속해 있다.\n따라서, 트리의 루트에 있는 원소(루트 값)를 각 집합의 대표라고 부르자.\n이런 연산을 구현 하기 위해서는, 모든 자식 노드가 부모에 대한 포인터를 가지고 있어야 한다.\n부모는 자식으로 내려갈 일이 없기 때문에 부모는 자식에 대한 포인터를 가질 필요가 없다. 루트는 부모가 없으므로, 대게 자기 자신을 가리키도록 구현 간단해진 합치기 연산: 각 트리의 루트를 찾은 뒤, 하나를 다른 한쪽의 자손으로 넣으면 된다.\n합치기, 찾기 연산의 시간복잡도 모두: 트리의 높이에 비례 25.1.4 상호 배타적 집합의 최적화 문제 상황 1: 트리를 사용하면, 연산의 순서에 따라 트리가 한쪽으로 기울어진다.\n기울어지면, 찾기, 합치기 연산모두 O(N)으로 되어버림 배열로 구현한것 보다 오히려 더 효율이 나빠져 버림 해결, 최적화 방법: 항상 높이가 더 낮은 트리를 더 높은 트리 밑에 집어넣음으로써 트리의 높이가 높아지는 상황을 방지\n=\u0026gt; 랭크에 의한 합치기 (union-by-rank) 최적화\n합치기, 찾기 연산 시간복잡도 모두 O(logN)\n기존 O(N)에서 계선 됨\n문제 상황 2: 찾기 연산이 중복된 연산을 여러 번 하고 있다.\n해결, 최적화 방법: 경로 압축(path compression) 최적화\nfind(u) 를 통해 u가 속하는 트리의 루트를 찾았을 때, parent[u] 를 찾아낸 루트로 아예 바꿔 버리면 다음 번에 find(u) 를 호출할 때, 경로를 따라 올라 갈 것 없이 바로 루트를 찾을 수 있게 된다. 재귀적으로 find() 를 구현\n재귀적인 구현 덕분에 find(u)를 호출하면 u에서 루트까지 올라가는 경로 상에 있는 모든 노드들에도 경로 압축 최적화 가 자동으로 수행 시간 복잡도\n수행 시간 분석하기 아주 까다로움, 분할 상환 분석 등 이용해야 함. 현실적인 입력에 대해, 합치기, 찾기 연산 모두 상수 시간에 동작한다고 봐도 무방 25.1.5 상호 배타적 집합이 사용되는 경우 그래프의 연결성 확인\n그래프의 노드들이 서로 왕래가 가능한지 알고 싶을 때\n서로 왕래가 가능한 도시들을 하나의 집합으로 표현\n가장 큰 집합 추적하기\n각 집합에 속한 원소의 수를 추적 size[] 배열을 추가 한 뒤, 두 집합이 합쳐질 때 마다 이 값을 갱신 집합들이 합쳐지는 과정에서, 가장 큰 집합의 크기가 어떻게 변하는지 추적 가능 25.2 유니온-파인드 Python 코드 구현 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 global parent def init(): parent = [0 for _ in range(N + 1)] for i in range(0, N + 1): parent[i] = i def find(a): if a == parent[a]: return a else: parent[a] = find(parent[a]) return parent[a] def union(a, b): # union 연산, 대표 노드끼리 합치기 a = find(a) b = find(b) if a != b: parent[b] = a for i in range(M): # solution q, a, b = map(int, input().split()) if q == 0: union(a, b) elif q == 1: if find(a) == find(b): print(\u0026#34;YES\u0026#34;) else: print(\u0026#34;NO\u0026#34;) Reference 프로그래밍 대회에서 배우는 알고리즘 문제 해결 전략 (구종만, 인사이트) https://www.algospot.com/ ","permalink":"https://2taezeat.github.io/posts/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EB%AC%B8%EC%A0%9C-%ED%95%B4%EA%B2%B0-%EC%A0%84%EB%9E%B5/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EB%AC%B8%EC%A0%9C-%ED%95%B4%EA%B2%B0-%EC%A0%84%EB%9E%B5-ch25.-%ED%8A%B8%EB%A6%AC/","summary":"25. 상호 배타적 집합 25.1 도입 유니온-파인드(Union-Find) 라는 트리 자료구조로 상호 배타적 집합(disjoint set)을 표현할 수 있다. 25.1.1 상호 배타적 집합 공통 원소가 없는, 상호 배타적인 부분 집합들로 나눠진 원소들에 대한 정보를 저장, 조작하는 자료구조가 유니온-파인드 자료구조 이다. 연산 초기화(init): n개의 원소가 각각의 집합에 포함되어 있도록 초기화 합치기(union): 두 원소 a,b 가 주어질 때 이들이 속한 두 집합을 하나로 합침 찾기(find): 어떤 원소 a가 주어질 때 이 원소가 속한 집합을 반환 25.","title":"[알고리즘 문제 해결 전략] ch25. 트리"},{"content":"24. 구간 트리 24.1 구간 트리: 구간에 대한 질문 대답하기 이제 까지 다룬 트리들은 모두 자료들을 특정 순서대로 저장, 추가, 삭제하는 등 자료를 저장하는 용도로 사용 구간 트리(segment tree) 는 저장된 자료들을 적절히 전처리해 그들에 대한 질의들을 빠르게 대답할 수 있도록 한다. 흔히 일차원 배열의 특정 구간에 대한 질문을 빠르게 대답하는데 사용 ( 일반적인 접근 =\u0026gt; O(N) ) 예시) 구간의 최소치 기본적인 아이디어: 주어진 배열의 구간들을 표현하는 이진 트리를 만든다. 구간 트리의 루트는 배열의 전체 구간 [0, n-1]을 표현 왼쪽, 오른쪽 자식은 각각 해당 구간의 왼쪽 반과 오른쪽 반을 표현 길이가 1인 구간을 표현하는 노드들은 구간 트리의 리프 노드가 된다. 구간 트리는 노드마다 해당 구간에 대한 계산 결과를 저장해 둔다. 이런 전처리 과정을 수행해 두면 어떤 구간 [i, j]가 주어지더라도 이 구간을 구간 트리의 노드에 포함된 구간들의 합집합으로 표현 가능 [6, 12] : [6, 7], [8, 11], [12, 12] 의 합집합 원하는 답은 각 구간의 최소치(미리 계산됨, 이 셋 중의 최소치) 이다. 어떤 구간이 주어지건 간에 답을 찾기 위해 우리가 고려해야 하는 구간의 수는 O(logN)이다. 따라서, O(N) 대신, O(logN) 시간에 질의에 대답할 수 있게 된다. 24.1.1 구간 트리의 표현 구간 최소 쿼리(range minimum query, RMQ): 특정 구간의 최소치 비교적 \u0026lsquo;꽉 찬\u0026rsquo; 이진 트리로 표현 =\u0026gt; 일차원 동적 배열로 표현 가능 루트를 1번으로, i번째 를 부모, 2*i(왼쪽 자손), 2*i+1(오른쪽 자손) 배열의 길이: 가장 가까운 2의 거듭제곱으로 n을 올림한 뒤 2를 곱함 간단하게, n에 4를 곱해도 가능 24.1.2 구간 트리의 초기화 초기화에서 각 노드마다 걸리는 시간은 O(1), 초기화 과정에는 노드의 수와 같은 시간이 걸린다. 배열의 크기가 O(N)임으로, 노드의 수도 O(N)이다. 따라서 초기화 과정의 시간복잡도는 O(N)이다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 // 배열의 구간 최소 쿼리를 해결하기 위한 구간 트리의 구현 struct RMQ{ int n; // 배열의 길이 vector\u0026lt;int\u0026gt; rangeMin; // 각 구간의 최소치 RMQ(const vector\u0026lt;int\u0026gt;\u0026amp; array){ n = array.size(); rangeMin.resize(n * 4); init(array, 0, n-1, 1); } // node 노드가 array[left .. right] 배열을 표현할 때 // node를 루트로 하는 서브트리를 초기화하고, 이 구간의 최소치를 반환한다. int init(const vector\u0026lt;int\u0026gt;\u0026amp; array, int left, int right, int node){ if(left == right) return rangeMin[node] = array[left]; int mid = (left + right) / 2; int leftMin = init(array, left, mid, node * 2); int rightMin = init(array, mid +1, right, node * 2 + 1); return rangeMin[node] = min(leftMin, rightMin); } }; 24.1.3 구간 트리의 질의 처리 query(left, right, node, nodeLeft, nodeRight) =\nnode가 표현하는 범위 [nodeLeft, nodeRight]와 우리가 최소치를 찾기 원하는 구간 [left, right]의 교집합의 최소 원소를 반환하는 함수\nquery는 아래와 같은 3가지 경우에 놓이게 된다. (구간의 최소치를 찾는 질의의 경우)\n교집합이 공집합인 경우 두 구간은 서로 겹치지 않는다. 따라서 반환 값은 존재하지 않는다. 반환 값이 무시되도록 아주 큰 값을 반환. 교집합이 [nodeLeft, nodeRight]인 경우 [left,right]가 노드가 표현하는 집합을 완전히 포함하는 경우 이 노드에 미리 계산해 둔 최소치를 곧장 반환. 이 외의 모든 경우 두 개의 자손 노드에 대해 query()를 재귀 호출한 뒤, 이 두 값 중 더 작은 값을 택해 반환합니다. 24.1.4 구간 트리의 갱신 전처리를 통해 구간 트리를 생성한 다음에, 원래 배열의 값이 바뀐 경우에 대한 갱신(update) 을 진행 원래 배열의 index 위치의 값이 newValue로 바뀌었다고 하자. 이 위치를 포함하는 구간은 트리에 O(logN)개 존재 이들만을 재계산하면 O(logN)시간에 구간트리를 갱신할 수 있습니다. 24.4 트리의 최소 공통 조상 찾기 (LCA), 족보 탐험 문제 두 노드의 최소 공통 조상(least/lowest common ancestor, LCA) 트리에서 두 노드 u,v의 최소 공통 조상(u,v) // LCA(u, v)는 두 노드를 모두 자손으로 갖는 노드 중 가장 아래 있는 노드이다. 24.4.1 트리를 일렬로 펴기 구간 트리는 일렬로 늘어선 배열을 처리하는 자료 구조이므로, 구간 트리를 사용하려면 트리를 쭉 ‘펴서’ 일렬로 만들어야 한다. 구현하는 방법은 트리를 전위 순회하면서 방문하는 노드들을 순서대로 늘어놓는 것 단, 재귀 호출이 끝나고 이전 노드로 돌아오는 것도 노드를 방문하는 것으로 쳐야 한다. 전위 순회 결과 Path = {0, 1, 2, 1, 3, 4, 3, 5, 3, 1, 0, 6, 7, 6, 0, 8, 9, 10, 9, 11, 9, 8, 12, 8, 0}\n이 경로(전체 경로의 길이)의 길이는?\n이 경로는 부모와 자식 간의 각 연결을 정확히 한 번씩 내려가고 한 번씩 올라온다.\n트리에는 항상 n-1개의 연결(edge)이 있으므로, 2n-2번 움직인다.\n루트에서 시작하므로 +1, 전체 경로의 길이는 2n-1이 됩니다.\n어떤 노드 u에서 시작해서 다른 노드 v에서 끝나는 부분 경로를 떼어냈을 때, 이 경로가 방문하는 최상위 노드는 항상 u와 v의 최소 공통 조상이다.\n즉, u와 v는 항상 LCA(u,v)의 서로 다른 서브트리에 포함되어 있다는 점을 이용해 설명 가능\nu를 포함하는 서브트리에서 v를 포함하는 서브트리로 넘어가려면 LCA(u,v)를 거치지 않으면 안 된다.\n따라서 LCA(u,v)는 항상 방문 LCA(u,v)에서 그 부모 노드로 이 경로가 올라가려면, 그 전에 LCA(u,v)를 루트로 하는 서브트리를 모두 돌아본 후여야 한다.\n따라서 LCA(u,v)의 조상 노드들을 u와 v사이에 방문하는 일은 없다. 이 문제는 P에서 u의 위치와 v의 위치가 주어질 때, 이 구간에서 가장 상위에 있는 노드는 무엇인가를 묻는 문제로 접근 가능 24.4.2 특정 구간에서 최상위 노드 찾기 최소 질의를 위한 구간 트리를 사용 상위에 있는 노드일수록 더 작은 번호를 갖도록 각 노드들의 번호를 다시 매긴다. 각 서브트리의 루트에 가장 먼저 번호를 매기기 때문에, 자손들의 번호는 항상 부모의 번호 뒤에 온다. 24.4.3 주어진 문제 풀기 이제 LCA질의는 시간복잡도는 O(logN)으로 해결 가능 두 사람 사이의 경로의 길이는 구하는 방법 u 에서 LCA(u, v) 까지 : depth[u] - depth[LCA(u,v)] LCA(u, v)에서 v까지 : depth[v] - depth[LCA(u,v)] 문제에서 원하는 두 사람 사이의 경로의 길이 depth[u] + depth[v] - 2 * depth[LCA(u,v)] 24.6 펜윅 트리: 빠르고 간단한 구간 합 구간 트리의 가장 흔한 사용 예는 바로 구간 합(prefix sum) 을 빠르게 구하는 것\n이 경우 구간 트리 대신, 펜윅 트리(Fenwick Tree) 혹은 이진 인덱스 트리(binary indexed tree) 라고 불리 우는 것을 사용할 수 있다. 중간에 배열의 원소의 값이 갱신(update) 되어도, O(logN)에 수행할 수 있다.\nch17에서 다룬 부분합 알고리즘을 이용할 수도 있지만, 이 경우 배열의 원소의 갱신(update) 하는 연산에 시간이 오래 걸린다. 구간 합 대신 부분 합(partial sum, psum) 만을 빠르게 계산할 수 있는 자료 구조를 만들어도, 구간 합을 계산할 수 있다는 것\npsum[pos] = A[0] + A[1] + … + A[pos]를 빠르게 구할 수 있으면,\n구간 [i ,j]에 대한 합은 psum[j] - psum[i]로 계산할 수 있다.\n부분 합만을 계산한다고 생각하면, 구간 트리가 미리 계산해 저장하는 정보의 상당수는 필요가 없다.\n하나의 긴 구간 밑에 두 개의 작은 구간이 있을 때, 이 두 구간 중 왼쪽 구간만 필요 (오른쪽은 지워도 된다.) 오른쪽을 지우고, 남은 구간의 갯수는 정확하게 N이다.\nN개의 수에 대한 부분 합을 N개의 숫자에 저장 펜윅 트리는 이 대응을 이용해 1차원 배열 하나에 각 구간의 합을 저장합니다. 배열 tree[]: tree[i] = 그림(b) 에서 오른쪽 끝 위치가 A[i]인 구간의 합 A[pos] 까지의 구간 합 // psum[pos]를 계산하고 싶으면 그림(b)에서 pos에서 끝나는 구간의 합, tree[pos] 를 답에 더한다. 남은 부분들은 왼쪽에서 찾아서 더한다. psum[12] === tree[12] + tree[11] + tree[7] 어떤 부분 합을 구하든 O(logN) 개의 구간 합만 있으면 된다. 24.6.1 펜윅 트리의 구현 https://yoongrammer.tistory.com/104 https://yabmoons.tistory.com/438 https://loosie.tistory.com/647 https://seongmok.com/5 Reference 프로그래밍 대회에서 배우는 알고리즘 문제 해결 전략 (구종만, 인사이트) https://www.algospot.com/ ","permalink":"https://2taezeat.github.io/posts/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EB%AC%B8%EC%A0%9C-%ED%95%B4%EA%B2%B0-%EC%A0%84%EB%9E%B5/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EB%AC%B8%EC%A0%9C-%ED%95%B4%EA%B2%B0-%EC%A0%84%EB%9E%B5-ch24.-%ED%8A%B8%EB%A6%AC/","summary":"24. 구간 트리 24.1 구간 트리: 구간에 대한 질문 대답하기 이제 까지 다룬 트리들은 모두 자료들을 특정 순서대로 저장, 추가, 삭제하는 등 자료를 저장하는 용도로 사용 구간 트리(segment tree) 는 저장된 자료들을 적절히 전처리해 그들에 대한 질의들을 빠르게 대답할 수 있도록 한다. 흔히 일차원 배열의 특정 구간에 대한 질문을 빠르게 대답하는데 사용 ( 일반적인 접근 =\u0026gt; O(N) ) 예시) 구간의 최소치 기본적인 아이디어: 주어진 배열의 구간들을 표현하는 이진 트리를 만든다. 구간 트리의 루트는 배열의 전체 구간 [0, n-1]을 표현 왼쪽, 오른쪽 자식은 각각 해당 구간의 왼쪽 반과 오른쪽 반을 표현 길이가 1인 구간을 표현하는 노드들은 구간 트리의 리프 노드가 된다.","title":"[알고리즘 문제 해결 전략] ch24. 트리"},{"content":"06장. 트리 정리\nch23. 우선운위 큐와 힙 23. 우선운위 큐와 힙 23.1 도입 우선순위 큐 에서는 가장 먼저 입력된 자료가 가장 먼저 꺼내지는 것이 아니라, 우선순위가 가장 높은 자료가 가장 먼저 꺼내진다. 균형 잡힌 이진 검색 트리를 사용해서 우선순위 큐를 구현할 수 있다. 하지만 이는 소 잡는 칼로 닭을 잡는 것과 같다. 휠씬 단순한 구조로도 구현할 수 있다. 힙(heap) 이라는 이진 트리 자료구조로 우선순위 큐를 구현 할 수 있다. 여기서는 최대 힙이라 가정 힙은 대부분의 프로그래밍 언어의 표준 라이브러리에 구현되어 있다. 23.2 힙의 정의와 구현 힙의 대소 관계 규칙: 부모 노드가 가진 원소는 항상 자식 노드가 가진 원소 이상이다. (최대 힙의 경우)\n가장 중요하고 기본적인 규칙 이진 검색 트리와 달리 부모 자식 관계에만 적용 왼쪽, 오른쪽 자식이 갖는 원소의 크기는 제한하지 않는다. 힙의 모양 규칙: 이진 검색 트리에서도 문제가 되었던, 트리가 기울어지는 일을 막음\n마지막 레벨을 제외한 모든 레벨에 노드가 꽉 차 있어야 한다.\n마지막 레벨에 노드가 있을 때는 항상 가장 왼쪽 부터 순서대로 채워져 있어야 한다.\n힙의 높이: O(logN)\n23.2.1 배열을 이용한 힙의 구현 힙이 요구하는 엄격한 모양 규칙은 구현할 때는 장점이다.\n트리에 포함된 노드의 개수만 알면 트리 전체의 구조를 알 수 있기 때문이다.\n동적 배열은 힙에 들어 있는 원소들을 맨 윗 레벨 부터, 왼쪽에서 오른쪽 순서대로 저장한다.\nA[i] 에 대응되는 노드의 왼쪽 자손은 A[2*i+1] 에 대응\nA[i] 에 대응되는 노드의 오른쪽 자손은 A[2*i+2] 에 대응\nA[i] 에 대응되는 노드의 부모는 A[(i-1) / 2 ]에 대응 (나눗셈 결과는 내림)\n23.2.2 새 원소의 삽입(push) 힙에서 새 원소를 삽입(push) 할때는 간단한 방법은 대소 관계 규칙 대신 모양 규칙을 먼저 만족시키는 것이다. 모양 규칙에 의해 새 노드는 항상 heap배열 에 맨 끝에 추가된다. 마직막에 추가한 새 원소를 자신의 부모와 비교 비교 후, 작다면 두 원소의 위치를 바꾼다. 새 원소가 더 크거나 같은 원소를 가진 부모를 만나거나, 루트에 도달할 때까지 이를 반복한다. push(삽입) 의 시간복잡도: 트리의 높이인 O(logN) 23.2.3 최대 원소 꺼내기(pop) 배열을 이용한, 최대 힙에서 최대 원소를 찾는 것은 첫 원소를 확인하면 된다. 매우 간단 문제는, 최대 원소를 힙에서 꺼내는 것(삭제, pop) 이다. 삭제에서도, 삽입과 같이 간단한 방법은 대소 관계 규칙 대신 모양 규칙을 먼저 만족시키는 것이다. 힙의 마지막에 있는 리프 노드를 삭제 마지막 노드에 있던 원소는 루트로 덮어 씌움 두 자식 노드가 가진 원소 중 더 큰 원소를 선택해 루트가 갖고 있는 원소와 맞바꿈. 이 작업을 트리의 바닥에 도달하거나, 두 자손이 모두 자기 자신 이하의 우너소를 갖고 있을 때 까지 반복 pop(삭제) 의 시간복잡도: 트리의 높이인 O(logN) 23.2.4 다른 연산들 힙을 만드는 연산(heapify)\nN개의 원소를 텅 빈 힙에 순서대로 삽입해야 할 때 쓸 수 있다. 원소들을 길이가 N인 배열에 저장한 뒤, heapify 연산을 수행하면, O(N)만에 힙으로 만들어 준다. push( O(logN) ) 연산을 N번 호출하는, O(NlogN)에 비해 빠르지만, 어차피, N개의 원소를 다시 꺼내는 데만도 O(NlogN) 시간이 걸리고, 이것을 프로그램의 수행 시간을 지배해 버리기 때문에 큰 의미는 없다. 힙 정렬(Heapsort)\n힙에서 원소들을 꺼낼 때, 항상 정렬된 순서대로 반환된다는 점을 이용\n배열을 힙으로 만든 뒤, 모든 원소들을 꺼내서 반환 순서대로 배열하면 정렬 결과가 된다.\n이때 힙에서 원소를 하나 꺼내면, 힙을 담은 배열의 맨 뒤쪽이 한 칸 비게 되므로,\n최대 원소를 여기에 옮기면 추가 메모리를 사용하지 않고 정렬 가능 최악의 경우에도 O(NlogN) 의 시간복잡도, 병합 정렬과 달리 추가적인 메모리 요구하지 않음\nReference 프로그래밍 대회에서 배우는 알고리즘 문제 해결 전략 (구종만, 인사이트) https://www.algospot.com/ ","permalink":"https://2taezeat.github.io/posts/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EB%AC%B8%EC%A0%9C-%ED%95%B4%EA%B2%B0-%EC%A0%84%EB%9E%B5/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EB%AC%B8%EC%A0%9C-%ED%95%B4%EA%B2%B0-%EC%A0%84%EB%9E%B5-ch23.-%ED%8A%B8%EB%A6%AC/","summary":"06장. 트리 정리\nch23. 우선운위 큐와 힙 23. 우선운위 큐와 힙 23.1 도입 우선순위 큐 에서는 가장 먼저 입력된 자료가 가장 먼저 꺼내지는 것이 아니라, 우선순위가 가장 높은 자료가 가장 먼저 꺼내진다. 균형 잡힌 이진 검색 트리를 사용해서 우선순위 큐를 구현할 수 있다. 하지만 이는 소 잡는 칼로 닭을 잡는 것과 같다. 휠씬 단순한 구조로도 구현할 수 있다. 힙(heap) 이라는 이진 트리 자료구조로 우선순위 큐를 구현 할 수 있다. 여기서는 최대 힙이라 가정 힙은 대부분의 프로그래밍 언어의 표준 라이브러리에 구현되어 있다.","title":"[알고리즘 문제 해결 전략] ch23. 트리"},{"content":"22. 이진 검색 트리 22.1 도입 검색 트리(search tree) 는 연결 리스트, 큐 처럼 자료들을 담는 컨테이너지만, 자료들을 일정한 순서에 따라 정렬한 상태로 저장합니다. 주어진 순서에 따라 자료들을 저장하는 리스트와 큐와는 다른 속성 이러한 특성을 이용해, 추가, 삭제, 존재 여부 확인 등 다양한 연산을 빠르게 수행 검색 트리에서 가장 흔하게 사용하는 것이 이진 검색 트리(binary search tree)와 그 변종들 이다. 22.2 이진 검색 트리의 정의와 조작 22.2.1 정의 이진 트리(binary tree): 각 노드가 왼쪽, 오른쪽 최대 두 개의 자식 노드만을 가질 수 있는 트리\n자식 노드들의 배열 대신 두개의 포인터 left, right를 담는 객체로 구현 이진 검색 트리는 이진 탐색에서 아이디어를 가져와서 만든 트리이다.\n우리가 N개의 원소 중에서 원하는 값을 찾는데, 매번 후보의 수를 절반씩 줄여갈 수 있다면 O(logN) 시간에 그 값을 찾을 수 있다.\n이진 검색 트리의 각 노드는 하나의 원소(value)를 가지고 있다.\n왼쪽 서브 트리에는 해당 노드의 원소보다 작은 원소를 가진 노드들\n오른쪽 서브 트리에는 보다 큰 원소를 가진 노드들이 들어간다.\n22.2.2 순회 이진 검색 트리는 중위 순회를 하면 크기 순서로 정렬된 원소의 목록을 얻을 수 있다. 집합에 포함된 최대 원소나 최소 원소를 쉽게 얻을 수 있다는 의미 왼쪽 연결로 쭉 내려갔을 때 만나는 노드: 최소 원소, 가장 일찍 출력되는 노드 오른쪽 연결로 쭉 내려갔을 때 만나는 노드: 최대 원소, 가장 마지막에 출력되는 노드 22.2.3 자료의 검색 한 번 원소를 비교하는 것 만으로도 찾아야 할 전체 대상의 절반을 줄일 수 있다. 실질적으로 이진 탐색과 비슷한 속도를 자료를 찾을 수 있다. 22.2.4 조작 (추가, 삭제) 추가, 삽입\n선형적인 구조의 제약이 없기 때문에, 새 원소가 들어갈 위치를 찾고, 거기에 노드를 추가하기만 하면 간단히 가능 추가, 삽입은 새 리프(잎) 노드가 생길 뿐이므로, 트리 전체의 구조에는 영향이 없음 삭제\n삭제는 트리 어디서든 일어날 수 있어, 트리 전체의 구조에 영향을 주므로 여럽다.\n간단한 방법: '합치기' 연산을 구현\n노드 t를 지울 거라면, t의 두 서브트리를 합친 새로운 트리를 만든 뒤, 이 트리를 t를 루트로 하는 서브트리와 바꿔치기 22.2.5 X보다 작은 원소의 수 찾기 / k번째 원소 찾기 표준 라이브러리에서 지원하는 언어는 거의 없기 때문에, 이 연산을 사용하려면, 직접 이진 검색 트리를 구현할 수 밖에 없다. 실제 구현은 트립 의 구현을 다루는 22.6절 을 참고 22.3 시간 복잡도 분석과 균형 잡힙 이진 검색 트리 이진 검색 트리에 대한 모든 연산은 모두 루트에서 부터 한 단계씩 트리를 내려가며 재귀 호출을 통해 수행된다. 최대 재귀 호출의 횟수는 트리의 높이 h와 같다. 따라서 모든 연산의 시간 복잡도가 트리의 높이 O(h) 라 할 수 있다. 이진 검색 트리의 높이는 자료들이 어떤 순서로 추가, 삭제되느냐에 따라 다르다. 극단적인 경우 한쪽으로만 노드가 있어서 기울어진(skewed) 트리가 될 수도 있다. (연결리스트와 다를 게 없다) 우리가 원하는 이상적인 경우는 가로로 넓게 퍼지고 \u0026lsquo;평평한\u0026rsquo; 트리 이다. 트리의 높이가 1 높아질 때마다 트리에 들어갈 수 있는 원속의 수가 대략 두 배 늘어간다 트리의 최소 높이(h)는 O(logN)이다 균형 잡힌 이진 검색 트리 (balanced binary search tree) 이진 검색 트리의 변종, 기울어짐 방지 트리의 구조에 추가적인 제약을 둠, 이 제약을 만족되도록 노드들을 옮김 트리의 높이가 항상 O(logN)이 되도록 유지 대표적인 예시: 레드-블랙(red-black) 트리, AVL 트리 이진 검색 트리의 구현도 내부적으로는 레드-블랙(red-black) 트리을 사용한다. 22.6 균형 잡힙 이진 검색 트리 직접 구현하기: 트립 대부분의 균형 잡힌 이진 검색 트리들(AVL 트리, 레드-블랙 트리) 은 구현이 매우 까다롭다. 코드가 길고, 한정된 시간 안에 코드를 작성해야하는 프로그래밍 대회에서 사용하기 부적합 따라서, 구현이 간단한 이진 검색 트리를 사용: 트립(treap, tree+heap) 22.6.1 트립의 정의 트립은 입력이 특정 순서로 주어질 때 그 성능이 떨어진다는 이진 검색 트리의 단점을 해결하기 위해 고안된 랜덤화된 이진 검색 트리이다. 트립은 원소들의 추가 순서에 따라 결정되지 않고, 난수에 의해 임의로 결정된다. 어느 순서대로 추가, 삭제 되더라도, 트리 높이의 기대치는 항상 일정하다. 이 속성을 위해서, 트립은 새 노드가 추가될 때 마다 해당 노드에 우선순위(priority) 를 부여한다. 우선순위 값은 난수 이다. 트립을 이해하는 또 다른 방법: 노드들을 우선순위가 높은 것부터 순서대로 추가한 이진 검색 트리 트립의 조건 2가지\n이진 검색 트리의 조건\n왼쪽 서브 트리에는 해당 노드의 원소보다 작은 원소를 가진 노드들\n오른쪽 서브 트리에는 보다 큰 원소를 가진 노드들이 들어간다.\n힙의 조건: 모든 노드의 우선순위는 각자의 자식 노드보다 크거나 같다.\nReference 프로그래밍 대회에서 배우는 알고리즘 문제 해결 전략 (구종만, 인사이트) https://www.algospot.com/ ","permalink":"https://2taezeat.github.io/posts/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EB%AC%B8%EC%A0%9C-%ED%95%B4%EA%B2%B0-%EC%A0%84%EB%9E%B5/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EB%AC%B8%EC%A0%9C-%ED%95%B4%EA%B2%B0-%EC%A0%84%EB%9E%B5-ch22.-%ED%8A%B8%EB%A6%AC/","summary":"22. 이진 검색 트리 22.1 도입 검색 트리(search tree) 는 연결 리스트, 큐 처럼 자료들을 담는 컨테이너지만, 자료들을 일정한 순서에 따라 정렬한 상태로 저장합니다. 주어진 순서에 따라 자료들을 저장하는 리스트와 큐와는 다른 속성 이러한 특성을 이용해, 추가, 삭제, 존재 여부 확인 등 다양한 연산을 빠르게 수행 검색 트리에서 가장 흔하게 사용하는 것이 이진 검색 트리(binary search tree)와 그 변종들 이다. 22.2 이진 검색 트리의 정의와 조작 22.2.1 정의 이진 트리(binary tree): 각 노드가 왼쪽, 오른쪽 최대 두 개의 자식 노드만을 가질 수 있는 트리","title":"[알고리즘 문제 해결 전략] ch22. 트리"},{"content":"21. 트리의 구현과 순회 21.1 도입 선형으로 표현하기 어려운 형태의 자료 중 흔한 것이 계층 구조 이다. 자료 간에 상하위, 포함 관계 조직도, 상품 분류 기준 등 등 트리는 계층 관계를 갖는 객체들을 표현하기 위한 자료구조 그러나 실제 계층 관계가 없는 자료들도 트리를 표현해서 같은 연산을 더 빠르게 할 수 있다. 하나의 상위 개념에서 가지를 쳐서 뻗어가는 모습이 실제 나무(상하가 뒤집혔지만)와 닮았다 해서 트리라고 부른다, 트리는 처음에 현실 세계의 개념을 추상화해 표현하는 자료 구조로 고안되었지만, 탐색형 자료 구조로도 유용하게 쓰인다. 특정한 조건을 지키도록 구성된 트리를 이용하면, 배열, 리스트를 사용하는 것보다 빠르게 작업을 할 수 있다. 21.1.1 트리의 기초적인 정의와 용어 21.1.2 트리의 구성 요소 트리는 자료가 저장된 node(노드)와 edge(간선)으로 서로 연결되어 있다. 노드 간에는 상/하위 관계가 있다. 두 노드가 연결되었을 때 한 노드는 좀더 상위, 다른 노드는 좀 더 하위에 있어야 한다. 상위 노드: 부모(parent) 노드 하위 노드: 자식(child) 노드 부모가 같은 노드: 형제(sibling) 노드 부모 노드와 그의 부모들을 통들어: 선조(ancestor) 자식 노드와 그의 자식들을 통들어: 자손(descendant) 부모-자식 비유 처럼, 트리에서 한 노드는 여러 개의 자식을 가질 수 있어도, 부모는 하나만 가질 수 있다. 모든 노드들을 자손으로 갖는 단 하나의 노드: 뿌리, 루트(root) 노드 자식이 하나도 없느 노드: 트리의 잎 노드, 리프(leaf) 노드 21.1.3 트리의 노드의 속성 깊이(depth): 루트에서 어떤 노드에 도달하기 위해 거쳐야 하는 간선의 수\n높이(height): 트리에서 가장 깊숙히 있는 노드의 깊이\n트리의 레벨(Level): 깊이가 같은 노드들의 집합\n21.1.4 트리의 재귀적 속성 트리는 재귀적인 성질을 가지고 있다. 트리를 다루는 코드들은 대개 재귀 호출을 이용해 구현 트리에서 한 노드와 그의 자손들을 모두 모으면 그들도 하나의 트리가 된다. 어떤 노드 t와 그 자손들로 구성된 트리를 t를 루트로 하는 서브트리(subtree) 라고 한다. 따라서, 모든 트리는 루트와 루트 밑에 있는 서브트리들의 집합 21.1.5 트리의 표현 트리는 다양한 방법으로 구현할 수 있다 가장 일반적인 형태는 각 노드를 하나의 구조체/객체로 표현하고, 이들을 서로의 포인터로 연결하는 것이다. 이때, 각 노드들은 자신의 부모와 모든 자손들에 대한 포인터를 가지고 있다. 기본적인(범용적인) 트리 구현 1 2 3 4 5 6 data class TreeNode\u0026lt;T\u0026gt;( val value: T, val parent: TreeNode\u0026lt;T\u0026gt;?, val children: MutableList\u0026lt;TreeNode\u0026lt;T\u0026gt;\u0026gt; ) // parent 없이, children 만 있어도 된다. 자식 노드의 포인터를 담는 배열 대신, 두 포인터 left, right를 이용해 자식들을 저장할 수 도 있다. (이진 검색 트리) 21.2 트리의 순회 트리는 트리의 재귀적 속성을 이용해서 순회를 해야 한다. 트리에 N개의 노드가 있을 때, 시간복잡도: 모든 노드에 대해서 한 번씩 재귀 함수가 호출 됨으로, O(N) 서브트리의 개념을 이용하면 트리의 높이 또한 재귀적으로 정의할 수 있다. 21.5 요새, FORTRESS, 난이도: 중 트리의 최장 경로 찾기 문제로 접근\n트리의 경로(path): 두 노드 사이를 연결하는 간선들을 트리의 경로라고 한다.\n트리의 최장 경로 =\u0026gt; 1,2번 둘 중 큰 값이다.\n양 끝 노드가 항상 루트 혹은 리프 노드 여야 한다. 가장 긴 루트-리프 경로의 길이 (== 트리의 height, 높이)\n가장 긴 리프-리프의 경로의 길이\n리프-리프 경로들은 항상 어떤 노드까지 쭉 위로 올라가다 쭉 아래로 내려가는 형태이다.\n최상위 노드: 경로가 올라가다가 내려가는 지점을 이 경로의 최상위 노드라 한다. 각 노드 마다 취상위 노드로 갖는 가장 긴 리프-리프 노드를 계산하고, 그중 최댓값을 구하면 된다. =\u0026gt; 각 서브트리의 높이를 계산한 뒤, 가장 높은 두개의 서브 트리를 선택하면 가장 긴 리프-리프 경로를 구할 수 있다. Reference 프로그래밍 대회에서 배우는 알고리즘 문제 해결 전략 (구종만, 인사이트) https://www.algospot.com/ ","permalink":"https://2taezeat.github.io/posts/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EB%AC%B8%EC%A0%9C-%ED%95%B4%EA%B2%B0-%EC%A0%84%EB%9E%B5/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EB%AC%B8%EC%A0%9C-%ED%95%B4%EA%B2%B0-%EC%A0%84%EB%9E%B5-ch21.-%ED%8A%B8%EB%A6%AC/","summary":"21. 트리의 구현과 순회 21.1 도입 선형으로 표현하기 어려운 형태의 자료 중 흔한 것이 계층 구조 이다. 자료 간에 상하위, 포함 관계 조직도, 상품 분류 기준 등 등 트리는 계층 관계를 갖는 객체들을 표현하기 위한 자료구조 그러나 실제 계층 관계가 없는 자료들도 트리를 표현해서 같은 연산을 더 빠르게 할 수 있다. 하나의 상위 개념에서 가지를 쳐서 뻗어가는 모습이 실제 나무(상하가 뒤집혔지만)와 닮았다 해서 트리라고 부른다, 트리는 처음에 현실 세계의 개념을 추상화해 표현하는 자료 구조로 고안되었지만, 탐색형 자료 구조로도 유용하게 쓰인다.","title":"[알고리즘 문제 해결 전략] ch21. 트리"},{"content":"20. 문자열 20.1 도입 현대의 컴퓨터는 많은 양의 문자열 자료를 다룬다. 문자열 검색 문제를 위한 KMP 알고리즘 문자열 처리를 위한 자료 구조, 접미사 배열(suffix array) substring, 부분 문자열 prefix, 접두사 suffix, 접미사 20.2 문자열 검색 20.2.1 단순 문자열 검색 알고리즘 H, N 모두 a로만 구성된 긴 문자열이라면 H - N +1 개의 모든 시작 위치에 대해서 비교를 수행하게 된다.\n시작 위치의 수: O(H)\n각각의 비교: O(N)\n시간 복잡도: O(N*H)\n20.2.2 KMP 알고리즘 긴 문자열에서 N = \u0026ldquo;aabaabac\u0026rdquo; 를 찾는 경우\n단순한 알고리즘은 i는 답이 아니니까, i+1에서 다시 답을 찾기 시작한다.\n시작 위치 중 일부는 답이 될 수 없음을 보지 않아도 알 수 있다.\n답이 될 수 있는 가능성이 있는, 시작 위치는 i+3과 i+6 밖에 없다.\n일치한 글자의 수는 항상 0 ~ N 사이의 정수\n전처리 과정에서 이 정보들을 미리 계산해 저장해 둘 수 있다.\n이러한 최적화 알고리즘이 Knuth-Morris-Pratt, KMP 알고리즘 이다.\n20.2.2.1 다음 시작 위치 찾기 pi[i] = N[ : i+1]의 접두사도 되고 접미사도 되는 문자열의 최대 길이 pi[]는 N이 어디까지 일치했는지가 주어질 때 다음 시작 위치를 어디로 해야 할지를 말해 준다. 부분 일치 테이블(partial match table) 이라고 부른다. 20.2.2.2 실제 문자열 검색의 구현 적절한 전처리 과정을 통해 pi[]를 계산했다고 하자. m(matched)가 일치한 후 불일치가 발생했다고 하자 다음 시작할 시작 위치: m - pi[m-1] 만큼 증가 새로운 위치에서 비교를 시작하더라도, N의 첫 pi[m-1] 글자는 대응되는 H의 글자와 일치 따라서, m를 pi[m-1]으로 변경하고 비료를 계속하면 된다. 불일치가 발생한 경우는 그렇다 치고, 답을 찾는 경우에는 어떻게 할까? 현재 시작 위치를 답의 목록에 추가해야 한다는 것 빼고는 불일치가 발생한 경우와 똑같다. 다음 시작 위치에서부터 검색을 계속하면 된다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 def kmp(Hstrs, Nstrs): lenH, lenN = len(Hstrs), len(Nstrs) pi, i = [0 for _ in range(lenN)], 0 # kmp_table for j in range(1, lenN): while i \u0026gt; 0 and Nstrs[i] != Nstrs[j]: i = pi[i - 1] if Nstrs[i] == Nstrs[j]: i += 1 pi[j] = i result, i = [], 0 # kmp for j in range(lenH): while i \u0026gt; 0 and Nstrs[i] != Hstrs[j]: i = pi[i - 1] if Nstrs[i] == Hstrs[j]: i += 1 if i == len(Nstrs): result.append(j - i + 1) i = pi[i - 1] return result print(kmp(\u0026#39;xabxxbaxbaxbaxbaxabxbaxbabx\u0026#39;, \u0026#39;abx\u0026#39;)) # [1, 17, 24] print(kmp(\u0026#39;abababab\u0026#39;, \u0026#39;abab\u0026#39;)) # [0, 2, 4] # https://yiyj1030.tistory.com/495 20.2.2.3 시간 복잡도 분석 문자 비교 성공은 짚더미(H)의 각 문자당 최대 한 번씩만 일어남: O(H) if문의 비교는 최대 O(H)번 수행 따라서 반복문의 전체 수행 횟수는 O(H) 이다. 바늘(N)의 길이와 상관없이, 항상 짚더미(H)에만 비례 20.5 접미사 배열 문자열을 다룰 때 자주 쓰이는 자료 구조: 접미사 배열(suffix array) 문자열 S의 모든 접미사를 사전순으로 정렬 해둔 것 접미사들을 그대로 문자열 배열에 저장하면 문자열 길이의 제곱에 비례하는 메모리가 필요하기 때문에, 보통 각 접미사의 시작 위치를 담는 정수 배열로 구현된다. group[i] = S[i : ]가 속한 그룹의 번호 20.5.1 접미사 배열을 만드는 맨버-마이어스(Manber \u0026amp; Myers)의 알고리즘 문자열들이 모두 공통된 한 문자열의 접미사라는 점을 이용하여, 기수 정렬 (첫 1글자, 2글자, 4글자, \u0026hellip;, 2^n 글자를 기준으로 정렬) 을 이용한 알고리즘이다. 이렇게 log N 번 정렬을 하고 나면 원하는 접미사 배열을 얻을 수 있다. 이렇게 정렬은 여러 번 하는데도 더 빠르게 동작하는 이유는 이전 정렬에서 얻은 정보를 이용해 두 문자열의 대소 비교를 O(1) 에 할 수 있기 때문이다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 def sortSuffix(text): # 접미사 배열을 만드는 맨버-마이어스의 알고리즘 n, suffix = len(text), [] g = [0] * n g.append(-1) # 현재 위치에서 t만큼 떨어진 위치가 없는 경우 rank를 -1로 설정 t = 1 for i in range(n): suffix.append(i) g[i] = ord(text[i]) - ord(\u0026#39;a\u0026#39;) while t \u0026lt; n: suffix.sort(key=lambda x: (g[x], g[min(x + t, n)])) ng = [0] * n ng.append(-1) for i in range(1, n): si, si_1 = suffix[i], suffix[i - 1] if g[si_1] != g[si] or g[min(si_1 + t, n)] != g[min(si + t, n)]: # # rank가 다르면 서로 다른 rank 값을 갖게함 ng[si] = ng[si_1] + 1 else: # rank가 같은 경우 서로 같은 rank ng[si] = ng[si_1] g = ng if ng[n - 1] == n - 1: break t *= 2 return suffix # https://codable.tistory.com/14 전체 시간 복잡도: O(N lg^2N) 기존, O(N^2 lgN)에 비해 큰 발전 Reference 프로그래밍 대회에서 배우는 알고리즘 문제 해결 전략 (구종만, 인사이트) https://www.algospot.com/ ","permalink":"https://2taezeat.github.io/posts/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EB%AC%B8%EC%A0%9C-%ED%95%B4%EA%B2%B0-%EC%A0%84%EB%9E%B5/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EB%AC%B8%EC%A0%9C-%ED%95%B4%EA%B2%B0-%EC%A0%84%EB%9E%B5-ch20.-%EA%B8%B0%EC%B4%88-%EC%9E%90%EB%A3%8C-%EA%B5%AC%EC%A1%B0/","summary":"20. 문자열 20.1 도입 현대의 컴퓨터는 많은 양의 문자열 자료를 다룬다. 문자열 검색 문제를 위한 KMP 알고리즘 문자열 처리를 위한 자료 구조, 접미사 배열(suffix array) substring, 부분 문자열 prefix, 접두사 suffix, 접미사 20.2 문자열 검색 20.2.1 단순 문자열 검색 알고리즘 H, N 모두 a로만 구성된 긴 문자열이라면 H - N +1 개의 모든 시작 위치에 대해서 비교를 수행하게 된다.\n시작 위치의 수: O(H)\n각각의 비교: O(N)\n시간 복잡도: O(N*H)\n20.2.2 KMP 알고리즘 긴 문자열에서 N = \u0026ldquo;aabaabac\u0026rdquo; 를 찾는 경우","title":"[알고리즘 문제 해결 전략] ch20. 기초 자료 구조"},{"content":"19. 큐와 스텍, 데크 19.1 도입 현실 세계의 규칙을 추상화하는 추상화 자료 구조(ADT)의 대표적인 예: 큐, 스택 ,데크 배열과 연결 리스트를 이용해 구현할 수 있다. 그럼에도 이름을 붙였다는 데는 이유가 있다. 개발자간의 의사소통이 더 쉬워지고, 더 큰 그림을 보며 프로그램을 설계할 수 있기 때문이다 push: 자료구조에 자료를 넣는 작업 pop: 자료를 꺼내는 작업 큐, 스택은 각각 넣고 빼는 방향에 따라 push, pop 연산을 O(1)에 지원 데크(deque) 는 앞과 뒤 모두에서 push, pop 연산을 O(1)에 지원 C를 제외한 대부분의 언어들에서 스택, 큐, 데크는 기본적인 자료구조 이기 때문에 표준 라이브러리에서 구현체를 제공한다. 19.1.2 큐 큐(queue)는 한쪽 끝에서 자료를 넣고, 반대 쪽 끝에서 자료를 꺼낼 수 있다. 이와 같은 속성에 따라, 가장 먼저 들어간 자료를 가장 먼저 꺼내게 된다. 선입선출(FIFO, First In First Out) 이라고도 한다. 놀이공원에 선 줄이 대표적인 예 19.1.3 스택 스택(stack)은 한쪽 끝에서만 자료를 넣고 뺄 수 있다. 따라서, 가장 늦게 들어간 자료를 가장 먼저 꺼내게 된다. 후입선출(LIFO, Last In First Out) 이라고도 한다. 컴퓨터는 내부적으로 스택을 사용해 함수들의 문맥(context)를 관리한다. (함수의 호출 그 후,이전 함수로 돌아가는 상황) 19.1.4 데크(dequeue) 데크 (dequeue: double-ended queue) 는 양쪽 끝에서 자료들을 넣고 뺄 수 있는 자료구조 따라서, 데크를 이용하면 스택과 큐를 모두 구현 할 수 있다. 19.2 큐, 스택, 데크의 구현 19.2.1 연결 리스트를 통한 구현 연결 리스트를 활용하면 양쪽 끝에서, 추가, 삭제를 O(1)에 할 수 있다. 하지만, 노드의 할당과 삭제 그리고 포인터를 따라가는 데 선형시간이 걸리기 때문에, 연결 리스트를 통한 구현은 효율적인 구현이 아니다. 19.2.2 동적 배열을 통한 구현 스택의 경우, 한쪽 끝에서만 자료의 추가, 삭제가 일어남으로 동적 배열을 곧 장 사용할 수 있다.\n하지만, 큐와 데크의 경우에는 뒤에서 원소를 추가하거나 삭제하기는 쉽지만, 배열의 맨 앞에 원소를 삭제하기 위해서는 O(N)의 시간이 걸린다.\n따라서, head, tail 변수로 첫 번째 와 마지막 원소의 위치를 유지하면서,\n맨 앞에서 원소를 꺼낼 때 뒤에 있는 원소들을 모두 앞으로 옮겨오는 대신 head를 다음 원소로 옮긴다.\n이 방법은 시간은 O(1)에 만족하지만, 공간이 너무 많이 버려진다는 문제가 발생\n앞의 버려지는 공간을 재활용하면서, 더 이상 원소를 삽입할 곳이 없을 때만, 동적 배열을 재할당하는 것으로 해결\ntail이 배열의 끝에 도달하자 처음으로 다시 돌아가서 원소를 저장,\n동적 배열의 처음과 끝을 붙여 원형으로 만들었다고 볼 수 도 있다.\n이와 같은 배열의 구현을 환형 버퍼(circular buffer) 라고 한다.\nReference 프로그래밍 대회에서 배우는 알고리즘 문제 해결 전략 (구종만, 인사이트) https://www.algospot.com/ ","permalink":"https://2taezeat.github.io/posts/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EB%AC%B8%EC%A0%9C-%ED%95%B4%EA%B2%B0-%EC%A0%84%EB%9E%B5/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EB%AC%B8%EC%A0%9C-%ED%95%B4%EA%B2%B0-%EC%A0%84%EB%9E%B5-ch19.-%EA%B8%B0%EC%B4%88-%EC%9E%90%EB%A3%8C-%EA%B5%AC%EC%A1%B0/","summary":"19. 큐와 스텍, 데크 19.1 도입 현실 세계의 규칙을 추상화하는 추상화 자료 구조(ADT)의 대표적인 예: 큐, 스택 ,데크 배열과 연결 리스트를 이용해 구현할 수 있다. 그럼에도 이름을 붙였다는 데는 이유가 있다. 개발자간의 의사소통이 더 쉬워지고, 더 큰 그림을 보며 프로그램을 설계할 수 있기 때문이다 push: 자료구조에 자료를 넣는 작업 pop: 자료를 꺼내는 작업 큐, 스택은 각각 넣고 빼는 방향에 따라 push, pop 연산을 O(1)에 지원 데크(deque) 는 앞과 뒤 모두에서 push, pop 연산을 O(1)에 지원 C를 제외한 대부분의 언어들에서 스택, 큐, 데크는 기본적인 자료구조 이기 때문에 표준 라이브러리에서 구현체를 제공한다.","title":"[알고리즘 문제 해결 전략] ch19. 기초 자료 구조"},{"content":"18. 선형 자료 구조 18.1 도입 일렬로 늘어선 같은 종류의 자료 여러 개를 저장하기 위한 가장 기초적인 자료구조는 배열(Array) 이다.\n동적 배열, 연결 리스트는 배열과 비슷하지만, 배열에서 비효율적이거나 할 수 없는 작업들을 효율적으로 작업한다.\n18.2 동적 배열 배열(일반 배열, 정적 배열) 의 문제는 배열을 선언할 때, 배열의 크기를 지정해야 하며, 그 이상의 자료를 집어넣을 수 없다는 점이다.\n이 문제를 해결 하기 위해, 자료의 개수가 변함에 따라 크기가 변경되는 동적 배열(dynamic array)이 고안되었다.\n동적 배열은 또 다른 종류의 배열이 아니다.\n동적 배열은 일반 배열처럼 언어 차원에서 지원되는 기능이 아니다.\n동적 배열은 일반 배열을 이용해 만들어 낸 별도의 자료 구조 이다.\n동적 배열은 대개 언어 문법이 아니라 언어의 표준 라이브러리에 포함되어 있다.\n내부적으로는 일반 배열로 구현되기 때문에, 동적 배열은 일반 배열이 갖는 특성을 그대로 물려 받는다.\n요즘에는 일반적인 배열을 제공하지 않고 동적 배열만을 제공하는 언어들도 있다. 동적 타입을 갖는 언어, 대표적으로 Python 이 동적 배열 기능도 내부적으로는 항상 일반 배열로 구현된다. 18.2.1 일반 배열의 특성 일반 배열은, 동적 배열과 비교하면 정적 배열로 볼 수 있다. 원소들은 메모리의 연속된 위치에 저장된다. 캐시의 효율성을 높여준다, 공간 지역성 주어진 위치의 원소를 반환하거나 변경하는 동작을 O(1) 에 할 수 있다. 배열에 원소를 삽입, 삭제 O(N), 원소를 삽입, 삭제하고 기존 원소를 모두 이동(데이터 복사)시켜줘야 한다. 정확한 수행 시간은 삽입, 삭제의 위치에 따라 달라지지만, 평균적으로 선형 시간 임의 접근(random access) 가 O(1) 에 가능하다. 순차 접근과 달리 인덱스에 해당하는 데이터에 접근할 수 있다. 18.2.2 동적 배열의 특성 일반 배열의 특성을 그대로 물려 받음 컴파일 시점에 크기를 지정해야 하는 일반 배열의 배열의 크기를 변경하는 resize() 연산이 가능 O(N) 시간이 걸림 주어진 원소를 배열의 맨 끝에 추가함으로써, 크기를 1 늘리는 append() 연산을 지원한다. O(1) 시간이 걸림 18.2.3 동적 배열의 연산 동적 배열의 연산을 하기 위해서는 동적으로 할당받은 배열(dynamically allocated array)을 사용한다. 동적으로 할당받은 배열은 new 등의 연산으로 고정된 길이의 배열 동적 배열의 크기가 바뀌어야 할 때는 단순하게 새 배열을 동적으로 할당받은 뒤 기존 원소들을 복사하고, 새 배열을 참조하도록 바꿔치기 한다 새 배열을 할당받고 기존 자료를 복사하는 데는 배열의 크기에 비례하는 시간이 걸린다. 따라서, resize() 연산은 O(N) 1 2 val size: Int; // 현재 배열의 크기 val arrayPointer: ElemntType // (동적으로 할당 받은) 실제 배열을 가리키는 포인터 메모리를 할당받을 때 배열의 크기가 커질 때를 대비해서 여유분의 메모리를 미리 할당받으면, append()를 O(1)에 구현할 수 있다.\n배열이 이미 할당한 메모리에 꽉 찼을 때, 더 큰 메모리를 할당받아 배열의 원소를 그 쪽으로 전부 옮긴다. 배열의 용량(capacity): 할당 받은 메모리의 크기\n배열의 크기(size): 실제 원수의 수\n여유분의 메모리(capacity)가 있지만, 실제로 동적 배열을 사용하는 프로그램에서는 배열의 크기가 5이라고 인식\n만약 현재 배열의 크기가 용량보다 작다면 append() 연산은 size를 1 증가 하고, 그 위치에 새 값을 할당하는 것으로 O(1) 에 구현 가능\n1 2 // append(newValue)의 일부 array[size++] = newValue 미리 할당해 둔 메모리가 꽉 찼을 때 append()는 어떻게 되는가?\n재할당: 더 큰 새 배열을 동적으로 할당받고, 새 배열에 기존 배열의 내용을 모두 복사한 다음 배열에 대한 포인터를 바꿔치기 한다. 미리 정해좋은 M이라는 크기만큼 배열의 용량을 늘려준다고 할 때, 시간 복잡도는 O(N+M), 선형 시간, 매우 가끔 일어남 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 // 배열 용량이 꽉 찼으면 재할당받는다. if (size == capacity) { int newCapacity = capacity + M; // 정해진 값 M 만큼의 새로운 배열을 새로 할당한다. int* newArray = new int[newCapacity]; for (int i = 0 ; i \u0026lt; size ; ++i) // 기존 배열의 원소들을 복사한다. newArray[i] = array[i]; if (array) delete [] array; // 기존 배열을 삭제한 뒤 , 새로운 배열로 바꿔치기 한다. array = newArray; capacity = newCapacity; } // size의 값을 1 늘리고, 새로운 값(newValue)를 추가한다. array[size++] = newValue; 18.2.4 동적 배열의 재할당 전략 재할당에 걸리는 시간 복잡도 계산\n연산을 아주 여러 번 반복해서 수행한 뒤 각 수행 시간의 평균을 내자. // 분할 상환 분석(amortized analysis) 각 재할당 과정에서 선형 시간이 걸리더라도, 그것이 아주 가끔 일어난다면 전체 평균은 여전히 상수 시간일 수 도 있다. 텅 빈 배열로 시작해서, N번 append 연산을 할 때, 재할당의 수 K = O(N/M) 이다.\nM은 상수이므로 N이 아주 커지면, K = O(N) 재할당마다 복사하는 원소의 수는 M, 2M, 3M \u0026hellip; KM개로 증가 전체 복사하는 원소의 수는 (K+1)KM * 1/2 = O(K^2) = O(N^2) N번의 append 연산에 드는 시간이 O(N^2) 이면, 한 번의 append 연산에 드는 시간은 평균적으로, O(N^2) / N = O(N) 이다.\n결과적으로 상수 시간에 append를 구현할 수 없게 된다. 상수 시간 [ O(1) ] 에 append를 구현하는 비결\n재할당을 할 때마다 정해진 개수의 여유분을 확보하는 것이 아니라, 현재 가진 원소의 개수에 비례해서 여유분을 확보하는 것이다.\n예를 들어, 배열 용량이 부족할 때마다 용량을 두 배로 늘리는 방법, 1,2,4 \u0026hellip;\n배열의 용량이 꽉 찼을 때 이것을 어떻게 증가, 또는 반대로 감소시키느냐의 전략은 동적 배열의 효율성에 큰 영향을 미친다.\n18.2.5 표준 라이브러리의 동적 배열 구현 현대에 사용되는 대부분의 언어들은 동적 배열을 표준 라이브러리에서 제공한다. C언어만 제외 C++: vector, Java: ArrayList , Kotlin: MutableList, Python: List 이들은 내부적으로 배열(Array, 일반 정적 배열) 를 사용하기 때문에, 이들은 배열과 거의 다를 것 없는 속도를 제공한다. 최종 크기가 얼마인지 알 수 있다면, 동적 배열의 용량을 미리 늘려둠으로써 재할당에 드는 비용을 줄이기 Java의 ArrayList에서 ensureCapacity() 를 호출 하면 된다. 18.3 연결 리스트 배열과 달리, 메모리에 원소들이 물리적으로 흩어져 있고, 각 원소들이 이전과 다음 원소를 가리키는 포인터를 가지고 있다.\n데이터를 감싼 노드를 포인터로 연결해서 공간 효율성을 극대화 시킨 자료 구조\n삽입과 삭제를 상수 시간에 할 수 있게 해준다.\n이와 같은 연결 리스트를 정확히는 양방향 연결 리스트(doubly linked list) 라고 한다.\n1 data class Node\u0026lt;T\u0026gt;(var element: T, var next: Node\u0026lt;T\u0026gt;? = null) 1 2 3 4 5 class LinkedList\u0026lt;T\u0026gt; { private var head: Node\u0026lt;T\u0026gt;? = null private var tail: Node\u0026lt;T\u0026gt;? = null private var size = 0 } 원소와 포인터들의 집합들을 리스트의 노드(node)라고 부른다. 대게 연결 리스트는 head, tail에 대한 포인터만을 가진 클래스로 구현된다. 18.3.1 연결 리스트 특성 특정 위치의 값을 찾기(탐색) 가 쉽지 않다. i번째 노드를 찾 데 드는 시간은 리스트의 길이에 선형 비례 한다. O(N) 연결 리스트의 머리부터 하나씩 포인터를 따라가며 다음 노드를 찾을 수 밖에 없다. 삽입, 삭제 노드들의 순서가 포인터에 의해 정의되기 때문에, 삽입, 삭제는 간단하다. O(1) 다른 노드들은 그대로 두고, 삽입/삭제 노드와 이전/이후 노드의 포인터만을 바꾸면 된다. 18.3.2 표준 라이브러리의 연결 리스트 구현 동적 배열과 같이, 대부분의 프로그래밍 언어에서 연결 리스트를 표준 라이브러리에서 제공한다. C++ STL의 list, Java: LinkedList 18.3.3 연결 리스트 응용 연산들 splicing: 잘라 붙이기 연산\n다른 리스트를 통째로 삽입 하는 것을 상수 시간에 할 수 있다. 잘라 붙이기 연산을 구현하면 연결 리스트의 크기를 O(1)에 알기 불가능해진다. 연결 리스트의 크기를 알 수 있는 방법이 없어서, 원소의 개수를 리스트 객체에서 유지하면서 새 원소를 삽입하거나 삭제할 때마다 갱신해줘야 한다. 하지만, 잘라 붙이기 연산을 할 때는 몇 개의 원소가 추가 되는지 알기 없기 때문이다. 이 때문에 잘라 붙이기 연산을 지원하는 연결 리스트 구현은 많지 않다. Java의 LinkedList의 구현은 잘라 붙이기 연산을 포기하는 대신, 리스트의 크기를 구하는 연산을 상수 시간에 지원한다. 삭제했던 원소 돌려놓기: 한 번 삭제했던 원소를 제자리에 쉽게 돌려 놓을 수 있다.\nnode의 포인터들은 원래 자기가 들어가 있던 위치를 알고 있기 때문에, recoverNode() 처럼 node에 대해서만 알고 있어도 원래 리스트에 쉽게 다시 삽입할 수 있다.\n이 방법은 이전, 이후 노드 또한 삭제된 상태에서 수행되면 리스트를 망가뜨리기 때문에, 항상 삭제한 순서의 반대로 복구가 이루어질 때만 사용할 수 있다.\n이 연산은 프로그램의 되돌리기(undo) 연산을 지원하는 데 유용하게 쓸 수 있다.\n사용자 인터페이스(UI)에 되돌리기 연산이 자주 사용 양뱡향 연결 리스트로 문제의 현재 상태를 표현하면 되돌리기 연산을 통해 문제의 상태를 되돌리는 작업을 효율적으로 할 수 있다: 조합 탐색 에 유용하다.\n1 2 3 4 5 6 7 8 9 10 11 // node 이전/이후 노드의 포인터를 바꿔서 node를 리스트에서 삭제한다 void deleteNode(listNode* node){ node-\u0026gt;prev-\u0026gt;next = node-\u0026gt;next; node-\u0026gt;next-\u0026gt;prev = node-\u0026gt;prev; } // node 이전/이후 노드의 포인터를 바꿔서 자기 자신을 다시 리스트에 삽입 void recoverNode(listNode* node){ node-\u0026gt;prev-\u0026gt;next = node; node-\u0026gt;next-\u0026gt;prev = node; } 18.4 동적 배열과 연결 리스트 비교 삽입, 삭제가 많다 =\u0026gt; 연결 리스트\n원소 접근이 많다 =\u0026gt; 동적 배열\n배열의 끝에서만 삽입, 삭제가 많다 =\u0026gt; 동적 배열\n작업 동적 배열 연결 리스트 이전 원소/다음 원소 찾기 O(1) O(1) 맨 뒤에 원소 추가/삭제하기 O(1) O(1) 맨 뒤 이외의 위치에 원소 추가/삭제하기 O(N) O(1) 임의의 위치의 원소 찾기 O(1) O(N) 크기 구하기 O(1) O(N) or O(1), 잘라 붙이기 연산 유무에 따라 Reference 프로그래밍 대회에서 배우는 알고리즘 문제 해결 전략 (구종만, 인사이트) https://www.algospot.com/ ","permalink":"https://2taezeat.github.io/posts/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EB%AC%B8%EC%A0%9C-%ED%95%B4%EA%B2%B0-%EC%A0%84%EB%9E%B5/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EB%AC%B8%EC%A0%9C-%ED%95%B4%EA%B2%B0-%EC%A0%84%EB%9E%B5-ch18.-%EA%B8%B0%EC%B4%88-%EC%9E%90%EB%A3%8C-%EA%B5%AC%EC%A1%B0/","summary":"18. 선형 자료 구조 18.1 도입 일렬로 늘어선 같은 종류의 자료 여러 개를 저장하기 위한 가장 기초적인 자료구조는 배열(Array) 이다.\n동적 배열, 연결 리스트는 배열과 비슷하지만, 배열에서 비효율적이거나 할 수 없는 작업들을 효율적으로 작업한다.\n18.2 동적 배열 배열(일반 배열, 정적 배열) 의 문제는 배열을 선언할 때, 배열의 크기를 지정해야 하며, 그 이상의 자료를 집어넣을 수 없다는 점이다.\n이 문제를 해결 하기 위해, 자료의 개수가 변함에 따라 크기가 변경되는 동적 배열(dynamic array)이 고안되었다.","title":"[알고리즘 문제 해결 전략] ch18. 기초 자료 구조"},{"content":"17. 부분 합, 누적 합, 구간 합 17.1 도입 누적 합(Cumulative Sum, prefix sum): 배열의 각 위치에 대해 배열의 시작부터 현재 위치까지의 원소의 합을 미리 구해 둔 배열 O(N), 수열의 길이에 선형으로 증가 누적 합(Cumulative Sum)을 미리 구해 두면, list의 특정 구간의 합(range sum)을 O(1)에 구할 수 있다. cumulativeSum[-1] = 0이라 가정할 때, list[a]부터 list[b]까지의 합은 cumulativeSum[b] - cumulativeSum[a-1] 이다. 핵심: O(N) 시간으로 계산한 누적 합을 통해서, 구간 합을 O(1) 시간으로 빠르기 구하기 누적 합(Cumulative Sum) 은 첫 위치가 항상 A[0]으로 고정된, 구간 합(range sum) 이라고 할 수도 있다. 부분 합은 Partial Sum 이라 한다. 수열의 어느 부분의 합을 의미한다. 17.1.2 2차원으로의 확장 누적 합은 2차원 배열에서 A[y1, x1]에서 A[y2, x2]까지의 직사각형 구간의 합을 계산해야 할 때도 유용하다.\ncumulativeSum[y, x]는 (0, 0)을 왼쪽 위 칸, (y, x)를 오른쪽 아래 칸으로 갖는 직사각형 구간에 포함된 원소들의 합\n누적 합을 이용한 구간 합 구하기\n그림에서 굵은 선으로 표시된 구간의 합(range sum) sum(y1, x1, y2, x2) = cumulativeSum[y2, x2] - cumulativeSum[y2, x1 - 1] - cumulativeSum[y1 - 1, x2] + cumulativeSum[y1 - 1, x1 - 1] 17.1.3 예제: 합이 0에 가장 가까운 구간 0 에 가장 가깝다는 말: cumulativeSum[ ]의 두 값의 차이가 가장 적다는 말\n완전 탐색: O(N^2)\n누적 합 이용\n정렬: O(NlogN)\n얻은 누적 합을 이용해서, 인접한 원소들 확인하는 것: O(N)\n총 결과: O(NlogN)\n배열에서 가장 가까운 두 값을 찾기 위한 방법\n이 배열을 정렬한 뒤, 인접한 원소들끼리 확인 Ex) 9, 100, 101, 300, 308 =\u0026gt; (100, 101) 17.2 누적 합(Cumulative Sum), 구간 합(range Sum) 코드 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 lst = [3, 5, 7, 9] N = len(lst) cumulativeSum = [0] for i in range(0, N): # 누적 합 구하기 cumulativeSum.append(cumulativeSum[i] + lst[i]) # [0, 3, 8, 15, 24] # 0 \u0026lt;= leftIdx \u0026lt; rightIdx \u0026lt; N def calRangeSum(lIdx, rIdx): # leftIdx 부터 rightIdx 까지의 합 global cumulativeSum return cumulativeSum[rIdx + 1] - cumulativeSum[lIdx] print(calRangeSum(0, 0)) # 3 print(calRangeSum(0, 1)) # 8 print(calRangeSum(0, 3)) # 24 print(calRangeSum(2, 3)) # 12 print(calRangeSum(3, 3)) # 9 초기에, cumulativeSum = [0] 으로 초기화 해야, 이후 계산이 편해진다.\n\u0026lsquo;cumulativeSum[-1] = 0이라 가정\u0026rsquo; 에 해당 실제 PS에 누적 합 알고리즘을 쓸 때, 구간 인덱스가 0 or 1부터 인지 꼭 확인해야 한다.\n이 코드는 idx를 기준으로 계산하는 코드이다.\n0 \u0026lt;= leftIdx \u0026lt; rightIdx \u0026lt; N 일반적인 구간 합 레퍼런스는 범위 정수를 기준으로 알려져 있다.\n이 경우에는 calRangeSum(left, right) = cumulativeSum[right - 1] - cumulativeSum[left] 이다. 슬라이딩 윈도우 (Sliding Window) 슬라이딩 윈도우는 **고정된 크기의 범위(윈도우)**를 데이터를 순차적으로 이동시키면서, 일정한 구간의 데이터를 효율적으로 처리하는 알고리즘 기법입니다.\n이 방식은 특히 연속적인 구간에서 합계나 최대값, 최소값 등을 구하는 문제에서 자주 사용됩니다.\n핵심 아이디어 슬라이딩 윈도우는 전체 데이터를 처리하지 않고, 고정된 크기의 구간을 한 칸씩 이동하면서 그때그때 구간 내의 값을 업데이트하는 방식입니다.\n구간을 이동할 때, 이전 구간의 값을 활용하여 새로운 구간의 계산을 빠르게 처리할 수 있습니다.\n슬라이딩 윈도우의 활용 상황 연속된 구간의 합을 구하는 문제 최대/최소값을 구하는 문제 부분 배열/문자열의 패턴 매칭 문제 슬라이딩 윈도우의 기본 예시: 연속된 구간의 합을 구하는 문제 예를 들어, 배열에서 크기 k인 구간의 합을 구하는 경우를 생각해보세요. 배열이 [1, 3, 2, 6, 4, 5, 8]이고, k = 3이라면 크기 3인 구간의 합을 차례로 구하고 싶습니다.\n1. Naive 접근법 (비효율적): 모든 구간을 하나씩 새로 계산하는 방법은 다음과 같습니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 public class Main { public static void main(String[] args) { int[] arr = {1, 3, 2, 6, 4, 5, 8}; int k = 3; // 각 구간의 합을 계산 (구간의 시작 인덱스는 i) for (int i = 0; i \u0026lt;= arr.length - k; i++) { int sum = 0; for (int j = i; j \u0026lt; i + k; j++) { sum += arr[j]; } System.out.println(\u0026#34;Sum of window starting at \u0026#34; + i + \u0026#34;: \u0026#34; + sum); } } } 여기서는 각 구간의 합을 구할 때마다 모든 원소를 다시 더하고 있습니다. 이 방법은 시간 복잡도가 **O(n*k)**이므로 비효율적입니다. 2. 슬라이딩 윈도우를 이용한 효율적인 방법: 한 번 계산한 구간에서, 구간을 한 칸 오른쪽으로 이동할 때 맨 앞의 값을 빼고, 새로 추가되는 값을 더하는 방식으로 합을 계산하면, 중복 계산을 피할 수 있습니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 fun main() { val arr = arrayOf(1, 3, 2, 6, 4, 5, 8) val k = 3 // 초기 구간의 합 계산 var sum = 0 for (i in 0 until k) { sum += arr[i] } println(\u0026#34;Initial sum: $sum\u0026#34;) // 슬라이딩 윈도우로 구간을 한 칸씩 이동하면서 합을 업데이트 for (i in 1..arr.size - k) { sum = sum - arr[i - 1] + arr[i + k - 1] println(\u0026#34;Sum of window starting at $i: $sum\u0026#34;) } } Initial sum: 6 Sum of window starting at 1: 11 Sum of window starting at 2: 12 Sum of window starting at 3: 15 Sum of window starting at 4: 17 슬라이딩 윈도우 활용법: 초기 윈도우 구간을 설정한 후, 구간이 이동할 때마다 이전 구간에서 제외되는 값을 빼고 새롭게 추가되는 값을 더하는 방식으로 계산을 빠르게 업데이트합니다. 이렇게 하면 시간 복잡도가 **O(n)**으로 줄어들어, 더 큰 데이터를 효율적으로 처리할 수 있습니다. 활용 예시 1: 최대 구간 합 배열에서 연속된 k개의 요소 중 최대 구간 합을 구하는 문제를 슬라이딩 윈도우로 해결할 수 있습니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 fun main() { val arr = arrayOf(1, 3, 2, 6, 4, 5, 8) val k = 3 // 초기 구간의 합 계산 var maxSum = 0 for (i in 0 until k) { maxSum += arr[i] } var currentSum = maxSum // 슬라이딩 윈도우로 구간을 한 칸씩 이동하면서 최대 구간 합 계산 for (i in 1..arr.size - k) { currentSum = currentSum - arr[i - 1] + arr[i + k - 1] if (currentSum \u0026gt; maxSum) { maxSum = currentSum } } println(\u0026#34;Maximum sum of any window: $maxSum\u0026#34;) } 활용 예시 2: 문자열에서 부분 문자열의 패턴 매칭 슬라이딩 윈도우는 문자열에서도 유용하게 쓰입니다. 예를 들어, 주어진 문자열에서 특정 길이의 부분 문자열이 패턴에 맞는지 확인하는 문제를 슬라이딩 윈도우로 해결할 수 있습니다.\n슬라이딩 윈도우의 장점: 효율성: 슬라이딩 윈도우는 불필요한 반복 계산을 줄여, 처리 속도를 크게 향상시킵니다. 시간 복잡도: 많은 문제에서 슬라이딩 윈도우 기법을 사용하면, 전체 배열이나 문자열을 매번 새로 계산하는 대신, O(n) 복잡도로 문제를 해결할 수 있습니다. 시간 복잡도 분석 초기 구간 계산:\n슬라이딩 윈도우 기법에서는 먼저 첫 번째 구간에 대한 합을 계산합니다. 이 작업은 구간의 크기 k에 대해 **O(k)**의 시간이 소요됩니다. 1 2 3 4 5 // 초기 구간의 합 계산 (O(k)) int sum = 0; for (int i = 0; i \u0026lt; k; i++) { sum += arr[i]; } 구간 이동 및 업데이트:\n이후, 윈도우를 한 칸씩 이동하면서, 이전 구간의 맨 앞 값을 빼고, 새로운 값을 더하는 방식으로 구간 합을 업데이트합니다. 이 작업은 한 번의 이동당 **O(1)**의 시간이 소요됩니다. 1 2 3 4 // 슬라이딩 윈도우로 구간을 한 칸씩 이동하면서 합을 업데이트 (O(n - k)) for (int i = 1; i \u0026lt;= arr.length - k; i++) { sum = sum - arr[i - 1] + arr[i + k - 1]; } 전체 배열을 처리:\n슬라이딩 윈도우는 배열을 한 번 순회하는 동안 고정된 크기의 구간을 이동하면서 계산을 수행합니다. 배열 전체의 크기가 n이라면, **전체 시간 복잡도는 O(n)**이 됩니다. 최종 시간 복잡도: 초기 구간 계산: O(k) (구간의 크기 k만큼의 합을 처음에 계산) 구간 이동 및 업데이트: O(n - k) (나머지 n - k개의 구간을 계산) 전체 시간 복잡도: O(n) 즉, 슬라이딩 윈도우는 배열 전체를 한 번 순회하면서 각 구간을 효율적으로 계산하기 때문에, **O(n)**의 시간 복잡도로 문제를 해결할 수 있습니다.\nReference 프로그래밍 대회에서 배우는 알고리즘 문제 해결 전략 (구종만, 인사이트) https://www.algospot.com/ ","permalink":"https://2taezeat.github.io/posts/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EB%AC%B8%EC%A0%9C-%ED%95%B4%EA%B2%B0-%EC%A0%84%EB%9E%B5/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EB%AC%B8%EC%A0%9C-%ED%95%B4%EA%B2%B0-%EC%A0%84%EB%9E%B5-ch17.-%EA%B8%B0%EC%B4%88-%EC%9E%90%EB%A3%8C-%EA%B5%AC%EC%A1%B0/","summary":"17. 부분 합, 누적 합, 구간 합 17.1 도입 누적 합(Cumulative Sum, prefix sum): 배열의 각 위치에 대해 배열의 시작부터 현재 위치까지의 원소의 합을 미리 구해 둔 배열 O(N), 수열의 길이에 선형으로 증가 누적 합(Cumulative Sum)을 미리 구해 두면, list의 특정 구간의 합(range sum)을 O(1)에 구할 수 있다. cumulativeSum[-1] = 0이라 가정할 때, list[a]부터 list[b]까지의 합은 cumulativeSum[b] - cumulativeSum[a-1] 이다. 핵심: O(N) 시간으로 계산한 누적 합을 통해서, 구간 합을 O(1) 시간으로 빠르기 구하기 누적 합(Cumulative Sum) 은 첫 위치가 항상 A[0]으로 고정된, 구간 합(range sum) 이라고 할 수도 있다.","title":"[알고리즘 문제 해결 전략] ch17. 기초 자료 구조"},{"content":" 자료 구조란 프로그램이 자료를 저장하는 방식\n가장 기초적인 형태의 자료 구조\n변수, 배열, 레코드(구조체 or 클래스) 모든 자료 구조는 추상화와 최적화를 위해 생겨 났다.\n추상화란 현실 세계에 존재하는 개념이나 구조를 간결화해 컴퓨터 프로그램에 사용되는 자료 구조로 표현하는 과정\n현실 세계는 너무 모호하고 많은 정보를 담고 있기에, 이를 프로그램으로 직접 구현하기 번거롭다 현실 세계의 개념을 추상화한 자료 구조는 개념에서 중요한 뼈대만을 뽑아내 이름을 붙이고, 명확한 정의들을 곁들여 사람들이 쉽게 사용할 수 있게 한다. 큐를 사용하는 데서 오는 가장 큰 장점은 큐를 사용하는 사람은 내부적으로 큐가 어떻게 구현되는지에 대해 전혀 신경 쓸 필요가 없다.\n추상화는 의사소통을 도와주는 역할도 한다.\n간결한 용어를 제공, 의사소통을 위한 좋은 약속 최적화는 프로그램의 동작 속도를 빠르게 하기 위한 것이다.\n16. 비트 마스크 16.1 도입 현대의 모든 CPU는 이진수를 이용해 모든 자료를 표현\n이진법 연산을 컴퓨터가 매우 빠르게 할 수 있다. 비트마스크(bitmask): 이진수 표현을 자료 구조로 쓰는 기법\n장점\n더 빠른 수행 시간\n더 간결한 코드\n더 작은 메모리 사용량\n연관 배열(map 객체)을 배열로 대체\n16.1.1 용어 정의 이진수의 한 자리를 비트(bit)라고 한다. 비트는 0 or 1의 값을 가질 수 있다. 1: 켜져 있다 0: 꺼져 있다 부호 없는 N비트 정수형 변수는 N자리의 이진수로 쓸 수 있다. 각 비트가 표현하는 값은 2^0 ~ 2^N-1 까지 이다 최상위 비트(most significant bit): 2^N-1에 해당하는 비트 최하위 비트(least significant bit): 2^0에 해당하는 비트 16.1.2 비트 연산자 AND 연산, a\u0026amp;b: 입력받은 두 정수를 한 비트씩 비교하면서, 두 정수에 해당 비트가 모두 켜져 있을 때만 결과의 비트를 킨다.\nOR 연산, a|b: 하나라도 켜져 있을 경우, 결과 비트를 킨다.\nXOR 연산, a^b: 하나는 켜져 있고, 하나는 꺼져 있을 경우, 결과 비트를 킨다.\nNOT 연산, ~a: 켜져 있는 비트는 끄고, 꺼져 있는 비트는 킨다.\nShift(시프트) 연산, a \u0026laquo; b / a \u0026raquo; b: 정수 a의 비트들을 왼쪽 또는 오른쪽으로 원하는 만큼 움직인다.\n반대쪽 끝 비트는 0으로 채워진다. 16.1.3 유의할 점들 연산자 우선순위 비트 연산자의 우선순위는, 비교 연산자 보다 낮다 (C++, Java) 파이썬의 경우는 반대이다. 64비트 정수를 비트마스크로 사용할 때 발생하는 오버플로 부호 있는 정수형의 사용 변수의 모든 비트를 다 쓰고 싶을 때는 부호 없는 정수형을 쓰는 게 좋다. 16.2 비트마스크를 이용한 집합의 구현 N비트 정수 변수는 0부터 N-1 까지의 정수 원소를 가질 수 있는 집합이 된다. 원소 i 가 집합에 속해 있는지 여부는 2^i을 나타내는 비트가 켜져 있는지 여부로 나타낸다. {1, 4, 5, 6, 7, 9}을 표현하는 정수는 754, 10 1111 0010(2진수) 이다. 16.2.1 피자집 예제 토핑은 20가지가 존재 (0 ~ 19번 번호를 가지고 있음)\n토핑을 넣기(1), 넣지 않기(0) 을 선택할 수 있다.\n공집합: 상수 0\n토핑 \u0026lsquo;전부 다\u0026rsquo; 올린 피자: (1 \u0026lt;\u0026lt; 20) - 1\n원소 추가, 해당 비트를 켠다는 의미\ntoppings |= ( 1 \u0026lt;\u0026lt; p ) 원소의 포함 여부 확인\nif (toppings \u0026amp; (1 \u0026lt;\u0026lt; p)) 원소의 삭제\ntoppings \u0026amp;= ~(1 \u0026lt;\u0026lt; p) 원소의 토글(toggle)\ntoppings ^= (1 \u0026lt;\u0026lt; p) 두 집합에 대해 연산\n합집합: (a | b) 교집합: (a \u0026amp; b) 차집합: (a \u0026amp; ~b) 하나에만 포함된 원소들의 집합: (a ^ b) 집합의 크기 구하기\n내장으로 구현되어 있다. C, C++, Java 1 2 3 def bitCount(x): if x == 0: return 0 return x % 2 + bitCount(x // 2) 최소 원소 찾기\n이 정수의 이진수 표현에서 끝에 붙어 있는 0이 몇 개 인가? 내장으로 구현되어 있다. C, C++, Java 최소 원소 지우기\ntoppings \u0026amp;= (toppings - 1) 이 방법은 어떤 정수가 2의 거듭제곱 값인지 확인할 때도 유용하게 쓰인다. 모든 부분 집합 순회하기\npizza = {0,1,2} 일 때 {0}, {0, 1}, {0, 1, 2}, {0, 2}, {1}, {1, 2}, {2} for pizza in toppings: subset = ((subset-1) \u0026amp; pizza) 공집합은 방문하지 않는다. subset - 1: 켜져 있던 최하위 비트가 꺼지고, 그 밑의 비트는 전부 켜진다. Reference 프로그래밍 대회에서 배우는 알고리즘 문제 해결 전략 (구종만, 인사이트) https://www.algospot.com/ ","permalink":"https://2taezeat.github.io/posts/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EB%AC%B8%EC%A0%9C-%ED%95%B4%EA%B2%B0-%EC%A0%84%EB%9E%B5/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EB%AC%B8%EC%A0%9C-%ED%95%B4%EA%B2%B0-%EC%A0%84%EB%9E%B5-ch16.-%EA%B8%B0%EC%B4%88-%EC%9E%90%EB%A3%8C-%EA%B5%AC%EC%A1%B0/","summary":"자료 구조란 프로그램이 자료를 저장하는 방식\n가장 기초적인 형태의 자료 구조\n변수, 배열, 레코드(구조체 or 클래스) 모든 자료 구조는 추상화와 최적화를 위해 생겨 났다.\n추상화란 현실 세계에 존재하는 개념이나 구조를 간결화해 컴퓨터 프로그램에 사용되는 자료 구조로 표현하는 과정\n현실 세계는 너무 모호하고 많은 정보를 담고 있기에, 이를 프로그램으로 직접 구현하기 번거롭다 현실 세계의 개념을 추상화한 자료 구조는 개념에서 중요한 뼈대만을 뽑아내 이름을 붙이고, 명확한 정의들을 곁들여 사람들이 쉽게 사용할 수 있게 한다.","title":"[알고리즘 문제 해결 전략] ch16. 기초 자료 구조"},{"content":"유명한 알고리즘이나 자료 구조를 도구로 사용해 풀어야 하는 문제들에 대해 다룸\n13. 수치 해석 13.1 도입 수치 해석: 직접 풀기 힘든 수학 문제를 근사적으로 푸는 알고리즘과 오차의 범위, 수치적 안정성을 연구하는 전산학의 분야 13.2 이분법 이분법: 주어진 범위 [lo, hi] 내에서 어떤 함수 f(x)의 값이 0이 되는 지점을 수치적으로 찾아내는 기법 이분법은 이분탐색의 토대가 된다. 정해진 횟수만큼 반복하기 반복문을 100번 반복하면, 절대 오차가 최대 lo-hi / 2 ^101 이 된다. 이 오차는 10 ^ -7 보다 작다. 따라서 큰 숫자를 다루는 경우에도 충분히 답을 구할 수 있다. 14. 정수론 14.1 소수 판별 O( √N ) 소수 판별 알고리즘 (다른 알고리즘 보다 빠르다.)\nnum이 합성 수 이면, p x q 꼴로 나타내어지고, p는 항상 √Num 이하, q는 항상 √Num 이상 이다. 따라서, num-1 까지 순회하지 않고, √Num 까지만 순회 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 def isPrime1(n): if n \u0026lt;= 1: return False if n == 2: return True if (n % 2) == 0: return False sqrtn = sqrt(n) for div in range(3, sprt + 1, 2): if (n % div) == 0: return False def isPrime2(n): end = int(n**(1/2)) for i in range(2, end+1): if n % i == 0: return False return True 14.2 에라토스테네스의 체 주어진 수 Num 이하의 소수들을 모두 찾아낸다. (배열로 return이 가능)\nn 까지의 수를 배열로 만든 상태에서 시작\n시간 복잡도: O(NloglogN) // 실용적인 범위에서 O(N)와 거의 비슷\n시간 보다는 메모리 사용량이 관건이다.\n1 2 3 4 5 6 7 8 9 10 def getPrimeNumbers(num): # by 에라토스테네스의 체 arr = [i for i in range(num + 1)] # 인덱싱을 수월하게 하기 위해 0부터 배열 선언 end = int(num ** (1 / 2)) for i in range(2, end + 1): if arr[i] == 0: # 이미 소수가 아님이 판별된 수는 건너뜀 continue for j in range(i * i, num + 1, i): # 자기 자신을 제외한 i의 배수는 모두 0으로 처리함. arr[j] = 0 return [i for i in arr[2:] if arr[i]] 14.5 유클리드 알고리즘 최대 공약수를 구하는 알고리즘 두 수, p, q (p \u0026gt; q)의 공약수의 집합은 p - q와 q의 공약수 집합과 같다는 점을 이용 gcd(q, p) = gcd(p-q, q) 1 2 3 4 5 6 7 8 9 10 11 12 def gcd(a, b): # 재귀 if a % b == 0: return b return gcd(b, a % b) def gcd(a, b): # 반복문 while b \u0026gt; 0: a, b = b, a % b return a def lcd(a, b): return a * b // gcd(a, b) 14.8 모듈러 연산 모듈러 연산: 모듈러(modulus) M에 도달하면 다시, 0으로 돌아가는 정수들을 가지고 하는 연산이다.\nEx) 시계는 25시나 42시가 없다, 1시나, 18시로 표현해야 한다. 시간(hour): 0~23 / M = 24 a % b 는 a 를 b로 나눈 나머지를 의미한다. (%: 나머지 연산자)\n두 수를 더한 뒤 나머지를 취하는 것은 미리 두 수의 나머지를 구한 뒤 더하고, 다시 나머지를 취하는 것과 같다.\n덧셈, 곱셈, 뺄셈에 적용, 나눗셈은 적용 안됨 15. 계산 기하 15.1 다각형 면적 구하기 1 2 3 4 5 6 figure.append(figure[0]) area = 0 for i in range(N): area += figure[i][0]*figure[i+1][1] - figure[i+1][0]*figure[i][1] area = area / 2 15.2 스위핑 알고리즘 평면 스위핑(Plane Wweeping), 라인 스위핑(Line Sweeping)이라고 불리는 패턴이 있습니다.\n평면 스위핑을 이용하는 알고리즘들은 수평선 혹은 수직선으로 주어진 평면을 \u0026lsquo;쓸고 지나가면서\u0026rsquo; 문제를 해결합니다.\n스위핑 알고리즘이란 단어의 뜻 그대로 휩쓸고 지나가며 문제를 해결하는 방식으로,\n특정 기준에 따라 정렬한 후 순서대로 처리하는 알고리즘이다.\n보통 문제들의 경우 인풋의 범위만큼 브루트 포스를 사용하게 되면 선분일 경우 N의 시간복잡도 이다. 평면: N^2\n스위핑 알고리즘은 정렬의 시간복잡도인 NlogN이 대부분이다.\n투 포인터 투 포인터의 기본 개념 포인터: 배열이나 리스트의 특정 인덱스를 가리키는 변수입니다.\n투 포인터: 두 개의 포인터를 사용하여 배열의 양쪽 끝이나, 두 위치에서 출발하여 동시에 배열을 탐색하는 방식입니다.\nPython 예시 코드\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 n = 5 # 데이터의 개수 N m = 5 # 찾고자 하는 부분합 M data = [1,2,3,2,5] count = 0 interval_sum = 0 end = 0 for start in range(n): # start를 차례대로 증가시키며 반복 while interval_sum \u0026lt; m and end \u0026lt; n: # end를 가능한 만큼 이동시키기 interval_sum += data[end] end += 1 if interval_sum == m: # 부분합이 m일 때 카운트 증가 count += 1 # start 가 증가 되기 때문에 (맨 위 for문) data[start] 값 만큼 빼주어야 한다. interval_sum -= data[start] 투 포인터의 동작 원리 두 개의 포인터를 배열이나 리스트의 다른 위치에 두고, 각 포인터를 조절하면서 문제를 해결합니다. 주로 하나의 포인터가 시작점을 가리키고, 다른 포인터가 끝점 또는 그 외의 적절한 지점을 가리킵니다. 각 포인터는 문제 조건에 맞게 이동하며 탐색 범위를 좁혀 나가거나 넓혀 나갑니다. 투 포인터의 사용 사례 (1) 정렬된 배열에서 두 수의 합을 구하는 문제 (Two Sum Problem) 배열에서 두 숫자의 합이 특정 값이 되는 쌍을 찾는 문제.\n동작 방식:\n배열이 정렬되어 있는 상태에서, 하나의 포인터는 시작 지점(왼쪽 끝), 다른 포인터는 끝 지점(오른쪽 끝) 에서 시작합니다. 두 수의 합이 목표 값보다 작으면 왼쪽 포인터를 오른쪽으로 이동시킵니다(값을 크게 하기 위해). 두 수의 합이 목표 값보다 크면 오른쪽 포인터를 왼쪽으로 이동시킵니다(값을 작게 하기 위해). 두 포인터가 만날 때까지 이 과정을 반복하며, 목표 값을 찾습니다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 fun twoSum(arr: IntArray, target: Int): Pair\u0026lt;Int, Int\u0026gt;? { var left = 0 var right = arr.size - 1 while (left \u0026lt; right) { val sum = arr[left] + arr[right] if (sum == target) { return Pair(left, right) // 두 수의 인덱스를 반환 } else if (sum \u0026lt; target) { left++ // 합이 작으면 왼쪽 포인터를 오른쪽으로 } else { right-- // 합이 크면 오른쪽 포인터를 왼쪽으로 } } return null // 목표 값에 맞는 두 수를 찾지 못함 } fun main() { val arr = intArrayOf(1, 2, 3, 4, 6) val target = 6 val result = twoSum(arr, target) println(result) // 출력: (1, 3), 즉 arr[1] + arr[3] = 2 + 4 = 6 } (2) 부분 배열의 합 문제 (Subarray Sum Problem) 배열에서 연속된 부분 배열의 합이 특정 값이 되는 경우를 찾는 문제. 동작 방식: 하나의 포인터는 부분 배열의 시작점, 다른 포인터는 부분 배열의 끝점을 가리킵니다. 부분 배열의 합이 목표 값보다 작으면 끝 포인터를 오른쪽으로 이동시켜 배열을 확장하고, 합이 목표 값보다 크면 시작 포인터를 오른쪽으로 이동시켜 배열을 축소합니다. (3) 두 배열 병합 (Merging Two Sorted Arrays) 정렬된 두 배열을 하나의 배열로 합치는 문제.\n동작 방식:\n각 배열에 하나씩 포인터를 두고, 각 배열의 포인터가 가리키는 값을 비교하면서 작은 값을 결과 배열에 추가합니다. 한 배열의 모든 요소가 처리될 때까지 이 과정을 반복합니다. (4) 세 수의 합 문제 (Three Sum Problem) 배열에서 세 수의 합이 특정 값이 되는 세 숫자를 찾는 문제. 해결 방법: 첫 번째 수는 배열을 순회하면서 선택하고, 나머지 두 수의 합을 찾는 부분은 투 포인터 알고리즘을 사용하여 해결합니다. 예시 코드 (세 수의 합 문제는 중복 처리와 관련된 추가적인 로직이 필요합니다). 투 포인터의 복잡도 메모리 사용량이 적습니다. 추가적인 메모리 공간을 거의 사용하지 않으며, 대부분의 경우 상수 공간 복잡도(O(1)) 를 유지합니다.\n투 포인터(Two Pointers) 알고리즘의 시간 복잡도는 일반적으로 O(N) 입니다. 이는 대부분의 투 포인터 문제에서, 배열이나 문자열을 한 번만 순회하기 때문입니다.\n투 포인터의 시간 복잡도 분석 기본 원리: 투 포인터 알고리즘은 보통 배열의 양 끝 또는 특정 위치에서 두 개의 포인터를 설정하고, 각 포인터가 배열을 한 방향으로 이동합니다.\n두 포인터는 서로를 향해, 또는 같은 방향으로 이동하면서 배열을 한 번에 한 요소씩 처리합니다.\n포인터들이 한 번에 하나의 요소만 스캔하기 때문에 전체 배열을 한 번만 순회하게 됩니다.\n상세 분석: 배열이나 문자열의 길이를 N이라고 할 때\n각 포인터는 배열의 한 끝에서 시작해서, 배열의 다른 끝까지 한 번만 이동합니다.\n두 포인터의 움직임이 반복될 때, 한 번의 움직임은 배열의 한 요소만을 처리하므로, 각 포인터는 최대 N번의 연산을 수행하게 됩니다.\n정렬된 배열에서 두 수의 합 찾기 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 fun twoSum(arr: IntArray, target: Int): Pair\u0026lt;Int, Int\u0026gt;? { var left = 0 var right = arr.size - 1 while (left \u0026lt; right) { val sum = arr[left] + arr[right] if (sum == target) { return Pair(left, right) } else if (sum \u0026lt; target) { left++ } else { right-- } } return null } left 포인터는 시작점에서 오른쪽으로 이동하고, right 포인터는 끝점에서 왼쪽으로 이동합니다. 각 포인터가 배열을 최대 한 번씩만 이동하므로, 시간 복잡도는 O(N) 입니다. 부분 배열의 합 구하기 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 fun subarraySum(arr: IntArray, target: Int): Pair\u0026lt;Int, Int\u0026gt;? { var currentSum = 0 var start = 0 for (end in arr.indices) { currentSum += arr[end] while (currentSum \u0026gt; target \u0026amp;\u0026amp; start \u0026lt;= end) { currentSum -= arr[start] start++ } if (currentSum == target) { return Pair(start, end) } } return null } end 포인터는 배열을 순차적으로 탐색하면서 오른쪽으로 이동합니다. start 포인터는 필요할 때만 오른쪽으로 이동합니다. 여기서도 start와 end 모두 배열의 각 요소를 최대 한 번씩만 방문하므로, 시간 복잡도는 O(N) 입니다. 투 포인터가 유용한 상황 정렬된 배열이나 리스트에서 특정 조건을 만족하는 쌍을 찾거나, 부분 배열을 탐색할 때.\n연속된 부분 배열 또는 서로 다른 배열을 동시에 탐색해야 하는 문제.\n배열의 양쪽 끝에서부터 범위를 줄여가며 최적의 해를 구해야 할 때.\nSlow-Fast 알고리즘 Slow-Fast 알고리즘(또는 토끼와 거북이 알고리즘, Floyd’s Tortoise and Hare Algorithm)은 연결 리스트나 배열에서 두 개의 포인터를 사용하는 기법입니다. 두 포인터를 서로 다른 속도로 움직여 문제를 해결하는 방식으로, 특히 순환이 있는지 또는 사이클을 탐지하는 문제에서 자주 사용됩니다. 시간 복잡도는 일반적으로 O(N), 공간 복잡도는 O(1) 로 매우 효율적입니다. 개념 Slow 포인터는 한 번에 한 칸씩 이동하고, Fast 포인터는 한 번에 두 칸씩 이동합니다. 두 포인터가 이동하다가 같은 지점에 도달하면, 그 구조에는 순환(사이클)이 존재한다는 것을 의미합니다. 반대로, Fast 포인터가 끝에 도달하면 순환이 없다는 것을 알 수 있습니다. 활용 사례 연결 리스트에서 사이클 탐지 중간 노드 찾기 사이클 시작 지점 찾기 대표적인 문제들 연결 리스트에서 사이클 탐지 주어진 연결 리스트가 순환(Cycle) 이 있는지 여부를 판별하는 문제입니다.\nSlow 포인터는 한 번에 한 칸씩 이동하고, Fast 포인터는 한 번에 두 칸씩 이동합니다. 두 포인터가 어느 순간 만나면 순환이 있다는 것을 의미합니다. 만약 Fast 포인터가 끝까지 도달하면 순환이 없다는 뜻입니다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class ListNode(val value: Int) { var next: ListNode? = null } fun hasCycle(head: ListNode?): Boolean { var slow = head var fast = head while (fast?.next != null) { slow = slow?.next // 한 칸 이동 fast = fast.next?.next // 두 칸 이동 if (slow == fast) { return true // 두 포인터가 만나면 순환이 있음 } } return false // fast가 끝에 도달하면 순환이 없음 } 사이클의 시작 지점 찾기 연결 리스트에 사이클이 존재하는 경우, 그 사이클의 시작 지점을 찾아내는 문제입니다.\n사이클을 감지하기 위해 Slow-Fast 알고리즘을 먼저 사용합니다. 두 포인터가 만나면, Slow 포인터를 다시 리스트의 시작 지점으로 이동시킵니다. 그 후 Slow 포인터와 Fast 포인터를 각각 한 칸씩 이동시키면, 두 포인터는 사이클의 시작 지점에서 만나게 됩니다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 fun detectCycle(head: ListNode?): ListNode? { var slow = head var fast = head // 사이클 존재 여부 확인 while (fast?.next != null) { slow = slow?.next fast = fast.next?.next if (slow == fast) { // 사이클 발견 시, slow를 시작점으로 이동 var cycleStart = head while (cycleStart != slow) { cycleStart = cycleStart?.next slow = slow?.next } return cycleStart // 사이클 시작 지점 반환 } } return null // 사이클이 없는 경우 null 반환 } 배열에서 중복 요소 찾기 배열에서 1부터 N까지의 숫자가 들어있을 때, 하나의 숫자가 중복되어 들어있는 배열이 있다고 가정합니다. 이때 중복된 숫자를 찾아내는 문제입니다.\n중복된 숫자는 사이클을 형성하는 것으로 간주할 수 있으며, 이를 찾는 방식은 연결 리스트의 사이클 탐지와 유사합니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 fun findDuplicate(nums: IntArray): Int { var slow = nums[0] var fast = nums[0] // 사이클 존재 여부 확인 do { slow = nums[slow] fast = nums[nums[fast]] } while (slow != fast) // 사이클 시작 지점 찾기 var finder = nums[0] while (finder != slow) { finder = nums[finder] slow = nums[slow] } return finder // 중복된 숫자 반환 } Reference 프로그래밍 대회에서 배우는 알고리즘 문제 해결 전략 (구종만, 인사이트) https://www.algospot.com/ ","permalink":"https://2taezeat.github.io/posts/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EB%AC%B8%EC%A0%9C-%ED%95%B4%EA%B2%B0-%EC%A0%84%EB%9E%B5/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EB%AC%B8%EC%A0%9C-%ED%95%B4%EA%B2%B0-%EC%A0%84%EB%9E%B5-ch13-14-15.-%EC%9C%A0%EB%AA%85%ED%95%9C-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98%EB%93%A4/","summary":"유명한 알고리즘이나 자료 구조를 도구로 사용해 풀어야 하는 문제들에 대해 다룸\n13. 수치 해석 13.1 도입 수치 해석: 직접 풀기 힘든 수학 문제를 근사적으로 푸는 알고리즘과 오차의 범위, 수치적 안정성을 연구하는 전산학의 분야 13.2 이분법 이분법: 주어진 범위 [lo, hi] 내에서 어떤 함수 f(x)의 값이 0이 되는 지점을 수치적으로 찾아내는 기법 이분법은 이분탐색의 토대가 된다. 정해진 횟수만큼 반복하기 반복문을 100번 반복하면, 절대 오차가 최대 lo-hi / 2 ^101 이 된다. 이 오차는 10 ^ -7 보다 작다.","title":"[알고리즘 문제 해결 전략] ch13, 14, 15. 유명한 알고리즘들"},{"content":"12. 최적화 문제 결정 문제로 바꿔 풀기 12. 1 도입 최적화 문제를 결정 문제로 바꿔 풀기(파라메트릭 서치): 유용한 디자인 원칙 중 하나, 최적화 문제를 결정 문제로 바꾼 뒤, 이를 이분법으로 해결하는 방법\n결정 문제(decision problem): yes, true or no, false 의 형태의 답만 나오는 문제들\n최적화 문제의 반환 값은 대개 실수 or 정수로 답이 무한한 데 반해, 결정 문제는 답이 두 가지만 존재\n최적화 문제와 결정 문제의 관계 1) 두 문제 형태가 똑같이 어려운 경우, 2) 최적화 문제가 더 여러운 경우\n결정 문제가 최적화 문제보다 어려울 수 없다.\n결정 문제 \u0026lt;= 최적화 문제 (Hardness)\n1 2 3 4 5 fun optimize(graph: G): double {} fun decision(graph: G, double: x) { return optimize(graph) \u0026lt;= x } 12.2 최적화 문제와 결정 문제 decision() 은 \u0026ldquo;답 x가 존재하는가? (b)\u0026rdquo; 라는 질문 대신 \u0026quot;x 또는 그 보다 좋은 답이 있는가? (a)\u0026quot;, 라는 질문에 대답한다. (a) 같은 형태의 질문을 이용해, 최적화 문제를 푸는 쉬운 방법이 존재하기 때문에 두 개의 차이는 중요하다. 최적화 문제를 결정 문제로 변형 하는 것은 더 쉽고 빠른 방법이 있기를 기대하기 때문이다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 def decision(input, midValue) { # decision 판별 logic with midValue # ... return False or return True } def optimize(input) { # decsion() 을 호출한다. start, end = 초기화, 초기화 # 이분법 사용 while True: mid = (start + end) // 2 if decision(input, mid): # 결정 문제 해결 함수 사용 start = mid else: end = mid return start or end or something } 12.3. 최적화 문제 결정 문제로 바꾸기(파라메트릭 서치) 레시피 \u0026ldquo;가장 좋은 답은 무엇인가?\u0026rdquo; 라는 최적화 문제를 \u0026quot;x 혹은 그보다 좋은 답이 있는가?\u0026quot; 라는 결정 문제 형태로 변경 결정 문제를 쉽게 풀 수 있는 방법을 찾는다 결정 문제를 내부적으로 이용하는(decision 함수 호출) 이분법 알고리즘 (optimize 함수) 을 구현한다. 12.4, 12.5 캐나다 여행, CANADATRIP, 난이도: 중 최적화 문제는 아니지만, 이 문제 또한 원래 문제를 결정 문제로 바꿀 수 있다. \u0026ldquo;K번째 표지판의 위치는 어디인가\u0026rdquo; 라는 문제를 다음과 같이 바꾼다. decision(x) = 시작점부터 x미터 지점까지 가면서 K개 이상의 표지판을 만날 수 있는가? 중요: 우리가 원하는 답이 \u0026lsquo;D\u0026rsquo;라고 하면, \u0026lsquo;D\u0026rsquo;는 decision()이 True를 반환하는 첫 번째 지점이다. 이전 부터, D-1까지 계속 False 이다가, D 이후부터 계속 True 라는 의미 decision(D-1) = false, decision(D) = True 여야 한다. ..... / D-1 / D / D+1 /... ... False / False / True / True ... Reference 프로그래밍 대회에서 배우는 알고리즘 문제 해결 전략 (구종만, 인사이트) https://www.algospot.com/ ","permalink":"https://2taezeat.github.io/posts/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EB%AC%B8%EC%A0%9C-%ED%95%B4%EA%B2%B0-%EC%A0%84%EB%9E%B5/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EB%AC%B8%EC%A0%9C-%ED%95%B4%EA%B2%B0-%EC%A0%84%EB%9E%B5-ch12.-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EC%84%A4%EA%B3%84-%ED%8C%A8%EB%9F%AC%EB%8B%A4%EC%9E%84/","summary":"12. 최적화 문제 결정 문제로 바꿔 풀기 12. 1 도입 최적화 문제를 결정 문제로 바꿔 풀기(파라메트릭 서치): 유용한 디자인 원칙 중 하나, 최적화 문제를 결정 문제로 바꾼 뒤, 이를 이분법으로 해결하는 방법\n결정 문제(decision problem): yes, true or no, false 의 형태의 답만 나오는 문제들\n최적화 문제의 반환 값은 대개 실수 or 정수로 답이 무한한 데 반해, 결정 문제는 답이 두 가지만 존재\n최적화 문제와 결정 문제의 관계 1) 두 문제 형태가 똑같이 어려운 경우, 2) 최적화 문제가 더 여러운 경우","title":"[알고리즘 문제 해결 전략] ch12. 알고리즘 설계 패러다임"},{"content":"11. 조합 탐색 11.1 도입 동적 계획법, 분할 정복 등의 디자인 패러다임은 유용하지만, 모든 문제에 적용할 수는 없다\n결국 우리는 시작점인 완전 탐색으로 돌아와 다시 시작할 필요성도 있다\n완전 탐색은 대개 답을 만드는 과정을 여러 개의 선택으로 나눈 뒤, 재귀 호출을 이용해 각각의 선택지를 채워가는 형태로 구현됨.\n이때 부분 답과 완성된 답의 집합을 탐색 공간(search space) 라고 한다 완전 탐색은 문제의 규모가 조금이라도 클 경우 사용하기 어려운 단점이 있다.\n완전 탐색을 포함해, 이렇게 유한한 크기의 탐색 공간을 뒤지면서 답을 찾아내는 알고리즘을 이 책에서는 조합 탐색(combinatorial search) 라고 한다.\n조합 탐색은 많은 최적화 방법이 있지만, 모두 기본적으로 최적해가 될 가능성이 없는 답들을 탐색하는 것을 방지하여 탐색할 답의 수를 줄이는 것을 목표로 함\n조합 탐색 최적화는 시공간, 입력 형태 등 모두 고려해야 하고, 깊은 식견이 요구됨, 딱히 정답이 없음\n조합 탐색 최적화는 크게 두 가지로 분류한다.\n가지치기(pruning): 탐색 과정에서 최적해로 연결될 가능성이 없는 부분들을 잘라냄 지금가지 찾아낸 최적해 보다 부분해가 이미 더 나빠졌다면, 현재 상태를 탐색하지 않고 종료 탐색의 순서 바꾸기, 탐색 시작 전에 탐욕법을 이용해 적당히 좋은 답 찾기, 휴리스틱(경험에 의거한 어림짐작) 을 이용한 가지치기 완전 탐색의 경우 답을 어떤 순서로 찾던 상관 없지만, 가지치기와 함께 사용할 경우, 더 일찍 탐색이 중단 됨으로 탐색의 효율이 높아짐 11.2 조합 탐색 기법들 간단한 휴리스틱을 이용한 가지치기\n조합 탐색에서 방문하는 상태의 수는 탐색의 깊이가 깊어질수록 증가, 따라서 \u0026rsquo;이 부분에서는 최적해가 나올 수 없다\u0026rsquo; 를 빨리 알아내는 것이 유리하다. 메모이제이션\n11.3, 11.4 게임판 덮기 2, BOARDCOVER2, 난이도: 하 최적화 문제에서 낙관적인 휴리스틱들은 문제를 과소평가 하는 대신, 과대평가 한다. 휴리스틱 함수를 만드는 쉬운 방법은 블록을 통째로 내려놓아야 한다는 제약을 없애서, 블록들을 한 칸씩 쪼개서 놓을 수 있도록 문제를 변형 우리가 놓을 수 있는 블록의 수: (남은 빈 칸의 수 / 블록의 크기) 이것은 우리가 실제 놓을 수 있는 블록의 수 이상이기에 우리가 얻을 수 있는 답의 상한이 된다. 각 경우에 계산된 상한이 현재 찾은 최적해 이하라면 탐색을 수행할 필요 없다. =\u0026gt; 가지치기 수행 Reference 프로그래밍 대회에서 배우는 알고리즘 문제 해결 전략 (구종만, 인사이트) https://www.algospot.com/ ","permalink":"https://2taezeat.github.io/posts/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EB%AC%B8%EC%A0%9C-%ED%95%B4%EA%B2%B0-%EC%A0%84%EB%9E%B5/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EB%AC%B8%EC%A0%9C-%ED%95%B4%EA%B2%B0-%EC%A0%84%EB%9E%B5-ch11.-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EC%84%A4%EA%B3%84-%ED%8C%A8%EB%9F%AC%EB%8B%A4%EC%9E%84/","summary":"11. 조합 탐색 11.1 도입 동적 계획법, 분할 정복 등의 디자인 패러다임은 유용하지만, 모든 문제에 적용할 수는 없다\n결국 우리는 시작점인 완전 탐색으로 돌아와 다시 시작할 필요성도 있다\n완전 탐색은 대개 답을 만드는 과정을 여러 개의 선택으로 나눈 뒤, 재귀 호출을 이용해 각각의 선택지를 채워가는 형태로 구현됨.\n이때 부분 답과 완성된 답의 집합을 탐색 공간(search space) 라고 한다 완전 탐색은 문제의 규모가 조금이라도 클 경우 사용하기 어려운 단점이 있다.\n완전 탐색을 포함해, 이렇게 유한한 크기의 탐색 공간을 뒤지면서 답을 찾아내는 알고리즘을 이 책에서는 조합 탐색(combinatorial search) 라고 한다.","title":"[알고리즘 문제 해결 전략] ch11. 알고리즘 설계 패러다임"},{"content":"10. 탐욕법 10.1 도입 탐욕적인 알고리즘: 우리가 원하는 답을 여러 개의 조각으로 쪼개고, 각 단계마다 답의 한 부분을 만들어간다는 점에서 완전 탐색, 동적 계획법과 다를 게 없다\n그러나 모든 선택지를 고려해 보고, 그 중 전체 답이 가장 좋은 것을 찾는 두 방법과 달리 탐욕법은 각 단계마다 지금 당장 가장 좋은 방법만을 선택한다. 탐욕법은 지금의 선택이 앞으로 남은 선택들에 어떤 영향을 끼칠지는 고려하지 않는다.\n탐욕법이 사용되는 경우\n탐욕법을 사용해도 항상 최적해를 구할 수 있는 경우, 탐욕법은 동적 계획법보다 휠씬 빠르다 시공간 제약으로 최적해를 찾기 너무 어려우면, 최적해 대신 적당히 괜찮은 답(근사 해) 을 찾는 것으로 타협할 수 있다. 이 때 사용 프로그래밍 대회에서는 주로 1번만 이용된다.\n10.1.1 예제, 회의실 예약 이 문제를 해결하는 탐욕적인 방법은 길이와 상관없이, 가장 먼저 끝나는 회의부터 선택하는 것 10.1.2 탐욕적 선택 속성(Greedy Choice Property) 탐욕적 선택 속성(Greedy Choice Property): 답의 모든 부분을 고려하지 않고, 탐욕적으로만 선택하더라도 최적해를 구할 수 있다. 이 속성이 성립할 경우, 우리가 각 단계에서 탐욕적으로 내리는 선택은 항상 최적해로 가는 길 중 하나 이다. 최적 부분 구조: 최적의 선택만을 내려서 전체 문제의 최적해를 얻을 수 있다. 동적 계획법의 속성 중 하나와 같음 탐욕법으로 최적해를 찾을 수 있는 많은 문제들은 동적 계획법으로도 풀 수 도 있다. 탐욕법을 설계하는 좋은 방법은 간단한 입력을 몇 개 손으로 풀어 보면서 패턴을 찾는 것 10.1.3 탐욕적 알고리즘 레시피 문제의 답을 만드는 과정을 여러 조각으로 나눈다. 각 조각마다 어떤 우선순위로 선택을 내려야 할지 결정한다. 좋은 방법: 간단한 입력을 몇 개 손으로 풀어 보면서 패턴을 찾는 것 탐욕적 선택 속성 증명: 다른 최적해가 존재함을 가정하고, 이것을 조작해서 우리가 선택한 답을 포함하는 최적해로 바꿀 수 있음을 보이는 형태로 이루어진다. 최적 부분 구조 증명 Reference 프로그래밍 대회에서 배우는 알고리즘 문제 해결 전략 (구종만, 인사이트) https://www.algospot.com/ ","permalink":"https://2taezeat.github.io/posts/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EB%AC%B8%EC%A0%9C-%ED%95%B4%EA%B2%B0-%EC%A0%84%EB%9E%B5/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EB%AC%B8%EC%A0%9C-%ED%95%B4%EA%B2%B0-%EC%A0%84%EB%9E%B5-ch10.-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EC%84%A4%EA%B3%84-%ED%8C%A8%EB%9F%AC%EB%8B%A4%EC%9E%84/","summary":"10. 탐욕법 10.1 도입 탐욕적인 알고리즘: 우리가 원하는 답을 여러 개의 조각으로 쪼개고, 각 단계마다 답의 한 부분을 만들어간다는 점에서 완전 탐색, 동적 계획법과 다를 게 없다\n그러나 모든 선택지를 고려해 보고, 그 중 전체 답이 가장 좋은 것을 찾는 두 방법과 달리 탐욕법은 각 단계마다 지금 당장 가장 좋은 방법만을 선택한다. 탐욕법은 지금의 선택이 앞으로 남은 선택들에 어떤 영향을 끼칠지는 고려하지 않는다.\n탐욕법이 사용되는 경우\n탐욕법을 사용해도 항상 최적해를 구할 수 있는 경우, 탐욕법은 동적 계획법보다 휠씬 빠르다 시공간 제약으로 최적해를 찾기 너무 어려우면, 최적해 대신 적당히 괜찮은 답(근사 해) 을 찾는 것으로 타협할 수 있다.","title":"[알고리즘 문제 해결 전략] ch10. 알고리즘 설계 패러다임"},{"content":"9. 동적 계획법 테크닉 9.1 최적화 문제의 실제 답 계산하기 최적화 문제를 풀때, 최적해의 점수만을 계산했다.\n가장 긴 증가 부분 수열(LIS)을 찾는 대신 해당 수열의 길이 를 찾음\n최적해를 직접 계산해야 할 때는 어떻게 해야 하는가?\n대개 동적 계획법을 사용하는 코드에서는 실제 답을 계산하는 과정을 별도로 구현한다.\n부분 문제가 주어질 때, 그중 첫 번째 조각을 어떤 선택지로 택했을 때, 최적해를 얻는지를 기록해 둔다. 별도의 배열을 사용해서 저장 별도의 재귀 함수를 이용해 각 조각에서 한 선택을 되짚어 가면서 최적해를 생성한다. 9.11 정수 이외의 입력에 대한 메모이제이션 연관 배열 사용하기 (map, defaultdict) 일대일 대응 함수 작성하기 n! 개의 가능한 사전 입력 중 몇 번째인지를 반환하는 함수 작성 입력이 순열일 경우에 응당, 이용 가능 입력이 불린 값의 배열인 경우 n인 배열을 길이가 n인 2진수로 보는것, n이 굉장히 작을 때(n\u0026lt;20) 사용 가능 true / 1(2진수)/ 1 true, false, true, flase / 0101 / 5(십진수) false, false, true, true, true / 11100 / 28 false, false, false, false / 0000 / 0 9.16 조합 게임 동적 계획법의 또 다른 사용처는 여러 조합 게임(combinatorial game) 을 해결하는 것이다.\n조합 게임은, 체스나 바둑 처럼 두 사람의 참가자가 하는 게임을 말한다.\n이런 게임을 \u0026lsquo;해결\u0026lsquo;한다는 말은 상태가 주어졌을 때 완벽한 한 수를 찾아내는 알고리즘을 만든다는 뜻이다.\n조합 게임을 해결하는 알고리즘은 게임판이 주어질 때, 어느 쪽이 이길 지를 미리 예측한다.\n한 쪽이 이긴다는 말은, 상대방이 어떻게 두더라도, 자신이 실수만 하지 않으면, 반드시 이길 수 있다는 의미이다. 완전한 게임 트리(게임의 모든 상태, 게임판에 대한 정보에 대한 상태)가 주어질 때, 어떤 게임도 맨 아래 쪽(최종 상태) 에서 거슬로 올라가면 풀 수 있다.\n마지막 수를 두는 참가자가 지는 경우는, 어떤 수를 두더라도, 질 수 밖에 없는 상태 뿐이다.\n그러므로, 마지막에서 두 번째 줄에 있는 모든 상태들에 대해 어느 쪽이 이길지를 판단 가능하다.\n그러고 나면 한 단계 위로 올라가 아까와 같은 작업을 다른 참가자에 대해 반복할 수 있다.\n실제 게임이 일제히 종료하는게 아니라, 그 전에 승부가 날 수 있기 때문에 bottom-up 이 접근이 아니라, top-down으로 재귀 호출 하는 식으로 접근한다.\ncanWin(state) = 게임의 현재 상태가 state 일 때, 이번에 수를 둘 차례인 참가자가 이기는 지 반환\ncanWin()은 이 상태에 서 둘 수 있는 수를 하나 하나 순회하면서, 해당 수를 둔 후의 상태인 state\u0026rsquo; 에 대해 canWin(state\u0026rsquo;) 을 호출한다. 이 때, canWin(state\u0026rsquo;) = true 면, 상대방이 이긴다는 의미이고, canWin(state\u0026rsquo;) = false면 내가 이긴다는 의미이다. canWin(state\u0026rsquo;) = false를 반환하는 수가 하나라도 있다면, 이 상태에서는 자신이 이길 수 있다는 의미 이다. 바둑이나 체스 처럼 상태가 매우 큰(게임 트리가 매우 깊은) 경우, 게임 트리의 일부만 탐색한다.\n휴리스틱(경험적 알고리즘), 이나 미니맥스(MiniMax) 알고리즘 이 사용된다. 9.17, 9.18 숫자 게임, NUMBERGAME / 미니맥스 알고리즘, play(state) = 현재 게임판에 남은 수들이 state 일 때, 이번 차례인 (참가자의 점수 - 다른 참가자의 점수)의 최대치 A는 play()의 반환 값을 가능한 최대화(max) 하고, B는 최소화(min) 하는 쪽으로 게임을 하게 된다. 게임 트리의 각 층 마다 번갈아가면서 최대화 / 최소화 한다는 의미에서 미니맥스 알고리즘이라고 한다. 9.21 반복적, 동적 계획법 재귀 호출과 메모이제이션 말고, 반복문을 이용해 동적 계획법을 구현할 수도 있다.\n이를 반복적(iterative) 동적 계획법, 타뷸레이션(Tabluation) 이라고 한다.\n타뷸레이션: table을 채워나간다는 느낌으로 하나씩 미리 계산한다.\n상향식(Bottom-up) 접근 방식, table을 채워나간다는 느낌으로, 하나씩 다 미리 계산한다.\n슬라이딩 윈도(sliding window) 기법을 사용해 공간 복잡도를 줄일 수 있다.\n슬라이딩 윈도: 데이터 전체를 메모리에 유지하는 것이 아니라 필요한 부분만을 저장하는 기법\nwindow의 start, end 을 나타내는 포인터 변수 가 필요하다. 메모이제이션을 사용하는 재귀적 동적 계획법에서는 부분 문제가 계산되는 순서가 일정하지 않기 때문에 슬라이딩 윈도 사용 불가\n9.21.1 반복적 vs 재귀적 / 동적 계획법 비교 재귀적 동적 계획법\n메모이제이션, Memoization 하향식, top-down, 재귀 함수 사용 Lazy-Evaluation, 결과가 필요할 때 계산 좀 더 직관적인 코드 작성 가능 부분 문제 간의 의존 관계를 고려해 계산되는 순서를 고민할 필요 없다. 전체 부분 문제 중 일부의 답만 필요한 경우 더 빠르게 동작 슬라이딩 윈도 사용 불가 스택 오버플로 조심해야 함, 함수 호출로 메인 메모리의 스택 영역가 계속 사용됨. 반복적 동적 계획법\n타뷸레이션, Tabluation 상향식, bottom-up, 반복문 사용 Eager-Evaluation, 필요하지 않은 값도 미리 계산 구현이 대개 짧다 재귀 호출에 필요한 부하가 없기에 조금 더 빠르게 동작 슬라이딩 윈도 사용가능 부분 문제 간의 의존 관계를 고려해 계산되는 순서를 고민해야 한다. 문제에 맞게, 자신이 선택할 수 있는 방식으로 일관되게 꾸준한 연습이 필요하다.\nReference 프로그래밍 대회에서 배우는 알고리즘 문제 해결 전략 (구종만, 인사이트) https://www.algospot.com/ ","permalink":"https://2taezeat.github.io/posts/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EB%AC%B8%EC%A0%9C-%ED%95%B4%EA%B2%B0-%EC%A0%84%EB%9E%B5/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EB%AC%B8%EC%A0%9C-%ED%95%B4%EA%B2%B0-%EC%A0%84%EB%9E%B5-ch09.-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EC%84%A4%EA%B3%84-%ED%8C%A8%EB%9F%AC%EB%8B%A4%EC%9E%84/","summary":"9. 동적 계획법 테크닉 9.1 최적화 문제의 실제 답 계산하기 최적화 문제를 풀때, 최적해의 점수만을 계산했다.\n가장 긴 증가 부분 수열(LIS)을 찾는 대신 해당 수열의 길이 를 찾음\n최적해를 직접 계산해야 할 때는 어떻게 해야 하는가?\n대개 동적 계획법을 사용하는 코드에서는 실제 답을 계산하는 과정을 별도로 구현한다.\n부분 문제가 주어질 때, 그중 첫 번째 조각을 어떤 선택지로 택했을 때, 최적해를 얻는지를 기록해 둔다. 별도의 배열을 사용해서 저장 별도의 재귀 함수를 이용해 각 조각에서 한 선택을 되짚어 가면서 최적해를 생성한다.","title":"[알고리즘 문제 해결 전략] ch09. 알고리즘 설계 패러다임"},{"content":"8. 동적 계획법 8.1 도입 동적 계획법(dynamic programming) 은 최적화 문제를 연구하는 수학 이론에서 왔으며,\n우리가 전산학 전반에서 사용하는 동적(dynamic), 프로그래밍이란 단어와는 관련이 없다. 따라서, 바른 명명은 동적 프로그래밍이 아니라, 동적 계획법이다.\n8.1.1 중복되는 부분 문제 동적 계획법은 큰 의미에서 분할 정복과 같은 접근 방식을 의미한다.\n처음 주어진 문제를 더 작은 문제들로 나눈 뒤 각 조각의 답을 계산하고, 이 답들로부터 원래 문제에 대한 답을 계산해 내기 때문이다. 동적계획법은 \u0026lsquo;어떤 부분 문제\u0026rsquo;를 \u0026lsquo;두 개 이상의 문제\u0026rsquo;를 푸는데 사용될 수 있기 때문에, 이 문제의 답을 여러 번 계산하는 대신 한 번만 계산하고 계산 결과를 재활용 함으로써 속도의 향상을 꾀할 수 있다. 이를 위해, 각 문제의 답을 메모리에 저장할 필요가 있고, 이 메모리 저장 장소를 cache(캐시) 라고 한다. =\u0026gt; 메모이제이션, 캐싱 두 번 이산 계산되는 부분 문제를 중복되는 부분 문제(overlapping subproblems) 라고 한다. 분할 정복: 단순한 재귀 호출을 통해, 문제를 분할해도 한 부분 문제를 한 번만 해결\n계산의 중복 횟수는 분할의 깊이가 깊어질수록 지수적으로 증가, 이를 해결하기 위해 고안된 알고리즘이 동적 계획법 몇몇 부분 문제 들은 여러 번 계산하기 됨 캐시 배열을 만들어서, 각 배열에 저장되어 있는지 확인하고, 저장 되어 있다면 즉시 반환 메모이제이션(memoization): 함수의 결과를 저장하는 장소를 마련해 두고, 한 번 계산한 값을 저장해 뒀다 재활용하는 최적화 기법 메모이제이션을 사용하면 모든 부분 문제가 한 번씩만 계산된다고 보장할 수 있기 때문에 함수 호출 횟수가 엄청나게 감소한다. 동적 계획법: 이와 같이 두 번 이상 반복되는 계산되는 부분 문제들의 답을 미리 저장함으로써, 속도의 향상을 꾀하는 알고리즘 설계 기법 8.1.2 메모제이션 구현 패턴 항상 base case(기저 사례) 를 먼저 처리 cache 에 데이터가 저장되어 있으면 (답을 계산한 적이 있으면) 바로 반환 8.1.2 메모제이션의 시간 복잡도 분석 (주먹구구) 시간 복잡도: 존재하는 부분 문제의 수 x 한 부분 문제를 풀때 필요한 반복문의 수행횟수 상한을 간단히 계산할 수 있는 방법, 항상 정확하지는 않음 실제 수행 시간이 이 식 보다 더 간단할 수 있다. 8.1.3 동적 계획법 레시피 동적 계획법 알고리즘 만드는 첫 단계는 해당 문제를 재귀적으로 해결하는 완전 탐색 알고리즘을 만드는 것 부터 시작\n중복된 부분 문제를 한 번 만 계산하도록 메모제이션을 적용\n\u0026ldquo;원하는 답이 존재하는가?\u0026rdquo; 이 질문을 완전 탐색을 구할 때 흔히 가장 문제가 되는 것은, 원하는 답은 없는데 전체 답의 개수는 무지막지하게 많은 경우이다. 완전 탐색의 경우, 어떤 경로는 마지막 칸에 도달할지도 모른다고 생각하고, 수없이 많은 경로를 일일히 탐색하게 된다. 경로의 갯수가 n에 대해 지수적 증가하게 됨 8.2, 8.3 와일드카드, WILDCARD, 난이도: 중 비둘기 집 원리에 따라, 101 x 101 = 10201 번 이상 호출되었다면, 부분 문제가 존재할 수 밖에 없음. 101 x 101 배열에 모든 부분 문제의 답을 저장 할 수 있음 8.4 전통적 최적화 문제들 동적 계획법의 가장 일반적인 사용처는 최적화 문제 이다.\n최적화 문제: 여러 개의 가능한 답 중 가장 좋은 답(최적해) 를 찾는 문제\n최적화 문제에 특정 성질이 성립할 경우, 단순히 메모이제이션을 적용하는 것 보다 더 효율적으로 동적 계획법을 구현할 수 있다.\n예제) 삼각형 위의 최대 경로, TRIANGLEPATH, 난이도: 하\npath1(y, x, sum) = 현재 위치가 (y, x)이고, 지금까지 만난 수의 합이 sum 일 때, 이 경로를 맨 아래줄까지 연장해서 얻을 수 있는 최대 합을 반환 함수의 반환 값을 전체 경로의 최대치(path1)가 아니라, (y, x)에서 시작하는 부분 경로의 최대치로 바꾸면, 부분 문제들을 얻을 수 있다. path2(y, x) = (y, x)에서 시작해서 맨 아래줄까지 내려가는 부분 경로의 최대 합을 반환 8.4.1 최적 부분 구조 삼각형 위의 최대 경로 의 속도를 최적화 할 수 있는 sum이라는 정보가 (y, x) 에서 맨 아래줄까지 내려가는 문제를 해결하는 데 아무 상관이 없다 는 것 때문이다. 어떤 경로로 이 부분 문제에 도달 했건, 남은 부분 문제는 항상 최적으로 풀어도 상관 없다는 의미이다, 이 조건은 최적 부분 구조(optimal substruture) 라는 동적 계획법의 중요 요소 이다. 최적 부분 구조(optimal substruture) 는 어떤 문제와 분할 방식에 성립하는 조건이다. 각 부분 문제의 최적해만 있으면, 전체 문제의 최적해를 얻어 낼 수 있는 경우 지금까지의 선택과 상관 없이, 각 부분 문제를 최적으로 풀기만 하면 전체 문제의 최적해도 알 수 있다는 것 최단 경로 문제는 각 부분의 최적해가 전체의 최적해(최단 경로) 이기 때문에 최적 부분 구조를 갖는다. 8.4.2 최적화 문제, 동적 계획법 레시피 모든 답을 만들어 보고, 그 중 최적해의 점수를 반환하는 완전 탐색 알고리즘을 설계한다. 전체 답의 점수를 반환하는 것이 아니라, 남은 선택들에 해당하는 점수만을 반환하도록 부분 문제 정의를 바꾼다. 재귀 호출의 입력, 파라미터에 이전의 선택에 관한 정보가 있다면, 꼭 필요한 것만 남기고 줄인다. 문제에 최적 부분 구조가 성립할 경우, 이전 선택에 관련된 정보를 완전히 없앨 수 도 있다. 목표는 가능한 한 중복되는 부분 문제를 많이 만드는 것 입력의 종류가 줄어들면 줄어들 수 록, 더 많은 부분 문제가 중복되고, 메모이제이션을 최대한 활용할 수 있게 된다. 입력이 배열이거나 문자열인 경우, 적절한 변환을 통해 메모이제이션을 활용할 수 있도록 한다. 메모이제이션을 적용한다. 8.11 경우의 수와 확률 동적 계획법은 경우의 수를 세거나 확률을 계산하는 문제에도 흔하게 사용된다. 경우의 수를 새는 경우, 재귀적인 특징이 있기 때문이다. 8.11.1 타일링 방법의 수 세기, TILING2, 난이도: 하 2 x n 사각형을 채우는 모든 방법들은 맨 왼쪽 세로줄이 어떻게 채워져 있느냐로 나눌 수 있다. 이 두 가지 분류는 타일링 하는 방법을 모두 포함한다. 두 가지 분류에 모두 포함되는 타일링 방법은 없다. 결과적으로, 더 세지도 않고, 덜 세지도 않는다. tiling(n) = tiling(n-1) + tiling(n-2) // 타일 1개 사용한 경우 + 타일 2개 사용한 경우 8.11.2 경우의 수, 계산하기 레시피 모든 답을 직접 만들어서 세어보는 완전 탐색 알고리즘을 설계한다. 모든 경우는 이 선택지들에 포함됨 (덜 세지 않음) 어떤 경우도 두 개 이상의 선택지에 포함되지 않음 (더 세지 않음) 최적화 문제를 해결할 때 처럼, 이전 조각에서 결정한 요소들에 대한 입력, 파라미터를 없애거나 변형해서 줄인다. 재귀 함수는 앞으로 남아 있는 조각들을 고르는 경우의 수만 반환해야 한다. 메모이제이션을 적용한다. Reference 프로그래밍 대회에서 배우는 알고리즘 문제 해결 전략 (구종만, 인사이트) https://www.algospot.com/ ","permalink":"https://2taezeat.github.io/posts/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EB%AC%B8%EC%A0%9C-%ED%95%B4%EA%B2%B0-%EC%A0%84%EB%9E%B5/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EB%AC%B8%EC%A0%9C-%ED%95%B4%EA%B2%B0-%EC%A0%84%EB%9E%B5-ch08.-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EC%84%A4%EA%B3%84-%ED%8C%A8%EB%9F%AC%EB%8B%A4%EC%9E%84/","summary":"8. 동적 계획법 8.1 도입 동적 계획법(dynamic programming) 은 최적화 문제를 연구하는 수학 이론에서 왔으며,\n우리가 전산학 전반에서 사용하는 동적(dynamic), 프로그래밍이란 단어와는 관련이 없다. 따라서, 바른 명명은 동적 프로그래밍이 아니라, 동적 계획법이다.\n8.1.1 중복되는 부분 문제 동적 계획법은 큰 의미에서 분할 정복과 같은 접근 방식을 의미한다.\n처음 주어진 문제를 더 작은 문제들로 나눈 뒤 각 조각의 답을 계산하고, 이 답들로부터 원래 문제에 대한 답을 계산해 내기 때문이다. 동적계획법은 \u0026lsquo;어떤 부분 문제\u0026rsquo;를 \u0026lsquo;두 개 이상의 문제\u0026rsquo;를 푸는데 사용될 수 있기 때문에, 이 문제의 답을 여러 번 계산하는 대신 한 번만 계산하고 계산 결과를 재활용 함으로써 속도의 향상을 꾀할 수 있다.","title":"[알고리즘 문제 해결 전략] ch08. 알고리즘 설계 패러다임"},{"content":"7. 분할 정복 7.1 도입 분할 정복(Divide \u0026amp; Conquer) 는 각개 격파 라고 간단히 설명 할 수 있다. 분할 정복이 일반적인 재귀 호출과 다른 점은 문제를 한 조각과 나머지 전체로 나누는 대신, 거의 같은 크기의 부분 문제로 나누는 것이다. 일반적인 재귀: 한 조각과 나머지로 쪼갬 분할 정복: 항상 절반씩 쪼갬 분할 정복의 구성 요소\ndivide(분할) : 문제를 더 작은 문제로 분할하는 과정 merge(병합) : 각 문제에 대해 구한 답을 원래 문제에 대한 답으로 병합하는 과정 base case : 더 이상 답을 분할하지 않고 곧장 풀 수 있는 매우 작은 문제 분할 정복 문제의 특성\n문제를 둘 이상의 부분 문제로 나누는 자연스러운 방법이 있어야 한다. 부분 문제의 답을 조합해 원래 문제의 답을 계산하는 효율적인 방법이 있어야 한다. 같은 문제라도 어떻게 분할하느랴에 따라 시간 복잡도 차이가 커진다.\n절반으로 나누는 알고리즘이 큰 효율 저하를 불러오는 이유는 바로 여러 번 중복되어 계산되면서 시간을 소모하는 부분 문제들이 있기 때문이다.\n이런 속성을 부분 문제가 중복된다(overlapping subproblems) 라고 한다. 이런 속성이 동적 계획법이 고안된 계기다. 7.1.1 병합 정렬과 퀵 정렬 두 개의 정렬 모두, 분할 정복 패러다임 기반\n두 개의 정렬 모두 같은 아이디어로 정렬하지만, 시간이 많이 걸리는 작업을 분할(퀵 정렬), 에서 하느냐, 병합(병합 정렬) 단계\n병합 정렬은 주어진 수열을 가운데에서 쪼개 비슷한 수열 두 개로 만든 뒤 이들을 재휘 호출을 이용해 각각 정렬한다.\n그 후 정렬된 배열을 하나로 합침으로써 정렬된 전체 수열을 얻는다.\n병합 정렬은 분할(divide)에는 O(1) 시간이 걸리고, 정렬된 배열들을 하나의 배열로 합치기 위해서 별도의 병합(merge) 과정에서 O(n) 시간이 걸린다.\n퀵 정렬은 배열을 단순하게 가운데에서 쪼개는 대신, 병합 과정이 필요 없도록 한쪽의 배열에 포함된 수가 다른 쪽 배열의 수보다 항상 작도록 배열을 분할한다.\n이를 위해, 파티션(paritition, 분할) 이라고 부르는 단계를 도입한다.\n이는 배열에 있는 수 중 임의의 \u0026lsquo;기준 수(pivot)\u0026rsquo; 를 지정한 후, 기준 보다 작거나 같은 숫자를 왼쪽, 더 큰 숫자를 오른쪽으로 보내는 과정이다.\n분할에 O(n) 시간이 걸리고, 이미 정렬된 상태이기에, 별도의 병합 작업에 걸리는 시간이 거의 없다.\n7.1.2. 시간 복잡도 분석 병합 정렬의 수행 시간은 병합(merge) 과정에 의해 지배된다.\n아래 단계로 내려갈수록 부분 문제의 수는 두 배로 늘고, 각 부분 문제의 크기는 반으로 줄어 들기 때문에, 한 단계 내에서 모든 병합(merge)에 필요한 총 시간은 O(n)으로 일정하다. 각 단계를 나타내는 각 가로줄에 있는 원소의 수는 항상 n으로 일정하다. 문제의 크기는 항상 거의 절반으로 나누어 지기 때문에, 필요한 단계의 수는 O(lgn)이 된다. 따라서, 병합 정렬의 시간 복잡도는 O(nlgn) 이다. 퀵 정렬은 주어진 문제를 두 개의 부분 문제로 나누는 파티션 과정( 분할 과정; divide )에 지배 된다.\n파티션에는 주어진 수열의 길이(n)에 비례하는 시간이 걸리므로, 병합 정렬에서의 병합 과정과 다를 것이 없다. 퀵 정렬이 시간 복잡도를 분석하기 까다로운 이유는 분할된 두 부분 문제가 비슷한 크기로 나누어진다는 보장이 없기 때문 최악의 경우 시간 복잡도는 O(n^2) 평균적으로 부분 문제가 절반에 가깝게 나눠질 때 시간복잡도는 병합 정렬과 같은 O(nlgn) 이 된다. 따라서, 퀵 정렬 구현은 가능한 한 절반에 가까운 분할을 얻기 위해 pivot(기준)을 뽑는 다양한 방법을 사용한다. 7.2, 7.3 쿼드 트리 뒤집기, QUADTREE, 난이도: 하 우리가 선택할 수 있는 접근 방법, 둘 중 어느 것이 맞는지 판단하기는 쉽지 않음, 보통 쉬운 것은 2번\n큰 입력에 대해서 동작하는 효율적인 알고리즘을 처음부터 새로 만들기 작은 입력에 대해서만 동작하는 단순한 알고리즘으로 시작해서 최적화 해 나가기 압축 문자열 분할하기\n각 부분의 길이가 일정하지 않기 때문에, 4 부분으로 쪼개기 쉽지 않음 s를 미리 쪼개는 것이 아니라, \u0026lsquo;필요한 만큼 가져다 쓰도록\u0026rsquo; 한다. s를 통째로 전달하는 것이 아니라, s의 한 글자를 가리키는 포인터를 전달하고, 한 글자씩 검사할때 마다, 이 포인터를 앞으로 한 칸씩 옮긴다. 압축 다 풀지 않고 뒤집기\n2^20 x 2^20을 모두 저장하는 것은 현실적으로 불가능 압축을 해제한 결과를 메모리에 다 저장하는 대신 결과 이미지를 뒤집은 결과를 곧장 생성하는 코드를 작성하자. 전체가 검은색이나 흰색인 그림은 뒤집어 봤자 다를게 없다. (base case) 전체가 한 가지색이 아닌 경우에는 재귀 호출을 이용해 네 부분을 각각 상하로 뒤집은 결과를 얻은 뒤, 이들을 병합해 답을 얻는다. 1 -\u0026gt; 2 -\u0026gt; 3-\u0026gt; 4-\u0026gt; // 3 -\u0026gt; 4 -\u0026gt; 1 -\u0026gt; 2 Reference 프로그래밍 대회에서 배우는 알고리즘 문제 해결 전략 (구종만, 인사이트) https://www.algospot.com/ ","permalink":"https://2taezeat.github.io/posts/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EB%AC%B8%EC%A0%9C-%ED%95%B4%EA%B2%B0-%EC%A0%84%EB%9E%B5/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EB%AC%B8%EC%A0%9C-%ED%95%B4%EA%B2%B0-%EC%A0%84%EB%9E%B5-ch07.-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EC%84%A4%EA%B3%84-%ED%8C%A8%EB%9F%AC%EB%8B%A4%EC%9E%84/","summary":"7. 분할 정복 7.1 도입 분할 정복(Divide \u0026amp; Conquer) 는 각개 격파 라고 간단히 설명 할 수 있다. 분할 정복이 일반적인 재귀 호출과 다른 점은 문제를 한 조각과 나머지 전체로 나누는 대신, 거의 같은 크기의 부분 문제로 나누는 것이다. 일반적인 재귀: 한 조각과 나머지로 쪼갬 분할 정복: 항상 절반씩 쪼갬 분할 정복의 구성 요소\ndivide(분할) : 문제를 더 작은 문제로 분할하는 과정 merge(병합) : 각 문제에 대해 구한 답을 원래 문제에 대한 답으로 병합하는 과정 base case : 더 이상 답을 분할하지 않고 곧장 풀 수 있는 매우 작은 문제 분할 정복 문제의 특성","title":"[알고리즘 문제 해결 전략] ch07. 알고리즘 설계 패러다임"},{"content":"03장. 알고리즘 설계 패러다임 정리\n알고리즘을 설계하는 작업은 한순간의 영감보다는 여러 전략적인 선택에 따라 좌우된다.\n해결할 문제의 특성을 이해하고, 동작 시간과 사용하는 공간 사이의 상충 관계를 이해하고, 적절한 자료 구조를 선택해야 한다.\n알고리즘 설계 패러다임: 주어진 문제를 해결하기 위해 알고리즘이 채택한 전략이나 관점 6. 무식하게 풀기 6.1 도입 전산학에서 **무식하게 푼다(brute-force)**는 컴퓨터의 빠른 계산 능력을 이용해 가능한 경우의 수를 일일이 나열하면서 답을 찾는 방법 이렇게 가능한 방법을 전부 만들어 보는 알고리즘들을 가리켜 흔히 완전 탐색(exhaustive search) 이라고 한다. 이는 가장 간단하지만, 컴퓨터의 장점을 가장 잘 이용하는 방법이다. 6.2 재귀 호출과 완전 탐색 컴퓨터가 하는 작업들은 대개 작은 조각들로 나누어 볼 수 있다.\n우리가 들여다보는 범위가 작아지면 작아질수록 각 조각들의 형태가 유사해지는 작업들을 많이 볼 수 있다.\n이런 작업을 구현 할 때, 유용하게 사용되는 개념이 바로 재귀 함수, 재귀 호출이다.\n재귀 함수: 자신이 수행할 작업을 유사한 형태의 여러 조각으로 쪼갠 뒤, 그 중 한 조각을 수행하고, 나머지를 자기 자신을 호출해 실행하는 함수\n모든 재귀 함수는 \u0026lsquo;더 이상 쪼개지지 않는\u0026rsquo; 최소한의 작업에 도달 했을 때, 답을 곧장 return 하는 조건문을 포함해야한다.\n이때, 가장 작은 작업들을 가리켜 재귀 호출의 base case(기저 사례) 라고 한다. 기저 사례를 선택할 때는 존재하는 모든 입력이 항상 기저 사례의 답을 이용해 계산할 수 있는지 신경써야 한다.\n기저 사례 조건의 순서는 바뀌면 안 된다.\n입력이 잘못되거나 범위에서 넘어가는 경우를 기저 사례에 맨 처음에 두면 편리하다.\n중첩 반복문을 재귀 호출 함수로 대체 해서, n개 중 몇 개를 고르든지 조합을 찾을 수 있다.\n이를 통해, 재귀 호출로 완전 탐색을 구현하기 용이하다. 6.2.1 완전 탐색 레시피 완전 탐색은 존재하는 모든 답을 하나씩 검사하므로, 걸리는 시간은 가능한 답의 수에 정확히 비례한다. 가능한 모든 답의 후보를 만드는 과정을 여러 개의 선택으로 나눈다. 각 선택은 답의 후보를 만드는 과정의 한 조각이 된다. 그 중 하나의 조각을 선택해 답의 일부를 만들고, 나머지 답을 재귀 호출을 통해 완성한다. 조각이 하나밖에 남지 않은 경우, 혹은 하나도 남지 않은 경우에는 답을 생성했으므로, 이것을 기저 사례로 선택해 처리한다. 6.2.2 재귀 호출과 부분 문제 재귀 호출을 논의할때 \u0026lsquo;문제\u0026lsquo;란 항상 수행해야 할 작업과 그 작업을 적용할 자료의 조합을 의미한다. 주어진 자연수 수열을 정렬하라: 문제 x {1,2,200,3,5} 을 정렬하라: 문제 o {1,2,3}을 정렬하라, {3,2,1}을 정렬하라는 서로 다른 문제이다. 원래 **문제(problem)**에서 한 조각이 원래 문제의 일부 일 때, 이런 문제들을 **부분 문제(subproblem)**라고 한다. 부분 문제가 원래 문제를 푼 결과이고, 원래 문제와 형식이 같을 때 6.3, 6.4 소풍, PICNIC, 난이도: 하 답을 중복으로 세는 경우 방지: 항상 특정 형태를 갖는 답만 세기 흔한 방법: 사전 순으로 가장 먼저 오는 답 하나만 세기, (2,3), (0,1) 은 세지 않고, (0,1), (2,3) 만 센다. 이 속성을 강제하기 위해서는 각 단계에서 남아 있는 학생들 중 가장 번호가 빠른 학생의 짝을 찾아 주도록 하면 된다. 6.5, 6.6 게임판 덮기, BOARDCOVER, 난이도: 하 블록을 놓는 순서는 중요하지 않다. 특정한 순서대로 답을 생선하도록 강제할 필요가 있다. 각 재귀 호출마다, 가장 윗 줄, 가장 왼쪽에 있는 칸을 덮도록만 한다. 6.7 최적화 문제 경우의 수 문제와 달리, 답이 하나가 아니라, 여러 개 이고, 그 중 어떤 기준에 따라, 가장 \u0026lsquo;좋은\u0026rsquo; 답을 찾아 내는 문제를 통칭해 최적화 문제라 한다. 최대화, 최소화, 최단 경로, 최소 비용 등등 이런, 최적화 문제를 푸는 여러 방법 중 기초적인 것은 완전 탐색이다. 가능한 답을 모두 생성하고, 그 중 가장 좋은 것을 찾아내면 되기 때문이다. 6.8, 6.9 시계 맞추기, CLOCKSYNC, 난이도: 중 입출력 설명이 유도하는 것과 달리, 스위치를 누르는 순서는 전혀 중요하지 않다. 누르는 순서를 바꾼다고, 그 결과가 바뀌지 않는다. 각 스위치를 몇 번이나 누르는 가를 계산해야 한다. 시계는 12시간 지나면, 제 자리로 돌아온다는 특성: 무한한 조합 -\u0026gt; 유한한 조합 3번 이상 누를 일이 없다. 6.10 많이 등장하는 완전 탐색 유형 주어진 원소로 만들 수 있는 모든 순열 만들기(경우의 수), 순열, nPn = n!, n이 10을 넘어가면 보통 시간 초과 주어진 원소 중 R개를 골라낼 수 있는 방법 만들기(경우의 수), 조합 2^n 가지 경우의 수 만들기 n개의 질문에 대한 답이 yes/no 일 때, 가능한 답의 모든 조합의 수는 2^n 가지이다. 각 조합을 하나의 n비트 정수로 표현하면, 재귀 호출을 사용할 것 없이 1차원 for문 하나로 이 조합들을 간단하게 모두 시도할 수 있다. 16장: 비트마스크 Reference 프로그래밍 대회에서 배우는 알고리즘 문제 해결 전략 (구종만, 인사이트) https://www.algospot.com/ ","permalink":"https://2taezeat.github.io/posts/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EB%AC%B8%EC%A0%9C-%ED%95%B4%EA%B2%B0-%EC%A0%84%EB%9E%B5/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EB%AC%B8%EC%A0%9C-%ED%95%B4%EA%B2%B0-%EC%A0%84%EB%9E%B5-ch06.-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EC%84%A4%EA%B3%84-%ED%8C%A8%EB%9F%AC%EB%8B%A4%EC%9E%84/","summary":"03장. 알고리즘 설계 패러다임 정리\n알고리즘을 설계하는 작업은 한순간의 영감보다는 여러 전략적인 선택에 따라 좌우된다.\n해결할 문제의 특성을 이해하고, 동작 시간과 사용하는 공간 사이의 상충 관계를 이해하고, 적절한 자료 구조를 선택해야 한다.\n알고리즘 설계 패러다임: 주어진 문제를 해결하기 위해 알고리즘이 채택한 전략이나 관점 6. 무식하게 풀기 6.1 도입 전산학에서 **무식하게 푼다(brute-force)**는 컴퓨터의 빠른 계산 능력을 이용해 가능한 경우의 수를 일일이 나열하면서 답을 찾는 방법 이렇게 가능한 방법을 전부 만들어 보는 알고리즘들을 가리켜 흔히 완전 탐색(exhaustive search) 이라고 한다.","title":"[알고리즘 문제 해결 전략] ch06. 알고리즘 설계 패러다임"},{"content":" 알고리즘을 평가하는 요소 시간: 얼마나 빠르게 공간: 더 적은 용량의 메모리를 사용 시간과 공간은 대부분 상충, Ex) 동적 계획법 4. 알고리즘의 시간 복잡도 분석 4.1 개요 반복문이 알고리즘 수행 시간을 지배한다(dominate), 한 가지 항목이 전체의 대소를 좌지우지 한다 === dominate 반복문이 수행되는 횟수를 입력의 크기에 대한 함수로 표현 4.2 선형 시간 알고리즘 수행 시간이 N에 정비례 주어진 입력을 최소한 한 번씩 쳐다보면 선형 시간 (linear time) 이 걸린다. 4.3 선형 이하 시간 알고리즘 Ex) 이분 탐색, 이진 탐색: log2 N (=== lgN) 이진 탐색 과정에서 얼마가 걸리건 간에 전체 는 선형 시간이 아니냐? 정렬도 필요하니까 탐색 배열을 A[] 모두 미리 계산해서 가질 필요 없이 A[i]가 필요할 때만, 계산하면 된다. 정렬과 탐색은 별개 이다. 한번 정렬 한 데이터는 2번 이상 계속 쓰일 수 있다. 4.4.1 다항 시간 알고리즘 다항식: N의 거듭제곱들의 선형 결합으로 이루어진 식들 다항식으로 표현할 수 있는 알고리즘이 다항 시간 알고리즘이다. 4.4.2 지수 시간 알고리즘 N이 하나씩 증가할 때마다 걸리는 시간이 배로 증가하는 알고리즘 (2^N, 3^N \u0026hellip;) 입력의 크기에 따라 다항 시간과는 비교도 안 되게 빠르게 증가 4.5 시간 복잡도 시간 복잡도(time complexity): 가장 널리 사용되는 알고리즘의 수행 시간의 기준\n알고리즘이 실행되는 동안 수행하는 기본적인 연산의 수를 입력의 크기에 대한 함수로 표현한 것\n반복문 내부의 있는 연산들은 더 쪼갤 수 없기 때문에, 이것이 시간 복잡도의 대략적인 기준이 된다.\n시간 복잡도가 높다는 말은 입력의 크기가 증가할 때 알고리즘의 수행 시간이 더 빠르게 증가한다는 의미\n시간 복잡도는 절대적 빠르기의 기준이 아니다. 입력의 크기에 따라 다름 (2^5 \u0026lt; 10^2)\n최선의 수행 시간, 최악의 수행 시간, 평균적인 수행 시간\n여러 알고리즘에서 평균과 최악의 수행 시간이 비슷함으로 두 개를 구분 하지 않고 쓰인다. 4.5.1 점근적 시간 표기: O 표기 시간 복잡도는 계산하기 너무 힘들다는 문제가 있다.\n명령어 수가 애매 모호하고, 세기 힘들다 따라서, 전체 수행 시간에 큰 영향을 미치지 않는 상수 부분은 무시하고 반복문의 반복 수만 고려하게 된다. 여기에서 한 발짝 더 나아가서 사람들이 이것을 더욱 간단하게 표현한 O 표기법(Big-O Notation) 이라는 것을 사용해 알고리즘의 수행 시간을 표기한다.\nO 표기법은 가장 빨리 증가하는 항만을 남긴 채 나머지를 다 버리는 표기법이다.\nO 표기법을 쓸 때, 시간 복잡도는 반복문에 의해서 결정되기 때문에, 반복문들이 몇 번이나 실행되는지만 보면 되기에 간단하다.\nO 표기법은 함수의 상한을 나타내는데 의미가 있다.\n상한을 나타내기에 알고리즘의 최악의 수행 시간을 나타낸다고, 착각 할 수도 있다. 하지만, O 표기법은 각 경우의 수행 시간을 간단히 나타내는 표기법일 뿐, 특별히 최악의 수행 시간과 관련이 있는 것은 아니다. 퀵 정렬의 최악의 시간 복잡도는 O(N^2) 이고, 평균 시간 복잡도는 O(NlgN) 이다. 4.5.2 시간 복잡도의 분할 상환 분석 시간 복잡도를 항상 반복문의 개수로 결정하지는 않는다. 더 정확한 시간 복잡도는 분할 상환 분석 을 사용한다. N개의 작은 작업들을 순서대로 할때, 각 작업에 걸리는 시간은 모두 다르지만 전체 작업에 걸리는 시간이 일정한 경우 적용할 수 있다. 시간이 오래 걸려 실행하지 못할 것이라고 여겼던 작업이 시간 안에 돌아가는 것을 이해할 수 있게 된다. Ex) N명이 N잔의 막걸리가 담긴 사발을 먹을 때: 각 신입생 마다 평균적으로 한 잔의 막걸리를 마셨다고 할 수 있다. 4.6 수행 시간 어림짐작하기 입력의 크기(N) 을 시간 복잡도에 대입해서 얻은 반복문 수행 횟수에 대해, 1초당 반복문 수행 횟수가 1억(10^8, 100,000,000) 넘어가면 시간 초과 할 가능성이 있다. 시간 제한이 5초면 500,000,000, 시간 제한이 10초면, 1,000,000,000 // 1초: 10^8은 보수적으로 정한 것이다. 어림짐작이기 때문에 이보다 작아도 통과 될 수도 있고, 반대일 수 도 있다. 5. 알고리즘의 정당성 증명 5.1. 개요 단위 테스트는 알고리즘에 문제가 있음을 증명할 수 있어도, 문제가 없음을 증명할 수 없다. 따라서, 알고리즘의 정확한 증명을 위해서는 각종 수학적인 기법이 동원 되어야 한다. 알고리즘의 증명이 알고리즘을 유도하는데 결정적인 통찰을 담고 있기에 중요하다. 5.2 수학적 귀납법과 반복문 불변식 5.2.1 수학적 귀납법 단계 나누기: 증명하고 싶은 사실을 여러 단계로 나눈다. 첫 단계 증명 귀납 증명: 1 단계에서 증명하고 싶은 내용이 성립하면, 다음 단계에서도 성립합을 보인다. 5.2.2 반복문 불변식 반복문 불변식: 반복문의 내용이 한 번 실행될 때마다 중간 결과가 우리가 원하는 답으로 가는 길 위에 잘 있는지를 명시하는 조건 반복문이 마지막 정답을 계산하기 위해서는 항상 이 식이 변하지 않고(불변식) 성립해야 한다. 반복문 진입시에 불변식이 성립함을 보인다 반복문 내용이 시작할 때 불변식이 성립했다면, 내용이 끝날 때도 불변식이 항상 성립함을 보인다. 반복문 종료시에 불변식이 성립하면 항상 우리가 정답을 구했음을 보인다. 1 2 3 4 5 6 // * 불변식은 여기에서 성립해야 한다. while (어떤 조건) { // 반복문 내용의 시작 // 반복문 내용의 끝 // ** 불변식은 여기에서도 성립해야 한다. } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 # 이진 탐색, 파이썬 코드 def binsearch(A: list, x: Int) { n = len(A) lo, hi = -1, n # 반복문 불변식 1: lo \u0026lt; hi # 반복문 불변식 2: A[lo] \u0026lt; x \u0026lt;= A[hi] while(lo + 1 \u0026lt; hi): mid = (lo + hi) // 2 if A[mid] \u0026lt; x: lo = mid else: hi = mid # 불변식은 여기서도 성립해야 한다. return hi } lo + 1 = hi: while 문이 종료했으니, lo +1 \u0026gt;= hi 인데, 불변식에 의하면 lo \u0026lt;hi 이니 lo + 1 = hi 일 수 밖에 없다. (ex.lo:3, hi:4)\nA[lo] \u0026lt; x \u0026lt;= A[hi]: 애초에 불변식이 성립한다고 가정했으니 이것은 당연히 성립한다.\n우리가 원하는 결과값 i는 A[i-1] \u0026lt; x \u0026lt;= A[i] 인 i 이므로, 이때 우리가 원하는 답은 hi라는 사실을 알 수 있다.\n이때, 반복문의 정당성은 귀납법과 다를 것이 없다.\n이런 과정을 거쳐 while문이 종료 될때, 우리가 원하는 값이 A[hi] 에 저장되어 있음을 알 수 있다.\n5.3 귀류법 귀류법: 우리가 원하는 바와 반대되는 상황을 가정하고 논리를 전개해서 결론이 잘못됐음을 찾아내는 증명 기법 보통 어떤 선택이 항상 최선임을 증명하고자 할 때 많이 이용된다. 우리가 선택한 답보다 좋은 답이 있다고 가정한 후, 사실 그럴 일이 있을 수 없을 보이면 우리가 최선의 답을 선택했음을 보일 수 있다. 5.4 다른 기술들 5.4.1 비둘기집의 원리 10마리의 비둘기가 9개의 비둘기집에 모두 들어갔다면, 2마리 이상이 들어 간 비둘기집이 반드시 무조건 하나는 있게 마련이다. 5.4.2 구성적 증명 답이 존재한다는 사실을 논증하는 것이 지금까지 다룬 방식이라면, 구성적 증명은 답의 실제 예를 들거나 답을 만드는 방법을 실제로 제시하는 증명이다. Ex. 하늘을 나는 교통 수단을 만들 수 있다는 주장을 증명하려한다. 비구성적 증명: 양력의 법칙, 지구의 공기 밀도 등등을 따져서 증명한다. 구성적 증명: 비행기를 만들어서 보여주거나, 비행기 만드는 설명서를 보여준다. \u0026lsquo;답이 존재하는가\u0026rsquo; 에 대한 답으로 \u0026lsquo;이렇게 만들면 된다\u0026rsquo; 라고 하는 것이다. 구성적 증명의 내용은 사실상 알고리즘 그 자체인 경우가 많다. Reference 프로그래밍 대회에서 배우는 알고리즘 문제 해결 전략 (구종만, 인사이트) https://www.algospot.com/ ","permalink":"https://2taezeat.github.io/posts/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EB%AC%B8%EC%A0%9C-%ED%95%B4%EA%B2%B0-%EC%A0%84%EB%9E%B5/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EB%AC%B8%EC%A0%9C-%ED%95%B4%EA%B2%B0-%EC%A0%84%EB%9E%B5-ch04-05.-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EB%B6%84%EC%84%9D/","summary":"알고리즘을 평가하는 요소 시간: 얼마나 빠르게 공간: 더 적은 용량의 메모리를 사용 시간과 공간은 대부분 상충, Ex) 동적 계획법 4. 알고리즘의 시간 복잡도 분석 4.1 개요 반복문이 알고리즘 수행 시간을 지배한다(dominate), 한 가지 항목이 전체의 대소를 좌지우지 한다 === dominate 반복문이 수행되는 횟수를 입력의 크기에 대한 함수로 표현 4.2 선형 시간 알고리즘 수행 시간이 N에 정비례 주어진 입력을 최소한 한 번씩 쳐다보면 선형 시간 (linear time) 이 걸린다. 4.3 선형 이하 시간 알고리즘 Ex) 이분 탐색, 이진 탐색: log2 N (=== lgN) 이진 탐색 과정에서 얼마가 걸리건 간에 전체 는 선형 시간이 아니냐?","title":"[알고리즘 문제 해결 전략] ch04, 05. 알고리즘 분석"},{"content":"1. 문제 해결과 프로그래밍 대회 문제 해결 능력: 제약 조건과 요구사항을 이해하고 최선의 방법을 찾아내는 능력 2. 문제 해결 개관 문제 해결 능력을 수련하는 법: 문제를 푸는 것이 아니라 문제를 푸는 기술을 연마 2.1 문제 해결 과정 문제를 읽고, 이해하기\n재정의와 추상화\n자신의 언어로 풀어쓰기 추상화: 현실 세계의 개념을 우리가 다루기 쉬운 저난학적 개념으로 옮겨 표현하는 과정 / 현실의 본질만 남겨두고 축약하여 표현하기 계획 세우기\n사용할 알고리즘과 자료구조 선택 검증하기\n시간 과 공간(메모리) 확인 구현하기\n회고하기\n자신이 푼 문제 과정을 돌이켜 보고 개선하기 기록하기 다른 사람의 코드 보기 2.3 문제 해결 전략 직관과 체계적인 접근 체계적인 접근: 백제에서부터 시작해 문제를 해결하기 위한 기반을 점진적으로 전진하는 것\n체계적인 접근을 위한 질문들 비슷한 문제플 풀어본 적이 있는가?\n단순한 방법에서 시작할 수 있을까?\n시간, 공간 제약을 생각하지 않고 문제를 해결하는 가장 단순한 알고리즘 만들기 무식하게 풀 수 있을까? =\u0026gt; 기준선 정해줌 =\u0026gt; 최적화 완전 탐색, 브루트 포스 내가 문제를 푸는 과정을 수식화할 수 있을까?\n손으로 문제를 풀어 보자 문제를 단순화 할 수 없을까?\n좀 더 쉬운 변형판 제약 조건 없애기, 변수의 수 줄이기, 다차원 -\u0026gt; 1차원으로 변환 그림으로 그려볼 수 있을까?\n수식으로 표현할 수 있을까?\n문제를 분해할 수 있을까?\n문제에 주어진 복잡한 조건을 더 단순한 형태를 갖는 조건의 집합으로 분해 뒤에서부터 생각해서 문제를 풀 수 있을까?\nA-\u0026gt;B 를 B-\u0026gt;A 로 변형 순서를 강제할 수 있을까?\n순서가 없는 문제를, 순서를 강제해서 문제를 푼다. 어떤 순서로 해도 상관 없다: 시도한 횟수만 결과에 영향을 준다 특정 순서대로 한다는 제약 추가 경우의 수 문제에서 중복하여 세는 경우를 방지할 때 유용 특정 형태의 답만을 고려할 수 있을까?\n순서 강제하기 기법의 연장선으로 정규화 기법이 있다. 정규화란 고려해야 할 답들 중 형태가 다르지만 결과적으로 똑같은 것들을 그룹으로 묶은 뒤, 각 그룹의 대표들 만 고려하는 방법 무한개의 모든 후보 =\u0026gt; 유한한 부분 집합 3. 코딩과 디버깅에 관하여 3.1 코딩(구현)의 중요성 간결, 일관된 코드 =\u0026gt; 가독성 증가 3.2 좋은 코드를 짜기 위한 원칙 적극적으로 코드 재사용, 모듈화\n항상 같은 형태로 프로그램 작성\n이분 탐색, BFS 등등 모든 자료를 정규화해서 저장하기\n시간 표현(h, m, s), 각도 표현 등등, 한 가지 형태로 저장해야 함 코드와 데이터 분리하기\n알파벳 모음을 따로 변수화, dy, dx 등등 3.3 자주 하는 실수 산술 오버플로\nindexOutof Range Error, 항상 0\u0026lt;=i\u0026lt;n 형태 지키기\n하나 더 많거나, 하나더 모자르거나: Off-by-one 오류\n최소 입력 (ex. 0,1 인 경우) 인 경우 테스트, 예외 처리 컴파일러가 잡아주지 못하는 오타\n스택 오버플로: 함수 재귀, 재귀 호출 깊이\n다차원 배열 인덱스 순서 바꿔 쓰기\n잘못된 비교 함수\n최소, 최대 예외 잘못 다루기\n가장 작은 입력, 가장 큰 입력에 대해 테스트 자료형의 프로모션: 실수, 정수 혼합 연산\n3.6 실수 자료형 정수는 컴퓨터가 정확하게 표현가능\n실수는 불가능, 실수는 무한의 세계, 컴퓨터 메모리는 유한\n실수는 근사 값으로 표현, 정확도가 제한된 근사 값\n부동 소수점 (floating-point)\n소수점이 둥둥 떠다닐 수 있다는 의미\n정수부와 소수부\n부호 비트: 양수인지 음수인지\n지수(exponent): 소수점을 몇 칸 옮겼나?\n가수(mantissa): 소수점을 옮긴 실수의 최상위 X 비트\n좋은 방법: 실수 연산을 아예 하지 않기\n적절한 변형으로 실수 연산 제거 양변 제곱, x배 확대 Reference 프로그래밍 대회에서 배우는 알고리즘 문제 해결 전략 (구종만, 인사이트) https://www.algospot.com/ ","permalink":"https://2taezeat.github.io/posts/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EB%AC%B8%EC%A0%9C-%ED%95%B4%EA%B2%B0-%EC%A0%84%EB%9E%B5/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EB%AC%B8%EC%A0%9C-%ED%95%B4%EA%B2%B0-%EC%A0%84%EB%9E%B5-ch01-02-03.-%EB%AC%B8%EC%A0%9C-%ED%95%B4%EA%B2%B0-%EC%8B%9C%EC%9E%91%ED%95%98%EA%B8%B0/","summary":"1. 문제 해결과 프로그래밍 대회 문제 해결 능력: 제약 조건과 요구사항을 이해하고 최선의 방법을 찾아내는 능력 2. 문제 해결 개관 문제 해결 능력을 수련하는 법: 문제를 푸는 것이 아니라 문제를 푸는 기술을 연마 2.1 문제 해결 과정 문제를 읽고, 이해하기\n재정의와 추상화\n자신의 언어로 풀어쓰기 추상화: 현실 세계의 개념을 우리가 다루기 쉬운 저난학적 개념으로 옮겨 표현하는 과정 / 현실의 본질만 남겨두고 축약하여 표현하기 계획 세우기\n사용할 알고리즘과 자료구조 선택 검증하기","title":"[알고리즘 문제 해결 전략] ch01, 02, 03. 문제 해결 시작하기"},{"content":"문자열 처리 1. 기본 문자열 함수 length: 문자열의 길이를 반환합니다.\n1 2 val str = \u0026#34;Hello, Kotlin!\u0026#34; println(str.length) // 14 substring(startIndex, endIndex): 문자열의 일부를 잘라내어 반환합니다.\n1 2 3 val str = \u0026#34;Hello, Kotlin!\u0026#34; val subStr = str.substring(0, 5) println(subStr) // Hello plus: 문자열을 이어붙이는 함수 (연산자 +와 동일한 기능).\n1 2 3 val greeting = \u0026#34;Hello\u0026#34; val name = \u0026#34;Kotlin\u0026#34; println(greeting.plus(\u0026#34;, \u0026#34;).plus(name)) // Hello, Kotlin 2. 문자열 비교 compareTo: 문자열을 비교하여 결과를 반환 (0: 동일, 음수: 작음, 양수: 큼).\n1 2 3 val str1 = \u0026#34;apple\u0026#34; val str2 = \u0026#34;banana\u0026#34; println(str1.compareTo(str2)) // 음수 반환 (-1) equals: 문자열이 같은지 비교.\n1 2 3 val str1 = \u0026#34;Kotlin\u0026#34; val str2 = \u0026#34;Kotlin\u0026#34; println(str1.equals(str2)) // true == 연산자: 코틀린에서 문자열 비교는 == 연산자를 사용해도 동일하게 동작합니다. 이는 equals 메서드를 호출하는 것과 같습니다.\n1 2 3 val str1 = \u0026#34;Kotlin\u0026#34; val str2 = \u0026#34;Kotlin\u0026#34; println(str1 == str2) // true 3. 문자열 검색 contains: 문자열에 특정 문자열이 포함되어 있는지 확인.\n1 2 val str = \u0026#34;Hello, Kotlin!\u0026#34; println(str.contains(\u0026#34;Kotlin\u0026#34;)) // true indexOf: 특정 문자의 첫 번째 인덱스를 반환. 찾지 못하면 -1을 반환.\n1 2 val str = \u0026#34;Hello, Kotlin!\u0026#34; println(str.indexOf(\u0026#34;Kotlin\u0026#34;)) // 7 lastIndexOf: 문자열 내에서 특정 문자의 마지막 인덱스를 반환.\n1 2 val str = \u0026#34;Hello, Kotlin, Kotlin!\u0026#34; println(str.lastIndexOf(\u0026#34;Kotlin\u0026#34;)) // 14 startsWith / endsWith: 문자열이 특정 접두사 또는 접미사로 시작하거나 끝나는지 확인.\n1 2 3 val str = \u0026#34;Hello, Kotlin!\u0026#34; println(str.startsWith(\u0026#34;Hello\u0026#34;)) // true println(str.endsWith(\u0026#34;Kotlin!\u0026#34;)) // true 4. 문자열 변경 replace: 특정 문자를 다른 문자로 변경.\n1 2 val str = \u0026#34;Hello, Kotlin!\u0026#34; println(str.replace(\u0026#34;Kotlin\u0026#34;, \u0026#34;World\u0026#34;)) // Hello, World! replaceFirst: 첫 번째로 일치하는 문자열만 변경.\n1 2 val str = \u0026#34;Kotlin is Kotlin\u0026#34; println(str.replaceFirst(\u0026#34;Kotlin\u0026#34;, \u0026#34;Java\u0026#34;)) // Java is Kotlin toUpperCase / toLowerCase: 문자열을 대문자 또는 소문자로 변환.\n1 2 3 val str = \u0026#34;Hello, Kotlin!\u0026#34; println(str.toUpperCase()) // HELLO, KOTLIN! println(str.toLowerCase()) // hello, kotlin! 5. 문자열 분리 및 결합 split: 문자열을 특정 구분자를 기준으로 분리하여 리스트로 반환.\n1 2 3 val str = \u0026#34;apple,banana,cherry\u0026#34; val fruits = str.split(\u0026#34;,\u0026#34;) println(fruits) // [apple, banana, cherry] joinToString: 리스트나 배열을 특정 구분자로 연결하여 하나의 문자열로 결합.\n1 2 3 val fruits = listOf(\u0026#34;apple\u0026#34;, \u0026#34;banana\u0026#34;, \u0026#34;cherry\u0026#34;) val result = fruits.joinToString(\u0026#34;, \u0026#34;) println(result) // apple, banana, cherry 6. 문자열 반복 및 처리 repeat: 문자열을 지정한 횟수만큼 반복.\n1 2 val str = \u0026#34;Kotlin\u0026#34; println(str.repeat(3)) // KotlinKotlinKotlin forEach: 문자열의 각 문자를 순회.\n1 2 3 4 5 6 7 8 9 10 val str = \u0026#34;Kotlin\u0026#34; str.forEach { char -\u0026gt; println(char) } // K // o // t // l // i // n 7. 문자열 트리밍 trim: 문자열의 양 끝에 있는 공백 제거.\n1 2 val str = \u0026#34; Hello, Kotlin! \u0026#34; println(str.trim()) // Hello, Kotlin! trimStart / trimEnd: 시작 또는 끝의 공백만 제거.\n1 2 3 val str = \u0026#34; Hello, Kotlin! \u0026#34; println(str.trimStart()) // \u0026#34;Hello, Kotlin! \u0026#34; println(str.trimEnd()) // \u0026#34; Hello, Kotlin!\u0026#34; 8. 문자열 템플릿 (String Templates) 코틀린에서 문자열 내에 변수를 쉽게 삽입할 수 있는 템플릿 기능을 제공합니다.\n$ 기호로 변수 삽입: 문자열 내에 $를 사용하여 변수를 삽입.\n1 2 3 val name = \u0026#34;Kotlin\u0026#34; val greeting = \u0026#34;Hello, $name!\u0026#34; println(greeting) // Hello, Kotlin! 표현식을 중괄호로 감싸서 삽입: 복잡한 표현식은 ${}로 감싸서 삽입.\n1 2 3 val apples = 3 val oranges = 5 println(\u0026#34;I have ${apples + oranges} fruits\u0026#34;) // I have 8 fruits String 과 StringBuilder 1. String 불변성: String은 불변(immutable) 객체입니다. 즉, 문자열이 한번 생성되면 그 값을 변경할 수 없습니다. 문자열을 조작하는 메서드를 호출할 때마다 새로운 문자열 객체가 생성됩니다.\n예를 들어, 문자열에 무언가를 추가하거나 변경하는 경우, 기존 문자열을 수정하는 것이 아니라 새로운 문자열을 반환합니다.\n1 2 3 4 val str = \u0026#34;Hello\u0026#34; val newStr = str + \u0026#34; World\u0026#34; println(newStr) // Hello World println(str) // Hello (기존 문자열은 그대로) 성능: 문자열을 자주 변경해야 하는 상황에서 String을 사용하면, 매번 새로운 객체를 생성하기 때문에 메모리 및 성능에 영향을 줄 수 있습니다. 이런 경우는 StringBuilder를 사용하는 것이 더 적합합니다.\n사용 예시:\n1 2 3 val name = \u0026#34;Kotlin\u0026#34; val greeting = \u0026#34;Hello, \u0026#34; + name println(greeting) // Hello, Kotlin 2. StringBuilder 가변성: StringBuilder는 가변(mutable) 객체입니다. 즉, 생성된 이후에도 문자열의 내용을 자유롭게 수정할 수 있습니다. 문자열을 추가하거나 삭제할 때마다 새로운 객체를 만들지 않고 내부의 버퍼를 수정하므로, 문자열을 자주 변경해야 할 때 성능 상 이점이 있습니다.\n성능: 문자열을 반복적으로 추가, 삭제, 변경하는 작업이 많을 경우 StringBuilder는 성능 측면에서 매우 효율적입니다. 특히 반복문 안에서 문자열을 여러 번 결합할 때는 String보다 StringBuilder를 사용하는 것이 좋습니다.\n사용 예시:\n1 2 3 val builder = StringBuilder(\u0026#34;Hello\u0026#34;) builder.append(\u0026#34; World\u0026#34;) println(builder.toString()) // Hello World 주요 메서드:\nappend(): 문자열을 이어 붙입니다.\n1 2 3 val builder = StringBuilder(\u0026#34;Kotlin\u0026#34;) builder.append(\u0026#34; is fun\u0026#34;) println(builder.toString()) // Kotlin is fun insert(): 특정 위치에 문자열을 삽입합니다.\n1 2 3 val builder = StringBuilder(\u0026#34;Kotlin\u0026#34;) builder.insert(6, \u0026#34; Programming\u0026#34;) println(builder.toString()) // Kotlin Programming delete(): 문자열의 일부를 삭제합니다.\n1 2 3 val builder = StringBuilder(\u0026#34;Kotlin Programming\u0026#34;) builder.delete(6, 17) println(builder.toString()) // Kotlin reverse(): 문자열을 뒤집습니다.\n1 2 3 val builder = StringBuilder(\u0026#34;Kotlin\u0026#34;) builder.reverse() println(builder.toString()) // niltoK 3. String과 StringBuilder의 차이점 특성 String StringBuilder 불변성(Immutable) 불변 (변경 불가) 가변 (내용 수정 가능) 새 객체 생성 여부 변경 시마다 새로운 객체 생성 내부 버퍼에서 직접 수정 성능 문자열을 자주 수정하면 성능이 저하될 수 있음 문자열을 자주 수정할 때 더 빠르고 효율적임 사용 용도 불변 문자열이 필요한 경우 (일반 문자열 처리) 자주 수정되는 문자열이 필요한 경우 (문자열 결합, 반복) 스레드 안전성 불변이므로 스레드 안전 스레드 안전하지 않음 (StringBuffer는 스레드 안전) 4. 언제 사용해야 하는가? String 사용: 문자열이 변경되지 않거나 자주 변경되지 않을 경우 String을 사용하는 것이 적합합니다. 예를 들어, 상수 문자열이나 간단한 텍스트 처리에는 String을 사용합니다.\nStringBuilder 사용: 문자열을 자주 변경하거나 반복적으로 추가, 삭제, 결합 등의 작업을 해야 하는 경우에는 StringBuilder를 사용하는 것이 성능 면에서 유리합니다. 특히, 반복문 내에서 문자열을 여러 번 수정할 때 StringBuilder가 더 효율적입니다.\n결론 String 은 불변성이 보장되며, 문자열을 수정할 필요가 없는 경우나 간단한 문자열 처리에 적합합니다. StringBuilder 는 문자열을 빈번하게 수정하거나 결합하는 경우 성능 이점을 제공합니다. list.sort( ) 와 sorted(list) 1. .sort() 리스트를 직접 변경하는 함수입니다. 즉, 원본 리스트를 제자리에서(in-place) 정렬합니다. MutableList에서만 사용할 수 있습니다. 반환값이 없으며, 정렬된 상태로 리스트를 변경합니다. 1 2 3 val mutableList = mutableListOf(3, 1, 4, 1, 5, 9) mutableList.sort() println(mutableList) // [1, 1, 3, 4, 5, 9] 2. sorted() 새로운 정렬된 리스트를 반환하는 함수입니다. 즉, 원본 리스트는 변경되지 않고, 정렬된 새 리스트를 반환합니다. List와 MutableList 모두에서 사용할 수 있습니다. 불변 리스트(immutable list) 또는 변경 불가능한 리스트를 정렬할 때 유용합니다. 1 2 3 4 val list = listOf(3, 1, 4, 1, 5, 9) val sortedList = list.sorted() println(sortedList) // [1, 1, 3, 4, 5, 9] println(list) // [3, 1, 4, 1, 5, 9] (원본 리스트는 변경되지 않음) 차이점 요약: 특성 .sort() sorted() 리스트 변경 여부 원본 리스트를 직접 변경함 원본 리스트는 그대로 두고, 새로운 리스트 반환 사용 가능한 리스트 타입 MutableList에서만 사용 가능 List와 MutableList 모두 사용 가능 반환 값 반환 값 없음 (Unit) 정렬된 새로운 리스트 반환 언제 사용할까? .sort(): 이미 MutableList가 있고, 그 리스트를 바로 정렬하고자 할 때 사용합니다. 원본 리스트가 필요 없고, 즉시 정렬된 리스트로 사용하려는 경우 적합합니다.\nsorted(): 원본 리스트를 유지하면서 새로운 정렬된 리스트가 필요한 경우 사용합니다. 불변 리스트(List)를 다룰 때 적합하며, sorted()는 원본 데이터를 변경하지 않고 안전하게 사용할 수 있습니다.\nnull 의 의미 개발에서 null 이라는 것은 \u0026ldquo;값이 없음\u0026rdquo; 또는 \u0026ldquo;정의되지 않은 상태\u0026rdquo; 를 의미합니다. 이는 특정 변수나 객체가 어떤 값을 가지고 있지 않음을 나타내는 값입니다. 하지만 단순히 값이 없는 상태를 의미하는 것 이상의 개념을 가지고 있으며, 개발에서 여러 가지 의미를 내포할 수 있습니다.\nnull은 값이 없음, 정의되지 않음, 또는 적용 불가능한 상태를 나타내며, 다양한 맥락에서 사용됩니다.\n이는 프로그래밍에서 결여된 정보를 명시적으로 나타내는 방식이며, 잘못된 참조로 인해 예외를 발생시키거나 시스템 오류를 유발할 가능성이 있습니다.\n1. 값이 없음 (Absence of a Value) 설명: null은 특정 변수나 필드가 값을 가지고 있지 않음을 명시적으로 나타냅니다.\n의미: 해당 변수가 초기화되지 않았거나, 그 위치에 값이 존재하지 않는 상황을 의미합니다.\n예시:\n1 var name: String? = null // name 변수에 값이 없음 실제 의미: 이 경우 변수 name에 아무 값도 할당되지 않았음을 의미합니다. 즉, 메모리 공간은 할당되었지만 해당 공간에 유효한 값은 저장되지 않은 상태입니다.\n2. 초기화 되지 않음 (Uninitialized or Not Applicable) 설명: 특정 변수나 객체가 아직 초기화되지 않았거나, 적용되지 않는 상태를 나타낼 때 사용됩니다.\n의미: 예를 들어, 어떤 데이터베이스 조회에서 값을 찾지 못했을 때, 해당 필드에 null이 반환될 수 있습니다.\n예시:\n1 val result = database.findUserById(1) // 사용자가 없으면 null 반환 실제 의미: null이 반환되었다면, 데이터베이스에서 사용자 ID 1에 해당하는 데이터가 없거나, 해당 값이 아직 설정되지 않았음을 의미합니다.\n3. 알 수 없는 상태 (Unknown State) 설명: 특정 정보가 알 수 없는 상태에 있을 때도 null이 사용됩니다. 이 경우 해당 값이 존재하지 않는 것이 아니라, 현재 값을 알 수 없거나 결정되지 않은 상태를 나타냅니다.\n의미: 아직 값을 제공하지 않은 경우에 사용될 수 있으며, 그 값이 나중에 설정될 가능성이 있습니다.\n예시:\n1 var score: Int? = null // 아직 점수가 입력되지 않음 실제 의미: score는 아직 입력되지 않았지만, 나중에 점수가 입력될 수 있음을 의미합니다.\n4. 오류 가능성 또는 예외 처리 필요 (Error Handling) 설명: null 값은 오류 또는 예외 상황을 나타낼 수 있습니다. 특히, 값이 예상대로 설정되지 않았거나, 실패한 작업을 나타낼 때 null이 사용될 수 있습니다.\n의미: 이 경우 null이 함수나 메서드의 실패를 의미할 수 있으며, 이를 처리해야 하는 로직이 필요합니다.\n예시:\n1 val connection = database.getConnection() ?: throw Exception(\u0026#34;Connection failed\u0026#34;) 실제 의미: 데이터베이스 연결이 실패했을 때, null이 반환되고 예외를 발생시켜야 하는 상황을 나타냅니다.\n5. 의도적 비활성화 (Intentional Absence) 설명: 개발자가 특정 값이 의도적으로 비활성화되었음을 나타내기 위해 null을 사용하기도 합니다. 즉, 값이 없다는 것이 명시적으로 선택된 경우입니다.\n의미: 어떤 값이나 객체가 사용되지 않을 것임을 명시적으로 나타냅니다.\n예시:\n1 var logger: Logger? = null // 로깅 기능이 필요 없을 때 null 실제 의미: 이 경우 logger 객체는 의도적으로 설정되지 않았으며, 필요할 때만 설정되거나 아예 사용되지 않을 것임을 의미합니다.\n","permalink":"https://2taezeat.github.io/posts/dev/kotlin-%EC%A0%95%EB%A6%AC-6/","summary":"문자열 처리 1. 기본 문자열 함수 length: 문자열의 길이를 반환합니다.\n1 2 val str = \u0026#34;Hello, Kotlin!\u0026#34; println(str.length) // 14 substring(startIndex, endIndex): 문자열의 일부를 잘라내어 반환합니다.\n1 2 3 val str = \u0026#34;Hello, Kotlin!\u0026#34; val subStr = str.substring(0, 5) println(subStr) // Hello plus: 문자열을 이어붙이는 함수 (연산자 +와 동일한 기능).\n1 2 3 val greeting = \u0026#34;Hello\u0026#34; val name = \u0026#34;Kotlin\u0026#34; println(greeting.plus(\u0026#34;, \u0026#34;).plus(name)) // Hello, Kotlin 2. 문자열 비교 compareTo: 문자열을 비교하여 결과를 반환 (0: 동일, 음수: 작음, 양수: 큼).","title":"Kotlin 정리 (6)"},{"content":"OOP 개요 핵심: 프로그램을 수많은 객체(Object)라는 기본 단위로 나누고, 이들의 상호작용으로 서술하는 방식 OOP란, 프로그램 설계 방법론, 패러다임 중 하나 객체: 하나의 역할을 하는 메소드와 변수(데이터) 의 묶음 객체지향은 메시지를 주고 받으면서 상호 협력하는 자율적인 객체들로 인식 OOP 효과 높은 응집도: 하나의 역할을 하는 데이터들을 모아 놓은 데이터형, 클래스 사용\n응집도: 한 모듈내의 구성요소들 간의 연관 정도 낮은 결합도: 객체들간의 적절한 협력에 필요한 관계만을 유지를 함으로써 결합력을 낮춤\n결합도(coupling): 묘듈 모듈간의 의존 정도 그에 따른 효과\n요구사항 변경에 대한 대응성 유지보수성 재사용성 중복되는 코드량 감소 OOP의 4가지 특징 추상화 객체의 공통적인 속성과 기능을 추출하여 하나의 묶음으로 이름 붙여 정의하는 것 다형성 서로 다른 클래스의 객체가 같은 메시지를 받았을 때 각자의 방식으로 동작하는 능력\n같은 자료형에 여러가지 타입의 데이터를 대입하여 다양한 결과를 얻어낼 수 있는 성질\n캡슐화 필드와 메서드를 내부에 구현하여 은닉하고 외부로 부터 접근을 제한\n관련 데이터와 코드 알고리즘이 하나의 묶음으로 내부에 구현됨 외부와의 상호작용은 메시지와 메소드를 통해서만 함 모듈 내에서 내부를 구현하여 응집도 높힘\n외부 노출 최소화 결합도 낮춤\n객체간에 의존성은 오직 public 메서드에 의해서만 발생\n호출 순서 파악이 쉬움 상속 자식 클래스가 부모 클래스의 특성과 기능을 그대로, 전부 물려 받는 것\n위험\n결합도를 크게 늘림\n컴파일 시점에 클래스의 관계가 결정, 유연하지 못한 소프트웨어\n상위 클래스가 하위 클래스의 is-a 관계 일때만 사용\nDog is-a Animal 위험에 대응하는 법\n상속 보단 합성이나 인터페이스 구현으로 대체 설계와 문서를 제대로 갖추고 상속 SOLID OOP의 5가지 기본 원칙의 첫 글자를 따서 명명한 원칙 OOP의 4가지 특징이 반영 효과 중복되는 코드 감소 낮은 결합도, 높은 응집도 유지보수 용이, 요구사항 변경에 유연 결과적으로 생산성 상승 SRP, 단일 책임 원칙 단일 모듈은 변경의 이유가 오직 하나뿐 이여야 한다 책임을 많이 질수록 서로 다른 역할을 수행하는 코드 끼리 결합도 상승의 위험 Ex) 회계팀, 인사팀의 Employee 클래스 사용 OCP, 개방 폐쇄 원칙 확장에 Open 요구사항이 변경될 때, 새로운 동작을 추가하여 애플리케이션의 기능을 확장할 수 있다 수정에 Closed 기존의 코드를 수정하지 않고 애플리케이션의 동작을 추가하거나 변경할 수 있다 LSP, 리스코프 치환 원칙 하위 타입은 상위 타입을 대체 할 수 있어야 한다는 원칙\n즉, 하위 클래스의 인스턴스는 상위형 객체 참조 변수에 대입해 상위 클래스의 인스턴스 역할을 하는데 문제가 없어야 한다\n위반 사례\n반영 사례\nISP, 인터페이스 분리 원칙 인터페이스를 잘게 분리하여, 클라이언트의 목적과 용도에 적합한 인터페이스 만을 제공해야 한다는 원칙\n클라이언트가 사용하지 않는 인터페이스에 변경이 발생하더라도 영향을 받지 않도록 만들어야 하는 것\n위반 사례\n반영 사례\nDIP, 의존 역전 원칙 고수준 모듈은 저수준 모듈의 구현에 의존해서는 안 되며, 저수준 모듈이 고수준 모듈에서 정의한 추상 타입에 의존해야 한다는 원칙\n자신보다 변하기 쉬운 것에 의존하던 것을 추상화된 인터페이스나 상위 클래스를 두어, 변하기 쉬운 것의 변화에 영향받지 않게 하는 것\n저수준의 구현에 의존하던 것을 인터페이스에 의존하게 변경 (저-\u0026gt;고) , (소스 코드 의존성)\n소스 코드의 의존성(저→고) 과 제어 흐름(고→저) 을 반대(역전)로 됨\n위반 사례\n반영 사례\n고수준 모듈 : 변하기 어려운, 추상화된 클래스 또는 인터페이스\n저수준 모듈 : 변하기 쉬운, 구체 클래스\n","permalink":"https://2taezeat.github.io/posts/dev/oop-%EC%A0%95%EB%A6%AC/","summary":"OOP 개요 핵심: 프로그램을 수많은 객체(Object)라는 기본 단위로 나누고, 이들의 상호작용으로 서술하는 방식 OOP란, 프로그램 설계 방법론, 패러다임 중 하나 객체: 하나의 역할을 하는 메소드와 변수(데이터) 의 묶음 객체지향은 메시지를 주고 받으면서 상호 협력하는 자율적인 객체들로 인식 OOP 효과 높은 응집도: 하나의 역할을 하는 데이터들을 모아 놓은 데이터형, 클래스 사용\n응집도: 한 모듈내의 구성요소들 간의 연관 정도 낮은 결합도: 객체들간의 적절한 협력에 필요한 관계만을 유지를 함으로써 결합력을 낮춤\n결합도(coupling): 묘듈 모듈간의 의존 정도 그에 따른 효과","title":"OOP 정리"},{"content":"컬렉션의 고차 함수들 1. map 정의: 컬렉션의 각 요소를 변환하여 새로운 컬렉션을 반환합니다. 용도: 리스트의 요소들을 다른 값으로 변환할 때 사용. 1 2 3 val numbers = listOf(1, 2, 3, 4) val squares = numbers.map { it * it } println(squares) // 출력: [1, 4, 9, 16] 2. filter 정의: 주어진 조건에 맞는 요소들만 필터링하여 새로운 컬렉션을 반환합니다. 용도: 리스트에서 특정 조건을 만족하는 요소들만 남기고 싶을 때 사용. 1 2 3 val numbers = listOf(1, 2, 3, 4, 5, 6) val evenNumbers = numbers.filter { it % 2 == 0 } println(evenNumbers) // 출력: [2, 4, 6] 3. reduce 정의: 컬렉션의 모든 요소를 누적하여 단일 값을 반환합니다. 용도: 리스트에서 값을 축적하거나 합산할 때 사용. 1 2 3 val numbers = listOf(1, 2, 3, 4) val sum = numbers.reduce { acc, number -\u0026gt; acc + number } println(sum) // 출력: 10 acc 는 누적된 값이고, number 는 리스트의 현재 요소입니다. 4. fold 정의: reduce와 유사하지만, 초기값을 지정할 수 있습니다. 용도: 초기값과 함께 누적 연산을 해야 할 때 사용. 1 2 3 val numbers = listOf(1, 2, 3, 4) val product = numbers.fold(1) { acc, number -\u0026gt; acc * number } println(product) // 출력: 24 초기값으로 1을 제공했고, 이를 기반으로 리스트의 각 요소를 곱하여 누적합니다. 5. forEach 정의: 컬렉션의 각 요소에 대해 주어진 동작을 수행합니다. 반환값은 없습니다. 용도: 컬렉션의 요소를 순회하면서 작업을 수행할 때 사용. 1 2 3 val numbers = listOf(1, 2, 3, 4) numbers.forEach { println(it) } // 출력: 1, 2, 3, 4 6. flatMap 정의: 각 요소를 변환하고, 변환된 결과들을 평탄화하여 하나의 리스트로 반환합니다. 용도: 리스트의 리스트를 하나의 리스트로 합치고 싶을 때 사용. 1 2 3 val listOfLists = listOf(listOf(1, 2), listOf(3, 4)) val flatList = listOfLists.flatMap { it } println(flatList) // 출력: [1, 2, 3, 4] 7. groupBy 정의: 컬렉션의 요소를 주어진 키로 그룹화하여 Map을 반환합니다. 용도: 리스트의 요소를 특정 조건에 따라 그룹화할 때 사용. 1 2 3 val words = listOf(\u0026#34;apple\u0026#34;, \u0026#34;banana\u0026#34;, \u0026#34;cherry\u0026#34;, \u0026#34;avocado\u0026#34;) val groupedWords = words.groupBy { it.first() } println(groupedWords) // 출력: {a=[apple, avocado], b=[banana], c=[cherry]} 8. partition 정의: 조건에 따라 컬렉션을 두 개의 리스트로 나눕니다. 조건을 만족하는 요소는 첫 번째 리스트에, 그렇지 않은 요소는 두 번째 리스트에 담깁니다. 용도: 리스트를 조건에 맞게 둘로 나눌 때 사용. 1 2 3 4 val numbers = listOf(1, 2, 3, 4, 5, 6) val (even, odd) = numbers.partition { it % 2 == 0 } println(even) // 출력: [2, 4, 6] println(odd) // 출력: [1, 3, 5] 9. take / takeWhile take: 처음부터 주어진 숫자만큼의 요소를 가져옵니다. takeWhile: 조건을 만족하는 동안만 요소를 가져옵니다. 1 2 3 val numbers = listOf(1, 2, 3, 4, 5) println(numbers.take(3)) // 출력: [1, 2, 3] println(numbers.takeWhile { it \u0026lt; 4 }) // 출력: [1, 2, 3] 10. zip 정의: 두 개의 컬렉션을 병합하여 쌍(pair)의 리스트를 만듭니다. 용도: 두 리스트를 쌍으로 묶고 싶을 때 사용. 1 2 3 4 val names = listOf(\u0026#34;Alice\u0026#34;, \u0026#34;Bob\u0026#34;, \u0026#34;Charlie\u0026#34;) val ages = listOf(25, 30, 35) val people = names.zip(ages) println(people) // 출력: [(Alice, 25), (Bob, 30), (Charlie, 35)] 11. any / all / none any: 하나라도 조건을 만족하는 요소가 있으면 true를 반환합니다. all: 모든 요소가 조건을 만족하면 true를 반환합니다. none: 하나도 조건을 만족하지 않으면 true를 반환합니다. 1 2 3 4 val numbers = listOf(1, 2, 3, 4, 5) println(numbers.any { it \u0026gt; 3 }) // 출력: true println(numbers.all { it \u0026lt; 6 }) // 출력: true println(numbers.none { it == 0 }) // 출력: true 12. find / firstOrNull find: 조건을 만족하는 첫 번째 요소를 반환합니다. firstOrNull: 조건을 만족하는 요소가 없으면 null 을 반환합니다. 1 2 3 val numbers = listOf(1, 2, 3, 4, 5) println(numbers.find { it \u0026gt; 3 }) // 출력: 4 println(numbers.firstOrNull { it \u0026gt; 5 }) // 출력: null 13. groupingBy / eachCount Python의 Counter 기능 1 2 3 val list = listOf(\u0026#34;apple\u0026#34;, \u0026#34;banana\u0026#34;, \u0026#34;apple\u0026#34;, \u0026#34;orange\u0026#34;, \u0026#34;banana\u0026#34;, \u0026#34;apple\u0026#34;) val counter = list.groupingBy { it }.eachCount() println(counter) // {apple=3, banana=2, orange=1} 14. groupBy와 groupingBy의 차이점 groupBy groupingBy 결과 즉시 그룹화된 맵을 반환 (Map\u0026lt;K, List\u0026lt;V\u0026gt;\u0026gt;) 지연 계산을 위한 Grouping 객체 (Grouping\u0026lt;K, T\u0026gt;) 동작 방식 그룹화와 동시에 결과를 반환 추가 처리가 필요, eachCount, fold, reduce 등 사용 시기 그룹화된 결과가 즉시 필요한 경우 그룹화 후 추가적인 처리나 지연 계산이 필요한 경우 예시 list.groupBy { it } list.groupingBy { it }.eachCount() 정렬 기준이 여러 개일 때 정렬 Kotlin에서 여러 기준으로 정렬하려면 sortedWith를 사용하고, 각 기준에 맞는 Comparator를 정의할 수 있습니다.\n정렬 기준을 여러 개 지정할 때는 주로 compareBy와 thenBy를 사용해 우선순위를 설정합니다.\n문제 예시: 만약 리스트가 List\u0026lt;Triple\u0026lt;Int, Int, Int\u0026gt;\u0026gt; 형식이고,\n각 요소에 대해 2번 요소(세 번째 값)를 우선적으로 비교하고, 그 다음으로 0번 요소(첫 번째 값), 마지막으로 1번 요소(두 번째 값)를 기준으로 정렬한다고 가정해 보겠습니다.\n코드 예시: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 fun main() { // 예시 데이터: Triple(0번 요소, 1번 요소, 2번 요소) val list = listOf( Triple(1, 2, 3), Triple(1, 3, 2), Triple(2, 1, 3), Triple(0, 0, 2) ) // 2번 요소를 우선으로, 0번 요소, 그 다음 1번 요소 기준으로 정렬 val sortedList = list.sortedWith( compareByDescending\u0026lt;Triple\u0026lt;Int, Int, Int\u0026gt;\u0026gt; { it.third } // 2번 요소 내림차순 .thenBy { it.first } // 0번 요소 오름차순 .thenBy { it.second } // 1번 요소 오름차순 ) // 결과 출력 for (item in sortedList) { println(item) } } [출력 결과] (2, 1, 3) (1, 2, 3) (1, 3, 2) (0, 0, 2) Kotlin에서 thenBy는 다중 정렬 기준을 사용할 때, 첫 번째 기준이 동일한 경우 두 번째 정렬 기준을 적용하기 위해 사용됩니다. 즉, 첫 번째 기준에서 비교가 끝나지 않았을 때, 추가적인 비교 기준을 설정하는 역할을 합니다. thenByDescending 도 가능 heap: PriorityQueue PriorityQueue는 기본적으로 최소 힙(min-heap)으로 동작하며, 최대 힙(max-heap)을 구현하려면 커스텀 비교 함수를 제공해줘야 한다.\n최소 힙 (Min-Heap) 사용 PriorityQueue는 기본적으로 최소 힙으로 구현되어 있으며, 값을 삽입할 때 자동으로 우선 순위에 맞게 정렬되어 가장 작은 값이 우선 처리된다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 import java.util.PriorityQueue fun main() { // 최소 힙 (기본적으로 작을수록 우선순위가 높음) val minHeap = PriorityQueue\u0026lt;Int\u0026gt;() // 값 삽입 minHeap.add(10) minHeap.add(4) minHeap.add(15) minHeap.add(1) // 최소값부터 출력 while (minHeap.isNotEmpty()) { println(minHeap.poll()) // poll()은 가장 작은 값부터 제거하며 반환 } } 출력 결과 1 4 10 15 최대 힙 (Max-Heap) 사용 최대 힙은 기본적으로 지원하지 않기 때문에, 커스텀 비교자를 설정해 값을 큰 순서대로 처리하도록 할 수 있다.\nComparator를 이용해 값을 반대로 비교하면 최대 힙을 구현할 수 있다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 import java.util.PriorityQueue fun main() { // 최대 힙 (큰 값이 우선순위가 높음) val maxHeap = PriorityQueue\u0026lt;Int\u0026gt;(compareByDescending { it }) // 값 삽입 maxHeap.add(10) maxHeap.add(4) maxHeap.add(15) maxHeap.add(1) // 최대값부터 출력 while (maxHeap.isNotEmpty()) { println(maxHeap.poll()) // poll()은 가장 큰 값부터 제거하며 반환 } } 출력 결과 15 10 4 1 사용자 정의 객체를 힙에 사용 만약 힙에 사용자 정의 객체를 저장하고 싶다면, 해당 객체의 우선순위를 지정할 수 있도록 Comparator를 정의해야 한다.\n예를 들어, 객체에 포함된 특정 속성 값을 기준으로 힙을 구성할 수 있다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 import java.util.PriorityQueue data class Person(val name: String, val age: Int) fun main() { // 나이를 기준으로 최소 힙 (나이가 적을수록 우선순위 높음) val personHeap = PriorityQueue\u0026lt;Person\u0026gt;(compareBy { it.age }) personHeap.add(Person(\u0026#34;Alice\u0026#34;, 30)) personHeap.add(Person(\u0026#34;Bob\u0026#34;, 25)) personHeap.add(Person(\u0026#34;Charlie\u0026#34;, 35)) // 나이가 적은 사람부터 출력 while (personHeap.isNotEmpty()) { println(personHeap.poll()) // 나이가 적은 사람부터 반환 } } [출력 결괴] Person(name=Bob, age=25) Person(name=Alice, age=30) Person(name=Charlie, age=35) PriorityQueue의 기능들 1. 생성자 PriorityQueue() : 기본 생성자로 빈 우선순위 큐를 생성한다.\nPriorityQueue(initialCapacity: Int) : 지정한 초기 용량을 가진 우선순위 큐를 생성한다.\nPriorityQueue(comparator: Comparator\u0026lt;in E\u0026gt;) : 커스텀 Comparator를 제공해 우선순위를 정의할 수 있다. 이를 통해 최대 힙을 구현할 수 있다.\n2. 주요 함수 2.1. 삽입과 삭제 add(element: E): Boolean : 우선순위 큐에 요소를 추가하고, 성공하면 true를 반환한다. 큐가 가득 찬 경우 예외를 던질 수 있다.\n1 2 3 4 val pq = PriorityQueue\u0026lt;Int\u0026gt;() pq.add(10) pq.add(5) pq.add(20) offer(element: E): Boolean : add()와 동일하게 요소를 큐에 추가하지만 예외를 던지지 않는다. 성공 여부를 Boolean으로 반환한다.\n1 pq.offer(15) poll(): E? : 우선순위가 가장 높은(가장 작은) 요소를 제거하고 반환한다. 큐가 비어있으면 null을 반환한다.\n1 val minValue = pq.poll() remove(element: E): Boolean : 특정 요소를 큐에서 제거하고, 성공하면 true를 반환한다. 큐에 해당 요소가 없으면 false를 반환한다.\n1 val isRemoved = pq.remove(5) 2.2. 조회 peek(): E? : 큐에서 우선순위가 가장 높은 요소를 제거하지 않고 반환한다. 큐가 비어 있으면 null을 반환한다.\n1 val topValue = pq.peek() element(): E :peek()와 동일하게 가장 높은 우선순위의 요소를 반환하지만, 큐가 비어있으면 예외(NoSuchElementException)를 던진다.\n1 val firstElement = pq.element() 2.3. 상태 확인 isEmpty(): Boolean : 큐가 비어 있는지 여부를 반환한다.\nsize(): Int\n2.4. 기타 함수 clear() : 큐의 모든 요소를 제거한다.\ncontains(element: E): Boolean : 특정 요소가 큐에 포함되어 있는지 확인하고 true나 false를 반환한다\ntoArray(): Array\u0026lt;Any?\u0026gt; : 큐의 모든 요소를 배열로 반환한다.\n1 val array = pq.toArray() deque: ArrayDeque, LinkedList Kotlin에서는 직접적으로 Deque(양방향 큐) 에 대한 클래스를 제공하지 않습니다.\n하지만 Java의 Deque 인터페이스와 그 구현체인 ArrayDeque 또는 LinkedList 를 Kotlin에서 사용할 수 있습니다.\nDeque는 양쪽에서 삽입과 삭제가 가능한 자료구조로, 스택이나 큐와 같은 동작을 모두 수행할 수 있습니다.\n1. ArrayDeque 사용 Java의 ArrayDeque 은 크기 조정이 가능한 배열 기반의 Deque 구현체로, 가변 크기의 양방향 큐입니다.\n기본 사용법: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 import java.util.ArrayDeque fun main() { // ArrayDeque 생성 val deque: ArrayDeque\u0026lt;Int\u0026gt; = ArrayDeque() // 양쪽에 요소 추가 deque.addFirst(1) // 앞쪽에 추가 deque.addLast(2) // 뒤쪽에 추가 deque.addLast(3) println(deque) // 출력: [1, 2, 3] // 양쪽에서 요소 제거 println(deque.removeFirst()) // 출력: 1 println(deque.removeLast()) // 출력: 3 println(deque) // 출력: [2] } 2. LinkedList 사용 또 다른 Deque 구현체는 LinkedList 입니다. LinkedList는 노드 기반의 자료구조로, Deque와 같은 양방향 큐로 사용할 수 있습니다.\n기본 사용법: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 import java.util.LinkedList fun main() { // LinkedList 생성 (Deque로 사용) val deque: LinkedList\u0026lt;Int\u0026gt; = LinkedList() // 양쪽에 요소 추가 deque.addFirst(1) // 앞쪽에 추가 deque.addLast(2) // 뒤쪽에 추가 deque.addLast(3) println(deque) // 출력: [1, 2, 3] // 양쪽에서 요소 제거 println(deque.removeFirst()) // 출력: 1 println(deque.removeLast()) // 출력: 3 println(deque) // 출력: [2] } 3. Deque의 사용 예시 (스택과 큐로 사용) 스택으로 사용 (addFirst, removeFirst):\n1 2 3 4 val stack: ArrayDeque\u0026lt;Int\u0026gt; = ArrayDeque() stack.addFirst(1) // push stack.addFirst(2) println(stack.removeFirst()) // pop, 출력: 2 큐로 사용 (addLast, removeFirst):\n1 2 3 4 val queue: ArrayDeque\u0026lt;Int\u0026gt; = ArrayDeque() queue.addLast(1) // enqueue queue.addLast(2) println(queue.removeFirst()) // dequeue, 출력: 1 결론: Kotlin에서는 Deque를 직접 제공하지 않지만, Java의 ArrayDeque 또는 LinkedList 를 사용하여 Deque와 같은 기능을 구현할 수 있습니다. ArrayDeque 는 배열 기반으로, 빠른 삽입 및 삭제를 지원하는 반면, LinkedList 는 노드 기반으로 동작합니다. 이 두 클래스는 Deque 인터페이스를 구현하고 있으며, 이를 통해 양방향 큐를 편리하게 사용할 수 있습니다. ArrayDeque의 기능들 1. 삽입 메서드 addFirst(element: E): 큐의 앞쪽에 요소를 추가합니다.\n1 2 3 4 val deque = ArrayDeque\u0026lt;Int\u0026gt;() deque.addFirst(1) deque.addFirst(2) println(deque) // 출력: [2, 1] addLast(element: E): 큐의 뒤쪽에 요소를 추가합니다.\n1 2 deque.addLast(3) println(deque) // 출력: [2, 1, 3] offerFirst(element: E): 큐의 앞쪽에 요소를 추가하고, 성공하면 true, 실패하면 false를 반환합니다.\nofferLast(element: E): 큐의 뒤쪽에 요소를 추가하고, 성공하면 true, 실패하면 false를 반환합니다.\n2. 삭제 메서드 removeFirst(): 큐의 앞쪽에서 요소를 제거하고 반환합니다. 만약 큐가 비어 있으면 NoSuchElementException 을 발생시킵니다.\n1 2 println(deque.removeFirst()) // 출력: 2 println(deque) // 출력: [1, 3] removeLast(): 큐의 뒤쪽에서 요소를 제거하고 반환합니다. 큐가 비어 있으면 NoSuchElementException 을 발생시킵니다.\n1 2 println(deque.removeLast()) // 출력: 3 println(deque) // 출력: [1] pollFirst(): 큐의 앞쪽에서 요소를 제거하고 반환합니다. 비어 있으면 null을 반환합니다.\npollLast(): 큐의 뒤쪽에서 요소를 제거하고 반환합니다. 비어 있으면 null을 반환합니다.\n3. 조회 메서드 getFirst(): 큐의 앞쪽 요소를 반환하지만, 제거하지 않습니다. 큐가 비어 있으면 NoSuchElementException 을 발생시킵니다.\n1 println(deque.getFirst()) // 출력: 1 getLast(): 큐의 뒤쪽 요소를 반환하지만, 제거하지 않습니다. 큐가 비어 있으면 NoSuchElementException 을 발생시킵니다.\n1 2 deque.addLast(5) println(deque.getLast()) // 출력: 5 peekFirst(): 큐의 앞쪽 요소를 반환하지만, 제거하지 않습니다. 비어 있으면 null을 반환합니다.\npeekLast(): 큐의 뒤쪽 요소를 반환하지만, 제거하지 않습니다. 비어 있으면 null을 반환합니다.\n4. 기타 메서드 size: Deque의 크기를 반환합니다.\n1 println(deque.size) // 출력: 2 isEmpty(): Deque가 비어 있으면 true, 비어 있지 않으면 false를 반환합니다.\n1 println(deque.isEmpty()) // 출력: false clear(): Deque의 모든 요소를 제거합니다.\n1 2 deque.clear() println(deque) // 출력: [] 5. 스택 기능으로 사용 push(element: E): 스택의 맨 위에 요소를 추가합니다. (addFirst와 동일한 동작)\n1 2 3 4 val stack = ArrayDeque\u0026lt;Int\u0026gt;() stack.push(10) stack.push(20) println(stack) // 출력: [20, 10] pop(): 스택의 맨 위에 있는 요소를 제거하고 반환합니다. (removeFirst와 동일한 동작)\n1 2 println(stack.pop()) // 출력: 20 println(stack) // 출력: [10] 6. 큐 기능으로 사용 offer(element: E): 큐의 뒤쪽에 요소를 추가합니다. (offerLast와 동일)\n1 2 3 4 val queue = ArrayDeque\u0026lt;Int\u0026gt;() queue.offer(100) queue.offer(200) println(queue) // 출력: [100, 200] poll(): 큐의 앞쪽에서 요소를 제거하고 반환합니다. (pollFirst와 동일)\n1 2 println(queue.poll()) // 출력: 100 println(queue) // 출력: [200] ArrayDeque의 특징: 스택과 큐 모두 지원: ArrayDeque는 양방향 큐로서 스택이나 큐로 유연하게 사용할 수 있습니다.\nNull 허용 안 함: ArrayDeque는 null 요소를 허용하지 않습니다.\n크기 조정 가능: 배열 기반이지만 동적으로 크기가 조정됩니다.\n성능: ArrayDeque는 가변 배열로 구현되어 있으며, 삽입과 삭제가 매우 빠릅니다. LinkedList에 비해 메모리 사용량이 적고 성능이 뛰어납니다.\nPython의 defaultdict을 Kotlin으로 구현하는 법 defaultdict를 Kotlin에서 구현하는 방법 getOrPut 함수는 주어진 키가 없으면 기본 값을 생성하고, 해당 값을 맵에 넣어주는 역할을 한다.\ndefaultdict(lambda: list)와 동일한 기능을 구현하려면 MutableMap을 사용해보자.\n1 2 3 4 5 6 7 8 9 10 11 12 fun main() { // MutableMap을 사용하여 defaultdict와 같은 기능을 구현 val map = mutableMapOf\u0026lt;String, MutableList\u0026lt;Int\u0026gt;\u0026gt;() // 특정 키가 없을 경우 기본값으로 빈 리스트를 생성하고, 있으면 기존 값을 가져옴 map.getOrPut(\u0026#34;key1\u0026#34;) { mutableListOf() }.add(1) map.getOrPut(\u0026#34;key1\u0026#34;) { mutableListOf() }.add(2) map.getOrPut(\u0026#34;key2\u0026#34;) { mutableListOf() }.add(10) println(map) // 출력: {key1=[1, 2], key2=[10]} } 코드 설명 mutableMapOf(): 변경 가능한 맵을 생성한다. getOrPut(): 주어진 키에 해당하는 값을 반환하고, 키가 없으면 기본 값을 넣은 후 반환한다. 첫 번째 매개변수는 키(key1, key2)다. 두 번째 매개변수는 값이 없을 때 제공할 기본 값으로, mutableListOf()를 사용하여 빈 리스트를 생성한다. 더 간단한 함수로 감싸기 defaultdict처럼 쓰기 위해 특정 함수로 감싸는 것도 가능하다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 fun \u0026lt;K, V\u0026gt; defaultMap(defaultValue: () -\u0026gt; V): MutableMap\u0026lt;K, V\u0026gt; { return mutableMapOf\u0026lt;K, V\u0026gt;().withDefault { defaultValue() } } fun main() { // 기본값이 빈 리스트인 defaultdict와 유사한 맵 생성 val map = defaultMap\u0026lt;String, MutableList\u0026lt;Int\u0026gt;\u0026gt; { mutableListOf() } map.getValue(\u0026#34;key1\u0026#34;).add(1) // key1에 1 추가 map.getValue(\u0026#34;key1\u0026#34;).add(2) // key1에 2 추가 map.getValue(\u0026#34;key2\u0026#34;).add(10) // key2에 10 추가 println(map) // 출력: {key1=[1, 2], key2=[10]} } 코드 설명 withDefault: 기본 값을 설정할 수 있는 Map의 확장 함수다. 지정된 기본 값이 없을 때 호출된다. defaultMap 함수: Python의 defaultdict처럼 기본값을 설정할 수 있는 MutableMap을 반환한다. 참고 map[key]: 키가 없으면 null을 반환한다.\nmap.getValue(key): 키가 없으면 지정된 기본 값을 반환한다. (그러나 맵에 추가되지는 않는다.)\nwithDefault: 키가 없을 때 기본 값을 제공하지만, 맵에는 값을 추가하지 않는다.\nmap[key]로 접근하면 null이 반환된다. getOrPut: 키가 없으면 기본 값을 추가하고, 값을 반환한다.\n","permalink":"https://2taezeat.github.io/posts/dev/kotlin-%EC%A0%95%EB%A6%AC-5/","summary":"컬렉션의 고차 함수들 1. map 정의: 컬렉션의 각 요소를 변환하여 새로운 컬렉션을 반환합니다. 용도: 리스트의 요소들을 다른 값으로 변환할 때 사용. 1 2 3 val numbers = listOf(1, 2, 3, 4) val squares = numbers.map { it * it } println(squares) // 출력: [1, 4, 9, 16] 2. filter 정의: 주어진 조건에 맞는 요소들만 필터링하여 새로운 컬렉션을 반환합니다. 용도: 리스트에서 특정 조건을 만족하는 요소들만 남기고 싶을 때 사용. 1 2 3 val numbers = listOf(1, 2, 3, 4, 5, 6) val evenNumbers = numbers.","title":"Kotlin 정리 (5)"},{"content":"MVC \u0026lsquo;아키텍처 디자인 패턴\u0026rsquo; or 개발 방법론 핵심: 비지니스 로직(model) 의 구현을 GUI (View) 와 분리하자 역할에 맞게 컴포넌트를 분리하자, 관심사 분리 플랫폼 따라 다양하게 해석되고 변화 MVP, MVVM은 전통적인 MVC로 부터 발전됨 Activity는 Controller이면서 View와 Model의 어딘가\n이것저것 다 신경쓰고, 처리해야 함,\n비대해짐, 역할 분리가 완벽히 되지 않게됨\n장점\n학습이 쉽다 코드들의 역할이 나누어짐 관심사 분리가 시작 단점\nModel과 View간의 의존성이 증가, 특히 Model이 View를 직접 참조하게 된다면 테스팅 어려움\nController 비대\n어떻게 view는 model 의 data를 얻는가?\nModel 스스로 변화를 View에게 알림\nView가 주기적으로 Model을 가져와 업데이트합니다: Polling\n비즈니스 로직 테스트(Model)를 할때 View의 로직이 포함되어 테스트가 힘듬 Model 어플리케이션에 쓰이는 데이터, 비즈니스 로직 MVC, MVP, MVVM 에서 Model 의 정의는 모두 같다. View 화면에 데이터를 표시하는 방법, UI Model을 통해 View를 그림 여기서, Model은 View에게 data를 제공 Controller 사용자의 Input을 입력받고 그에 따라 Model을 변경\n안드로이드에서 Activity가 이 역할을 함\nMVP 장점\nActivity가 View가 됨\nMVC에서 Activity 경계가 애매한 것이 해결 View와 Model(=비즈니스 로직)이 서로를 의존하지 않음.\n단점\nView와 Presenter가 1:1로 결합하고 서로를 알고 있다. (서로 의존성 증가)\nView마다 Presenter를 추가하게 되고, Presenter 갯수가 늘어남\nMVP는 MVC와 다르게 유저의 Input을 View가 받는다.\nView 하는 일은 MVC와 동일 (UI) MVC의 View와 다르게, 사용자의 Input을 입력 받음 Presenter를 참조함 Presenter View와 Model의 연결다리\nView와 1:1 관계를 가지고, 서로 참조\nMVVM 핵심 목적: 비즈니스 로직(Model에 존재) 과 UI 로직(VM에 존재) 을 UI(View) 로부터 분리 UI 로직: 실제 데이터를 어떻게 보이게 할 것인가? 가령, False 값을 \u0026ldquo;아니요\u0026rdquo; 라고 보이게 함 장점\nView가 Model(= 비즈니스 로직)에 의존하지 않음 (MVP에 기존 장점 그대로)\nMVP와 달리 View와 ViewModel이 강하게 결합하지 않음\nViewModel이 View를 모르기 때문에, 의존성 분리가 되고, View 교체가 쉬워짐\n때문에, 여러 패턴 중 가장 테스트를 작성하기 수월 VM과 View가 1:1 관계가 아니기 때문에, ViewModel을 잘 나누면 여러 뷰에서 재활용 가능\n다만, 최근 안드로이드 가이드에서는 뷰단위의 ViewModel 재활용을 비추천하고 있으니 주의가 필요 단점\nMVC, MVP에 비해 복잡하다고 느낄 수 있다.\nDatabinding 등 추가로 학습해야하는 요소가 있다.\nView 하는 일은 MVC, MVP와 동일 (UI, 사용자의 Input을 입력 받음)\nViewModel 을 알고 있다. (VM을 의존한다)\nViewModel View의 요청으로 Model을 적절히 업데이트 하고, Model의 데이터를 홀드 (UI State Holder) View를 모름, View를 참조하지 않음 Databinding, Observable 패턴으로 View는 ViewModel에 있는 UI State에서 데이터에 접근 DataBinding 프로그래매틱 방식이 아니라 선언적 방식을 사용하여 UI 구성요소를 데이터에 결합할 수 있는 지원 라이브러리 뷰를 데이터 객체와 결합하는 데 필요한 클래스를 자동으로 생성 (view와 data를 바인딩) DataBinding으로 인해 ViewModel이 View를 알지 못해도, 다양한 인터랙션 처리 가능 Model에서 데이터가 변경되면, ViewModel에 전달 변경된 데이터가 ViewModel에서 View로 전달되도록 LiveData, RxJava, Kotlin Flow을 사용해 구현 옵저버 패턴 or Reactive(반응형) 프로그래밍 Reference https://medium.com/delightroom/mvc-mvp-mvvm-mvi-%EC%95%84%ED%82%A4%ED%85%8D%EC%B3%90-%EC%95%88%EB%93%9C%EB%A1%9C%EC%9D%B4%EB%93%9C%EC%97%90%EC%84%9C-%EC%9D%B4%ED%95%B4%ED%95%98%EA%B8%B0-1-2442a4189c79 ","permalink":"https://2taezeat.github.io/posts/dev/mvc-mvp-mvvm-%EC%A0%95%EB%A6%AC/","summary":"MVC \u0026lsquo;아키텍처 디자인 패턴\u0026rsquo; or 개발 방법론 핵심: 비지니스 로직(model) 의 구현을 GUI (View) 와 분리하자 역할에 맞게 컴포넌트를 분리하자, 관심사 분리 플랫폼 따라 다양하게 해석되고 변화 MVP, MVVM은 전통적인 MVC로 부터 발전됨 Activity는 Controller이면서 View와 Model의 어딘가\n이것저것 다 신경쓰고, 처리해야 함,\n비대해짐, 역할 분리가 완벽히 되지 않게됨\n장점\n학습이 쉽다 코드들의 역할이 나누어짐 관심사 분리가 시작 단점\nModel과 View간의 의존성이 증가, 특히 Model이 View를 직접 참조하게 된다면 테스팅 어려움","title":"MVC, MVP, MVVM 정리"},{"content":"코틀린 언어 특징 정적 타입 언어 모든 프로그램의 구성요소의 타입을 컴파일 시점에 알 수 있고, 컴파일러가 타입을 검증 해줌. 자바와 다르게 개발자가 타입을 선언하지 않아도 타입 추론이 지원됨 컴파일러가 프로그램 타입의 정확성을 검증하기 때문에 런타임에 프로그램이 오류로 중단될 가능성이 적어짐. NULL 안전성 코틀린은 null이 될 수 있는 타입도 지원한다. null 값 허용여부를 컴파일 단계에서 검사하기 때문에 널 포인터 에러로 인한 프로그램 중단 예방 가능 null pointer exception 에서 자바와 다르게 이 에러를 컴파일 탐임에 에러를 알려준다. 함수 타입에 대한 지원 코틀린은 함수형 프로그래밍 순수함수 같은 인자에 대하여 항상 같은 값을 반환 함수 외부의 어떤 상태도 바꾸지 않음 함수형 프로그래밍에서는 함수를 일급객체로 여김 일급 객체란 함수의 인자로 전달 가능 함수의 반환값으로 사용 가능 변수에 담기 가능 람다식 지원 람다식이란, 다른 함수의 인자로 넘기는 함수, 함수의 결과값으로 반환하는 함수, 변수에 저장하는 함수 고차 함수 : 고차 함수는 다른 함수를 인자로 사용하거나, 함수를 결과값 반환하는 함수를 말함. 일급 객체 or 일급 함수를 서로 주고 받을 수 있는 함수가 고차함수가 된다. 일급 객체인 함수, 그로인한 내부 상태가 절대로 바뀌지 않은 불변 객체를 사용해 side effect가 없음. 입력이 같으면 항상 같은 출력을 내놓고, 다른 객체의 상태를 변경하지 않으며, 함수 외부나 다른 바깥 환경과 상호작용하지 않은 순수함수를 사용할 수 있음. 자바와 호환성 JAVA Virtual Machine이 코틀린의 타겟 플랫폼이기 때문에 자바 메소드 호출, 자바 클래스 상속, 인터페이스 구현 등 자바에서 적용하던걸 모두 코틀린에서 할 수 있음. 자바 표준 라이브러리 클래스에 의존하기에 자바 라이브러리를 활용 할 수 있다. 간결성 getter, setter 같은 자바의 보일러 코드를 코틀린에서는 묵시적으로 제공 안전성 JVM에서 실행 하기 때문에 메모리 안전성과 버퍼 오버 플로우, 동적 메모리 할당의 문제 예방 가능 정적 타입 언어로 타입 자동 추론을 통해 타입 안전성 보장 null 타입 가능성도 지원하기 때문에 NullPointerException 으로 인한 프로그램 오류 방지 Class Cast Exception 예방 : 자바와 달리 코틀린에서는 타입 검사와 Cast가 한 연산자에 의해 이뤄진다. 어떤 객체의 타입을 검사했고, 그 객체가 그 타입에 속한다면 별도의 Cast 없이 해당 타입의 메소드나 필드 등의 멤버를 사용할 수 있다. 따라서 타입 검사를 생략할 이유가 없기에, 검사를 생략해서 생기는 오류가 발생할 일이 없다. val과 var의 차이점 val은 불변 변수입니다. val로 지정된 불변 타입 변수는 초기에 값을 할당하게 되면 나중에 값을 변경할 수 없다. val은 java의 final과 같다고 볼 수 있다. val은 값을 변경시키는 것은 불가능하지만, 변수의 참조가 가리키는 객체의 내부 값은 변경 가능 var로 지정된 가변 타입 변수는 초기화 후 값의 변경이 가능합니다. 하지만 var 변수는 다른 타입의 값을 넣을 수는 없습니다. 이미 정의된 타입을 변경하려면 ‘형 변환’을 해주어야 합니다. Null Safey와 Nullable Types 이란? Elvis 연산자란? 코틀린은 NPE를 방지하기 위해, String?, Int? 같은 nullable 타입들을 이용합니다. 이러한 타입들은 null 값을 가질 수 있습니다. 엘비스 연산자는 이런 nullable 타입들을 안전하게 값을 이용할 수 있도록 사용할 수 있게 합니다. nullable 타입 뒤에 ?: 로 표시하며, nullable 타입의 값이 null 일 경우 오른쪽 값을 이용합니다. null 이 아니면 엘비스 연산자의 왼쪽 값이 변수에 할당 됩니다. const와 val 비교 기본적으로 val 프로퍼티는 runtrime에 결정됨. const 를 붙이면, val은 compile-time에 상수가 됩니다. !! 와 ? 의 차이점은? nullable 값을 안전하게 이용 할 수 있는 다른 방법은? !! 는 nullable 타입의 값을 강제로 가져오기 위해 쓰입니다. !! 은 개발자가 null이 아니라고 확신 할때만 이용해야 합니다. 아니라면 NPE가 발생합니다. ?(안전한 호출 연산자)는 피연사자가 null이 아닌 경우 일반적인 함수 호출 처럼 작동함. 하지만 수신 객체가 null이면 안전한 호출 연산자는 호출을 수행하지 않고 그냥 null을 돌려 준다. let 함수를 ? 연산자 뒤에 사용하여, null이 아닌 경우에만 함수 타입의 람다를 실행하게끔 할 수 도 있다. == 와 === 의 차이점 == : value 비교 ==== : reference 비교 코틀린에서 생성자의 타입들은 어떤 차이가 있는가? Primary Class Header에 정의 Logic을 가질 수 없음. Class당 하나만 존재 Secondary Class Body에 정의 Primary 생성자가 있는 경우, 반드시 위임 해야 한다. Logic을 가질 수 있다. Class 당 1개 이상 존재 가능 코틀린에서 init block이란? init은 코틀린의 초기화 block 이다. Primar 생성자가 인스턴스화 되면 실행됨. Secondary 생성자가 호출되면, Primary 생성자 다음에 실행됨. 생성자 내부 argument들의 타입들은? var로 따로 지정하지 않는 한, 기본적으로 val이다. 코틀린에서 switch 문에 해당하는 것은? JAVA와의 차이점은? when 에서는 임의 조건을 검사할 수 있지만, switch에서는 주어진 식의 여러가지 값 중 하나만 선택할 수 있다. when 은 switch와 다르게 fall-through 를 하지 않고, 조건을 만족하는 가지만 실행한다. data class 란? Java에서는 data를 저장하는 class를 생성하기 위해, 변수마다 getter, setter를 설정하고, toString(), haseCode(), copy() 함수를 직접 override 해야 한다. 하지만 코틀린에서는 class 앞에 data 키워드를 추가하면, 위와 같은 코드를 자동으로 생성해줌. 구조 분해 선언(destructing declaration) 이란? 구조 분해 선언이란 객체가 가지고 있는 여러 값을 분해해서 여러 변수에 한꺼번에 초기화 할 수 있는 방법 구조 분해 선언의 내부에서는 각 변수를 초기화 하기 위해 componentN이라는 함수를 호출하게 되며, 여기서 N은 구조 분해 선언에 있는 변수 위치에 따라 붙는 번호 이다. lazy 와 lateinit lateinit을 사용하면 변수의 값을 지정하는 작업을 뒤로 미룸. Nullable 하지 않는 변수를 선언하면서 Assign 하는 작업을 뒤로 미루고 싶을때는 lateinit 키워드를 사용하면 가능하다. lateinit은 mutable 한 변수만 가능하기 때문에 var 키워드를 가진 변수에서만 사용이 가능하다. by lazy 키워드는 lateinit과 비슷하게 값을 지정하는 작업을 미루는 것인데, Assign 되는 시점이 변수를 호출하는 시점이다. by lazy는 immutable 변수에서만 적용이 가능해, val 키워드 변수에만 적용이 가능하다. 변수에 값을 최초에만 설정하고 변경할 필요가 없는 경우에 사용하면 유용하다. ","permalink":"https://2taezeat.github.io/posts/dev/kotlin-%EC%A0%95%EB%A6%AC-4/","summary":"코틀린 언어 특징 정적 타입 언어 모든 프로그램의 구성요소의 타입을 컴파일 시점에 알 수 있고, 컴파일러가 타입을 검증 해줌. 자바와 다르게 개발자가 타입을 선언하지 않아도 타입 추론이 지원됨 컴파일러가 프로그램 타입의 정확성을 검증하기 때문에 런타임에 프로그램이 오류로 중단될 가능성이 적어짐. NULL 안전성 코틀린은 null이 될 수 있는 타입도 지원한다. null 값 허용여부를 컴파일 단계에서 검사하기 때문에 널 포인터 에러로 인한 프로그램 중단 예방 가능 null pointer exception 에서 자바와 다르게 이 에러를 컴파일 탐임에 에러를 알려준다.","title":"Kotlin 정리 (4)"},{"content":"코틀린 Reflection 설명 Reflection은 프로그램 실행 중에 코드의 구조 (클래스, 함수, 프로퍼티 등)를 분석하고 조작할 수 있는 기능입니다.\n코틀린에서는 kotlin-reflect 라이브러리를 통해 Reflection을 사용할 수 있습니다.\nReflection의 주요 기능:\n클래스 정보 조회: 클래스 이름, 상위 클래스, 인터페이스, 생성자, 메서드, 프로퍼티 등 클래스의 구조 정보를 가져올 수 있습니다. 함수 호출: 함수 객체를 가져와 동적으로 함수를 호출하고 결과를 얻을 수 있습니다. 프로퍼티 접근: 프로퍼티 객체를 가져와 값을 읽거나 변경할 수 있습니다. 생성자 호출: 생성자 객체를 가져와 동적으로 객체를 생성할 수 있습니다. 코틀린 Reflection 사용 방법:\n의존성 추가: build.gradle 파일에 kotlin-reflect 라이브러리 의존성을 추가합니다. 클래스 참조 가져오기: ::class 연산자를 사용하여 KClass 객체를 가져옵니다. 1 val personClass = Person::class 클래스 정보 조회: KClass 객체의 메서드를 사용하여 클래스 정보를 조회합니다. 1 2 val constructors = personClass.constructors val properties = personClass.memberProperties 함수 호출: KFunction 객체의 call() 또는 callBy() 메서드를 사용하여 함수를 호출합니다. 1 2 val getNameFunction = personClass.members.find { it.name == \u0026#34;getName\u0026#34; } as KFunction\u0026lt;*\u0026gt; val name = getNameFunction.call(personInstance) 프로퍼티 접근: KProperty 객체의 getter 또는 setter를 사용하여 프로퍼티 값을 읽거나 변경합니다. 1 2 val nameProperty = personClass.memberProperties.find { it.name == \u0026#34;name\u0026#34; } as KMutableProperty1\u0026lt;Person, String\u0026gt; nameProperty.set(personInstance, \u0026#34;Alice\u0026#34;) Reflection 사용 시 주의 사항:\n성능 저하: Reflection은 일반적인 메서드 호출이나 프로퍼티 접근보다 성능이 떨어질 수 있습니다.\n유지보수 어려움: Reflection을 사용하면 컴파일 시점에 타입 검사가 이루어지지 않으므로, 런타임 오류 발생 가능성이 높아지고 코드의 유지보수가 어려워질 수 있습니다.\n보안 문제: Reflection을 통해 private 멤버에 접근할 수 있으므로, 보안에 유의해야 합니다.\nReflection 사용 예시:\nJSON 파싱 라이브러리: Gson, Moshi 등의 JSON 파싱 라이브러리는 Reflection을 사용하여 JSON 데이터를 객체로 변환합니다. 의존성 주입 프레임워크: Dagger, Hilt 등의 의존성 주입 프레임워크는 Reflection을 사용하여 의존성을 주입합니다. 테스트 프레임워크: Mockito 등의 테스트 프레임워크는 Reflection을 사용하여 Mock 객체를 생성하고 메서드 호출을 가로챕니다. Kotlin 1.9에서 Enum.entries 설명 Kotlin 1.9.0부터 Enum 클래스에 entries 프로퍼티가 추가되었습니다.\n이는 기존의 values() 함수의 대안으로, 더 안전하고 효율적인 방식으로 Enum 상수 목록을 가져올 수 있도록 합니다.\nEnum.entries의 장점:\n불변성 (Immutability): entries는 Enum 상수 목록의 복사본을 반환하지 않고, 원본 목록에 대한 참조를 반환합니다. 따라서 실수로 목록을 수정하여 예기치 않은 결과를 초래하는 것을 방지합니다.\n성능 향상: values() 함수는 매번 호출될 때마다 새로운 배열(Array) 을 생성하여 반환하는 반면,\nentries는 한 번만 생성된 목록을 반환하므로 메모리 사용량을 줄이고 성능을 향상시킵니다. List 인터페이스 지원: entries는 List 인터페이스를 구현하므로, filter, map, forEach 등 다양한 List 관련 함수를 활용할 수 있습니다.\nvalues()는 모든 호출 마다 Mutable Array 복사본을 생성해서 반환하기 때문에, API 본질적 설계 버그입니다.\n이는 values()이 반환한 Array 값을 악의적인 의도로 변경하거나 배열을 조작하려는 개발자의 실수로 이어질 수 있습니다.\n코틀린 코드 컴파일 및 빌드 코틀린 컴파일러는 자바 컴파일러가 자바 소스코드를 컴파일할 때와 마찬가지로 코틀린 소스코드(.kt)를 분석해서 .class 파일을 만들어낸다. 만들어진 .class 파일은 개발 중인 애플리케이션의 유형에 맞는 표준 패키징 과정을 거쳐 실행될 수 있다. Java 코드와 Kotlin 코드의 빌드 과정은 다음과 같은 순서로 이루어진다. 코틀린 컴파일러가 코틀린 코드를 컴파일해 .class 파일을 생성한다. 이 과정에서 코틀린 코드가 참조하는 Java 코드가 함께 로딩되어 사용된다. Java 컴파일러가 Java 코드를 컴파일해 .class 파일을 생성한다. 이때 이미 코틀린이 컴파일한 .class 파일의 경로를 클래스 패스에 추가해 컴파일한다. 코틀린 컴파일러로 컴파일한 코드는 코틀린 런타임 라이브러리(kotlin runtime library)에 의존한다. 코틀린 런타임 라이브러리 : 코틀린 자체 표준 라이브러리 클래스 + 코틀린에서 자바 API의 기능을 확장한 내용 코틀린으로 컴파일한 애플리케이션을 배포할때는 코틀린 런타임 라이브러리도 함께 배포해야 한다. 프로젝트를 컴파일하기 위해 메이븐(Maven)과 그레이(Gradle), 앤트(Ant) 등의 빌드 시스템을 사용 빌드 시스템은 모두 코틀린과 자바가 코드베이스에 함께 들어있는 혼합 언어 프로젝트를 지원할 수 있다 메이븐(Maven)과 그레이(Gradle)들은 애플리케이션을 패키지할 때 알아서 코틀린 런타임 라이브러리을 포함시켜준다. Map Kotlin의 Map 인터페이스는 구현 방법에 따라 다르며, 그 자체는 특정 자료구조(예: 해시 테이블)에 의존하지 않습니다.\nMap 은 단지 키-값 쌍을 관리하는 기능을 정의한 인터페이스일 뿐, 이를 어떻게 구현할지는 구체적인 구현체에 따라 달라집니다.\n1. Map은 인터페이스 Map 은 키-값 쌍을 관리하는 추상적인 개념을 정의한 인터페이스입니다. Map 인터페이스를 구현하는 여러 클래스들이 존재하며, 이 클래스들이 각기 다른 방식으로 내부 동작을 처리합니다. 예를 들어, Map 인터페이스를 구현한 클래스 중에는 해시 테이블 기반의 HashMap, 순서를 유지하는 LinkedHashMap, 정렬된 맵을 제공하는 TreeMap 등이 있습니다. 2. HashMap은 해시 테이블 기반 HashMap 은 Map 인터페이스의 구현체 중 하나로, 해시 테이블을 사용하여 데이터를 저장하고 관리합니다. 이는 빠른 조회와 삽입을 위해 해시 함수를 사용하며, 평균적으로 O(1)의 성능을 제공합니다. 따라서, HashMap은 해시 테이블 기반의 맵이 맞습니다. 3. 다른 Map 구현체들 Map 인터페이스는 여러 가지 구현체가 있으며, 각 구현체는 다른 방식으로 데이터를 저장하고 관리합니다.\nmapOf(): 내부적으로java.util.Collections.singletonMap() 을 사용, 불변인 map 객체를 반환 mutableMapOf() :내부적으로 LinkedHashMap 을 사용 1 2 3 4 5 // MapsJVM.kt public actual fun \u0026lt;K, V\u0026gt; mapOf(pair: Pair\u0026lt;K, V\u0026gt;): Map\u0026lt;K, V\u0026gt; = java.util.Collections.singletonMap(pair.first, pair.second) public fun \u0026lt;K, V\u0026gt; mutableMapOf(vararg pairs: Pair\u0026lt;K, V\u0026gt;): MutableMap\u0026lt;K, V\u0026gt; = LinkedHashMap\u0026lt;K, V\u0026gt;(mapCapacity(pairs.size)).apply { putAll(pairs) } 주요 Map 구현체: HashMap:\n해시 테이블 기반으로, 키의 순서를 유지하지 않으며 빠른 접근 성능(O(1))을 제공합니다. LinkedHashMap:\n해시 테이블을 기반으로 하지만, 삽입된 순서를 유지합니다. 따라서 데이터를 삽입한 순서대로 접근할 수 있습니다. TreeMap (자바):\n1 2 3 4 val treeMap: TreeMap\u0026lt;String, Int\u0026gt; = TreeMap\u0026lt;String, Int\u0026gt;().apply { put(\u0026#34;b\u0026#34;, 2) put(\u0026#34;a\u0026#34;, 1) } 코틀린에서 pass By 방법 Kotlin은 기본적으로 \u0026ldquo;값에 의한 전달\u0026rdquo; (pass by value) 를 사용합니다.\n그러나 참조 타입을 사용할 때는, 참조의 값을 전달하는 방식으로 작동하기 때문에, 참조에 의한 전달(pass by reference) 와 비슷하게 동작할 수 있습니다.\n자세한 설명: 기본 타입 (Primitive Types): Int, Float, Double, Boolean과 같은 기본 데이터 타입은 값에 의한 전달 (pass by value) 로 동작합니다. 즉, 함수에 값을 전달하면 복사본이 전달되며, 함수 내에서 값을 변경하더라도 원본에는 영향을 미치지 않습니다.\n예시:\n1 2 3 4 5 6 7 8 9 10 fun modifyValue(x: Int) { // x는 복사된 값이므로, 이 함수 내에서 변경되어도 원래 값에는 영향을 주지 않음 x = x + 1 } fun main() { var a = 10 modifyValue(a) println(a) // 출력: 10 (변경되지 않음) } 참조 타입 (Reference Types): Kotlin의 클래스 객체나 배열, 리스트 등 참조 타입의 경우, 값에 의한 전달이지만 참조의 값을 전달합니다. 즉, 객체 자체는 전달된 참조를 통해 접근할 수 있기 때문에, 객체의 속성을 변경할 수 있습니다. 하지만, 참조 자체를 변경하면, 그 변경은 함수 외부에 영향을 미치지 않습니다.\n예시:\n1 2 3 4 5 6 7 8 9 10 11 12 data class Person(var name: String) fun modifyPerson(person: Person) { // person은 참조의 값이 전달되므로, 객체의 속성을 변경할 수 있음 person.name = \u0026#34;Modified\u0026#34; } fun main() { val person = Person(\u0026#34;Original\u0026#34;) modifyPerson(person) println(person.name) // 출력: Modified (속성이 변경됨) } 이 경우, 객체의 속성은 함수 내에서 변경할 수 있지만, 참조 자체를 다른 객체로 바꾸는 것은 함수 외부에 영향을 주지 않습니다. 요약: 기본 타입 (Primitive types): 값에 의한 전달 (pass by value)로 동작. 참조 타입 (Reference types): 참조의 값을 전달하지만, 객체의 속성을 변경할 수 있기 때문에 참조에 의한 전달처럼 동작할 수 있음. 실제로 Kotlin은 값에 의한 전달만 존재합니다. 다만 참조 타입을 함수에 전달할 때, 그 참조된 객체의 속성은 함수 내에서 변경될 수 있습니다.\n참고 result.add(combination.toList()) 에서 toList() 로 깊은 복사를 하지 않으면,\nresult 가 [[], [], []] 가 되어 버린다.\n이유는 combination를 result에 추가할 때 참조의 값를 그대로 넘겨주기 때문입니다.\nKotlin의 MutableList는 참조 타입이므로, combination가 변경되면 result에 있는 리스트도 함께 변경됩니다.\n따라서 나중에 값을 변경할 때 result에 추가된 값도 동일하게 변경되는 문제가 발생합니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 fun combineWithBackTracking(n: Int, k: Int): List\u0026lt;List\u0026lt;Int\u0026gt;\u0026gt; { // 참고용 val result = mutableListOf\u0026lt;List\u0026lt;Int\u0026gt;\u0026gt;() val combination = mutableListOf\u0026lt;Int\u0026gt;() fun backtrack(start: Int) { if (combination.size == k) { result.add(combination.toList()) return } for (i in start..n) { combination.add(i) backtrack(i + 1) combination.removeAt(combination.size - 1) } } Array 에서는? IntArray는 Kotlin에서 기본 타입 배열(primitive array) 로, Int 타입의 값들을 저장하는 배열입니다.\n이 경우도 마찬가지로, Kotlin은 값에 의한 전달(pass by value) 를 사용합니다. 하지만, IntArray 자체는 참조 타입으로 동작하므로, 참조의 값이 전달됩니다.\n따라서, 배열 내부의 요소는 함수에서 수정할 수 있지만, 배열 자체를 새로운 배열로 변경하는 것은 함수 외부에 영향을 미치지 않습니다.\n예시 1: 배열의 요소를 변경할 때 1 2 3 4 5 6 7 8 9 fun modifyArray(arr: IntArray) { arr[0] = 100 // 배열의 첫 번째 요소를 100으로 변경 } fun main() { val nums = intArrayOf(1, 2, 3) modifyArray(nums) println(nums.joinToString()) // 출력: 100, 2, 3 } 배열의 참조가 전달되므로, 배열의 내부 값을 수정할 수 있습니다. 위의 경우, 함수 내에서 배열의 첫 번째 요소가 변경되었고, 원래 배열(nums)도 이 변경 사항을 반영합니다. 예시 2: 배열 자체를 새로 할당할 때 1 2 3 4 5 6 7 8 9 fun reassignArray(arr: IntArray) { arr = intArrayOf(4, 5, 6) // 배열 자체를 새로 할당 (실제로는 함수 내에서만 영향) } fun main() { val nums = intArrayOf(1, 2, 3) reassignArray(nums) println(nums.joinToString()) // 출력: 1, 2, 3 (변경되지 않음) } 배열 자체를 새로운 배열로 할당하려고 하면, 함수 내에서만 새로운 배열이 할당되고, 원본 배열은 변경되지 않습니다. 이는 배열의 참조 값이 복사되어 전달되기 때문에, 원본 배열의 참조 자체는 변경되지 않는 것입니다. 요약: 배열의 요소는 함수 내에서 변경할 수 있으며, 이 변경 사항은 함수 외부에도 영향을 미칩니다. 이는 배열의 참조가 전달되기 때문입니다. 하지만 배열 자체를 새로운 배열로 할당하는 것은 함수 내에서만 영향을 미치며, 함수 외부의 배열에는 영향을 주지 않습니다. 따라서, IntArray의 경우에도 참조의 값이 전달되므로, 배열의 내부 값을 수정할 수는 있지만, 참조 자체는 변경되지 않습니다.\nIntArray vs Array\u0026lt;Int\u0026gt; Kotlin에서 IntArray와 Array\u0026lt;Int\u0026gt;는 모두 정수형 배열을 나타내지만,\n둘 사이에는 중요한 차이점이 있습니다. 이 차이는 메모리 효율성과 타입에 대한 처리 방식에서 비롯됩니다.\n1. IntArray Primitive 타입 배열로, 메모리 효율이 뛰어납니다. 배열의 요소가 int 타입의 원시값으로 저장되므로, 박싱(boxing) 이 발생하지 않습니다. Kotlin에서 제공하는 원시 배열 중 하나로, 자바의 primitive 배열(int[])과 대응됩니다. 주로 성능이 중요한 상황에서 사용됩니다. 1 val intArray = IntArray(5) { it * 2 } // 0, 2, 4, 6, 8 이 경우, 메모리에는 각 요소가 원시 정수로 저장됩니다.\nIntArray는 자바의 int[]와 대응\n2. Array\u0026lt;Int\u0026gt; 참조 타입 배열입니다. 배열의 각 요소가 객체(Integer)로 저장되며, 박싱(boxing) 이 발생합니다. 즉, 배열 요소들이 기본적으로 객체로 처리되므로, 추가적인 메모리 사용이 있습니다. Array\u0026lt;Int\u0026gt;는 제네릭 배열이므로 Kotlin의 Array\u0026lt;T\u0026gt; 와 대응됩니다. 1 val arrayInt = Array(5) { it * 2 } // 0, 2, 4, 6, 8 각 요소는 객체(Integer) 로 저장되므로, 박싱이 발생합니다.\nArray\u0026lt;Int\u0026gt;는 Integer[]와 대응\n3. 차이점 요약 속성 IntArray Array\u0026lt;Int\u0026gt; 타입 Primitive 타입 (int) 참조 타입 (Integer) 메모리 효율성 더 효율적 (박싱 없음) 덜 효율적 (박싱 발생) 자바 대응 int[] Integer[] 주 사용 상황 성능이 중요한 경우 제네릭 배열이 필요한 경우 함수 지원 IntArray에 맞는 특수 함수 제공 Array\u0026lt;T\u0026gt;에 맞는 일반 함수 제공 4. 어떤 경우에 사용하나요? IntArray: 성능과 메모리 사용이 중요한 경우, 예를 들어 대규모 데이터를 처리하거나, 원시 배열과의 호환성이 중요한 경우. Array\u0026lt;Int\u0026gt;: 일반적인 제네릭 배열이 필요한 경우 또는 참조 타입을 사용해야 하는 경우. 5. 변환 방법 두 배열 간의 변환이 필요한 경우 다음과 같이 처리할 수 있습니다:\nIntArray -\u0026gt; Array\u0026lt;Int\u0026gt; 변환:\n1 2 val intArray = IntArray(5) { it } val arrayInt: Array\u0026lt;Int\u0026gt; = intArray.toTypedArray() Array\u0026lt;Int\u0026gt; -\u0026gt; IntArray 변환:\n1 2 val arrayInt = arrayOf(1, 2, 3, 4, 5) val intArray: IntArray = arrayInt.toIntArray() Map의 반복 처리 Kotlin에서 Map 이 Iterable 인터페이스를 직접 구현하지 않으면서도 반복 처리가 가능한 이유는 Map 자체가 entries, keys, 그리고 values 라는 컬렉션 뷰(Collection Views) 를 제공하기 때문입니다.\n이 각각의 뷰는 Set 또는 Collection 으로 표현되며, 이들이 Iterable 을 구현하고 있어 for 루프나 forEach와 같은 반복 처리가 가능해집니다.\n구체적인 설명: 1. Map 자체는 Iterable을 구현하지 않음 Map 인터페이스 자체는 Iterable 을 직접 구현하지 않습니다. 즉, Map 자체는 키와 값의 쌍을 저장하는 고유한 자료구조로, 단순히 한 방향으로 순차적으로 탐색되는 데이터 구조가 아닙니다.\nMap의 key, value, entry들은 내부적으로 별도의 컬렉션(Set, Collection 등) 을 통해 구현됩니다.\n2. entries, keys, values 컬렉션 Map에서 제공하는 세 가지 주요 컬렉션 뷰는 모두 반복 처리를 위한 Iterable을 구현하고 있습니다. 이 컬렉션들이 바로 Map을 반복 처리할 수 있게 도와줍니다.\nentries: Map의 모든 키-값 쌍을 나타내며, 이는 Set\u0026lt;Map.Entry\u0026lt;K, V\u0026gt;\u0026gt; 로 반환됩니다. Set은 Iterable을 구현하므로, 이 entries 컬렉션을 통해 Map의 각 엔트리를 순회할 수 있습니다. keys: Map의 모든 키를 포함한 컬렉션이며, 이는 Set\u0026lt;K\u0026gt; 로 반환됩니다. 역시 Set이 Iterable을 구현하므로, keys를 통해 모든 키를 순회할 수 있습니다. values: Map의 모든 값을 포함한 컬렉션이며, 이는 Collection\u0026lt;V\u0026gt; 로 반환됩니다. Collection은 Iterable을 구현하므로, values를 순회할 수 있습니다. 함수 타입과 함수형 인터페이스 Kotlin은 자바와 달리 람다 표현식을 사용할 때 함수 타입을 지원합니다.\n자바는 함수 타입을 지원하지 않기 때문에, 람다를 넘기려면 함수형 인터페이스를 사용해야 합니다.\n그러나 Kotlin에서는 굳이 함수형 인터페이스를 만들 필요 없이, 함수 타입을 직접 인자로 사용할 수 있기 때문에, 인터페이스에 의존하는 방식이 필요하지 않습니다.\n1. Kotlin의 함수 타입 Kotlin에서는 함수 타입을 파라미터로 정의할 수 있습니다. 예를 들어, (Int) -\u0026gt; Unit과 같은 함수 타입을 직접적으로 파라미터로 사용해 함수를 작성할 수 있습니다.\n함수 타입을 인자로 사용하는 예시: 1 2 3 4 5 6 7 8 9 10 11 // 함수 타입을 인자로 받는 함수 fun executeAction(action: () -\u0026gt; Unit) { action() } fun main() { // 함수 타입을 바로 람다로 전달 executeAction { println(\u0026#34;Doing something...\u0026#34;) } } 이 코드는 정상적으로 작동하며, executeAction 함수는 함수 타입(() -\u0026gt; Unit) 을 인자로 받습니다. Kotlin에서는 이처럼 인터페이스 대신 함수 타입을 직접 사용할 수 있습니다.\n2. 함수형 인터페이스와의 차이점 Kotlin에서는 fun interface 키워드를 사용하여 자바의 함수형 인터페이스와 유사한 방식을 사용할 수 있습니다. 하지만 기본적으로 함수 타입을 사용할 수 있기 때문에, 대부분의 경우 함수형 인터페이스보다 함수 타입을 더 선호합니다.\n자바 스타일의 함수형 인터페이스 사용: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 // 함수형 인터페이스 fun interface MyAction { fun perform() } // MyAction 인터페이스를 인자로 받는 함수 fun executeAction(action: MyAction) { action.perform() } fun main() { // 인터페이스를 람다로 넘기기 executeAction { println(\u0026#34;Doing something...\u0026#34;) } } 위 코드는 함수형 인터페이스를 사용하여 인자로 넘기는 예시입니다. fun interface로 정의된 인터페이스는 단일 추상 메서드(SAM) 를 가지기 때문에 람다로 구현할 수 있습니다.\n하지만 이 방식은 자바와의 상호 운용성(interop)을 위해 사용되며, 일반적으로 Kotlin에서는 함수 타입을 사용하는 것이 더 자연스럽습니다.\n3. 요약 Kotlin에서 하나의 추상 메서드만 있는 인터페이스를 인자로 받는 함수에 람다를 넘기려면, fun interface 를 명시적으로 선언해야 합니다. 그렇지 않으면, Kotlin은 그 인터페이스를 함수 타입으로 간주하지 않기 때문에 람다 표현식을 바로 전달할 수 없고 오류가 발생합니다.\n하지만 Kotlin에서는 함수형 인터페이스 없이도 함수 타입을 바로 사용할 수 있으므로, 함수 타입을 파라미터로 사용할 수 있는 경우에는 인터페이스를 굳이 정의하지 않아도 됩니다. 이는 Kotlin의 함수 타입 지원 덕분에 발생하는 차이점입니다.\nreified 상세 Kotlin에서 reified 키워드는 제네릭 타입을 런타임에 구체화(reify) 할 수 있게 해줍니다.\n보통 제네릭 타입은 런타임에 타입 정보가 소거(erase) 되지만, reified를 사용하면 타입 정보를 런타임에도 유지할 수 있어, 제네릭 타입에 대한 타입 검사나 타입 캐스팅을 런타임에 수행할 수 있게 됩니다.\nreified가 필요할 때: 제네릭 타입 소거(Type Erasure) 문제: 일반적으로 제네릭 타입은 런타임에 소거됩니다. 즉, 제네릭 타입 정보는 컴파일 시에는 존재하지만, 런타임에서는 해당 정보가 제거되어 타입 정보를 알 수 없습니다. 예를 들어, 제네릭 함수에서 T::class 또는 T is SomeClass와 같은 타입 체크나 타입 캐스팅을 하려면 reified가 필요합니다. 예시: reified 사용 1 2 3 4 5 6 7 8 9 10 11 // reified를 사용한 제네릭 인라인 함수 inline fun \u0026lt;reified T\u0026gt; checkType(value: Any): Boolean { return value is T // 런타임에 제네릭 타입 T에 대한 타입 검사 가능 } fun main() { val result1 = checkType\u0026lt;String\u0026gt;(\u0026#34;Hello\u0026#34;) // true val result2 = checkType\u0026lt;Int\u0026gt;(\u0026#34;Hello\u0026#34;) // false println(result1) println(result2) } 설명: inline 함수: reified 키워드는 인라인 함수에서만 사용할 수 있습니다. 인라인 함수는 컴파일 시 함수 호출을 본문으로 대체하므로, 제네릭 타입이 소거되지 않고 타입 정보가 유지됩니다. reified 키워드: 제네릭 타입 T를 구체화(reify) 하여, 런타임에서도 해당 타입에 접근할 수 있습니다. 이로 인해 T is String과 같은 타입 검사를 런타임에서 할 수 있습니다. reified 없는 경우: 컴파일 오류 발생 1 2 3 4 fun \u0026lt;T\u0026gt; checkType(value: Any): Boolean { // 컴파일 오류: \u0026#39;is\u0026#39; 검사를 제네릭 타입 T에 대해 수행할 수 없음 return value is T } 위 코드에서 제네릭 타입 T는 타입 소거가 발생하기 때문에, 런타임에는 T의 타입 정보를 알 수 없습니다. 그래서 value is T와 같은 코드는 컴파일 오류가 발생합니다.\nreified를 사용한 응용: 제네릭 타입을 클래스 타입으로 변환 (T::class 사용): 1 2 3 4 5 6 7 8 inline fun \u0026lt;reified T\u0026gt; getTypeName(): String { return T::class.simpleName ?: \u0026#34;Unknown\u0026#34; } fun main() { println(getTypeName\u0026lt;String\u0026gt;()) // 출력: String println(getTypeName\u0026lt;Int\u0026gt;()) // 출력: Int } 제네릭 타입의 인스턴스 생성: 1 2 3 4 5 6 7 8 inline fun \u0026lt;reified T\u0026gt; createInstance(): T? { return T::class.java.getDeclaredConstructor().newInstance() } fun main() { val instance: String? = createInstance\u0026lt;String\u0026gt;() println(instance) // 출력: 빈 문자열 (기본 생성자 호출) } 제네릭 타입 캐스팅: 1 2 3 4 5 6 7 8 9 10 11 inline fun \u0026lt;reified T\u0026gt; cast(value: Any): T? { return value as? T } fun main() { val stringValue: String? = cast\u0026lt;String\u0026gt;(\u0026#34;Hello\u0026#34;) println(stringValue) // 출력: Hello val intValue: Int? = cast\u0026lt;Int\u0026gt;(\u0026#34;Hello\u0026#34;) println(intValue) // 출력: null (타입이 맞지 않음) } 결론: reified 는 제네릭 타입을 구체화하여 런타임에 타입 정보를 유지할 수 있게 해줍니다. 이를 통해 타입 검사, 타입 캐스팅, 타입 관련 함수(T::class) 를 사용할 수 있습니다. reified는 인라인 함수와 함께 사용해야 하며, 일반 제네릭 함수에서는 사용할 수 없습니다. runCatching runCatching은 Kotlin에서 예외 처리와 관련된 함수로, 코드 블록을 실행하고 그 결과나 예외를 Result 객체로 반환한다.\n이 함수는 코드에서 발생할 수 있는 예외를 간결하게 처리할 수 있도록 도와준다.\nrunCatching은 함수 블록을 실행한 후 성공했을 경우에는 Result.success로, 예외가 발생했을 경우에는 Result.failure로 감싼 결과를 반환한다.\n이를 통해 예외를 명시적으로 던지지 않고도 안전하게 처리할 수 있다.\n사용법 1 2 3 val result = runCatching { // 예외가 발생할 수 있는 코드 } 반환되는 Result 객체 성공 (Result.success): 블록이 성공적으로 실행되면 결과 값을 포함한 Result.success 객체를 반환한다. 실패 (Result.failure): 블록에서 예외가 발생하면 해당 예외를 포함한 Result.failure 객체를 반환한다. 주요 함수 isSuccess: 실행이 성공했는지 여부를 확인.\nisFailure: 예외가 발생했는지 여부를 확인.\ngetOrNull(): 성공한 경우 결과 값을 반환하고, 실패한 경우 null을 반환.\nexceptionOrNull(): 실패한 경우 예외를 반환하고, 성공한 경우 null을 반환.\ngetOrElse(defaultValue): 성공하면 값을 반환하고, 실패하면 기본 값을 반환 또는 다른 예외 처리를 적용\nonSuccess(action): 성공했을 때 실행할 동작을 지정.\nonFailure(action): 실패했을 때 실행할 동작을 지정.\n예시 성공 예시 1 2 3 4 5 6 7 8 9 fun main() { val result = runCatching { // 정상 실행 42 } println(result) // Result.success(42) println(result.getOrNull()) // 42 } 실패 예시 1 2 3 4 5 6 7 8 9 fun main() { val result = runCatching { // 예외 발생 throw IllegalArgumentException(\u0026#34;에러 발생\u0026#34;) } println(result) // Result.failure(java.lang.IllegalArgumentException: 에러 발생) println(result.exceptionOrNull()) // java.lang.IllegalArgumentException: 에러 발생 } getOrElse로 기본 값 처리 1 2 3 4 5 6 7 8 9 fun main() { val result = runCatching { throw IllegalArgumentException(\u0026#34;에러 발생\u0026#34;) } // 실패할 경우 기본 값으로 처리 val value = result.getOrElse { 0 } println(value) // 0 } onSuccess와 onFailure runCatching에서 반환된 Result 객체는 onSuccess와 onFailure를 이용해 성공과 실패에 대해 각각의 후속 작업을 정의할 수 있다.\n1 2 3 4 5 6 7 8 9 fun main() { val result = runCatching { \u0026#34;성공\u0026#34; } result .onSuccess { println(\u0026#34;성공: $it\u0026#34;) } // 성공 시 처리 .onFailure { println(\u0026#34;실패: ${it.message}\u0026#34;) } // 실패 시 처리 } 장점 코드가 간결해지고 가독성이 향상된다. 함수형 프로그래밍 스타일과 잘 맞아 onSuccess, onFailure 등의 체이닝이 가능하다. 명시적인 예외 처리와 Result 객체를 활용한 구체적인 예외 처리 로직을 적용할 수 있다. 단점 복잡한 예외 처리에 적합하지 않다. 디버깅이 어려울 수 있고, 성능 오버헤드가 발생할 수 있다. 익숙하지 않은 경우 직관적으로 이해하기 어려울 수 있다. ","permalink":"https://2taezeat.github.io/posts/dev/kotlin-%EC%A0%95%EB%A6%AC-3/","summary":"코틀린 Reflection 설명 Reflection은 프로그램 실행 중에 코드의 구조 (클래스, 함수, 프로퍼티 등)를 분석하고 조작할 수 있는 기능입니다.\n코틀린에서는 kotlin-reflect 라이브러리를 통해 Reflection을 사용할 수 있습니다.\nReflection의 주요 기능:\n클래스 정보 조회: 클래스 이름, 상위 클래스, 인터페이스, 생성자, 메서드, 프로퍼티 등 클래스의 구조 정보를 가져올 수 있습니다. 함수 호출: 함수 객체를 가져와 동적으로 함수를 호출하고 결과를 얻을 수 있습니다. 프로퍼티 접근: 프로퍼티 객체를 가져와 값을 읽거나 변경할 수 있습니다. 생성자 호출: 생성자 객체를 가져와 동적으로 객체를 생성할 수 있습니다.","title":"Kotlin 정리 (3)"},{"content":"Kotlin 다시 보기 (2) ‘빅 너드 랜치의 코틀린 프로그래밍’ 을 읽고 정리\n인터페이스와 추상 클래스 abstact 함수(추상 함수) : 함수의 헤더만 선언하고 몸체(Body)의 구현 코드가 없는 함수\n객체간의 상속 관계가 없으면서, 주로 공통적인 속성이나 행동을 갖는 경우 : 인터페이스\n객체간의 상속 관계가 있으면서, 주로 인스턴스 생성이 필요 없는 부모 클래스가 필요한 경우 : 추상 클래스\n인터페이스 구현하기 인터페이스는 무엇을 해야 하는지 정의한 것이므로, 클래스로 구현(implement) 해야 한다.\n해당 인터페이스를 구현하는 클래스를 정의(구현)한 후에 이 클래스에서 인터페이스에 명시된 속성과 함수의 구현 코드를 제공하게 한다.\n인터페이스의 속성과 함수는 open 키워드를 지정하지 않아도 된다.\n인터페이스는 how가 아닌 what을 정의한다.\nhow는 인터페이스의 구현 클래스에서 정의 다중 상속 가능\n속성 초기화, 값 지정 불가능\n인터페이스 타입의 매개변수를 가지므로 이 인터페이스를 구현하는 어떤 클래스의 인스턴스도 인자로 받을 수 있다\n인터페이스에 정의된 속성에 기본으로 구현된 getter와 함수에도 기본으로 구현된 몸체 코드를 제공할 수 있다.\ndamageRoll의 속성의 값을 지정하지 않을 경우 기본으로 구현된 getter에서 값이 지정됨 1 2 3 4 5 6 7 8 9 interface Fightable { var healthPoints: Int val damageRoll: Int get() = (O until dicecount).map { Random().nextInt(diceSides) + 1 }.sum() fun attack(opponent: Fightable): Int } SAM(single abstract method) 인터페이스 하나의 추상 메서드만 갖는 인터페이스 (코틀린이랑 상관없음)\n인터페이스 임으로, 하나의 타입이 된다 (컴파일러가 자동 타입 추론 및 에러 검출)\n함수형 인터페이스 라고도 불린다.\n1 2 3 public interface OnClickListener { // 대표적 예, Java 코드 void onClick(View v); } SAM 변환 자바 8 이전에는 함수형 인터페이스를 인자로 받는 Java 함수를 호출할 경우, 인터페이스를 구현한 익명 클래스 인스턴스를 만들어서 넘겨줘야 했다. 자바 8 이후와 코틀린에서 인터페이스를 인자로 받는 Java 메서드를 호출 할 경우, 객체(object) 대신 람다를 넘길 수 있다. 이를 SAM 변환이라고 한다. SAM 주의 사항 SAM 변환은 자바에서 작성한 인터페이스일 때만 동작 코틀린에서 하나의 추상 메소드만 있는 인터페이스를 생성하고, 그 인터페이스를 인자로 받는 함수에 람다를 넘기려고 하면 오류가 발생 이유는 코틀린에서는 함수를 파라미터로 사용할 수 있기 때문이다. 코틀린에서는 함수 타입이라는 특별한 타입이 존재하기 때문 만약 코틀린에서 SAM 변환을 사용하고 싶다면, 인터페이스 앞에 fun 키워드를 붙여주면 된다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 fun interface Practice{ fun a() } fun main(){ doSomething{ println(\u0026#34;a\u0026#34;) } // 방법 1 val practice = Practice{ println(\u0026#34;a\u0026#34;) } // 방법 2 doSomething(practice) } fun doSomething(practice: Practice){ practice.a() } 추상 클래스 인터페이스와 비슷하게 추상 함수와 속성을 갖는다.\n구현 코드가 있는 일반 함수도 가질 수 있다.\n서브 클래스에서 추상 클래스의 속성과 함수를 상속받아 구현하도록 하는 것이 추상 클래스의 주 목적이다.\n추상 클래스는 주로 부모 클래스를 정의할 때 사용된다. (상속)\n인터페이스에 정의된 함수는 기본적으로 추상 함수지만, 추상 클래스에 정의되는 추상 함수에는 abstract 키워드를 지정해야 한다.\n일반 클래스는 하나의 추상 클래스만 부모 클래스로 가질 수 있지만, 인터페이스는 여러 개 구현 가능하다.\n제네릭 제네릭: 타입을 미리 확정하지 않고, 사용되는 시점에서 특정 타입을 지정할 수 있도록 해주는 기법\n동일한 인터페이스 및 클래스, 함수의 정의를 재사용할 수 있어서 코드의 중복을 줄여준다.\n컴파일 시점에서 사용 타입의 적합성을 확인할 수 있으므로, 타입 안전을 보장해 준다. (타입 추론 가능)\nList 는 ‘제네릭 인터페이스’로 정의 되었다.\n여기서 \u0026lsquo;List\u0026rsquo; 는 raw 타입 \u0026lt;\u0026gt; 안에 지정된 타입을 제네릭 타입(generic type) 이라고 한다. List\u0026lt;out E\u0026gt; 제네릭 클래스의 인스턴스의 타입은 raw 타입과 제네릭 타입이 결합된 타입이 된다. ( 하나의 List\u0026lt;Int\u0026gt; 타입 )\n제네릭 타입 정의하기 1 2 3 4 5 6 7 8 9 10 11 12 class LootBox\u0026lt;T\u0026gt;(item: T) { private var loot: T = item var tmp = false fun fetch(): T? { // 제네릭 함수 return loot.takeIf { tmp } } fun \u0026lt;R\u0026gt; fetch( lootModFunction: (T) -\u0026gt; R ): R? { // 복합 제네릭 타입 함수 return loot.takeIf { tmp } } } 제네릭 타입 매개변수 : T / \u0026lt; \u0026gt;안에 지정됨\n보통 return 타입 매개 변수는 ‘R’로 표현\n(T) -\u0026gt; R =\u0026gt; 함수 타입\n제네릭 타입 제약 제네릭 타입 T에: Loot를 지정하면, Loot 클래스 및 이것의 서브 클래스만 LootBox 클래스의 매개변수 타입으로 사용될 수 있다. 1 2 3 class LootBox\u0026lt;T: Loot\u0026gt;(itme: T) { } vararg 1 2 3 class LootBox\u0026lt;T: Loot\u0026gt;(vararg itme: T) { } vararg 키워드를 추가하면 매개변수가 배열(Array) 로 처리되므로 여러 개의 아이템을 인자로 전달할 수 있다. 코틀린에서 기본 타입이 아닌 Arrays 라는 참조 타입으로 배열을 지원한다. (코틀린은 모두 참조 타입) 여기서 배열은 컬렉션 타입이다. 1 2 3 4 5 6 7 8 9 10 class MyDataClass constructor(vararg val numbers: Int) { // ... } val myData1 = MyDataClass(1, 2, 3) val myData2 = MyDataClass() // 빈 배열 전달 가능 val myData3 = MyDataClass(4, 5) val numbers = intArrayOf(1, 2, 3) val myData = MyDataClass(*numbers) // 배열을 펼쳐서 전달 기본 생성자에서의 vararg\n코틀린의 기본 생성자에서 vararg를 사용하면, 생성자에 가변적인 개수의 인자를 전달하여 객체를 초기화할 수 있다. vararg 사용 시 주의 사항:\n하나의 생성자에 vararg 매개변수는 최대 하나만 사용할 수 있다.\nvararg 매개변수는 항상 마지막 매개변수로 와야 한다.\nvararg 매개변수는 내부적으로 배열로 처리된다.\n활용 예시:\n다양한 개수의 인자를 받는 함수: 예를 들어, 평균을 계산하는 함수를 정의할 때 vararg를 사용하면 여러 개의 숫자를 인자로 받아 처리할 수 있다.\n배열을 펼쳐서 전달: 스프레드 연산자(*)를 사용하여 배열을 펼쳐서 vararg 매개변수에 전달할 수 있다.\nin과 out 제네릭 클래스의 인스턴스는 raw 타입과 제네릭 타입이 결합된 것이 자신의 타입이 된다.\n\u0026lt;\u0026gt;로 나타낸 제네릭 타입 간의 부모-자식 관계가 있더라도 컴파일러가 인식하지 못한다.\n개발자 입장에서 불편함 이 불편을 해결 방법이 in과 out 이다.\nout 키워드를 지정하면, 두 제네릭 타입 간의 부모-자식 타입 관계를 ‘그대로’ 컴파일러가 고려해준다.\nList의 타입도 List\u0026lt;out E\u0026gt;로 되어 있다.\n제네릭 타입 매개변수에 out 키워드를 지정한 것을 공변형(covariance)\nin 키워드를 지정하면, 제레릭 타입 매개변수를 포함한 클래스나 인터페이스의 관계가 제네릭 타입 매개변수의 부모-자식 관계와 ‘반대’ 로 된다.\n‘동물’ 타입이 ‘사자’ 타입의 부모인 경우\n‘Pet\u0026lt;동물\u0026gt; 타입’이 ‘Pet\u0026lt;사자\u0026gt; 타입’의 자식 타입으로 간주된다.\n제네릭 타입 매개변수에 in 키워드를 지정한 것을 반공변형(contravariance)\nreified 키워드 컴파일된 JVM 바이트 코드에서는 제네릭 타입 매개변수의 정보가 수록되지 않고 소거된다.\nList\u0026lt;Int\u0026gt;, List\u0026lt;Double\u0026gt; 모두 JVM 바이트코드에는 raw 타입 List 로 처리된다. 실체화(reification): 코틀린은 이 문제를 해결하기 위해 제네릭 타입 매개변수를 컴파일러가 실제 타입으로 변경해주는 기능을 지원 제네릭 타입 매개변수의 실체화(reification) 제네릭 타입 매개변수가 지정된 클래스는 타입 검사에 사용될 수 없다.\nif (l is List\u0026lt;String\u0026gt;) ⇒ 컴파일 에러 reified 키워드 를 사용하면 제네릭 매개변수로 전달된 인자의 타입과 인스턴스의 타입을 런타임 시에 검사할 수 있게 된다. (inline 키워드와 같이 사용)\n타입 매개변수의 실체화는 inline 키워드가 지정된 인라인 함수에서만 가능하다. 1 2 3 inline fun \u0026lt;reified T\u0026gt; check(f1: () -\u0026gt; T): T { // ~~~ } 확장 기존 타입(클래스 or 인터페이스)의 정의를 직접 변경하지 않고 새로운 기능을 추가해준다.\nJVM 바이트 코드는 코틀린 확장 함수가 static 메서드로 된다.\n각 타입에 대한 확장 함수나 속성을 포함하는 코틀린 표준 라이브러리 파일들은 타입 이름 끝에 s를 붙인 파일 이름을 갖는다.\nStrings.kt도 그렇고 Sequences.kt, Ranges.kt, Maps.kt 코틀린은 확장 함수를 굉장히 많이 사용하여 핵심 API를 정의하고 있다.\n표준 라이브러리의 크기가 작으면서도 많은 기능을 제공한다.\n확장을 사용하면 함수나 속성을 하나만 정의하여 여러 타입에 같은 기능을 제공할 수 있으므로 메모리 효율 상승\n확장 함수 정의하기 확장 함수를 추가할 타입을 수신자 타입 이라고 한다. 그리고 이것을 지정해야 한다.\nthis 는 확장 함수가 호출된 ‘수신자 객체’를 뜻한다.\n클래스의 자식 클래스를 만들 수 없거나, 해당 클래스의 정의를 변경할 수 없을때(외부 라이브러리), 주로 확장을 사용한다.\n제네릭 확장 함수 1 2 3 fun \u0026lt;T\u0026gt; T.easyPrint() : T { // } 제네릭 확장 함수인 ‘easyPrint’는 어떤 타입에도 사용 가능하며 타입 정보도 유지된다. 확장 속성 확장 속성은 backing field를 갖지 않으므로 초기화할 수 없다. var 대신 val을 지정하고, 원하는 값을 반환하는 get 을 반드시 정의해야 한다. 속성에서 반환될 값을 지정해줘야 한다. backing field에 데이터가 저장된다. 1 2 val String.numVowels get() = count { \u0026#34;aeiouy\u0026#34;.contains(it) } infix 키워드 infix 키워드는 하나의 인자를 갖는 확장 함수와 클래스 함수에 모두 사용할 수 있다. infix(중위) 함수는 함수 호출 사이의 점(.) 과 괄호를 생략하게 해준다. 일반 함수 호출 처럼 호출도 가능 1 2 3 // 같은 함수 호출 null.printWithDefault(\u0026#34;기본 문자열\u0026#34;) null printWithDefault \u0026#34;기본 문자열\u0026#34; 함수형 프로그래밍 함수형 프로그래밍은 컬렉션을 사용하도록 설계된 고차 함수가 반환하는 데이터에 의존한다.\n고차 함수의 연쇄적 호출 함수 타입의 역할 =\u0026gt; 다른 함수를 값으로 정의해주거나, 인자로 받거나 반환하는 일급 함수을 지원 함수형 프로그램을 구성하는 함수의 유형에는 변환(transform), 필터(filter), 결합(combine) 이 있다.\n코틀린은 다중 프로그래밍 방식으로 상황에 따라, 객체지향과 함수형 프로그래밍을 혼합하여 코드를 작성 가능\n일급 함수 (First-Class Function)\n정의: 일급 함수는 다른 변수와 동일하게 다룰 수 있는 함수를 의미 변수화, 매개변수화, 반환 값으로 사용가능 val func: (Int) -\u0026gt; Int = { it * 2 } 람다(익명 함수, 이름 없는 함수) 형태를 띔 고차 함수 (Higher-Order Function)\n정의: 고차 함수는 \u0026lsquo;일급 함수\u0026rsquo;를 인자로 받거나 반환하는 함수를 의미 val doubled = numbers.map { it * 2 } // map은 고차 함수 변환 (transform) 변환 함수는 입력 컬렉션에 저장된 모든 요소를 읽는다.\n지정 변환 함수를 실행하여 컬렉션의 각 요소나 항목을 변환한 후, 변경된 ‘새로운 컬렉션’을 반환한다.\n입력 컬렉션은 변경되지 않는다. 임시로 새로운 객체 생성 후, 다음 연쇄 호출된 함수로 넘김 map, flatMap\n제네릭 타입 매개변수를 사용함으로 인자의 타입과 반환 타입을 다르게 처리할 수 있다. \u0026lt;T, R\u0026gt; Iterable\u0026lt;T\u0026gt;.map(transform: (T) -\u0026gt; R): List\u0026lt;R\u0026gt;\nflatMap 함수는 인자로 전달된 변환 함수의 결과로 산출된 모든 요소를 하나의 컬렉션으로 생성하여 반환한다.\nlistOf( listOf(1,2,3), listOf(4,5,6) ).flatMap { it } // [1,2,3,4,5,6] 필터 (filter) 필터 함수는 컬렉션의 각 요소를 검사하고, true or false를 반환하는 술어 함수를 인자로 받는다.\nfilter 하나\ntrue를 반환하는 요소만 결과 컬렉션에 해당 요소가 추가 된다.\n결합 (combine) 서로 다른 컬렉션 인자로 받아서 모든 요소들이 합쳐진 새로운 컬렉션을 생성한다\nzip, fold\nfold : 최초 누적값을 인자로 받으며, 이 값은 각 요소에 대해 호출되는 익명 함수의 결과값으로 변경된다.\n왜 함수형 프로그래밍일까? 처리 중간에 값을 축적하는 변수들이 내부적으로 정의되므로, 상태를 보존하는 변수들을 줄일 수 있다.\n자동으로 축적 변수에 추가되므로, 코드 에러 발생 위험이 줄어든다.\nSide Effect 제거, 불변성 증가, 테스트 용이성 향상 새로운 연산이 필요하면, 함수의 연쇄 호출에 추가하면 된다.\n시퀀스 (sequence) 컬렉션 타입들은 eager collection( 조기 컬렉션 ) 이라고 한다.\n인스턴스가 생성될 때는 자신이 포함하는 요소나 항목이 추가되므로 바로 사용될 수 있기 때문이다. 지연 컬렉션(lazy collection)라는 내장된 타입 : sequence, 필요할 때만 값이 생성된다.\n시퀀스를 사용할 때는 새로운 값이 요청될 때마다 참조되는 반복자 함수를 정의한다.\n함수형 프로그래밍에는 보통, 새로운 컬렉션을 자주 생성해야 한다.\n그러나 시퀀스를 사용하면 대형 컬렉션에 사용할 수 있는 매커니즘을 제공한다.\n시퀀스로 검사할 항목개수의 상한값을 정의할 필요가 없기 때문이다. 1 2 3 val oneThousandPrimes = generatesequence(3) { value -\u0026gt; value + 1 }.filter { it.isPrime() }.take(1000) 그러나 수십만 개의 요소를 가질 정도로 컬렉션이 커지면 컬렉션 타입을 변경하는 데따른 성능 향상이 중요해질 수 있다.\n이 경우에는 asSequence 함수를 사용해서 List를 시퀀스로 쉽게 변환할 수 있다. ","permalink":"https://2taezeat.github.io/posts/dev/kotlin-%EC%A0%95%EB%A6%AC-2/","summary":"Kotlin 다시 보기 (2) ‘빅 너드 랜치의 코틀린 프로그래밍’ 을 읽고 정리\n인터페이스와 추상 클래스 abstact 함수(추상 함수) : 함수의 헤더만 선언하고 몸체(Body)의 구현 코드가 없는 함수\n객체간의 상속 관계가 없으면서, 주로 공통적인 속성이나 행동을 갖는 경우 : 인터페이스\n객체간의 상속 관계가 있으면서, 주로 인스턴스 생성이 필요 없는 부모 클래스가 필요한 경우 : 추상 클래스\n인터페이스 구현하기 인터페이스는 무엇을 해야 하는지 정의한 것이므로, 클래스로 구현(implement) 해야 한다.\n해당 인터페이스를 구현하는 클래스를 정의(구현)한 후에 이 클래스에서 인터페이스에 명시된 속성과 함수의 구현 코드를 제공하게 한다.","title":"Kotlin 정리 (2)"},{"content":"Kotlin 다시 보기 (1) ‘빅 너드 랜치의 코틀린 프로그래밍’ 을 읽고 정리\n타입 코틀린 타입 특징 정적 타입 시스템\n소스 코드에 정의된 타입을 컴파일러가 알고 있다. 프로그램을 컴파일하기 전에 타입 체킹 : 정적 타입 체킹\nbuilt-in, 내장 타입 String\nChar\nBoolean\nInt\nDouble\nList - 컬렉션 타입\nSet - 컬렉션 타입\nMap - 컬렉션 타입\n변수 val : read-only, 변경 불가능, 읽기 전용 var : 값이 변경 될 수 있음, writeable 쓰기 가능, 가변성 타입 추론 코틀린 컴파일러가 타입을 추론 해줌 따라서, 타입을 생략 가능, 컴파일러가 소스 코드의 타입을 알고 있음 코틀린은 기본 타입을 포함해서, 모든 타입이 객체다. 코틀린 컴파일러가 자바의 기본 타입과 가장 유사한 것과 매핑 컴파일 시점 상수(constant) val 변수는 상수(constant) 가 아니다. const val MAX_LIMIT = 50000 상수는 프로그램 실행 전에 생성 및 초기화 됨 초기화된 값을 절대로 변경하지 않는 값 프로그램 실행 전 컴파일러가 알 수 있어야 함으로, \u0026lsquo;built-in 타입\u0026rsquo; 중 하나가 되어야 함 String, Int, Double, Float, Boolean, Char 모든 함수 외부에 정의 되어야 함, 컴파일 될때 값이 지정되야 함 상수와 달리, 변수들은 runtime에 생성되어 값이 지정된다. 코틀린의 자바 기본 타입 자바는 참조 타입과 기본 타입 2개가 존재\n기본 타입: 내장, 소문자\nint 참조 타입: 별도의 소스 코드 파일로 정의, Ex) 클래스, 항상 대문자\nInterger 모든 기본 타입은 그것과 대응되는 참조 타입이 있다. (역은 불가)\n기본 타입이 참조 타입보다 성능이 좋음\n기본 타입 배열(int[], byte[], boolean[])\n자바와 달리 코틀린은 참조 타입만 제공 (int가 아닌 Int만 제공) → 선택지가 하나로 됨, 코드 쉽게 작성 가능\n기본(primitive, 원시) 타입도 참조 타입(reference) 으로 사용\n코틀린 컴파일러는 가능한 한 자바 바이트코드의 기본(primitive) 타입을 사용한다. ( 더 좋은 성능을 내기에 )\n코틀린은 자바와 달리 원시 타입(Primitive Type) 과 참조 타입(Reference Type) 을 엄격하게 구분하지 않는다.\nNullable type(ex. Int?)은 자바의 Wrapper Class(Interger)로 컴파일된다.\n원시, 기본 타입, primitive 값을 직접 저장하는 데이터 타입입니다. 종류 정수 타입: Byte, Short, Int, Long 부동 소수점 타입: Float, Double 문자 타입: Char 불리언 타입: Boolean 특징 컴파일 시 자바의 기본 타입으로 변환됩니다. (예: Int -\u0026gt; int) 숫자 타입은 객체처럼 사용할 수 있습니다. (박싱/언박싱 자동 처리) 기본형을 참조형으로 변환: 이 기능을 박싱(boxing) 오토박싱(Autoboxing)은 Java 컴파일러가 원시 타입과 해당 객체 래퍼 클래스 간에 수행하는 자동 변환을 말한다. (예시: int =\u0026gt; Integer) 참조 타입, reference 객체의 메모리 주소를 저장하는 데이터 타입입니다. 종류 클래스 (Class) 인터페이스 (Interface) 배열 (Arrays) 문자열 (String) 컬렉션 (Collection) 기타 객체 타입 특징 기본 타입 (Primitive Type) 참조 타입 (Reference Type) 메모리 할당 JVM의 스택(Stack) 영역에 직접 값 할당 JVM의 힙(Heap) 영역에 객체 생성 후 스택에 참조 값 저장 값 표현 실제 값 (정수, 실수, 문자, 논리 값 등) 객체의 메모리 주소 (참조 값) 크기 고정된 크기 (타입별로 정의됨) 가변적인 크기 (객체의 상태에 따라 달라짐) 연산 값 자체를 이용한 연산 참조 값을 이용한 연산 (객체의 메서드 호출 등) 비교 == 연산자로 값 비교 == 연산자로 참조 값 비교, .equals() 메서드로 객체 내용 비교 제네릭 사용 불가 사용 가능 종류 byte, short, int, long, float, double, boolean, char 클래스, 인터페이스, 배열, 열거형(enum), 문자열 등 메모리 사용량 적음 많음 속도 스택에서 값을 직접 사용, 빠름 스택에 저장된 참조 값을 통해 힙에 있는 객체에 접근, 느림 GC 없음 있음 OOP 불가 가능 조건문과 조건식 문과 식 문(Statement): 프로그램의 실행 흐름을 제어하는 명령어 또는 명령어들의 집합입니다.\n식(Expression): 값을 생성하는 코드 조각, 값을 반환\n식은 문의 일부가 될 수 있다.\n특징 문 (Statement) 식 (Expression) 값 생성 X O 실행 결과 반환 X O 상태 변경 O X 세미콜론(;) O (일반적으로) X 예시 int x = 10 x + 5 조건 표현식 (conditional expression) if/else 문(Statement) 대신 조건 표현식 을 사용할 수 있다.\n식(Expression)은 값을 반환한다.\n1 2 3 4 5 6 7 8 9 10 11 val tmp1 = if () { \u0026#34;yes\u0026#34; } else { \u0026#34;no\u0026#34; } val tmp2 = when (para) { 100 -\u0026gt; \u0026#34;1\u0026#34; in 1..90 -\u0026gt; \u0026#34;2\u0026#34; else -\u0026gt; \u0026#34;3\u0026#34; } when 문\nelse 없어도 상관 없음 when 표현식\nelse 가 꼭 있는지 컴파일러가 검증 결과를 반환하기때문 간결하고 다양하게 로직을 나타냄 when\n임의의 조건들을 검사할 수 있다 풀 스루가 아님 Java switch 문\n값만 검사 풀 스루 (break 없으면, 아래의 조건들도 검사) 함수 기본적으로 가시성 제한자가 public\n함수의 매개변수(===인자) 는 var이 아닌 val 이다.\n함수 내에 있는 지역 범수는 함수 범위에만 존재, 함수가 return 되면 소멸된다. (매개변수도 마찬가지)\n매개변수 또한 함수 종료시 소멸됨 파일 수준 변수는 프로젝트 어디서든 사용 가능\n자바 클래스의 static 메서드가 된다, ~.kt 파일을 Java byteCode(.class)를 decompile(역컴파일)로 확인 가능 파일 수준 변수는 초깃값이 지정되어야 한다. 아니면 컴파일 에러\n기본 인자 ( default argument ) 지원\n함수 인자가 기본값을 가짐 단일 표현식, 함수 대입 연산자 = 으로 정의\noverload 함수들은 컴파일러가 함수 호출시에 전달되는 인자의 타입과 갯수로 무슨 함수인지 알 수 있다.\nUnit 함수 아무 값도 return 하지 않는 함수 타입\nvoid 로는 제네릭 함수 를 구현할 방법이 없음, Unit 으로 해결\nvoid는 타입이 아니며, 타입 정보가 의미가 없으므로, 생략해라 라는 의미 Unit으로 함수의 반환 타입을 나타냄 =\u0026gt; 제네릭 함수에도 사용 가능\nNothing 타입 함수의 실행이 끝나더라도, 호출 코드로 제어가 복귀되지 않는다 의도적으로 exception 예외를 발생시킬 때 사용 public inline fun TODO(): Nothing = throw NotImplementedError() 컴파일러는 이 TODO 코드를 에러로 처리하지 않는다. 제어가 복귀되지 않아서, 컴파일러가 TODO 코드의 다음 코드는 절대 실행되지 않는 것을 알게됨 자바의 파일 수준 함수 코틀린의 파일 수준 함수는 자바 클래스의 static 메서드가 된다. 코틀린 파일 이름의 Kt를 붙임 Game.kt =\u0026gt; public final class GameKt 함수 Overloading 이름은 같지만 매개변수의 개수가 타입이 다른 여러 개의 함수로 구현하는 것 1 2 3 4 5 6 7 8 9 fun performCombat() { //... } fun performcombat (eneryName: String) { //... } fun performcombat (enemyName : string, isBlessed: Boolean) { // ... } 코틀린 컴파일러는 함수 호출시에 전달되는 인자의 개수와 타입의 일치되는 것을 알기 때문에 어떤 오버로딩 함수를 실행할지 알게됨 익명 함수와 함수 타입 익명 함수 말그대로, 이름이 없는 함수\n익명 함수 == 람다(lambda)\n다른 함수의 인자와 반환 가능\n익명 함수도 타입을 가질 수 있고, 이것을 함수 타입 이라고 한다\n함수의 타입을 컴파일러에게 알려 준다. 익명 함수를 변수화 할 수 있다.\n익명 함수는 익명 클래스 인스턴스로 생성된다.\n암시적 반환\n암시적으로 or 자동으로 함수 정의의 마지막 코드 결과를 반환한다. 람다에서 return 키워드는 사용이 금지되어 있음 어디로 복귀 되어야 하는지, 컴파일러는 알 수 없기 때문, 어디에서든 람다가 호출 될 수 있기 때문 하나의 인자만 받는 익명 함수의 매개변수 이름을 지정하는 대신 it 키워드를 사용할 수 있다.\n함수 타입 역시 타입 추론(type inference) 지원\n익명 함수가 값으로 지정되면 타입을 필수로 지정하지 않아된다. (당연히 해도 됨) 람다 (lambda) 익명 함수를 람다(lambda)라 부름 람다 표현식, 람다식: 익명 함수 정의 익명 함수의 반환 결과 : 람다 결과(lambda result) 어떤 함수에서 마지막 매개변수로 함수 타입을 받을때는 ()를 생략할 수 있다. \u0026quot;Mississippi\u0026quot;.count ({ it == 's' }) \u0026quot;Mississippi\u0026quot;.count { it == 's' } { it == 's' } 가 람다, 익명 함수 이다. 이것은 람다가 마지막 인자로 함수에 전달될 때만 가능, 따라서 함수 타입 매개변수를 마지막 매개변수로 선언하는 것이 좋다. inline 함수로 만들기 람다(익명 함수) 는 JVM에서 객체로 생성\n메모리 부담 인라인을 사용하면 람다의 객체 사용과 변수의 메모리 할당을 JVM이 하지 않아도 된다.\ninline 키워드를 추가하면, 람다가 객체로 전달 되지 않는다.\n컴파일러가 바이트 코드를 생성할 때, 람다 코드가 포함된 함수 몸체의 전체 코드를 복사한후, 함수를 호출하는 곧에 붙여 넣기 하여 교체 하기 때문\n하지만 재귀 함수는 무수히 많이 복사 됨으로, 코틀린 컴파일러는 재귀함수를 단순히 인라인 처리하지 않고, 루프 형태로 변경한다.\n함수 참조 람다를 사용해서 다른 함수의 인자로 함수를 전달하는 방법도 있지만, 다른 방법으로 함수 참조를 인자로 전달 함수 참조를 얻을 때는 함수 이름 앞에 :: 연산자를 사용한다. 매개변수에 적합한 이름 있는 함수가 있다면 람다 대신 함수 참조를 사용할 수 있다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 fun runsimulation(playerName: String, greetingFunction: (String, Int) -\u0026gt; string) { val numBuildings = (1.3).shuffled().last() println (greetingFunction(playerName, numButlatngs)) } fun printConstructionCost(numBuildings: Int) { vaL cost = 500 println(\u0026#34;건축 비용: sfcost * numBuildings}\u0026#34;) } fun main(args: Array\u0026lt;string\u0026gt;) { runsimulation(\u0026#34;김선달\u0026#34;, ::printConstructionCost) { playerName, numBuildings -\u0026gt; val currentYear = 2019 \u0026#34;simvitlage 방문을 환영합니다, SplayerName! (copyright scurrentyear)\u0026#34; } } 반환 타입으로 함수 타입 사용하기 코틀린의 람다는 클로저(closure, close over) 이다.\n다른 함수에 포함한 함수(예를 들어, 람다) 에서 자신을 포함하는 함수의 매개변수와 변수를 사용할 수 있는 것을 말한다.\n람다(익명 함수)가 외부 변수의 참조를 갖는다.\n따라서 람다식은 자신이 포함된 외부 함수에 선언된 매개변수와 변수를 그냥 사용할 수 있다.\n외부 함수에 val 변수는 람다식에서 그 값이 바로 저장\nvar은 별도의 객체로 저장되며, 그 객체의 참조값이 람다식 코드에 저장되어 값을 변경할 때 사용\n다른 함수를 인자로 받거나 반환하는 함수를 고차 함수(higher-order function) 이라고 한다.\nfilter, map 등 코틀린에서는 익명 함수가 자신의 범위 밖에 정의된 변수를 변경하고 참조할 수 있다.\n람다가 외부의 변수를 포획한다는 의미 람다 vs 익명 내부 클래스 함수 타입을 사용하면 진부한 코드가 줄어들고 유연성이 증가한다.\n예를 들어, 자바 8과 같이 함수 타입을 제공하지 않는 언어 자바 8은 객체지향 프로그래밍과 람다 표현식을 모두 지원한다.\n그러나 함수의 매개변수나 변수 에 함수를 정의할 수 있는 기능이 없다. (함수의 변수화가 불가)\n대신에 자바는 익명 내부 클래스(anonymous inner cass) 를 제공\n이것은 단일 메서드(method)를 구현하기 위해 다른 클래스에 정의된 이름이 없는 클래스다.\n그리고 람다처럼 익명 내부 클래스를 인스턴스로 생성하여 전달할 수 있다.\n자바에서는 람다를 정의하는 함수를 나타내기 위해(변수화) 이름이 있는 타입(인터페이스나 클래스)의 정의가 추가로 필요하다\nnull 안전과 예외 코틀린의 null 처리 개요 nullable / non-nullable\n자바는 어떤 타입의 변수도 null 값을 가질 수 있다.\n코틀린은 non-nullable 변수는 null을 가질 수 없다. 따라서 런타임이 아닌 컴파일 시점에 방지 할 수 있다.\nnull이 필요 없다면 non-nullable 타입을 사용하는 것이 가장 안전하다.\n가능한 한, non-nullable 타입을 사용하자 에러 검출 시점(컴파일 vs 런타임) 코틀린은 컴파일러라는 특별한 프로그램에 의해, 기계어로 변환되는 컴파일 언어 이다. 런타임 에러는 프로그램이 실행된 이후에 발생된 에러임으로, 사전에 알려 줄 수 없다. null 안전 처리 안전 호출 연산자 → ?.\n?.는 객체가 null일 경우에는 null을 반환하고, 그렇지 않으면 해당 객체의 속성이나 메서드를 호출 non-null 단언(assertion) 연산자 → !!\nnull이면 런타임에 NPE 예외 발생 컴파일러가 null 발생을 미리 알 수 없는 상황이 생길 수 있을 때 사용된다. 프로그램의 오류가능성을 runtime에 예측하는 것은 거의 불가능하니, 조심해서 사용해야 함 값이 null인지 if 문 검사\n엘비스 연산자(null 복합 연산자) → ?:\nval beverageServed: String = beverage ?: \u0026quot;맥주\u0026quot;\n엘비스 연산자는 null이 될 수 있는 값을 바로잡는 데 사용될 수 있다.\n자바에서 @NotNull 어노테이션 → null 일 수 없다.\n코틀린 소스 코드가 컴파일되어 JVM의 자바 코드로 생성될 때, checkParameterIsNotNull 이라는 메서드가 사용됨. 자바로 역컴파일된 바이트코드를 보면 알 수 있다. 예외 던지기, Exception Throw 예외는 프로그램이 잘못되었다는 것을 나타낼때 사용 예외가 발생할 때는 그것을 처리해야 하며, 그렇지 않으면 실행이 중단(crash) 된다. 미처리 예외(unhandled exception): 처리되지 않은 예외 1 2 3 fun proficiencyCheck(swordsJuggling: Int?) { swordsJuggling ?: throw IllegalStateException(\u0026#34;플레이어가 저글링을 할 수 없음!) } throw : 예외를 발생 시킨다. === 예외를 던진다\n실행전에 처리되어야 하는 문제를 알려 주기 위해 예외를 던진다.\nCrash 되는 이유를 명확히 알 수 있음\nstackTrace, message 예시에서, swordsJuggling 변수가 null 이되는 경우가 생긴다면, 개발하는 시점에 알 수 있는 가능성이 커진다.\n커스텀 예외 : 예외를 상속 받은 클래스, 코드 유연성 증가, 재사용성 증가, 에러 메서지 출력 가능\n예외 처리 가이드 논리 오류: 프로그램이 강제 종료되지도 않고 의도대로 동작하지도 않는 상황\n예외가 던져지지 않으므로 런타임에 발생하는 RuntimeException과는 다른 상황\n기존에는 예외가 던져지지 않았기에, 이런 경우에 예외를 던져보자 기본적으로 일단, 최대한 논리 오류가 태초에 발생 하지 않도록 만들어야 함\n그럼에도 불구하고, 논리 오류가 발생하는 경우에 예외를 던져야 함\n논리 오류는 에러 원인을 예측하기 어렵기 때문에 디버깅이 굉장히 어렵다.\nEx) 양수여야 하는 값이 음수인 경우\n논리 오류(\u0026lsquo;예외적인 상황\u0026rsquo;) 일 때만 예외를 던지세요.\n논리 오류가 아니면 예외를 던지지 말고, null을 반환하세요.\n실패하는 경우가 복잡해서 null로 처리할 수 없으면 sealed class를 반환하세요.\n성공, 실패들을 모두 sealed class로 선언해보세요. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class IdentityNumber(private val numbers: List\u0026lt;Int\u0026gt;) { companion object { fun from(front: List\u0026lt;Int\u0026gt;, back: List\u0026lt;Int\u0026gt;): IdentityNumberResult = when { front.size != 6 -\u0026gt; IdentityNumberResult.InvalidFrontSize back.size != 7 -\u0026gt; IdentityNumberResult.InvalidBackSize else -\u0026gt; IdentityNumberResult.Success(IdentityNumber(front + back)) } } } sealed class IdentityNumberResult { data class Success(val identityNumber: IdentityNumber) : IdentityNumberResult() object InvalidFrontSize : IdentityNumberResult() object InvalidBackSize : IdentityNumberResult() } 일반적인 코틀린 코드에서 try-catch, runCatching()를 사용하지 마세요.\n예외는 반드시 예외적인 상황에서만 던져야 합니다.\n\u0026lsquo;논리 오류일 때만 예외를 던지세요.\u0026rsquo;\n논리 오류일 때 던지는 예외를 포함해서, 프로그램 전체적으로 발생하는 예외들을 전역적으로 처리해주는 예외 처리기를 통해 보고해야 합니다.\n예시) 예상 가능한 네트워크 예외 처리에 대한, CoroutineExceptionHandler 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class PositiveNumber private constructor(val value: Int) { companion object { fun from(value: Int): PositiveNumber? { if (value \u0026lt;= 0) return null return PositiveNumber(value) } }} class PositiveNumberTest { @Test fun `음수로는 만들 수 없다`() { // when val actual = PositiveNumber.from(-1) // then assertNull(actual) }} 생성자를 사용할 수 없도록 private으로 숨기고 from() 팩토리 함수를 추가하였습니다.\n이렇게 하면 외부에서는 반드시 from() 함수를 통해서만 PositiveNumber를 만들어야 하고 만약 음수라면 null이 반환됩니다. 이 방식에서는 음수로 양수(PositiveNumber)를 만든다는 논리 오류 자체가 발생할 수가 없습니다. 다음 링크의 글을 참고\nhttps://medium.com/@galcyurio/kotlin%EC%97%90%EC%84%9C%EC%9D%98-%EC%98%88%EC%99%B8-%EC%B2%98%EB%A6%AC-%EB%B0%A9%EB%B2%95-48a5cd94a4e6 예외 처리 try / catch\ntry문에서는 예외가 발생될 수 있는 코드를 넣는다.\ncatch문은 예외가 생길 때만 실행\ncatch 문에서는 처리할 예외의 특정 타입을 인자로 받는다\n코틀린에서의 예외는 unchecked 예외,\n예외를 생길 수 있는 모든 코드를 컴파일러가 try / catch문으로 처리하도록 강제하지 않는다. (자바는 checked, unchecked가 구분되어 있다.) 전제 조건 전제 조건 함수: 일부 코드가 실행되기 전에 충족되어야 하는 전제 조건을 정의한 함수 checkNotNull, require, requireNotNull, error, assert\n안전하게 코드 작성 가능\nnull 무엇이 좋을까? 값을 지정하지 않고 변수를 초기화 할 수 있다.\nnull으로 상태(State) 를 표시함 변수의 초깃값에 많이 사용 NPE를 피하는 방법\nempty 값을 통해 더 좋고 안전한 코드 초기화를 할 수 있다.\nnull 불가 타입으로 지정하고, 빈 문자열(\u0026quot;\u0026quot;)로 초기화 null이 될 수 있다는 것을 인정하고, null 가능 타입의 처리 방법들 을 사용\nvar personName: String? = \u0026quot;\u0026quot; checked 예외와 unchecked 예외 코틀린에서는 모든 예외가 unchecked 예외다.\n즉, 예외가 생길 수 있는 모든 코드를 우리가 try / catch로 반드시 처리하도록 강요하지 않음 자바는 checked와 unchecked 예외 타입이 구분되어 있다.\nchecked 예외의 경우, 예외 처리를 했는지를 컴파일러가 검증함 대부분의 checked 예외(예를 들어, 파일을 저장, IOException) 는 발생했더라도 우리가 특별히 할 것이 없다.\n따라서 개발자들이 해당 예외의 catch 블록 안에 처리 코드를 작성하지 않는 경우가 있다\n예를 들어, catch (e: IOException) { } 해당 checked 예외가 무시되고(경보가 울렸는데 무시하는 것과 같다) 프로그램은 정상적으로 수행된다. 원인을 찾기 어려워짐\nchecked 예외는 문제를 해결하기 보다는 오히려 더 많은 문제를 야기할 수 있다.\n코드 중복, 어려운 에러 복구 로직, 예외 무시 문자열 해체 선언 (destructing declaration) val (type, name, price) = menuData.split(',')\n문자열은 불변이다. 코틀린의 모든 문자열(String 타입)은 val or var 중 어느 것으로 정의되든 자바처럼 불변이다. replace 처럼 값을 변경하는 것 처럼 보이는 어떤 함수도 실제로는 새로운 문자열로 변경값을 생성한다. 문자열 비교 참조 동등 : 특정 타입 인스턴스의 참조를 똑같이 갖는지 검사한다. heap 메모리 영역에 같은 객체를 참조하는지 검사한다. (=== 연산자) 자바에서는 == 연산자가 두 문자열의 참조를 비교하므로 코틀린과 다르다. 자바에서 문자열의 값을 비교할때는 equals 메서드를 사용해야 한다. 비교 연산 Kotlin Java 동등성(Equality, Structural equality) == equals 동일성(Identify, Referential equality) === == 자바, 코틀린 모두 원시 타입인 경우 동등성 비교는 == 으로 같은 연산자를 사용\n참조 타입일 때만, 달라짐\n구조적 동등성, Equality 비교 (==, !=)\n기본 타입인 경우: 값 비교, 값의 동등성 비교\n참조 타입인 경우: equals() 로 객체의 내용 비교\n==는 내부적으로 equals를 호출한다. (연산자 오버라이딩 기능) 참조 동등성, Identify 비교 (===, !==))\n객체의 메모리 주소를 비교\n코틀린은 자바에는 없는 ===연산자를 지원한다.\n즉, 자바의 주소 값 비교인 ==와 코틀린의 ===가 동일한 역할을 한다.\n1 2 3 4 5 6 7 8 9 10 int a = 1 // 원시 타입 int b = 2 int c = 1 System.out.println(a == b) // false System.out.println(a == c) // true String a = \u0026#34;hi\u0026#34; // 주소값 : 1번지, 참조 타입 String b = \u0026#34;hi\u0026#34; // 주소값 : 2번지 System.out.println(a == b) // false, Idenrify 비교 System.out.println(a.equals(b)) // true, Equality 비교 1 2 3 4 5 val a: String = \u0026#34;hi\u0026#34; val b: String = \u0026#34;hi\u0026#34; println(a === b) // false, Idenrify 비교 println(a == b) // true, Equality 비교 숫자 Byte (8비트)\nShort (16비트)\nInt (32비트)\nLong (64비트)\nFloat (32비트)\nDouble (64비트)\n숫자에는 정수와 소수가 있다.\n문자열을 숫자 타입으로 변환하기 toFloat, toDouble, toLong, toIntOrNull val gold: Int = \u0026quot;5.91\u0026quot;.toIntOrNull ?: 0 소수 소수점값을 구하려면 코틀린이 부동 소수점 연산을 해야 한다.\n위치가 달라질 수 있는 소수점을 의미하는 부동 소수점은 실수의 근사치이며, 정밀도와 성능 모두를 지원하기 위해 근사치를 사용한다.\n%.2f.format(~~~) : 소수점 이하 두 자리 형식\nDouble 타입에 toInt 를 호출하면, 소수점 이하 값이 절삭되어 정수로 변환된다. (4.91.toInt → 4) 표준 함수 (범위 지정 함수) 코틀린의 표준 함수(범위 지정 함수) 는 내부적으로 확장 함수이며,\n확장 함수를 실행하는 주체를 수신자 또는 수신자 객체, 수신 객체, receiver 라고 한다.\n표준 함수(범위 지정 함수) 는 람다를 인자로 받아 동작한다.\n인자로 받은 block 변수(함수)를 실행 수신 객체라는 용어는 Kotlin의 확장 함수에서 등장한다.\n확장 함수에서 this는 확장된 클래스의 객체, 즉 확장 함수를 사용하는 그 객체가 된다.\n그 객체가 바로 수신 객체(Receiver object)이고,\n확장할 클래스가 수신 객체 타입(Receiver Type)\n수신: ‘(수신) 객체가 코드를 받는다.’\n수신 객체 지정 람다 (Lambdas with Receivers) 수신 객체 지정 람다는 람다에 확장 함수 처럼 수신 객체를 사용한 것이다. T.() -\u0026gt; R\n확장 함수에서 수신 객체를 사용하여 블록 내에 객체를 전달했듯이,\n수신 객체 지정 람다(Lambdas with Receivers) 또한 수신 객체를 이용하여 객체를 전달한다. 따라서 수신 객체 지정 람다에서는 수신 객체를 this로 대신할 수 있다.\n또한 this를 생략하고 해당 객체의 멤버에 바로 접근이 가능하다.\n반면 일반 람다는 객체를 인자(파라미터) 로 전달한다. (T) -\u0026gt; R\t람다의 매개변수가 하나뿐이고, 컴파일러가 타입을 추론할 수 있을 때 객체는 기본 매개변수인 it으로 받을 수 있다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 inline fun \u0026lt;T\u0026gt; T.apply(block: T.() -\u0026gt; Unit): T { block() return this } inline fun \u0026lt;T, R\u0026gt; T.run(block: T.() -\u0026gt; R): R { return block() } inline fun \u0026lt;T, R\u0026gt; with(receiver: T, block: T.() -\u0026gt; R): R { return receiver.block() } inline fun \u0026lt;T\u0026gt; T.also(block: (T) -\u0026gt; Unit): T { block(this) return this } inline fun \u0026lt;T, R\u0026gt; T.let(block: (T) -\u0026gt; R): R { return block(this) } apply 수신자 객체의 참조 가능\nthis로 참조, this 생략 가능 람다의 실행이 끝나면 현재의 수신자 객체가 반환된다.\nrun apply와 다르게 run은 수신자 객체를 반환하지 않는다. 람다의 결과, 마지막 코드 줄의 실행 결과를 반환한다. 함수 호출이 여러 개 있을때 함수 중첩 보다 run을 사용하면 편리하다. \u0026quot;~~~\u0026quot;.run(::myFun) = myFun(\u0026quot;~~~\u0026quot;) with run 과 동일하게 동작하지만 호출 방식이 다르다.\n수신자 객체를 첫 번째 매개변수의 인자로 받는다.\nwith 대신 run을 사용할 것을 권한다.\n잘 사용 안됨 also let 처럼 자신을 호출한 수신자 객체를 람다의 인자로 전달한다. let과 달리, 람다의 결과를 반환하지 않고, 수신자 객체를 반환한다. let 수신 객체를 람다의 인자(파라미터) 로 전달\n전달된 람다를 실행한 후, 마지막 코드 줄의 실행 결과를 반환해준다.\nnull check 후 코드를 실행해야 하는 경우\n안전 호출 연산자 → ?. \u0026lsquo;?.let\u0026rsquo;을 사용 하게 되면 let의 block은 수신객체가 null이 아닐 때만 수행된다. 따라서 let block에서의 it의 타입은 nullable하지 않은 타입이 된다. (스마트 캐스팅) nullable한 수신객체를 다른 타입의 변수로 변환해야 하는경우\n1 2 3 4 var person: Person? = null val isReserved = person?.let { it: Person -\u0026gt; reserveMovie(it) } List, Set, Map 컬렉션은 연관된 값들을 모아서 저장하고 사용하는 자료구조 List, Map, Set이 있다. 컬렉션에 저장된 각각의 데이터를 element (요소) 라고 한다. 코틀린에서는 mutable(변경 가능한) 타입과 read-only(읽기 전용) 타입이 있다. 코틀린 컬렉션은 가변성 개념을 제공하면서, 강력한 기능을 제공 List List\u0026lt;myType\u0026gt; 에서\nmyType: 매개변수화 타입, 요소의 타입이 myType이라는 것을 알려줌. List은 제네릭 타입 이다. ⇒ List는 어떤 타입의 데이터도 저장할 수 있다\nlistOf 함수: 컬렉션 자체를 생성 하고, 데이터 추가 하는 일을 둘 다 하는 함수\n안전한 인덱스 사용 : getOrElse, 예외 대신 기본값을 반환 / getOrNull 와 :? 사용\ncontainsAll : 요소가 존재하는 지 한 번에 확인할때 사용\nList의 변경 가능 여부는 List의 타입에 의해 결정\n‘변경 가능(mutable)’ 은 저장된 요소를 변경할 수 있다는 것을 의미한다. List 타입은 read-only 이다. 변경 가능 ⇒ MutableList 타입을 사용해야 함, add, remove 사용 가능\ntoList \u0026lt;=\u0026gt; toMutableList 으로 상호 변경 가능\n반복 처리 in 키워드 : for 루프에서 반복 처리되는 객체를 나타낸다.\nitertation(반복 처리) 가능\nfor 루프로 요소의 이름을 지정하면, 코틀린 컴파일러가 타입을 알아서 처리 Iterable 타입은 반복 처리를 지원한다.\nList, Set, Map, IntRange 해체 선언 List는 또한, 맨 앞의 다섯 개 요소까지 변수로 해체 할 수 있는 기능을 제공한다. 해체를 원하는 않는 요소에 _(밑줄)을 사용해서 선택적으로 해체할 수도 있다. Set 수학의 집합처럼 요소가 고유한 것을 보장해 주는 컬렉션\n인덱스와 인덱스 연산자([])를 사용해서 요소를 처리할 수 없다.\nelementAt 함수를 사용해서 특정 인덱스의 요소를 요청 할 수 있다.\n\u0026lsquo;논리적\u0026rsquo;으로 인덱스처럼 접근\n한 번에 하나의 요소를 반복해서 읽는다. (반복 처리 가능, itertation)\n따라서, 인덱스 연산자 보다 느리다\n순서를 갖지 않는다.\n‘값’ 이 고유하다.\n인덱스로 접근하는 자료구조는 아님\nArray, 배열 타입 코틀린은 참조 타입밖에 없다. (컬렉션도 참조 타입)\n자바에서는 Array을 기본(원시) 타입으로 지원\n코틀린에서 기본 타입이 아닌 Arrays 라는 참조 타입으로 배열을 지원한다.\nval playerAges: IntArray = IntArrayOf(34, 23, 12) Kotlin에서 Arrays는 참조 타입이지만, 특별한 배열 타입을 통해 기본 타입 배열과 유사한 기능을 제공 내부적으로 원시 타입 값을 저장하여 메모리 사용량을 줄이고 성능을 향상 코틀린의 (특별한) 배열 타입(IntArray, ByteArray, BooleanArray) IntArray 타입은 자바의 기본 타입(배열 타입) 으로 컴파일 된다.\n코틀린 컬렉션을 자바의 기본 배열 타입으로 변환 가능\ntoIntArray val array1 = arrayOf(1, 2, 3) , val array2 = Array(5) { it }\n자바로 디컴파일 후 확인: @NotNull final Interger[] array1; val array1 = intarray(1, 2, 3) ,val array2 = IntArray(5) { it }\n자바로 디컴파일 후 확인: @NotNull final int[] array1; 1 2 3 4 5 6 7 8 9 10 11 // 일반 객체 배열 val numbers: Array\u0026lt;Int\u0026gt; = arrayOf(1, 2, 3) val strings: Array\u0026lt;String\u0026gt; = arrayOf(\u0026#34;hello\u0026#34;, \u0026#34;world\u0026#34;) // 기본 타입 배열 val intNumbers: IntArray = intArrayOf(1, 2, 3) val booleanValues: BooleanArray = booleanArrayOf(true, false, true) // 가변 배열 val mutableArray = Array(5) { 0 } // 0으로 초기화된 크기 5의 배열, Array\u0026lt;Int\u0026gt; 타입 mutableArray[0] = 1 읽기 전용 vs 변경 불가능 불변은 ‘변경 불가능’ 을 의미 따라서 코틀린 컬렉션은 ‘읽기 전용’이 더 어울림. 1 2 3 4 5 6 7 8 val x = listOf( mutableListOf(1, 2, 3) ) x[0].add(4) // x = list( mutableListOf(1, 2, 3, 4) ) var myList: List\u0026lt;Int\u0026gt; = listOf(1,2,3) (myList as MutableList)[2] = 1000 println(myList) // [1, 2, 1000] Map 키와 값의 쌍의 데이터 (entry 라고 한다.) iteration 반복 처리 지원 정수 인덱스 기반 처리 대신 키를 기반으로 데이터 처리 to 함수로 키와 값을 정의한다. getValue, [ ], getOrElse, getOrDefault ‘키’ 가 고유하다. Map이 Iterable을 직접 구현하지 않음 하지만, keys, values, entries 가 Iterable을 구현함 클래스 정의하기 클래스는 사물이나 개념을 추상화 한 프로그래밍 요소이다.\n속성(property)과 기능(function) 을 갖는다.\n행동(역할)과 데이터를 정의한다.\nOOP의 핵심 요소 default가 public\n인스턴스 생성하기 생성자(constructor) 를 호출하여 인스턴스를 생성한다. 함수 호출과 비슷 가시성 제한자 클래스 함수나 속성의 가시성을 제한 하는 개념을 OOP에서 정보은닉, 캡슐화라 한다.\npublic : 클래스 외부에서 클래스 요소 사용가능\nprivate : 클래스 내부에서만 요소 사용 가능\nprotected : 클래스 내부 or 클래스의 서브 클래스에서만 사용될 수 있다\ninternal : 클래스가 포함된 ‘모듈(module) ’에서 사용될 수 있다\n속성(프로퍼티, property) 프로퍼티는 클래스의 데이터 즉, 상태나 특성을 나타낸다.\n변수와 다르게 클래스 속성은 반드시 초깃값이 지정되어야 한다.\n인스턴스가 생성될 때 모든 속성이 값을 가져야 한다. 다른 함수나 프로그램에서 이 클래스의 속성에 접근할 수 도 있기 때문 속성(프로퍼티)의 getter와 setter 프로퍼티를 외부에서 사용할때, 코틀린은 자동으로 getter를 통해 가져오고, setter를 통해 값을 지정한다.\n정의한 각 속성에 대해 field와 getter or setter 가 생성된다.\ngetter 에서는 속성값을 읽는 방법이 명시된다.\n커스텀 getter, setter를 정의할 수 있다. ⇒ getter, setter를 overriding\n커스텀(override) 하지 않으면, 기본으로 생성되는 속성값을 있는 그대로 반환 및 지정 field 키워드는 프로퍼티에 대해 코틀린이 자동으로 관리해주는 backing field 를 참조한다.\nfield 키워드는 getter, setter에서만 사용할 수 있다.\nbacking field 는 getter, setter가 사용하는 프로퍼티의 데이터다.\ngetter는 backing field를 변경하지 않는다. setter는 backing field를 변경한다.\n프로퍼티는 외부에 노출시키되(public), setter는 노출시키지 않으려면 private set 으로 따로 정의도 가능하다.\n기본적으로 getter, setter 의 가시성은 속성 자체의 가시성과 일치 getter는 프로퍼티를 참조할 때 자동 호출\nsetter는 대입 연산자(ex. =)를 사용해서 속성에 값을 지정할 때 자동 호출\n1 2 3 4 5 var name = \u0026#34;tae\u0026#34; get() = field.capitialize() private set(value) { field = value.trim() } 산출 속성(computed property) 다른 속성이나 변수 등의 값을 사용해서 자신의 값을 산출하는 속성, backing field 생성하지 않음. 초깃값이나 기본값이 없다 1 2 3 4 class Dice() { val rolledValue get() = (1..6).shuffled().first() } 이런 경우에서도 볼 수 있듯, \u0026lsquo;변경 불가능\u0026rsquo; 보다 \u0026lsquo;읽기 전용\u0026rsquo; 이라는 표현이 더 적합 패키지 사용하기 Ex) com.myProject.presentation.music\n패키지(package) 는 폴더 처럼 비슷한 요소들을 분류하고 모아 놓은 것이다.\n프로그램에서 직접 패키지를 지정할 때는 package 키워드를 사용한다.\n지정된 .kt 파일이 컴파일되면, 생성된 바이트코드 파일(.clsas) 는 정의한 패키지 경로에 위치하게 된다.\n같은 패키지에 있는 클래스들은 기본적으로 같이 사용할 수 있다.\n단, 코틀린 표준 라이브러리의 모든 클래스나 함수 등은 import를 지정하지 않아도 바로 사용 가능 다른 패키지에 있는 클래스나 함수 등을 사용하려면 import 문을 사용해서 그것들의 위치를 컴파일러에게 알려주어야 한다.\n경합 상태(race condition) 1 2 3 4 5 6 7 8 9 10 11 12 class Weapon(val name: String) class Player { var weapon: Weapon? = Weapon(\u0026#34;Ebony Kris\u0026#34;) fun printweaponName() { if (weapon != null) { println(weapon.name) // Weapon 타입으로 스마트 캐스팅 할 수 없는 컴파일 에러 } } } fun main(args: Array\u0026lt;string\u0026gt;) { player().printWeaponName() } 컴파일러는 변수가 null이 아님이 if문 등으로 확인되더라도,\n경합 상태가 생길 수 있기 때문에(여러 개의 스레드로 실행될 가능성 존재) 스마트 캐스팅이 할 수 없고, 컴파일 에러를 알려준다. weapon의 값이 if로 확인된 시점과 println으로 weapon의 name을 출력하는 시점 사이에 weapon 이 null로 변경될 가능성이 여전히 있다. =\u0026gt; 스마트 캐스팅 불가\n1 2 3 4 5 6 class Player { // 해결법 var weapon: Weapon? = Weapon(\u0026#34;Ebony Kris\u0026#34;) fun printweaponName() { weapon?.also { print(it.name) } } } also를 사용하면 해결 가능 also 익명 함수 내에서만 존재하는 지역변수 it 으로 weapon 인스턴의 name 속성이 참조되기 때문 ?.로 null이 아님이 확인 되었고, it의 값은 프로그램의 다른 코드에서 변경불가능 함 컴파일러가 Weapon 타입으로 스마트 캐스팅 가능 패키지 가시성 자바는 기본적으로 패키지 가시성을 사용한다.\n같은 패키지에 있는 클래스에서만 사용 가능하다. 코틀린에서는 패키지 가시성이 없다.\n같은 패키지에 있는 클래스, 함수, 속성 등은 기본적으로 상호 사용가능하기 때문에 굳이 별도의 패키지 가시성을 가질 필요가 없기 때문이다. 모듈은 독자적으로 실행 및 테스트될 수 있는 프로그래밍 구성 단위\n코틀린은 internal 가시성을 지원한다. 자바는 지원하지 않음\n바이트코드 파일에서 internal은 public이 된다.\n초기화 클래스의 인스턴스를 생성하는 것은, 클래스에 정의된 속성을 구조로 갖는 객체를 메모리에 할당하는 것 기본 생성자 커스텀하지 않고, 자동으로 생성되는 기본 getter와 setter를 사용하는 속성의 경우에는,\n클래스 내부에 속성을 따로 정의하지 않고 기본 생성자에만 정의해도 된다. 기본 생성자에 정의된 변수는 클래스 속성과 생성자 매개변수 두 가지 역할을 하게 된다.\n기본 생성자에 속성을 정의할 때는 var, val을 추가해야 한다.\n1 2 3 4 5 6 7 class Player(_name: String, _health: Int) { val name = _name } class Player(private val name: String, var health: Int = 100) { } 보조 생성자 1 2 3 4 5 6 7 8 9 10 11 12 13 class Player(_name: string, val health: Int) { val race = \u0026#34;DWARF\u0026#34; val alignment: String init { require(health \u0026gt; 0, {\u0026#34;health는 양수여야 한다\u0026#34;}) println(\u0026#34;initializing player\u0026#34;) alignment =\u0026#34;GOOD\u0026#34; } constructor (_name: String) : this(_name, 100) { race = \u0026#34;The Shire\u0026#34;\u0026#39; } } 말 그대로, 기본 생성자에 정의된 속성을 다양하게 초기화하는 보조 역할을 수행\n보조 생성자에서는 클래스 속성(프로퍼티) 를 정의할 수 없다.\n속성은 기본 생성자 or 클래스 몸체에서 정의되어야 한다. this 키워드는 보조 생성자를 사용해서 생성되는 클래스 인스턴스의 기본 생성자를 뜻한다.\n초기화 블록 (init) 전제 조건 검사는 초기화 블록에서 주로 한다.\n생성자에 전달되는 인자가 적합한지 확인 require 문을 주로 사용 초기화 블록은 어떤 생성자가 호출되든 클래스 인스턴스가 생성될 때 마다 자동으로 호출되어 실행된다.\n속성을 초기화하는 코드가 복잡하다면, init 에 초기화 코드를 넣는 것도 가능하다.\n속성(프로퍼티) 초기화 속성(프로퍼티)은 정의된 타입으로 반드시 초기화되어야 한다. 초기화 순서 기본 생성자에 정의된 속성에 인자값 지정\n클래스 내부에 지정된 속성에 초깃값 저장\n초기화 블록(init) 실행\n보조 생성자 실행\n초기화 지연시키기 클래스 속성은 non-nullable 변수가, null이 아닌 값으로 초기화된 다는 것을 보장하기 때문에, 초기화는 중요하다.\n기본 타입(ex. Int) 이 아니고, 다른 객체를 참조하는 속성의 경우 \u0026lsquo;지연 초기화(lateinit)\u0026lsquo;가 가능하다.\n다른 객체를 참조하는 속성의 경우, 생성자가 호출되는 방법과 시점은 우리가 제어할 수 없는 경우가 있기 때문에 Ex) 외부 프레임워크에서 초기화되는 경우, 안드로이드의 뷰 속성 lateinit 키워드는 개발자가 해당 속성을 사용하기 전에 초기화해야 된다는 것을 의미한다.\n개발자가 스스로 책임지고, 해당 속성을 사용하기 전에 초기화해야 된다는 것을 뜻함\n\u0026lsquo;지연 초기화\u0026rsquo;\nisInitialized 함수는 속성이 초기화 되었는지 검사해준다.\nif (::alignment.isInitialized) 속성의 값이 아닌 참조를 전달해야 함으로 :: 를 붙임 클래스 인스턴스의 생성 시점에서 속성을 초기화 할 수 없다면, 지연 초기화를 사용해야 하고, lateinit 키워드를 사용해서 이를 나타낸다.\nlateinit\n기본 타입이 아니여야 함 다른 타입의 객체 참조 때문에 var non-nullable이어야 한다. 커스텀 getter, setter 정의 불가하고, 기본으로 생성되는 getter, setter 사용해야 함 lateinit 대신 nullable 타입으로 변수 선언하고, 변수에 null으로 초기화도 가능하긴 한데, null 체크를 개발자가 계속 해야 한다.\nvar tmp: String? = null lateinit은 클래스 속성 뿐만 아니라 최상위 수준 속성과 함수의 지역 변수에서도 사용 가능하다.\n늦 초기화 (lazy initalization) \u0026lsquo;지연 초기화\u0026rsquo; 만이 초기화를 지연시킬 수 있는 유일한 방법은 아니다.\n변수나 속성이 ‘최초’ 사용될 때까지 초기화를 ‘연기’ 할 수도 있다.\n속성을 즉시로 사용할 필요가 없다면 \u0026lsquo;늦 초기화\u0026rsquo;가 좋은 선택이 된다.\n늦 초기화는 코틀린에서 delegation(위임) 패턴을 사용해서 구현한다. lazy 함수 를 대리자로 위임 처리 한다. lazy 함수는 람다를 인자로 받아 실행 시켜준다. lazy 함수와 람다로 초기화 후에 이후에는 다시 초기화되지 않고, 캐시에 저장되 결과가 사용된다. val homtTown by lazy { myFun() }\nby 키워드를 사용해서, 위임받은 일을 처리하는 대리자(delegate) 를 지정한다\n대리자로 커스텀 함수 또는 코틀린 표준 라이브러리의 함수를 사용할 수 있다. 컴파일러는 소스 코드상의 초기화 순서를 검사하지 않는다.\n속성을 사용하는 함수의 순서를 비교하지는 않는다. 상속 서브 클래스(자식 클래스) 는 상속해 주는 클래스의 모든 속성과 함수를 공유한다.\n상속해 주는 클래스를 부모 클래스 또는 슈퍼 클래스라고 한다. open 키워드를 붙혀서 서브 클래스를 가질 수 있게 해야 한다.\n상속 받은 속성과 함수를 그대로 사용하지 않고, overrideing 할 수도 있다.\n이때 override 하는 함수에도 open 키워드 사용해야 한다. super 키워드를 사용해서, 부모 클래스 함수 or 속성을, 자식(서브) 클래스에서 호출 or 접근 할 수 있다.\n슈퍼 클래스의 public, protected 속성과 함수를 사용할 수 있다. 슈퍼 클래스로 타입을 선언하면, 어떤 서브 클래스 인스턴스도 참조 할 수 있다. ⇒ 다형성\n서브 클래스는 기본적으로 open이 되므로, 서브 클래스의 서브 클래스는 언제든 override 할 수 있다.\n코틀린에서는 클래스가 정의될 때 기본적으로 서브 클래스를 만들지(상속 되게) 못하게 되어 있다.\nfinal 키워드: 키워드를 붙인 함수 or 속성만, override 될 수 없게 함.\n타입 검사 is 연산자로 객체가 특정 타입인지 검사할 수 있다.\n자식 클래스의 인스턴스는 해당 자식 클래스의 타입이면서 동시에 부모 클래스의 타입도 된다.\n사자 인스턴스는 사자 타입이면서 동시에 동물 타입이다. 코틀린 타입의 상속 계층 코틀린의 모든 non-nullable 클래스는 자동으로 Any라는 최상위 슈퍼 클래스로 부터 상속 받는다.\nAny는 자바의 모든 클래스가 java.lang.Object의 서브 클래스인 것과 비슷하다. as 연산자 : 상속 관계가 있을 때, 타입 변환에 사용\n변환된 타입의 속성 참조나 함수 호출을 할 수 있는 것이지 해당 객체가 갖는 값을 변환하는 것은 아니다. 두 타입 간에 상속 관계가 없으면 타입 변환은 불가능\n스마트 캐스팅 코틀린 컴파일러가 특정 조건에서 명시적 캐스팅이 아닌, 자동으로 타입 변환을 수행하는 것 간결성, 가독성, 안전성 직접 변환하지 않아도 스마트 캐스팅이 일어나면, 컴파일러는 해당 타입으로 간주한다. (컴파일 에러 안남) non-nullable 타입은 nullable 타입의 자식(서브) 타입이다. JVM 애플리케이션으로 컴파일하면 Any 클래스는 java.lang.Object로 바이트 코드에 구현되지만, 다른 플랫폼을 대상으로 컴파일하면 해당 플랫폼에 맞게 다른 형태로 구현된다. Any 클래스 1 2 3 4 5 public open class Any { public open operator fun equals(other: Any?): Boolean public open fun hashCode() : Int public open fun tostring(): String } 모든 클래스의 부모 클래스\n기본 메서드 제공: Any 클래스는 다음과 같은 기본 메서드를 제공합니다.\nequals(other: Any?): Boolean: 객체의 동등성을 비교합니다. hashCode(): Int: 객체의 해시 코드를 반환합니다. toString(): String: 객체의 문자열 표현을 반환합니다. 해당 타입에 맞게 오버라이딩해서 구현하라는 의미\n확장 함수 활용: Any 클래스는 확장 함수를 통해 다양한 기능을 추가할 수 있습니다. 예를 들어, to() 함수를 사용하여 Pair 객체를 생성할 수 있습니다.\n다양한 플랫폼에 독립적인 애플리케이션을 생성할 수 있게 해주는 방법 중 하나다.\n즉, 각 플랫폼에 공통적으로 사용할 수 있는 최상위 슈퍼 클래스인 것이다.\n코틀린 프로그램을 JVM 애플리케이션으로 컴파일하면 Any 클래스가 java, Lang.object로 바이트 코드에 구현됨\nPC 운영체제의 JVM에서 실행되는 애플리케이션 다른 플랫폼을 대상으로 컴파일하면 해당 플랫폼에 맞게 다른 형태로 구현된다.\nJVM 없이 실행되는 네이티브 App, 웹 브라우저에서 실행되는 자바스크립트, 안드로이드 App 따라서 우리 코드에서는 최상위 슈퍼 클래스가 Any라고 생각하고 사용하면 된다.\n코드가 실행된 각 플랫폼에서 Any가 어떻게 다르게 구현되는지 자세히 알 필요 없기 때문이다.\n객체 object 키워드 싱글톤은 하나의 인스턴스(객체)만 메모리에 생성되는 것을 말한다.\n코드의 정의된 곳에 생성되어 동작하며, 다른 클래스 내부에 포함시켜 사용할 수 있다.\n멀티 스레드로 실행될때는 반드시 하나의 객체만 생성되도록 동기화 처리를 해야 한다.\n최초 사용 시점에 하나만 생성되어, 계속 유지됨\n일반 클래스처럼 속성과 함수가 포함될 수 있고, 최초로 사용될 때 초기화 된다.\nobject 키워드를 사용하여 정의된 객체는 JVM에서 로드될 때 즉시 초기화되며, 이 때 쓰레드 안전(thread-safe) 하게 초기화됩니다. =\u0026gt; 동기화 문제 해결\n객체 선언(object 키워드) 에도 일반 클래스처럼 속성과 함수가 포함될 수 있다. 그리고 이런 속성이나 함수가 최초로 사용될 때 비로소 해당 객체가 생성되고 초기화된다.\n객체 표현식 기존 클래스의 서브 클래스를 원하는 코드 안에 ‘이름 없이’ 정의 하고 바로 인스턴스를 생성해서 사용하는 경우 편하게 사용된다. annonymous 클래스 (익명 클래스) 라고 한다. 1 2 3 val anyClassInstance = object : ParentClass() { override fun load() = \u0026#34;~~~\u0026#34; } 익명 클래스는 ParentClass 의 자식 클래스임으로, 속성과 함수를 상속 받는다.\noverride 및 새로운 속성 및 함수 추가 가능하다. 'anyClassInstance'인스턴스는 싱글톤 객체가 됨으로,\n함수 내부에서 사용될 때는, 매번 인스턴스가 생성될 수 있기 때문에 사용시 유의해야 한다. 동반 객체 (companion object) 최상위 수준에서는 사용할 수 없고, 클래스 내부에서 정의하여 사용한다. 클래스 내부에 정의된 객체 선언(object) 하나의 클래스에서는 하나의 동반 객체만 포함될 수 있다. 클래스의 인스턴스가 얼마나 많이 생성되던, 동반 객체의 인스턴스는 하나만 생긴다. 중첩 클래스 다른 클래스 내부 안에 정의된 클래스, nested class 중첩된 클래스의 인스턴스는 외곽 클래스의 인스턴스가 생성되어야 사용할 수 있다. 외곽 클래스는 중첩 클래스의 속성과 함수를 사용할 수 있다. Nested Class는 외부 클래스의 인스턴스에 대한 참조를 가지지 않으며, 외부 클래스의 멤버에 직접 접근할 수 없습니다. 1 2 3 4 5 6 class OuterClass { private val outerValue = \u0026#34;외부 클래스 값\u0026#34; class NestedClass { // outerValue에 접근 불가 } } 내부 클래스 (inner class) Kotlin의 inner 키워드를 사용하여 선언된 클래스를 Inner Class(내부 클래스)라고 합니다. 자신을 감싸고 있는 외부 클래스(Outer Class)의 인스턴스에 대한 참조를 암시적으로 가지고 있습니다. nested class와 다름 암시적으로 참조하므로, 메모리 누수에 주의해야 합니다. Inner Class는 외부 클래스의 인스턴스 없이 생성할 수 없습니다. 1 2 3 4 5 6 7 8 class OuterClass { private val outerValue = \u0026#34;외부 클래스 값\u0026#34; inner class InnerClass { fun accessOuter() { println(outerValue) // 외부 클래스의 private 멤버 접근 가능 } } } data class 주로 데이터를 표현하는 객체를 간편하게 생성, 저장, 표현하기 위해 사용됩니다.\n일반 클래스와 달리 데이터 클래스는 컴파일러가 자동으로 몇 가지 유용한 메서드를 생성해줌\nJVM은 객체를 고유하기 관리하기 위해 해시 코드 값을 생성함\n인스턴스끼리 각 속성(프로퍼티) 의 값을 비교 (equals 함수)\nEquality, 동등성 연산에서 사용 인스턴스를 컬렉션(Ex. Map)에 저장할 때 사용할 키 값인 해시 코드를 생성 (hashCode 함수)\nhash와 관련된 연산을 할 때 사용 객체를 문자열로 나타내는 기능 (toString 함수)\n해체 선언 함수 (componentN 함수)\n기존 인스턴스(객체)의 속성값을 변경하여 새로운 인스턴스를 생성하는 (copy 함수)\n얕은 복사; Shallow Copy: copy() 메서드는 기본적으로 얕은 복사를 수행합니다. 원본 객체와 같은 참조를 공유합니다. 따라서 참조 타입 프로퍼티를 변경하면 원본 객체에도 영향을 미칠 수 있습니다.\ncopy() 를 사용하면 원시 타입 프로퍼티는 값 복사(Value Copy) 를 통해 새로운 객체에 복사됩니다.\ncopy() 를 사용하면 참조 타입 프로퍼티는 참조 복사(Reference Copy) 를 통해 새로운 객체에 복사됩니다.\n깊은 복사; Deep Copy: 새로운 객체 생성, 이는 코틀린에서 개발자가 직접 구현해야 합니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 data class Address(var city: String) data class Person(val name: String, val address: Address) // 참조 타입 복사 val address = Address(\u0026#34;Seoul\u0026#34;) val person1 = Person(\u0026#34;Alice\u0026#34;, address) val person2 = person1.copy() person2.address.city = \u0026#34;Busan\u0026#34; // person2의 address 변경 println(person1.address.city) // Busan (person1의 address도 변경됨) // 원시 타입 복사 val person1 = Person(\u0026#34;Alice\u0026#34;, 25) val person2 = person1.copy() person2.age = 26 // person2의 age 값만 변경 println(person1.age) // 25 (person1의 age는 변경되지 않음) 위 5개의 함수를 코틀린 컴파일러가 자동으로 생성한다.\nAny 클래스의 (equals, toString, hashCode) 함수들을 오버라이딩 해준다. 반드시 ‘기본 생성자’ 에 속성들을 지정해야 한다.\nopen 으로 피상속 불가, 슈퍼 클래스 불가\n상속을 허용한다면, 부모 클래스에서 자동 생성된 메서드들이 자식 클래스의 모든 프로퍼티를 고려하여 정확하게 동작하도록 보장하기가 어렵기 때문 data class의 목적과 부합하지 않음 Data Class는 다른 클래스를 상속할 수 없으며, 인터페이스만 구현할 수 있습니다.\n해시 코드 값은 인스턴스를 고유하기 식별하기 위해 생성된 값이다.\nenum 클래스 ‘상수값’을 정의하는 열거형 클래스를 정의할때 사용\n상수보다 더 서술적이라서 무엇을 의미하기 알기 쉽다.\nenum 의 항목은 단순한 상수가 아니라, 서브 타입이다.\n각 상수(항목들) 는 자체적으로 프로퍼티와 메서드를 가질 수 있는 객체 항목들은 enum class 내부에서만 생성되며, 외부에서 임의로 생성할 수 없습니다.\nenum 는 모든 상수가 컴파일 타임에 결정되므로, 각 상수는 JVM 내부적으로 단일 인스턴스로 표현됩니다. (메모리 사용 측면에서 효율적)\nenum 클래스 내부적으로 ‘name’(항목 이름, String 타입), ‘ordinal’(항목 위치, Int 타입, 0부터 시작)\nEnumClass.values : 모든 항목 이름을 ‘배열’로 생성\nenum 클래스의 함수 호출은 ‘enum 클래스명.항목명.함수명’ 의 형태로 호출해야 한다.\n컴파일러가 모든 타입을 처리했는지 검사할 수 있다는 장점\n싱글턴 패턴과 유사한 특징을 가지고 있어, 싱글턴처럼 사용할 수 있습니다.\n하지만 상속 불가 및 값 표현 등의 차이점이 있으므로, 엄밀히 말하면 싱글턴은 아닙니다. 연산자 오버로딩 연산자 오버로딩: 피연산자의 타입이 무엇이든 같은 연산자를 사용해서 동일한 기능을 구현할 수 있게 해주는 것\n코틀린에서는 각 연산자를 사전에 약속된 함수로 구현하여 연산자 오버로딩을 지원한다.\n코틀린 컴파일러는 a+b 를 컴파일하여, a.plus(b) 를 실행하도록 바이트코드로 생성 + 연산자 를 사전에 약속된 plus 함수로 싱행하게 되면, 피연산자의 타입이 다르더라도 덧셈은 항상 + 로 표기가능 피연산자의 타입마다 서로 다른 덧셈 연산자를 사용하면, 불편하고 연산자 수가 매우 많아짐 코틀린에서== 비교 연산자 가 내부적으로 equals 함수로 호출되는 이유가 연산자 오버로딩 때문이다. (ex. +, plus() )\n객체의 값 비교하기 equals 함수를 override 할 때는 haseCode 함수도 같이 override 해야 한다. 동등성, Equality 연산 hash와 관련된 자료구조(hashMap, hashTable)는 동등성 연산(equals) 전에 먼저, Hash Value비교를 수행한다. 즉, hashCode()의 값이 같은 경우에만 **동등성 연산(equals)**이 수행된다.\n두 개의 다른 인스턴스에 대해 같은 Hash Value가 나오는 경우를 Hash 충돌(Hash Collision) 이라 한다.\nHash Value가 같으므로 동등성 연산(equals) 가 수행된다.\n같은 해시 값을 갖는 인스턴스들이 LinkedList 형태로 이어져있어 하나하나씩 Iteration이 돌아가면서 동등성 연산이 수행\n따라서 N개의 값 객체가 있고 해당 값 객체들이 모두 같은 Hash Value를 갖는다면 동등성 연산 수행에 O(N)의 시간 복잡도가 필요하다.\n하지만 만약 모든 값 객체들이 다른 Hash Value를 갖는다면 동등성 연산 수행에 O(1)의 시간 복잡도 따라서 hashCode()값을 Hash 충돌을 최대한 피할 수 있도록 짜야한다. 1 2 3 4 5 6 7 8 9 10 11 12 class GalaxyTab(val modelName: String, val size: Int) { override fun hashCode(): Int { return modelName[1].toString().toInt() } } val tabS6 = GalaxyTab(\u0026#34;S6\u0026#34;, 11) val tabS7 = GalaxyTab(\u0026#34;S7\u0026#34;, 11) val tabStock = mutableMapOf\u0026lt;GalaxyTab,Int\u0026gt;() tabStock[tabS6] = 0 tabStock[tabS7] = 2 JVM에서 Hash와 메모리 주소 값 비교 특징 Hash (해시 코드) 메모리 주소 값 의미 객체의 데이터를 기반으로 생성된 정수 값 객체가 저장된 메모리 상의 실제 위치 목적 객체 비교, 해시 기반 컬렉션 활용 객체 식별, 참조 비교 고유성 동일 객체는 항상 같은 값, 다른 객체는 다른 값을 가질 수 있음 (해시 충돌 가능) 각 객체마다 고유한 값 가변성 객체의 상태가 변하지 않으면 불변 가비지 컬렉션 등에 의해 변경될 수 있음 메모리 주소와의 관계 일반적으로 무관 직접적인 관계 JVM에서 hash와 메모리 주소 값은 둘 다 객체를 식별하는 데 사용되지만, (공통)\nHash는 주로 객체의 논리적 동등성 비교와 해시 기반 컬렉션에서 활용되며, 메모리 주소 값은 객체의 고유성 판별과 참조 비교에 사용됩니다. Hash\n객체의 데이터를 기반으로 생성된 정수 값입니다. Object 클래스의 hashCode() 메서드를 통해 얻을 수 있습니다. 해시 기반 컬렉션: 해시 기반 컬렉션에서 객체를 효율적으로 저장하고 검색하는 데 사용됩니다. 해시 코드를 통해 객체를 버킷에 분류하고, 충돌 발생 시 equals() 로 최종 비교 메모리 주소 값\n객체가 저장된 메모리 상의 실제 위치를 나타내는 값입니다. 자바는 == 연산자, 코틀린은 === 연산자 sealed class enum 항목이 복잡한 로직을 가질 경우, 각 항목을 클래스로 정의하고, 이를 sealed class로 묶어서 사용 가능 유연한 데이터 저장, 복잡한 구조 가능 자신의 서브(자식) 클래스 종류를 제한하기 위해 사용된다. enum 클래스의 각 항목은 하나의 인스턴스만 생성되지만, sealed class에 속하는 서브 클래스들은 일반 클래스 이므로, 인스턴스 개수에 제한이 없다. 컴파일러는 해당 수퍼 클래스의 서브 클래스들을 컴파일 타임에 파악할 수 있게됨 when 표현식과 함께 사용될 때 모든 하위 클래스를 검사하므로, else 절이 필요하지 않습니다. enum도 마찬가지 1 2 3 4 5 sealed interface ApiResult\u0026lt;out T\u0026gt; { data class Success\u0026lt;out T\u0026gt;(val data: T) : ApiResult\u0026lt;T\u0026gt; data class Error(val exception: Exception) : ApiResult\u0026lt;Nothing\u0026gt; object Loading : ApiResult\u0026lt;Nothing\u0026gt; } 말 그대로 인터페이스이기 때문에 다중 상속을 통한 타입의 다형성을 부여할 수 있습니다. 다시 말해, 특정 타입의 성질을 하위 타입에게 전달하기가 쉽습니다. 또한, when 문을 사용하여 타입을 참조하여 분기해야할 상황에서 장점이 명확해짐 enum의 한계 각 요소당 하나의 single instance를 사용하기 때문에 서로 다른 형태를 가질 수 없습니다. 1 2 3 4 enum class Result { SUCCESS, FAILED(val exception: Exception) // 이런 형태는 불가함. } ","permalink":"https://2taezeat.github.io/posts/dev/kotlin-%EC%A0%95%EB%A6%AC-1/","summary":"Kotlin 다시 보기 (1) ‘빅 너드 랜치의 코틀린 프로그래밍’ 을 읽고 정리\n타입 코틀린 타입 특징 정적 타입 시스템\n소스 코드에 정의된 타입을 컴파일러가 알고 있다. 프로그램을 컴파일하기 전에 타입 체킹 : 정적 타입 체킹\nbuilt-in, 내장 타입 String\nChar\nBoolean\nInt\nDouble\nList - 컬렉션 타입\nSet - 컬렉션 타입\nMap - 컬렉션 타입\n변수 val : read-only, 변경 불가능, 읽기 전용 var : 값이 변경 될 수 있음, writeable 쓰기 가능, 가변성 타입 추론 코틀린 컴파일러가 타입을 추론 해줌 따라서, 타입을 생략 가능, 컴파일러가 소스 코드의 타입을 알고 있음 코틀린은 기본 타입을 포함해서, 모든 타입이 객체다.","title":"Kotlin 정리 (1)"},{"content":"코틀린 코드 컴파일 및 빌드 코틀린 컴파일러는 자바 컴파일러가 자바 소스코드를 컴파일할 때와 마찬가지로 코틀린 소스코드(.kt)를 분석해서 .class 파일을 만들어낸다. 만들어진 .class 파일은 개발 중인 애플리케이션의 유형에 맞는 표준 패키징 과정을 거쳐 실행될 수 있다. Java 코드와 Kotlin 코드의 빌드 과정은 다음과 같은 순서로 이루어진다.\n코틀린 컴파일러(kotlinc)가 코틀린 코드를 컴파일해 .class 파일을 생성한다. 이 과정에서 코틀린 코드가 참조하는 Java 코드가 함께 로딩되어 사용된다.\nParsing (파싱): 코틀린 컴파일러는 .kt 파일의 코드를 읽어 들여 문법적으로 올바른지 검사하고, 추상 구문 트리(AST, Abstract Syntax Tree)를 생성합니다.\nType Checking (타입 검사): AST를 분석하여 타입 정보를 추론하고, 타입 오류를 검사합니다. 코틀린의 강력한 타입 추론 시스템은 이 단계에서 중요한 역할을 합니다.\nCode Generation (코드 생성): 타입 검사가 완료된 AST를 기반으로 JVM 바이트코드(.class 파일)를 생성합니다. 이때 코틀린 런타임 라이브러리에 대한 참조가 추가됩니다.\nOptimization (최적화): 생성된 바이트코드를 최적화하여 실행 속도를 향상시킵니다.\nJava 컴파일러(javac)가 Java 코드를 컴파일해 .class 파일을 생성한다. 이때 이미 코틀린이 컴파일한 .class 파일의 경로를 클래스 패스에 추가해 컴파일한다.니\n코틀린 컴파일러로 컴파일한 코드는 코틀린 런타임 라이브러리(kotlin runtime library)에 의존한다.\n코틀린 런타임 라이브러리 : 코틀린 자체 표준 라이브러리 클래스 + 코틀린에서 자바 API의 기능을 확장한 내용\n코틀린으로 컴파일한 애플리케이션을 배포할때는 코틀린 런타임 라이브러리도 함께 배포해야 한다.\n프로젝트를 컴파일하기 위해 메이븐(Maven)과 그레이(Gradle), 앤트(Ant) 등의 빌드 시스템을 사용\n빌드 시스템은 모두 코틀린과 자바가 코드베이스에 함께 들어있는 혼합 언어 프로젝트를 지원할 수 있다\n메이븐(Maven)과 그레이(Gradle)들은 애플리케이션을 패키지할 때 알아서 코틀린 런타임 라이브러리을 포함시켜준다.\nJDK, JRE, JVM의 관계 및 역할 JDK (Java Development Kit):\n정의: 자바 개발 도구 모음입니다. 자바 애플리케이션을 개발, 컴파일, 실행하는 데 필요한 모든 것을 포함합니다. 개발하려면 필요\n구성 요소:\nJRE (Java Runtime Environment): 자바 애플리케이션을 실행하기 위한 환경입니다.\n컴파일러 (javac): 자바 소스 코드를 바이트코드로 변환합니다.\n디버거 (jdb): 자바 애플리케이션의 오류를 찾고 수정하는 데 사용됩니다.\n자바독 (javadoc): 자바 소스 코드에서 API 문서를 생성합니다.\n기타 도구: jar, jlink, jmod 등 다양한 개발 도구가 포함됩니다.\nJRE (Java Runtime Environment):\n정의: 자바 애플리케이션을 실행하기 위한 환경입니다. 실행하려면 필요\n구성 요소:\nJVM (Java Virtual Machine): 자바 바이트코드를 실행하는 가상 머신입니다.\n핵심 라이브러리: 자바 언어의 핵심 기능을 제공하는 클래스 라이브러리입니다.\nJVM (Java Virtual Machine):\n정의: 자바 바이트코드를 실행하는 가상 머신입니다.\n역할:\n플랫폼 독립성: JVM은 다양한 운영체제와 하드웨어에서 동일한 자바 바이트코드를 실행할 수 있도록 해줍니다.\n메모리 관리: JVM은 자바 애플리케이션의 메모리를 자동으로 관리합니다.\n보안: JVM은 자바 애플리케이션의 안전한 실행을 보장합니다.\n성능 최적화: JVM은 JIT(Just-In-Time) 컴파일러를 사용하여 바이트코드를 실행 중에 기계어로 변환하여 성능을 향상시킵니다.\n관계: JDK는 JRE를 포함하고, JRE는 JVM을 포함합니다. 즉, JDK를 설치하면 JRE와 JVM도 함께 설치됩니다.\n추가 정보:\nJVM은 자바 애플리케이션의 WORA(Write Once, Run Anywhere) 특성을 가능하게 합니다. JVM은 자바 언어의 핵심 기술이며, 다양한 자바 애플리케이션 개발에 사용됩니다. JAVA 컴파일 Java Compiler가 소스 코드 .java 파일을 .class 파일인 Byte Code(중간 레벨) 로 컴파일한다. 단, 해당 코드는 직접 CPU에서 동작할 수 있는 코드가 아니다. 정확히 말하면 가상머신 JVM이 이해할 수 있는 코드이다 이제 이 Byte Code를 기계어(Binary 코드) 로 변환시키기 위해 가상 머신이 필요한데, 이것이 JVM(Java Virtual Machine) 의 역할이다. JVM이 Byte Code(.class) 를 기계어(Binary Code) 로 변환한다. 이렇게 JVM에 의해 컴파일된 기계어는 바로 CPU에서 실행되어 사용자에게 서비스를 제공해준다. 단, 간과하지 말아야 할 점은 자바 프로그램과는 달리 자바 가상 머신(JVM)은 운영체제에 종속적이므로, 각 운영체제에 맞는 자바 가상 머신을 설치해야 한다는 점이다.\nJIT (Just-In_Time) 컴파일러 JIT 컴파일러는 같은 코드를 매번 해석하지 않고, 실행할 때 컴파일을 하면서 해당 코드를 캐싱 한다.\n이후에는 바뀐 부분만 컴파일하고 나머지는 캐싱된 코드를 사용한다. JIT 컴파일은 프로그램 실행 중에 기계어로 번역하는 컴파일 기법입니다.\n전통적인 인터프리터 방식과 정적 컴파일 방식의 장점을 결합하여 성능을 향상시키는 데 목표를 둡니다.\nJVM의 동작 방식 자바 프로그램을 실행하면 JVM은 OS로부터 메모리를 할당받는다. 자바 컴파일러(javac)가 자바 소스코드(.java)를 자바 바이트 코드(.class)로 컴파일 한다. Class Loader는 동적 로딩을 통해 필요한 클래스들을 로딩 및 링크 하여 Runtime Data Area(실질적인 메모리를 할당 받아 관리하는 영역) 에 올린다. Runtime Data Area에 로딩 된 바이트 코드는 Execution Engine을 통해 해석된다. 이 과정에서 Execution Engine에 의해 Garbage Collector의 작동과 Thread 동기화가 이루어진다. JVM의 구조 Execution Engine, 실행 엔진 실행 엔진은 클래스 로더를 통해 런타임 데이터 영역에 배치된 바이트 코드를 명령어 단위로 읽어서 실행한다\n자바 바이트 코드(*.class) 는 기계가 바로 수행할 수 있는 언어보다는 가상머신이 이해할 수 있는 중간 레벨로 컴파일 된 코드이다.\n그래서 실행 엔진은 이와 같은 바이트 코드를 실제로 JVM 내부에서 기계가 실행할 수 있는 형태로 변경해준다. 이 수행 과정에서 실행 엔진은 인터프리터와 JIT 컴파일러 두 가지 방식을 혼합하여 바이트 코드를 실행한다.\n런타임 데이터 영역 (Runtime Data Area) 런타입 데이터 영역은 쉽게 말하면 JVM의 메모리 영역으로 자바 애플리케이션을 실행할 때 사용되는 데이터들을 적재하는 영역이다. Method Area Method Area는 우리가 보통 정적(Static) 영역이라고 부르는 메모리이다. 프로그램 실행 중 클래스나 인터페이스를 사용하게 되면, JVM은 Class Loader을 이용해 클래스와 인터페이스의 메타 데이터를 Method Area에 저장한다. 즉, 클래스가 로드 되는 시점은 해당 클래스가 사용되기 위해 호출되는 시점이다. 메타 데이터는 Type Information, Runtime Constant Pool, Field Information, Method Information, Class Variable을 가리킨다. Stack Area Stack Area는 메서드가 호출될 시 할당되는 영역이다.\n메서드 호출 시 메서드 내부의 지역 변수 또한 Stack Area에 할당된다.\nHeap 공간에 객체 데이터를 올리고 그 객체 데이터에 대한 참조값이 할당된다는 뜻이다. 예외적으로 원시 타입(Primitive type) 변수는 Stack 영역에 값 자체가 할당된다.\n코어를 최대한 활용하기 위해 Thread를 사용하여 프로그래밍을 하는데, 각 스레드는 하나의 Stack 영역을 할당 받는다.\n즉, 스레드는 각자의 메모리 공간을 가지고 메서드를 수행하는 것이다. 메서드 호출 시마다 각각의 스택 프레임(그 메서드만을 위한 공간)이 생성되고 메서드 안에서 사용되는 값들을 저장하고,\n호출된 메서드의 매개변수, 지역변수, 리턴 값 및 연산 시 일어나는 값들을 임시로 저장한다.\n그리고 메서드 수행이 끝나면 프레임별로 삭제된다. (LIFO)\n프로세스가 메모리에 로드 될 때 스택 사이즈가 고정되어 있어, 런타임 시에 스택 사이즈를 바꿀 수는 없다.\nJVM 스택에서 프로그램 실행 중 메모리 크기가 충분하지 않다면 StackOverFlowError 발생 Heap Area Heap Area는 프로그램이 실행되면서 동적으로 생성된 객체(인스턴스) 가 저장되는 공간이다. Heap Area에 생성된 객체들은 다른 객체의 필드 또는 스택에 존재하는 다른 메서드에 의해 참조될 수 있다. 메서드가 실행되면서 Stack영역에는 참조값만을 저장해놓고 Heap Area에 객체 데이터를 저장해 놓는다. 자료구조에 관한 내용이 Heap Area에서 많이 쓰인다. 예를 들어 아래와 같이 배열과 리스트가 선언되었다고 해보자. 이런 경우 Stack 영역에는 참조값만 저장되며 Heap 영역에 실제 데이터가 저장된다. 1 2 var arrayExample: Array\u0026lt;String\u0026gt; = arrayOf(\u0026#34;a\u0026#34;, \u0026#34;b\u0026#34;, \u0026#34;c\u0026#34;) var listExample: List\u0026lt;String\u0026gt; = listOf(\u0026#34;a\u0026#34;, \u0026#34;b\u0026#34;, \u0026#34;c\u0026#34;) listOf는 Arrays.asList로 array를 전달하여 ArrayList를 생성하므로 위와 같은 결과가 나온다. String을 효율적으로 사용하기 위해 JVM상에서 String을 다른 객체들과 차별되게 저장되도록 해놓았는데, 그것이 바로 Heap Area 상의 String Constant Pool이다.\n1 2 3 4 5 6 7 8 9 10 11 val stringA1 = \u0026#34;A\u0026#34; val stringA2 = \u0026#34;A\u0026#34; stringA1 == stringA2 // true stringA1 === stringA2 // true val stringABC1 = String(charArrayOf(\u0026#39;A\u0026#39;,\u0026#39;B\u0026#39;,\u0026#39;C\u0026#39;)) val stringABC2 = \u0026#34;ABC\u0026#34; stringABC1 == stringABC2 // true stringABC1 === stringABC2 // false String Constant Pool은 플라이웨이트 패턴을 구현한 대표적인 예로 한 번 저장한 변수를 다시 저장하지 않도록 만들어졌다. 따라서 String을 을 이용하여 선언할 경우 먼저 String Constant Pool에 해당 변수가 있는지 확인 후 있으면 기존 값을 참조하도록 주소값을 설정하고, 아니라면 새로운 String은 String Constant Pool에 넣는다. 이러한 과정을 통해 String은 JVM 상에서 매우 효율적으로 동작할 수 있다. 그렇다면, 다른 변수들 처럼 String Constant Pool 바깥에 String을 저장할 수 있는 방법은 없을까? 당연히 있다. \u0026quot;\u0026quot;가 아니라 String 생성자를 이용하여 String을 생성할 경우 Constant Pool 바깥에 생성된다. PC 레지스터 (Program Counter Register) PC 레지스터는 쓰레드가 시작될 때 생성되며, 현재 수행중인 JVM 명령어 주소(Current Instruction Address)를 저장하는 공간이다.\nJVM 명령의 주소는 쓰레드가 어떤 부분을 무슨 명령으로 실행해야할 지에 대한 기록을 가지고 있다.\n하지만 자바의 PC Register는 CPU Register와 다르다.\n자바는 OS나 CPU의 입장에서는, 하나의 프로세스이기 때문에 가상 머신(JVM)의 리소스를 이용해야 한다.\n그래서 자바는 CPU에 직접 연산을 수행하도록 하는 것이 아닌, 현재 작업하는 내용을 CPU에게 연산으로 제공해야 하며,\n이를 위한 버퍼 공간으로 PC Register라는 메모리 영역을 만들게 된 것이다 따라서 JVM은 스택에서 비연산값 Operand를 뽑아 별도의 메모리 공간인 PC Register에 저장하는 방식을 취한다.\nJVM의 Stack, Heap 할당 방식 Stack에는 원시 타입 변수 값이나, Heap을 가리키는 주소값 둘 중 하나만 저장된다.\nStack은 좁은 메모리 공간이지만, Heap은 넓은 메모리 공간이다.\nStack 메모리에 값을 할당하고 해제하는 것은 많은 비용이 들지 않지만,\nHeap 메모리에 값을 할당하고 해제하는 것은 많은 비용을 요한다.\nJVM 프로세스와 멀티스레드 JVM(가상 머신)은 하나의 프로세스 이다. 하나의 프로세스는 여러 작업 단위를 가질수 있는데 이 작업 단위를 바로 스레드라고 한다. JVM에서는 Main Thread라 불리는 쓰레드가 있고, 우리가 main() 메서드를 사용해 불리는 것이 바로 Main Thread이다. Main Thread가 종료되면 나머지 Thread 들도 자동으로 종료가 된다 멀티 쓰레드의 경우 여러 쓰레드가 하나의 Heap 영역의 변수에 동시 접근하여 변경이 생기면, 동기화 이슈 발생\n해결법\n불변(읽기 전용) 변수로 선언, val 가변 변수일 경우 해당 값을 변경하는 연산을 @Synchronized 키워드를 이용해 한번에 하나의 스레드에서만 접근할 수 있게 막아야 함 가장 좋은 방법은 불변 변수로 선언하고, 임계 구역에서 접근하는 변수는 변화하지 않게 하는 것이다. 1 2 3 4 5 6 7 8 val immutableString = \u0026#34;Kotlin World @Synchronized fun append(str: String?): StringBuffer? { toStringCache = null super.append(str) return this } 최근 CPU는 기본적으로 여러개의 코어를 가지고 있어 여러 개의 스레드를 활용하는 프로그래밍이 가능하다.\n따라서 멀티스레드를 활용하는 비동기 프로그래밍이 요즘 경향이다.\n비동기 프로그래밍이란, 연산을 다른 스레드로 넘겨버리고, 현재 스레드에서는 다른 작업을 할 수 있도록 하는 프로그래밍 방식이다.\n비동기 프로그래밍의 이점은 메인 스레드를 blocking 하지 않고 다른 스레드에서 작업을 수행하는 것이 가능하다는 것이다.\nUI가 있는 프로그램에서는 보통 메인스레드가 UI를 제어하게 되는데 메인 스레드가 non-blocking되면, UI가 끊기지 않아 사용자 경험 또한 개선시킬 수 있다.\nJVM에서 GC GC란, Heap 영역에서 동적으로 할당했던 메모리 중 필요 없게 된 메모리 객체(garbage) 를 모아 주기적으로 제거하는 것\n자동으로 처리해준다 해도 메모리가 언제 해제되는지 정확하게 알 수 없어 제어하기 힘들며,\n가비지 컬렉션(GC)이 동작하는 동안에는 다른 동작을 멈추기 때문에 오버헤드가 발생되는 문제점이 있다. =\u0026gt; Stop the world\nGC 대상 GC 방식 Mark-Sweep 이란 다양한 GC에서 사용되는 객체를 솎아내는 내부 알고리즘이다.\n가비지 컬렉션이 동작하는 아주 기초적인 청소 과정이라고 생각하면 된다.\n모든 머신들이 그렇듯 JVM 또한 사용되지 않는 객체들이 제때 메모리에서 정리되지 못하고 한 번에 정리되거나 한다면 앱이 버벅거리거나, 제대로 동작하지 않을 수 있다.\n또한 만약 사용되지 않는 객체가 GC의 대상이 되지 못한다면 Out of Memory Error 로 인해 앱이 강제 종료될 수도 있다.\nYoung Generation 영역은 짧게 살아남는 메모리들이 존재하는 공간이다.\n모든 객체는 처음에는 Young Generation에 생성되며, Young Generation의 공간은 Old Generation에 비해 상대적으로 적기 때문에 메모리 상의 객체를 찾아 제거하는데 적은 시간이 걸린다. 작은 공간에서 데이터를 찾기 위해 걸리는 시간이 적기 때문이다. 이 때문에 Young Generation 영역에서 발생되는 GC는 Minor GC라 불린다. Old Generation은 길게 살아남는 메모리들이 존재하는 공간이다.\nOld Generation의 객체들은 처음에는 Young Generation에 의해 시작되었으나, GC 과정 중에 제거되지 않은 경우 Old Generation으로 이동한다. Old Generation은 Young Generation에 비해 상대적으로 큰 공간을 가지고 있으며 이 공간에서 메모리 상의 객체 제거에 많은 시간이 걸린다. 이 때문에 Old Generation에서 발생되는 GC는 Major GC라 불린다. Eden -\u0026gt; Survior0 -\u0026gt; Surviior1 이래도 GC에서도 살아남는다면, Old Generation 영역으로 넘어간다. Old Generation에서는 Major GC가 일어난다. Major GC는 매우 큰 공간이기 때문에 데이터를 지우는데 많은 시간이 걸린다. 또한 Major GC가 일어나면 Thread가 멈추고 Mark and Sweep 작업을 해야 해서 CPU에 부하를 주기 때문에 Major GC가 자주 일어나는 앱들에서는 GC가 일어날 때마다 멈추거나 버벅이는 현상이 발생한다. 따라서 최대한 Major GC는 일어나지 않도록 하는 것이 좋다. 제때 참조(Reference)를 해제하고, 오래 붙잡는 객체를 최소화해야 이러한 장애 상황을 최소화 할 수 있다. ","permalink":"https://2taezeat.github.io/posts/dev/jvm-%EC%A0%95%EB%A6%AC/","summary":"코틀린 코드 컴파일 및 빌드 코틀린 컴파일러는 자바 컴파일러가 자바 소스코드를 컴파일할 때와 마찬가지로 코틀린 소스코드(.kt)를 분석해서 .class 파일을 만들어낸다. 만들어진 .class 파일은 개발 중인 애플리케이션의 유형에 맞는 표준 패키징 과정을 거쳐 실행될 수 있다. Java 코드와 Kotlin 코드의 빌드 과정은 다음과 같은 순서로 이루어진다.\n코틀린 컴파일러(kotlinc)가 코틀린 코드를 컴파일해 .class 파일을 생성한다. 이 과정에서 코틀린 코드가 참조하는 Java 코드가 함께 로딩되어 사용된다.\nParsing (파싱): 코틀린 컴파일러는 .kt 파일의 코드를 읽어 들여 문법적으로 올바른지 검사하고, 추상 구문 트리(AST, Abstract Syntax Tree)를 생성합니다.","title":"JVM 정리"},{"content":"소개 Dependency Injection (의존성 주입): 어떤 객체가 필요한 다른 객체를 직접 생성하는 대신, 외부로부터 제공받는 방식\n필드 주입 or 생성자 주입 핵심: 객체 간의 의존성을 줄임\nDI를 적용안하면, 결합도 증가(tight coupling)\n장점 객체간 의존성 줄임 재사용성 증가 의존하는 객체의 구현을 쉽게 갈아끼울 수 있다. 서브 타입 등 다양한 구현을 수용할 수 있고, 때문에 다양한 곳에서 클래스를 재사용 테스트 편의성 의존성이 분리되어, 즉, Mocking 이 쉬워 진다 : Test Double 이 가능해졌다 Test Double Test Double: 테스트를 진행할 때 실제 객체를 대신 사용하는 객체\n마치 스턴트맨처럼, 테스트 코드에서 실제 객체를 대신하여 테스트를 안전하고 효율적 수행 Mock: 미리 정의된 행동을 하는 가짜 객체입니다. 실제 객체와 동일한 인터페이스를 가지고 있지만, 실제 구현은 Mock 객체 자체에서 수행합니다. Stub: 특정 입력에 대해 미리 정의된 출력을 반환하는 가짜 객체입니다. Mock 객체와 유사하지만, Mock 객체보다 더 간단하고 제한적인 기능을 제공합니다. Dummy: 아무것도 하지 않는 가짜 객체입니다. 실제 객체와 인터페이스만 동일하며, 실제 구현은 전혀 없습니다. Spy: 실제 객체의 행동을 감시하고 기록하는 객체입니다. 테스트 코드에서 Spy 객체의 행동을 확인하여 테스트 결과를 검증할 수 있습니다. 효과 테스트 코드의 독립성 향상 테스트 코드의 안정성 향상 테스트 코드의 실행 속도 향상 IoC IoC(제어의 역전): 프로그램 제어권을 framework가 가져가는 것 개발자가 모든 제어의 중심이지만 코드 전체에 대한 제어는 framework가 한다. 개발자가 설정(xml, annotation 등)만 하면 Container가 알아서 처리한다. 즉, Framework 속에서 프로그래밍을 하는 것. 화이트박스 테스트(White Box Test) 화이트박스 테스트는 모듈의 원시 코드를 오픈시킨 상태에서 원시 코드의 논리적인 모든 경로를 테스트하여 테스트 케이스를 설계하는 방법이다.\n화이트박스 테스트는 설계된 절차에 초점을 둔 구조적 테스트며, 테스트 과정의 초기에 적용된다. 모듈 안의 작동을 직접 관찰한다. 원시 코드(모듈)의 모든 문장을 한 번 이상 실행함으로써 수행된다. 프로그램의 제어 구조에 따라 선택, 반복 등의 분기점 부분들을 수행함으로써 논리적 경로를 제어한다. ","permalink":"https://2taezeat.github.io/posts/dev/di-%EC%A0%95%EB%A6%AC/","summary":"소개 Dependency Injection (의존성 주입): 어떤 객체가 필요한 다른 객체를 직접 생성하는 대신, 외부로부터 제공받는 방식\n필드 주입 or 생성자 주입 핵심: 객체 간의 의존성을 줄임\nDI를 적용안하면, 결합도 증가(tight coupling)\n장점 객체간 의존성 줄임 재사용성 증가 의존하는 객체의 구현을 쉽게 갈아끼울 수 있다. 서브 타입 등 다양한 구현을 수용할 수 있고, 때문에 다양한 곳에서 클래스를 재사용 테스트 편의성 의존성이 분리되어, 즉, Mocking 이 쉬워 진다 : Test Double 이 가능해졌다 Test Double Test Double: 테스트를 진행할 때 실제 객체를 대신 사용하는 객체","title":"DI(Dependency Injection) 정리"},{"content":"\n핵심 소프트웨어를 고수준과 저수준으로 경계 짓고, 의존성 단방향 원칙을 따르는 아키텍처 자주 변경되는 것(저)과 변경되지 않는 것(고)의 경계를 나눠 분리시키자는 것 핵심: 계층 분리(layering) 를 통한 관심사 분리 presentation, domain, data layer로 나눔 특징 소스 코드 의존성은 반드시 안쪽으로, 고수준의 정책을 향해야 한다: 의존성 단방향 원칙 내부: 고수준, 추상화되어 변경이 잘 안됨 외부: 저수준, 구체화되어 변경이 잘 됨 외부는 내부를 의존, 내부는 외부의 존재를 모른다. 내부는 외부에 영향을 주지 않음 경계를 넘을 때는 추상화된 고수준의 인터페이스를 통한, 의존성 역전과 주입을 적용 저수준의 구현에 의존하던 것을 인터페이스에 의존하게 변경 (저-\u0026gt;고) 소스 코드의 의존성(저→고) 과 제어 흐름(고→저) 을 반대(역전)로 됨 구글 권장 아키텍처와 차이 구글 권장 아키텍처에서 domain layer이 옵셔널\n구글 권장 아키텍처는 domain -\u0026gt; data layer를 참조함 (알고 있음)\ndomain layer가 프레임워크나 라이브러리에 종속될 수 있음 서비스가 커지고 비즈니스 로직이 늘어날 수록 ViewModel이 비대해지고,\n반복되는 비즈니스 로직들도 생겨났다. Domain layer 를 도입하여 관심사 분리가 필요\ndomain layer는 자체가 어떠한 언어로든 프레임워크나 라이브러리에 종속되지 않아(순수 kotlin) 테스트, 모듈화가 용이\n왜 쓰냐? 모바일 환경에서 사용자가 다양한 앱을 시도때도 없이 바꾸기도 하고 전화나 알림 등의 작업도 동시에 하기 때문에 앱에서 사용자 흐름이 중단되지 않고 연속적으로 흘러가도록 처리해야 함 App 컴포넌트 에 앱 데이터나 상태를 저장해서는 안되며, 앱 구성요소가 서로 종속되도록 개발해선 안됨 단위 테스트 하기 매우 어려워짐 생명주기에 의해, 메모리 릭이 발생 할 수도 있음 우리의 경우 멀티 모듈을 도입 -\u0026gt; 클린 아키텍처가 멀티 모듈에는 적합하다 생각\n여러 모듈들을 조립하여 다른 앱 개발에 활용: 확장성 UP\n수정된 모듈만 빌드, 시간 단축: 생산성 UP\n모듈화를 통해 클린 아키텍쳐의 계층을 분리하고, 모듈들 간에 알아야 하는 대상과 몰라야 하는 대상의 제약이 강제됨: 휴먼 에러 제거 app 모듈: app 의 진입점이다.\nfeature 모듈 ( = presentation layer)\n독립적인 기능을 분리하였다. (home, playlist, search, my, player 등등) core 모듈\n다른 모듈에서 자주 사용 하는 공통 모듈이다. ui ( = presentation layer) : 다양한 기능에서 공통적으로 사용하는 UI를 포함하여 UI의 일관성을 유지하는데 도움을 준다.\ndomain ( = domain layer) : 앱의 비즈니스 로직을 캡슐화 한다. domain 모듈은 안드로이드의 의존성이 없는 순수 Java/Kotlin 코드로만 구성한다.\ndata ( = data layer) : data를 CRUD 한다.\n장점 도메인 단위 혹은 viewmodel 의 단위 테스트가 쉽게 가능\n유저의 동작으로 시작해서 화면에 보여지는 뷰의 데이터들의 흐름에 대해 파악하기 쉬워짐\nUI(View) → VM(프레젠터) → Usecase → Repository → Datasource 신규 개발자들도 파일 이름이나 클래스 명으로 어떤 기능을 해야 하고, 하고 있는지 알기 쉬워짐\ndomain과 data간의 분리가 이루어져 있기 때문에, 데이터 소스를 변경해도 domain 모듈에는 영향이 없기 때문에 비즈니스 로직은 피해없이 안전\n모듈간의 결합도가 낮아짐 (서로 영향을 덜 줌)\n단점 많은 파일들이 생겨남 단순 포워딩을 위한 Usecase가 생겨남 과도하게 집착하면, layering을 위한 수단으로 코드를 짜게 됨 (주객전도) 구성 요소 Entitiy : 핵심 비지니스 규칙을 캡슐화 Use Case : 비즈니스 로직을 정의 Interface Adapter : 어댑터들로 구성, Controller, Presenter, Gateway 가 속함. 인터페이스 역할 Framwork \u0026amp; Drivers : 시스템의 핵심 업무와는 관련 없는 세부 사항. layer Presentation 뷰(View): 직접적으로 플랫폼 의존적인 구현, 즉 UI 화면 표시와 사용자 입력을 담당합니다.단순하게 프레젠터가 명령하는 일만 수행합니다. 프레젠터(Presenter): MVVM의 ViewModel과 같이, 사용자 입력이 왔을 때 어떤 반응을 해야 하는지에 대한 판단을 하는 영역입니다. 무엇을 그려야 할지도 알고 있는 영역입니다. Domain 유즈 케이스(Use Case): 비즈니스 로직이 들어 있는 영역입니다.\n모델(Entity): 앱의 실질적인 데이터가 정의\nData 리포지터리(Repository): 유즈 케이스가 필요로 하는 데이터의 저장 및 수정 등의 기능을 제공하는 영역으로,\n데이터 소스를 인터페이스로 참조하여, 로컬 DB와 네트워크 통신을 자유롭게 할 수 있습니다. 데이터 소스(Data Source): 실제 데이터의 입출력이 여기서 실행됩니다.\n","permalink":"https://2taezeat.github.io/posts/dev/clean-architecture-%EC%A0%95%EB%A6%AC/","summary":"핵심 소프트웨어를 고수준과 저수준으로 경계 짓고, 의존성 단방향 원칙을 따르는 아키텍처 자주 변경되는 것(저)과 변경되지 않는 것(고)의 경계를 나눠 분리시키자는 것 핵심: 계층 분리(layering) 를 통한 관심사 분리 presentation, domain, data layer로 나눔 특징 소스 코드 의존성은 반드시 안쪽으로, 고수준의 정책을 향해야 한다: 의존성 단방향 원칙 내부: 고수준, 추상화되어 변경이 잘 안됨 외부: 저수준, 구체화되어 변경이 잘 됨 외부는 내부를 의존, 내부는 외부의 존재를 모른다. 내부는 외부에 영향을 주지 않음 경계를 넘을 때는 추상화된 고수준의 인터페이스를 통한, 의존성 역전과 주입을 적용 저수준의 구현에 의존하던 것을 인터페이스에 의존하게 변경 (저-\u0026gt;고) 소스 코드의 의존성(저→고) 과 제어 흐름(고→저) 을 반대(역전)로 됨 구글 권장 아키텍처와 차이 구글 권장 아키텍처에서 domain layer이 옵셔널","title":"Clean Architecture 정리"},{"content":"Jetpack Navigation Jetpack Navigation의 장점:\n직관적인 Navigation 관리: Navigation Graph를 통해 앱의 Navigation 구조를 시각적으로 파악하고 관리할 수 있습니다. 유형 안전한 데이터 전달: Safe Args를 사용하여 Fragment 간에 데이터를 안전하게 전달할 수 있습니다. 간편한 Fragment 이동: navigate()와 popBackStack() 메서드를 사용하여 Fragment 이동을 간편하게 처리할 수 있습니다. deep link 지원: 앱 외부의 링크를 통해 특정 Fragment로 바로 이동할 수 있습니다. navigate() 호출 시 상세 동작 과정 Action 검색:\nNavController는 전달받은 action ID를 기반으로 Navigation Graph에서 해당 Action을 찾습니다.\nAction에는 이동할 목적지 Fragment (Destination) 정보와 전달할 데이터(Arguments) 등이 포함되어 있습니다.\nDestination 확인:\nAction에서 지정된 Destination Fragment의 유형을 확인합니다.\nFragment, Activity, DialogFragment, Custom Destination 등 다양한 유형의 Destination을 지원합니다.\n현재 상태 저장 (선택 사항):\nsaveState() 메서드를 통해 현재 Fragment의 상태를 저장할 수 있습니다.\n이는 Fragment가 다시 표시될 때 이전 상태를 복원하기 위해 필요합니다.\nArgument 전달 (선택 사항):\nSafe Args를 사용하여 Destination에 정의된 Argument를 전달할 수 있습니다.\nArgument는 Bundle 형태로 전달되며, Destination Fragment에서 arguments 속성을 통해 받을 수 있습니다.\nFragmentTransaction 생성:\nNavController는 FragmentManager를 사용하여 FragmentTransaction을 생성합니다.\nFragmentTransaction은 Fragment 추가, 삭제, 교체 등 Fragment 상태 변경 작업을 정의합니다.\nFragmentTransaction 실행:\n생성된 FragmentTransaction을 실행하여 새로운 Destination Fragment를 화면에 표시합니다.\n이때, 사용자가 정의한 Transition 애니메이션이나 기본 애니메이션이 적용될 수 있습니다.\nLifecycle Callback 호출:\nFragment 생명주기(onCreate, onViewCreated, onResume 등)에 따라 필요한 콜백 메서드가 호출됩니다.\n이를 통해 Fragment 초기화, 데이터 로드, UI 업데이트 등의 작업을 수행할 수 있습니다.\nBackStack 업데이트 (선택 사항):\nnavigate() 메서드에 addToBackStack 옵션을 true로 설정하면, 현재 Fragment가 BackStack에 추가됩니다.\n사용자가 뒤로 가기 버튼을 누르면 BackStack에 저장된 Fragment가 다시 표시됩니다.\n추가 고려 사항:\nViewModel 공유: by activityViewModels() 또는 by navGraphViewModels()를 사용하여 ViewModel을 공유하고, Fragment 간에 데이터를 안전하게 전달할 수 있습니다. Deep Link: navigate() 메서드에 URI를 전달하여 Deep Link를 통해 특정 Destination으로 이동할 수 있습니다. Navigation Listener: NavController.OnDestinationChangedListener를 등록하여 Destination 변경 이벤트를 감지하고 추가 작업을 수행할 수 있습니다. FragmentManager 를 통한 Transaction add: Host Activity의 생명주기에 Fragment 생명주기 추가, add된 Fragment는 onAttach ~ onResume까지 호출\nAdd a fragment to the activity state. remove: onPause ~ onDetach까지 호출, Fragment가 메모리에서 제거됨.\nRemove an existing fragment. If it was added to a container, its view is also removed from that container. replace: replace() 함수 인자로 지정된 Fragment를 제외한 나머지 모든 프래그먼트가 remove\n(나머지 Fragment는 onDetach 까지 호출, 지정된 Fragment는 onAttach ~ onResume ) show / hide: 기본적으로 add된 Fragment를 대상으로 View를 보이게 하거나 감춤.(visibility 변경)\nattach: 대상 Fragment의 onCreateView ~ onResume 까지 호출\nRe-attach a fragment after it had previously been detached from the UI with detach(android.app.Fragment). This causes its view hierarchy to be re-created, attached to the UI, and displayed. detach: 대상 Fragment의 onPause ~ onDestroyView 까지 호출\nDetach the given fragment from the UI. This is the same state as when it is put on the back stack: the fragment is removed from the UI backStack 에서 없어지면(pop되면), onDestoryView ~ onDetach 까지 호출\nbackStack 에 존재하면, onDestoryView 까지만 호출, 다시 backStack 최상단에 특정 Fragment가 존재하면, onCreateView 부터 호출\nA -\u0026gt; B로 naviagte() 시, B가 Create 되고, A가 Destory 됨. (선 Create, 후 Destory)\npopUpTo 속성으로 특정 Fragment를 지정하면, 그 사이의 NavBackStackEntry 은 backStack에서 제거된다. popUpToInclusive 속성을 true로 설정해주면, backStack popUpTo로 지정된 NavBackStackEntry 은 제거된다. popUpToInclusive 값을 지정하지 않으면, popUpToInclusive=false와 같다. false가 default ","permalink":"https://2taezeat.github.io/posts/android/jetpack-navigation/","summary":"Jetpack Navigation Jetpack Navigation의 장점:\n직관적인 Navigation 관리: Navigation Graph를 통해 앱의 Navigation 구조를 시각적으로 파악하고 관리할 수 있습니다. 유형 안전한 데이터 전달: Safe Args를 사용하여 Fragment 간에 데이터를 안전하게 전달할 수 있습니다. 간편한 Fragment 이동: navigate()와 popBackStack() 메서드를 사용하여 Fragment 이동을 간편하게 처리할 수 있습니다. deep link 지원: 앱 외부의 링크를 통해 특정 Fragment로 바로 이동할 수 있습니다. navigate() 호출 시 상세 동작 과정 Action 검색:\nNavController는 전달받은 action ID를 기반으로 Navigation Graph에서 해당 Action을 찾습니다.","title":"Jetpack Navigation 기초"},{"content":"Android View View 생명주기의 핵심 단계 생성 (Construction): View 객체가 생성되는 단계입니다. 생성자를 통해 초기화 작업을 수행합니다. 주로 XML 레이아웃 파일에서 View가 inflate 되거나, Kotlin/Java 코드에서 View 객체를 생성할 때 호출됩니다. 부착 (Attachment): View가 윈도우(Window)에 부착되는 단계입니다. onAttachedToWindow() 메서드가 호출됩니다. 이 시점부터 View는 화면에 표시될 준비가 되었으며, 사용자 입력을 처리할 수 있습니다. 리소스 할당이나 이벤트 리스너 등록 등 초기화 작업을 수행하기에 적합한 시점입니다. 측정 (Measurement): View의 크기를 결정하는 단계입니다. onMeasure() 메서드가 호출됩니다. 부모 View로부터 전달받은 제약 조건과 View 자신의 특성을 고려하여 View의 크기를 계산합니다. 배치 (Layout): View의 위치를 결정하는 단계입니다. onLayout() 메서드가 호출됩니다. 부모 View로부터 전달받은 크기와 위치 정보를 기반으로 View의 위치를 설정합니다. 자식 View가 있다면, 자식 View들의 위치도 결정합니다. 그리기 (Drawing): View의 내용을 화면에 그리는 단계입니다. onDraw() 메서드가 호출됩니다. Canvas 객체를 사용하여 View의 배경, 텍스트, 이미지 등을 그립니다. 분리 (Detachment): View가 윈도우에서 분리되는 단계입니다. onDetachedFromWindow() 메서드가 호출됩니다. 이 시점부터 View는 더 이상 화면에 표시되지 않으며, 사용자 입력을 처리할 수 없습니다. 사용하지 않는 리소스를 해제하고 이벤트 리스너를 제거하는 등 정리 작업을 수행하기에 적합한 시점입니다. View 생명주기 활용 예시\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class CustomView(context: Context, attrs: AttributeSet?) : View(context, attrs) { override fun onAttachedToWindow() { super.onAttachedToWindow() // 리소스 초기화, 이벤트 리스너 등록 등 } override fun onMeasure(widthMeasureSpec: Int, heightMeasureSpec: Int) { // View의 크기 계산 } override fun onLayout(changed: Boolean, left: Int, top: Int, right: Int, bottom: Int) { // View의 위치 설정 } override fun onDraw(canvas: Canvas) { // View의 내용 그리기 } override fun onDetachedFromWindow() { super.onDetachedFromWindow() // 리소스 해제, 이벤트 리스너 제거 등 } } invalidate() vs. requestLayout(): 차이점 및 사용 시점 invalidate()\n역할: View의 외관(appearance)이 변경되었을 때 호출하여 해당 View만 다시 그리도록 요청합니다. 동작: invalidate() 메서드가 호출되면 View는 \u0026ldquo;dirty\u0026rdquo; 상태로 표시됩니다. 다음 UI 렌더링 주기에서 시스템은 \u0026ldquo;dirty\u0026rdquo; 상태인 View의 onDraw() 메서드를 호출하여 다시 그립니다. View의 크기나 위치는 변경되지 않습니다. 사용 시점: View의 내용(텍스트, 색상, 이미지 등)이 변경되었을 때 View의 일부 영역만 다시 그려야 할 때 (예: invalidate(Rect) 사용) 애니메이션 효과를 구현할 때 requestLayout()\n역할: View의 크기나 위치가 변경되었을 때 호출하여 View의 측정 및 배치 과정을 다시 실행하도록 요청합니다. 동작: requestLayout() 메서드가 호출되면 View는 \u0026ldquo;layout requested\u0026rdquo; 상태로 표시됩니다. 다음 UI 렌더링 주기에서 시스템은 \u0026ldquo;layout requested\u0026rdquo; 상태인 View와 해당 View의 모든 자식 View에 대해 측정 (onMeasure()) 및 배치 (onLayout()) 과정을 다시 실행합니다. View의 내용은 변경되지 않을 수도 있습니다. 사용 시점: View의 크기 (LayoutParams)가 변경되었을 때 View의 내용 변경으로 인해 View의 크기가 변경될 수 있을 때 화면 회전 등으로 인해 레이아웃이 변경되어야 할 때 주의 사항\ninvalidate()는 View의 외관만 변경하므로, 크기나 위치 변경에는 영향을 미치지 않습니다. requestLayout()는 View의 크기나 위치를 변경하므로, 해당 View와 모든 자식 View의 측정 및 배치 과정을 다시 실행하여 성능에 영향을 줄 수 있습니다. 불필요한 invalidate() 또는 requestLayout() 호출은 UI 성능 저하를 야기할 수 있으므로 주의해야 합니다. 예시\n1 2 3 4 5 6 7 8 9 // 텍스트 내용 변경 (invalidate() 사용) textView.text = \u0026#34;새로운 텍스트\u0026#34; textView.invalidate() // View의 크기 변경 (requestLayout() 사용) val params = textView.layoutParams params.width = ViewGroup.LayoutParams.WRAP_CONTENT textView.layoutParams = params textView.requestLayout() Android View 계층 구조 Android View는 트리 형태의 계층 구조를 이루며, 이를 View 계층 구조(View Hierarchy)라고 합니다.\n각 View는 트리의 부모-자식 관계로 연결되어 있으며, 최상위 View를 루트 View(Root View) 라고 합니다.\n전위 순회 (root-\u0026gt; left -\u0026gt; right)\nView와 ViewGroup View: 화면에 보이는 UI 요소의 기본 단위입니다. TextView, ImageView, Button 등이 View에 해당합니다. ViewGroup: 다른 View들을 담는 컨테이너 역할을 하는 View입니다. LinearLayout, RelativeLayout, ConstraintLayout 등이 ViewGroup에 해당합니다. ViewGroup은 View를 상속받기 때문에 View의 모든 속성과 기능을 가지면서, 추가로 자식 View들을 관리하는 기능을 제공합니다. View 계층 구조의 특징 트리 구조: View 계층 구조는 하나의 루트 View를 시작으로 여러 개의 자식 View들이 연결되어 트리 형태를 이룹니다. 부모-자식 관계: 각 View는 하나의 부모 View를 가지며, 여러 개의 자식 View를 가질 수 있습니다. 레이아웃 관리: ViewGroup은 자식 View들의 크기와 위치를 결정하여 화면에 배치하는 역할을 합니다. 이벤트 전달: 터치, 클릭 등 사용자 이벤트는 View 계층 구조를 따라 전달됩니다. View 계층 구조의 예시 DecorView (Root View) ㄴ LinearLayout ㄴ TextView ㄴ ImageView ㄴ Button 위 예시에서 DecorView는 루트 View이며, LinearLayout은 DecorView의 자식 View이자 ViewGroup입니다.\nTextView, ImageView, Button은 LinearLayout의 자식 View입니다.\nView 계층 구조의 활용 UI 구성: View 계층 구조를 통해 다양한 UI 요소를 조합하여 복잡한 화면을 구성할 수 있습니다. 레이아웃 관리: ViewGroup을 사용하여 자식 View들의 배치를 효율적으로 관리할 수 있습니다. 커스텀 View 생성: View 클래스를 상속받아 새로운 View를 만들거나 기존 View의 기능을 확장할 수 있습니다. 이벤트 처리: View 계층 구조를 통해 사용자 이벤트를 처리하고 적절한 동작을 수행할 수 있습니다. 추가 정보 View 계층 구조는 액티비티(Activity)가 시작될 때 setContentView() 메서드를 통해 설정됩니다. View 계층 구조는 findViewById() 메서드를 통해 특정 View를 찾을 수 있습니다. View 계층 구조는 getParent() 메서드를 통해 부모 View를, getChildCount() 및 getChildAt() 메서드를 통해 자식 View들을 확인할 수 있습니다. Android에서 ConstraintLayout을 사용하는 이유와 설명 ConstraintLayout은 Android UI 개발에서 복잡한 레이아웃을 효율적으로 구성하기 위해 설계된 강력한 ViewGroup입니다.\n기존의 RelativeLayout이나 LinearLayout 등의 레이아웃 방식보다 더욱 유연하고 성능이 뛰어나다는 장점을 가지고 있습니다.\nConstraintLayout 사용 이유\n복잡한 레이아웃 구현 용이: 제약 조건(constraints) 을 사용하여 View 간의 관계를 정의함으로써 복잡한 레이아웃을 간결하게 표현할 수 있습니다. 상대적인 위치, 정렬, 비율 등 다양한 제약 조건을 설정하여 View를 원하는 위치에 배치할 수 있습니다. Guideline, Barrier, Group 등의 기능을 활용하여 더욱 유연한 레이아웃 구성이 가능합니다. 중첩 레이아웃 감소: ConstraintLayout은 View 간의 관계를 직접적으로 정의하므로, 불필요한 중첩 레이아웃을 줄일 수 있습니다. 중첩 레이아웃은 UI 성능 저하의 주요 원인이 될 수 있으므로, ConstraintLayout을 사용하면 성능 향상을 기대할 수 있습니다. 성능 향상: ConstraintLayout은 내부적으로 효율적인 알고리즘을 사용하여 레이아웃을 계산합니다. 따라서 렌더링 속도가 빠르고, 특히 복잡한 레이아웃에서 성능 이점을 얻을 수 있습니다. 다양한 화면 크기 지원: ConstraintLayout은 다양한 화면 크기와 해상도에 대한 적응성이 뛰어납니다. 제약 조건을 사용하여 View의 크기와 위치를 상대적으로 설정하므로, 다양한 기기에서 일관된 UI를 유지할 수 있습니다. ConstraintLayout은 다음과 같은 주요 기능을 제공합니다.\n제약 조건 (Constraints): View의 위치, 크기, 정렬 등을 다른 View나 부모 레이아웃에 상대적으로 정의합니다. Guideline: View의 위치를 잡기 위한 보조선 역할을 합니다. 수직 또는 수평 Guideline을 생성하여 View를 정렬하거나 배치할 수 있습니다. Barrier: 여러 View의 위치를 기준으로 동적으로 생성되는 보이지 않는 장벽입니다. Barrier를 사용하여 특정 View들이 특정 위치를 넘어가지 않도록 제한할 수 있습니다. Group: 여러 View를 하나의 그룹으로 묶어서 관리합니다. 그룹 단위로 Visibility를 설정하거나 제약 조건을 적용할 수 있습니다. Chains: 여러 View를 연결하여 일렬로 배치하고 간격을 조절하는 기능입니다. Android Data Binding Android Data Binding은 UI 레이아웃과 데이터를 연결하여 UI 업데이트를 단순화하는 라이브러리입니다.\nData Binding의 핵심 기능:\n데이터 바인딩 표현식: 레이아웃 파일에서 데이터를 직접 참조하고 조작할 수 있습니다.\n예를 들어 @{user.name}과 같이 데이터 객체의 속성을 참조하여 TextView에 표시할 수 있습니다. 이벤트 핸들링: 버튼 클릭과 같은 이벤트 발생 시 데이터 객체의 메서드를 호출하거나 특정 로직을 실행할 수 있습니다.\nObservable 객체: 데이터가 변경될 때 UI를 자동으로 업데이트할 수 있도록 Observable 객체를 사용합니다. LiveData, ObservableField 등이 이에 해당합니다.\nBinding Adapter: Data Binding 표현식에서 사용할 수 있는 커스텀 속성을 정의하고, 속성 값에 따라 View의 속성을 변경하는 로직을 구현할 수 있습니다.\nData Binding 사용 이유:\nUI 코드 간소화: UI 업데이트를 위한 findViewById() 및 setText()와 같은 반복적인 코드 작성을 줄여줍니다. 가독성 향상: UI 로직이 레이아웃 파일에 명확하게 표현되어 코드의 가독성이 좋아집니다. 오류 감소: 데이터 바인딩 표현식의 유효성을 컴파일 타임에 검사하여 런타임 오류 발생 가능성을 줄여줍니다. 유지보수성 향상: UI 로직과 데이터 로직이 분리되어 유지보수가 용이해집니다. 프로그래매틱 방식이 아니라, 선언적 방식을 사용하여 UI 구성요소를 데이터에 결합할 수 있는 지원 라이브러리 뷰를 데이터 객체와 결합하는 데 필요한 클래스를 자동으로 생성 (view와 data를 바인딩) DataBinding으로 인해 ViewModel이 View를 알지 못해도, 다양한 인터랙션 처리 가능 Model에서 데이터가 변경되면, ViewModel에 전달 변경된 데이터가 ViewModel에서 View로 전달되도록 LiveData, RxJava, Kotlin Flow을 사용해 구현 옵저버 패턴 or Reactive(반응형) 프로그래밍 binding 클래스 자동 생성 Android Data Binding 라이브러리를 사용하면 레이아웃 파일(*.xml)에 대응하는 바인딩 클래스가 자동으로 생성됩니다.\n이 바인딩 클래스는 레이아웃 파일의 UI 요소와 데이터를 연결하는 데 사용됩니다.\n자동 생성 클래스 규칙\n클래스 이름: 레이아웃 파일 이름을 파스칼 표기법(PascalCase)으로 변환하고 \u0026ldquo;Binding\u0026rdquo; 접미사를 붙입니다. 예를 들어 activity_main.xml 레이아웃 파일은 ActivityMainBinding 클래스로 변환됩니다. 클래스 위치: build 디렉토리 안에 생성됩니다. (예: app/build/generated/data_binding_base_class_source_out/debug/out/com/example/databinding/) 클래스 구성: 레이아웃 파일의 각 View 요소에 대한 참조 변수 데이터 바인딩 표현식에 정의된 변수에 대한 getter/setter 메서드 inflate() 메서드: 레이아웃 파일을 inflate하고 바인딩 객체를 생성하는 정적 메서드 Android BindingAdapter DataBinding에서, 데이터 바인딩 표현식과 View의 속성을 연결하는 역할을 합니다.\n기본적으로 제공되는 BindingAdapter 외에도 개발자가 직접 정의하여 커스텀 속성과 View의 동작을 연결할 수 있습니다.\nBindingAdapter의 주요 기능:\n커스텀 속성: @BindingAdapter 어노테이션을 사용하여 View의 속성과 연결할 커스텀 속성을 정의할 수 있습니다. 예를 들어, ImageView에 이미지 URL을 바인딩하는 app:imageUrl 속성을 만들 수 있습니다. 속성 값 변환: BindingAdapter 메서드를 통해 데이터 모델의 값을 View의 속성 값으로 변환하는 로직을 구현할 수 있습니다. 예를 들어, app:imageUrl 속성에 전달된 URL 문자열을 Glide 라이브러리를 사용하여 이미지로 변환하여 ImageView에 표시할 수 있습니다. Android View Binding vs. Data Binding 비교 Android View Binding과 Data Binding은 모두 레이아웃 파일의 View에 쉽게 접근하고 UI 업데이트를 용이하게 하는 데 사용되는 라이브러리입니다.\nView Binding\n핵심 기능: 레이아웃 파일에 정의된 View에 대한 참조를 자동으로 생성합니다. findViewById() 메서드를 사용하지 않고 View에 직접 접근할 수 있습니다. Null 안정성을 보장합니다. (ID가 없는 View에 접근하려고 하면 컴파일 오류 발생) 장점: 빌드 시간에 바인딩 클래스를 생성하므로 런타임 성능에 영향을 주지 않습니다. Data Binding보다 가볍고 간결합니다. findViewById() 메서드 사용 시 발생할 수 있는 null 관련 오류를 방지합니다. 단점: 레이아웃 파일과 코드 간의 데이터 바인딩 기능은 제공하지 않습니다. 양방향 데이터 바인딩이나 복잡한 UI 로직을 구현하기 어렵습니다. Data Binding\n핵심 기능: 레이아웃 파일과 데이터를 직접 연결하여 UI 업데이트를 자동화합니다. 데이터 변경 시 UI를 자동으로 갱신합니다. 이벤트 리스너를 간편하게 설정할 수 있습니다. BindingAdapter를 사용하여 커스텀 속성을 정의하고 View의 동작을 제어할 수 있습니다. 장점: UI 로직을 레이아웃 파일에 명시하여 코드의 가독성을 높입니다. 데이터 변경에 따른 UI 업데이트를 자동화하여 생산성을 향상시킵니다. 양방향 데이터 바인딩과 복잡한 UI 로직 구현이 가능합니다. 단점: 빌드 시간이 다소 증가할 수 있습니다. View Binding보다 학습 곡선이 가파릅니다. 복잡한 표현식 사용 시 런타임 성능에 영향을 줄 수 있습니다. Android Custom View 설명 Android Custom View는 기본으로 제공되는 View 클래스들을 조합하거나 상속하여 개발자가 직접 정의하는 View입니다.\n기존 View로 표현하기 어려운 복잡한 UI나 특정 기능을 구현할 때 유용하게 사용됩니다.\nCustom View를 만드는 이유\n재사용성: 자주 사용되는 UI 요소를 Custom View로 만들어 여러 곳에서 재사용할 수 있습니다. 캡슐화: Custom View 내부의 로직을 캡슐화하여 코드의 복잡성을 줄이고 유지보수를 용이하게 합니다. 유연성: 기존 View의 기능을 확장하거나 새로운 기능을 추가하여 원하는 디자인과 동작을 구현할 수 있습니다. Custom View 종류\n기존 View 조합: 여러 개의 기존 View를 조합하여 새로운 UI 요소를 만듭니다. 예: 복합적인 레이아웃, 특정 디자인의 버튼 등 View 상속: View 클래스를 상속받아 새로운 View를 만듭니다. 예: 원형 ProgressBar, 특정 모양의 그래프 등 ViewGroup 상속: ViewGroup 클래스를 상속받아 여러 자식 View를 포함하는 Custom View를 만듭니다. 예: RecyclerView와 유사한 리스트 뷰 등 Custom View 생성 방법\n클래스 생성: View 또는 ViewGroup 클래스를 상속받아 새로운 클래스를 만듭니다. 생성자 정의: Context와 AttributeSet을 매개변수로 받는 생성자를 정의합니다. 속성 정의: attrs.xml 파일에 Custom View의 속성을 정의합니다. 메서드 오버라이딩: 필요에 따라 View의 생명주기 메서드 (onMeasure(), onLayout(), onDraw())를 오버라이딩하여 Custom View의 동작을 구현합니다. RecyclerView RecyclerView : 많은 수의 데이터 집합(Data Set)을 개별 아이템 단위로 구성하여 화면에 출력하는 뷰그룹(ViewGroup) 이며, 한 화면에 표시되기 힘든 많은 수의 데이터를 스크롤 가능한 리스트로 표시해주는 위젯입니다.\n리스트뷰(ListView)의 경우, 문제점 중의 하나는, 리스트 항목이 갱신될 때마다, 매번 아이템 뷰를 새로 구성해야 한다는 것이었습니다.\n리스트뷰의 단점을 참고하여, 리사이클러뷰는 아이템을 표시하기 위해 생성한 뷰를 재활용(recycle)합니다. 애니메이션 불가, 수직만 가능 Adapter : 리사이클러뷰에 표시될 ‘아이템 뷰’를 생성하는 역할은 어댑터가 담당합니다. 사용자 데이터 리스트로부터 ‘아이템 뷰’를 만드는 것, 그것이 바로 어댑터가 하는 역할이죠.\nlayoutManger : 레이아웃매니저는 리사이클러뷰가 아이템을 화면에 표시할 때, 아이템 뷰들이 리사이클러뷰 내부에서 배치되는 형태를 관리하는 요소입니다\nViewHolder : 뷰홀더(ViewHolder)는 화면에 표시될 아이템 뷰를 저장하는 객체입니다.\nRecyclerView.Adapter를 상속받아 새로운 어댑터를 만들 때, 오버라이드가 필요한 메서드는 아래와 같습니다.\nonCreateViewHolder() : ViewHolder를 새로 만들어야 할 때 호출되는 메서드이다. 이 메서드를 통해 각 아이템을 위한 XML 레이아웃을 이용한 뷰 객체를 생성하고 뷰 홀더에 담아 리턴한다. 이때는 뷰의 콘텐츠를 채우지 않는다. 왜냐하면 아직 ViewHolder가 특정 데이터에 바인딩된 상태가 아니기 때문이다.\nonBindViewHolder() : ViewHolder 를 ’어떠한 데이터와 연결할 때’ 호출되는 메소드로, 이를 통해 ’뷰 홀더 객체들의 레이아웃’을 채우게 된다. position 이라는 파라미터를 활용하여 데이터의 순서에 맞게 아이템 레이아웃을 바인딩해줄 수 있다.\nViewHolder 패턴은, 각 뷰의 객체를 ViewHolder 에 보관함으로써 뷰의 내용을 업데이트하기 위한 findViewById() 메소드 호출을 줄여 효과적으로 퍼포먼스 개선을 할 수 있는 패턴이다.\nViewHolder 패턴을 사용하면, 한 번 생성하여 저장했던 뷰는 다시 findViewById() 를 통해 뷰를 불러올 필요가 사라지게 된다.\n만약 데이터가 1번부터 10번까지 10개 있고, 이를 리스트 형태로 보여줄 때 스마트폰의 화면 크기 상 1번부터 5번까지 보여준다고 가정해보자. 그럼 사용자가 스크롤을 하게 되면, 최상단에 있던 1번 및 2번 아이템의 레이아웃은 눈에 보이지 않게 될 것이다. 그와 동시에 6번 및 7번 아이템이 화면에 새롭게 보여지지 않겠는가? 이 때, 6번 및 7번 아이템을 화면에 표시하기 위해 findViewById() 를 일일히 호출하여 레이아웃에 데이터를 바인딩하지 않고, 기존에 1번 및 2번 아이템을 그려줄 때 사용했던 View 를 재사용하여 이미 불러왔었던 레이아웃에 데이터만 채워주는 것이다. 재사용성을 높였을 뿐더러 불필요한 High-Cost 동작을 줄인 것이다. Android RecyclerView 구성 요소 Android RecyclerView는 복잡한 리스트를 효율적으로 표시하기 위한 강력한 도구입니다.\nViewHolder 패턴: 각 아이템을 나타내는 ViewHolder를 사용하여 뷰 재활용을 통해 성능을 향상시킵니다.\n1. RecyclerView:\n역할: 화면에 아이템 목록을 표시하는 뷰(View)입니다. 스크롤, 아이템 추가/삭제 등의 기능을 담당합니다. 특징: 유연한 레이아웃: 다양한 LayoutManager를 사용하여 리스트, 그리드, 폭포수 등 다양한 형태로 아이템을 배치할 수 있습니다. 효율적인 뷰 재활용: ViewHolder 패턴을 사용하여 화면 밖으로 사라진 아이템 뷰를 재활용하여 메모리 사용량을 줄이고 성능을 향상시킵니다. 2. Adapter:\n역할: 데이터와 RecyclerView를 연결하는 다리 역할을 합니다. 데이터를 ViewHolder에 바인딩하고, ViewHolder를 생성하여 RecyclerView에 제공합니다. 핵심 메서드: onCreateViewHolder(): ViewHolder 객체 생성, 이 메서드를 통해 각 아이템을 위한 XML 레이아웃을 이용한 뷰 객체를 생성하고 ViewHodler에 담아 리턴한다. 이때는 뷰의 콘텐츠를 채우지 않는다. 왜냐하면 아직 ViewHolder가 특정 데이터에 바인딩된 상태가 아니기 때문이다. onBindViewHolder(): ViewHolder에 데이터를 바인딩합니다. getItemCount(): 전체 아이템 개수를 반환합니다. 3. ViewHolder:\n역할: 말 그대로, 각 아이템의 View를 담고(Hold) 있는 객체입니다. 뷰 재활용을 위해 뷰를 참조하고 데이터를 바인딩하는 역할을 합니다. 특징: itemView 속성을 통해 아이템 뷰에 접근할 수 있습니다. adapter의onBindViewHolder() 에서 ViewHolder에서 우리가 작성한 bind 함수를 호출해 데이터를 바인딩합니다. 4. LayoutManager:\n역할: 아이템 뷰를 화면에 배치하는 방식을 결정합니다. 종류: LinearLayoutManager: 아이템을 수직 또는 수평으로 배치합니다. GridLayoutManager: 아이템을 격자 형태로 배치합니다. StaggeredGridLayoutManager: 아이템을 엇갈리게 배치합니다. (Custom LayoutManager): 개발자가 직접 정의한 레이아웃 방식을 사용할 수 있습니다. 5. ItemDecoration:\n역할: 아이템 뷰 사이에 구분선, 간격 등을 추가하여 시각적인 효과를 줍니다. 6. ItemAnimator:\n역할: 아이템 추가, 삭제, 이동 등의 변경 사항에 대한 애니메이션 효과를 제공합니다. RecyclerView 작동 방식:\n1. 초기화 단계:\nRecyclerView는 Adapter에게 화면에 표시될 아이템 개수(getItemCount())를 요청합니다. LayoutManager는 화면 크기와 아이템 크기를 기반으로 초기 화면에 표시할 아이템 개수를 계산합니다. RecyclerView는 Adapter에게 필요한 만큼의 ViewHolder를 요청합니다. Adapter는 onCreateViewHolder() 메서드를 호출하여 ViewHolder를 생성하고 각 아이템에 해당하는 레이아웃을 inflate 합니다. RecyclerView는 생성된 ViewHolder를 LayoutManager에게 전달합니다. LayoutManager는 ViewHolder를 화면에 배치하고, Adapter에게 각 ViewHolder의 데이터 바인딩을 요청합니다. Adapter는 onBindViewHolder() 메서드를 호출하여 ViewHolder에 데이터를 설정합니다. 2. 스크롤 및 뷰 재활용 단계:\n사용자가 RecyclerView를 스크롤하면 화면 밖으로 사라지는 아이템 뷰는 RecyclerView의 Recycler Pool로 이동합니다.\n화면에 새로운 아이템이 나타나면 RecyclerView는 Recycler Pool에서 재활용 가능한 ViewHolder를 찾습니다.\n재활용 가능한 ViewHolder가 있으면, Adapter는 onBindViewHolder() 메서드를 호출하여 새로운 데이터를 바인딩합니다.\n재활용 가능한 ViewHolder가 없으면, Adapter는 onCreateViewHolder() 메서드를 호출하여 새로운 ViewHolder를 생성합니다.\nLayoutManager는 새로운 또는 재활용된 ViewHolder를 화면에 배치합니다.\nRecyclerView 장점:\n유연성: 다양한 레이아웃과 아이템 유형을 지원하여 복잡한 UI를 쉽게 구현할 수 있습니다. 성능: ViewHolder 패턴과 뷰 재활용을 통해 대량의 데이터를 효율적으로 처리할 수 있습니다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 class PlaylistAdapter : ListAdapter\u0026lt;PlaylistUiModel, PlaylistAdapter.PlaylistViewHolder\u0026gt;(PlaylistItemDiffUtil) { override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): PlaylistViewHolder { return PlaylistViewHolder.from(parent) } override fun onBindViewHolder(holder: PlaylistViewHolder, position: Int) { holder.bind(currentList[position]) } class PlaylistViewHolder private constructor(private val binding: ItemPlaylistBinding) : RecyclerView.ViewHolder(binding.root) { private val moreMessage = itemView.context.getText(R.string.develop_in_future) init { binding.ibMore.setOnClickListener { Snackbar.make(itemView, moreMessage, Snackbar.LENGTH_LONG).show() } } fun bind(item: PlaylistUiModel) { binding.playlist = item } companion object { fun from(parent: ViewGroup) = PlaylistViewHolder( ItemPlaylistBinding.inflate( LayoutInflater.from(parent.context), parent, false ) ) } } object PlaylistItemDiffUtil : DiffUtil.ItemCallback\u0026lt;PlaylistUiModel\u0026gt;() { override fun areItemsTheSame(oldItem: PlaylistUiModel, newItem: PlaylistUiModel): Boolean { return oldItem.id == newItem.id // 아이템의 고유 ID 비교 } override fun areContentsTheSame(oldItem: PlaylistUiModel, newItem: PlaylistUiModel): Boolean { return oldItem == newItem // 아이템 내용 비교 } } } Android ListAdapter 설명 RecyclerView.Adapter를 상속받아 구현되었으며, DiffUtil을 내부적으로 사용하여 데이터 변경 시 효율적인 업데이트를 수행합니다.\nListAdapter의 주요 특징:\nDiffUtil 기반 업데이트: DiffUtil을 사용하여 이전 목록과 새 목록 간의 차이점을 계산하고, 변경된 부분만 업데이트합니다.\n이는 notifyDataSetChanged()처럼 전체 목록을 새로고침하는 것보다 성능이 훨씬 좋습니다. 백그라운드 스레드 활용: DiffUtil의 차이점 계산은 백그라운드 스레드에서 수행되므로 UI 스레드를 차단하지 않아 부드러운 UI를 유지할 수 있습니다.\n간편한 사용: submitList() 메서드를 통해 새 목록을 전달하면 ListAdapter가 알아서 차이점 계산 및 업데이트를 처리합니다.\n애니메이션 지원: DefaultItemAnimator와 함께 사용하면 변경된 아이템에 대한 애니메이션 효과를 자동으로 적용할 수 있습니다.\nListAdapter 사용 방법:\nListAdapter 상속: RecyclerView.Adapter 대신 ListAdapter를 상속받아 Adapter 클래스를 생성합니다. DiffUtil.ItemCallback 구현: 데이터 클래스의 어떤 속성을 기준으로 아이템의 동일성과 내용 변경을 판단할지 정의하는 DiffUtil.ItemCallback 객체를 생성합니다. submitList() 호출: 데이터 변경 시 submitList() 메서드를 호출하여 새 목록을 전달합니다. DiffUtil.ItemCallback 사용 방법:\nItemCallback 구현: DiffUtil.ItemCallback을 상속받아 추상 메서드인 areItemsTheSame()과 areContentsTheSame()를 구현합니다.\nDiffUtil.calculateDiff() 호출: DiffUtil.calculateDiff() 메서드에 구현한 ItemCallback 객체와 이전 목록, 새 목록을 전달하여 DiffResult 객체를 얻습니다.\n1 2 3 4 val diffCallback = MyDiffCallback() val diffResult = DiffUtil.calculateDiff(diffCallback) diffResult.dispatchUpdatesTo(myAdapter) Adapter 업데이트: DiffResult 객체의 dispatchUpdatesTo() 메서드를 호출하여 RecyclerView의 Adapter에 변경 사항을 알립니다.\nListAdapter 사용 시 주의 사항:\nDiffUtil.ItemCallback을 정확하게 구현해야 합니다. 아이템의 동일성과 내용 변경을 정확하게 판단하지 못하면 업데이트가 제대로 이루어지지 않을 수 있습니다.\nareItemsTheSame() 함수가 먼저 실행이 되고 해당 함수의 결과로 true 가 반환됐을 경우에만, areContentsTheSame() 이 호출됩니다.\n그렇기 때문에 areItemsTheSame() 에는 id 처럼 아이템을 식별할 수 있는 유니크한 값을 비교하고,\nareContentsTheSame() 에는 아이템의 내부 정보가 모두 동일한지 비교합니다.\nsubmitList() 메서드 호출 시 이전 목록과 새 목록을 비교하는 데 시간이 소요될 수 있습니다. 따라서 너무 자주 호출하지 않도록 주의해야 합니다.\nListAdapter는 RecyclerView.Adapter의 모든 기능을 지원하지 않을 수 있습니다. 필요한 기능이 있는지 확인하고, 필요하다면 직접 구현해야 합니다.\n","permalink":"https://2taezeat.github.io/posts/android/android-view/","summary":"Android View View 생명주기의 핵심 단계 생성 (Construction): View 객체가 생성되는 단계입니다. 생성자를 통해 초기화 작업을 수행합니다. 주로 XML 레이아웃 파일에서 View가 inflate 되거나, Kotlin/Java 코드에서 View 객체를 생성할 때 호출됩니다. 부착 (Attachment): View가 윈도우(Window)에 부착되는 단계입니다. onAttachedToWindow() 메서드가 호출됩니다. 이 시점부터 View는 화면에 표시될 준비가 되었으며, 사용자 입력을 처리할 수 있습니다. 리소스 할당이나 이벤트 리스너 등록 등 초기화 작업을 수행하기에 적합한 시점입니다. 측정 (Measurement): View의 크기를 결정하는 단계입니다. onMeasure() 메서드가 호출됩니다.","title":"Android View 기초"},{"content":"Kotest 특징과 Given-When-Then 패턴 Kotest 특징\n다양한 테스트 스타일: FunSpec, StringSpec, ShouldSpec, BehaviorSpec, FeatureSpec, WordSpec, FreeSpec, DescribeSpec 등 다양한 테스트 스타일을 지원하여 테스트 코드를 원하는 방식으로 작성할 수 있습니다.\n코틀린 DSL: 코틀린 DSL(Domain-Specific Language)을 사용하여 테스트 코드를 간결하고 읽기 쉽게 작성할 수 있습니다.\nJUnit 호환성: JUnit 플랫폼 위에서 동작하므로 기존 JUnit 테스트와 함께 사용할 수 있습니다.\n확장성: 다양한 테스트 확장 기능(Property Testing, Data-Driven Testing 등)을 제공하여 복잡한 테스트 시나리오를 쉽게 구현할 수 있습니다.\nMatchers: 다양한 Matcher를 제공하여 테스트 결과를 더욱 명확하게 표현할 수 있습니다.\n비동기 테스트 지원: 코루틴을 사용하여 비동기 테스트를 간편하게 작성할 수 있습니다.\nGiven-When-Then 패턴\nGiven-When-Then 패턴은 BDD(Behavior-Driven Development)에서 사용되는 테스트 작성 패턴으로, 테스트 시나리오를 세 단계로 나누어 작성합니다.\nGiven (준비): 테스트에 필요한 초기 상태를 설정합니다. When (실행): 테스트 대상 코드를 실행합니다. Then (검증): 실행 결과를 검증합니다. Kotest는 Given-When-Then 패턴을 지원하는 BehaviorSpec 스타일을 제공합니다.\nKotest BehaviorSpec 예시:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class CalculatorTest : BehaviorSpec({ val calculator = Calculator() given(\u0026#34;두 개의 숫자\u0026#34;) { val a = 1 val b = 2 `when`(\u0026#34;덧셈 연산을 수행하면\u0026#34;) { val result = calculator.add(a, b) then(\u0026#34;결과는 3이어야 한다\u0026#34;) { result shouldBe 3 } } } }) Android Unit Test vs. Integration Test (Instrumented Test) Unit Test (단위 테스트):\n목표: 앱의 가장 작은 단위인 개별 클래스나 메서드의 기능을 독립적으로 검증합니다.\n실행 환경: JVM (Java Virtual Machine) 상에서 실행되며, Android 프레임워크에 대한 의존성 없이 테스트를 수행합니다.\n테스트 대상: ViewModel, Repository, UseCase, Data Model 등\n도구: JUnit, Mockito, Truth, MockK 등\n장점:\n빠른 실행 속도: Android 프레임워크를 실행하지 않으므로 테스트 속도가 매우 빠릅니다. 격리된 환경: 외부 요인에 영향을 받지 않고 독립적으로 테스트할 수 있습니다. 높은 재현성: 동일한 입력에 대해 항상 동일한 결과를 보장합니다. 단점:\nAndroid 의존성 테스트 불가: Android 프레임워크(Context, Activity, View 등)와의 상호 작용을 테스트할 수 없습니다.\nMock 객체 필요: 외부 의존성을 가진 경우 Mock 객체를 사용하여 의존성을 대체해야 합니다.\nIntegration Test (Instrumented Test) (통합 테스트):\n목표: 여러 컴포넌트 간의 상호 작용을 테스트하거나, 실제 Android 환경에서 앱의 동작을 검증합니다. 실행 환경: Android 기기 또는 에뮬레이터에서 실행됩니다. 테스트 대상: Activity, Fragment, Service, Content Provider 등 종류: UI 테스트 (Espresso): 사용자 인터페이스 요소의 동작을 테스트합니다. 통합 테스트: 여러 컴포넌트 간의 상호 작용을 테스트합니다. 도구: Espresso, UI Automator, Robolectric 등 장점: 실제 환경 테스트: 실제 Android 환경에서 앱의 동작을 테스트할 수 있습니다. Android 의존성 테스트 가능: Android 프레임워크와의 상호 작용을 테스트할 수 있습니다. 단점: 느린 실행 속도: Android 환경을 실행해야 하므로 테스트 속도가 상대적으로 느립니다. 낮은 재현성: 외부 요인(네트워크, 다른 앱 등)에 의해 테스트 결과가 달라질 수 있습니다. ","permalink":"https://2taezeat.github.io/posts/android/android-testing-%EC%A0%95%EB%A6%AC/","summary":"Kotest 특징과 Given-When-Then 패턴 Kotest 특징\n다양한 테스트 스타일: FunSpec, StringSpec, ShouldSpec, BehaviorSpec, FeatureSpec, WordSpec, FreeSpec, DescribeSpec 등 다양한 테스트 스타일을 지원하여 테스트 코드를 원하는 방식으로 작성할 수 있습니다.\n코틀린 DSL: 코틀린 DSL(Domain-Specific Language)을 사용하여 테스트 코드를 간결하고 읽기 쉽게 작성할 수 있습니다.\nJUnit 호환성: JUnit 플랫폼 위에서 동작하므로 기존 JUnit 테스트와 함께 사용할 수 있습니다.\n확장성: 다양한 테스트 확장 기능(Property Testing, Data-Driven Testing 등)을 제공하여 복잡한 테스트 시나리오를 쉽게 구현할 수 있습니다.","title":"Android Testing 기초"},{"content":"Android Retrofit 설명 Retrofit은 Square에서 개발한 안드로이드 및 JVM 환경에서 사용되는 타입-세이프(type-safe) HTTP 클라이언트 라이브러리입니다.\nREST API 기반의 네트워크 통신을 간편하고 효율적으로 처리할 수 있도록 도와줍니다.\nRetrofit의 주요 특징:\n타입 안정성: Retrofit은 인터페이스를 사용하여 API 엔드포인트를 정의하고, 어노테이션을 통해 HTTP 요청 메서드(GET, POST, PUT, DELETE 등)와 파라미터를 명시합니다. 이를 통해 컴파일 시점에 오류를 확인할 수 있어 안정적인 코드 작성이 가능합니다. 선언적인 API: Retrofit은 선언적인 방식으로 API 인터페이스를 정의하여 코드의 가독성을 높이고 유지보수를 용이하게 합니다. 비동기 처리: Retrofit은 기본적으로 OkHttp 라이브러리를 사용하여 네트워크 요청을 비동기적으로 처리합니다. 따라서 UI 스레드를 차단하지 않고 백그라운드 스레드에서 네트워크 작업 수행 확장성: Retrofit은 Converter, CallAdapter 등 다양한 확장 기능을 제공하여 JSON, XML 등 다양한 데이터 형식을 지원하고, RxJava, Coroutines 등 다양한 비동기 처리 방식을 사용할 수 있습니다. Retrofit 구성 요소 1. 인터페이스 (Interface):\nREST API의 엔드포인트를 정의합니다. 각 엔드포인트는 HTTP 메서드(GET, POST, PUT, DELETE 등)와 URL 경로, 파라미터 등을 포함합니다. Retrofit은 이 인터페이스를 기반으로 동적인 프록시 객체를 생성하여 실제 네트워크 요청을 처리합니다. 1 2 3 4 5 6 7 interface ApiService { @GET(\u0026#34;users/{user}\u0026#34;) fun getUser(@Path(\u0026#34;user\u0026#34;) user: String): Call\u0026lt;User\u0026gt; @POST(\u0026#34;users/new\u0026#34;) fun createUser(@Body user: User): Call\u0026lt;User\u0026gt; } 2. 어노테이션 (Annotation):\n인터페이스의 메서드에 사용되어 HTTP 요청 정보를 명시합니다. @GET, @POST, @PUT, @DELETE, @PATCH, @HEAD 등의 HTTP 메서드 어노테이션을 사용하여 요청 방식을 지정합니다. @Path, @Query, @Body, @Header 등의 어노테이션을 사용하여 URL 경로, 쿼리 파라미터, 요청 본문, 헤더 등을 설정합니다. 1 2 @GET(\u0026#34;users/{user}\u0026#34;) fun getUser(@Path(\u0026#34;user\u0026#34;) user: String): Call\u0026lt;User\u0026gt; 3. Retrofit 객체:\n인터페이스를 기반으로 동적인 프록시 객체를 생성합니다. Retrofit.Builder를 사용하여 Retrofit 객체를 생성하고, 베이스 URL, Converter, CallAdapter 등을 설정합니다. 1 2 3 4 val retrofit = Retrofit.Builder() .baseUrl(\u0026#34;https://api.example.com/\u0026#34;) .addConverterFactory(GsonConverterFactory.create()) .build() 4. Call 객체:\n네트워크 요청(Request) 을 나타내는 객체입니다. enqueue() 메서드를 호출하여 비동기 요청을 보내고, execute() 메서드를 호출하여 동기 요청을 보냅니다. 콜백 메서드(onResponse, onFailure)를 통해 요청 결과를 처리합니다. 1 2 3 4 val call = apiService.getUser(\u0026#34;JohnDoe\u0026#34;) call.enqueue(object : Callback\u0026lt;User\u0026gt; { // ... }) 5. Converter:\n서버 응답 데이터(JSON)를 객체로 변환하는 역할을 합니다. Gson, Moshi, Jackson 등의 라이브러리를 Converter로 사용할 수 있습니다. Retrofit.Builder의 addConverterFactory() 메서드를 사용하여 Converter를 추가합니다. Android Retrofit 사용 시 주의 사항 1. 메인 스레드 네트워크 작업 금지:\nRetrofit은 기본적으로 OkHttp를 사용하여 네트워크 요청을 처리합니다. 안드로이드에서는 메인 스레드에서 네트워크 작업을 수행하면 NetworkOnMainThreadException 예외가 발생합니다. 따라서, Coroutine, RxJava, 또는 Executor 등을 사용하여 네트워크 요청을 백그라운드 스레드에서 처리해야 합니다. 2. 에러 핸들링:\n네트워크 요청은 항상 실패할 가능성이 있으므로, 예외 처리를 철저히 해야 합니다. Retrofit은 onFailure() 콜백 또는 RxJava의 onError() 메서드를 통해 에러를 처리할 수 있습니다. HTTP 상태 코드(404, 500 등)에 따른 적절한 에러 메시지를 사용자에게 표시해야 합니다. 3. 응답 데이터 처리:\n서버에서 받은 응답 데이터는 JSON, XML 등 다양한 형식일 수 있습니다. Retrofit은 Gson, Moshi, Jackson 등의 Converter를 사용하여 응답 데이터를 자바 객체로 변환할 수 있습니다. 데이터 변환 과정에서 발생할 수 있는 예외를 처리해야 합니다. Android Retrofit 에서 coroutine을 사용하면, 백그라운드 스레드에서 처리되는 이유 1. Main Thread 안전성 (Main Thread Safety):\n안드로이드는 UI 업데이트와 사용자 입력 처리를 담당하는 메인 스레드(Main Thread) 를 가지고 있습니다.\n메인 스레드에서 시간이 오래 걸리는 작업(예: 네트워크 요청)을 수행하면 UI가 멈추거나 응답하지 않는 현상이 발생할 수 있습니다.\n이를 ANR(Application Not Responding) 이라고 합니다. Coroutine은 suspend 함수를 통해 비동기 작업을 간편하게 처리할 수 있도록 도와주는 기능입니다.\nRetrofit과 Coroutine을 함께 사용하면 suspend 함수 내에서 네트워크 요청을 수행하고, 요청이 완료될 때까지 해당 Coroutine을 일시 중단(suspend)시킵니다.\n이때 Coroutine은 백그라운드 스레드로 전환되어 네트워크 요청을 처리 하고, 요청이 완료되면 다시 메인 스레드로 돌아와 결과를 처리 합니다.\n이러한 방식으로 메인 스레드를 차단하지 않고 네트워크 요청을 처리하여 UI의 반응성을 유지할 수 있습니다.\n2. Retrofit의 Main Safety 보장:\nRetrofit 2.6.0 버전부터는 Coroutine을 공식적으로 지원하며, suspend 함수를 사용하여 네트워크 요청을 수행할 수 있습니다. Retrofit은 내부적으로 OkHttp 라이브러리를 사용하여 네트워크 요청을 처리하는데, OkHttp는 기본적으로 백그라운드 스레드에서 네트워크 작업을 수행하도록 설계되어 있다. 따라서 Retrofit에서 Coroutine을 사용하더라도, 실제 네트워크 요청은 OkHttp에 의해 백그라운드 스레드에서 처리됩니다. 이는 Coroutine의 Main Safety 보장 기능과 함께 작동하여, 개발자가 명시적으로 백그라운드 스레드를 지정하지 않아도 안전하게 네트워크 요청을 처리할 수 있도록 합니다. Android OkHttp 설명 OkHttp는 Square에서 개발한 강력하고 효율적인 HTTP 클라이언트 라이브러리입니다. 안드로이드 뿐만 아니라 자바 및 코틀린 환경에서도 사용할 수 있습니다.\nOkHttp는 HTTP/2, WebSocket 등 최신 웹 기술을 지원하며, 안정성과 성능이 뛰어나다는 장점을 가지고 있습니다.\nOkHttp 주요 특징:\nHTTP/2 지원: HTTP/2 프로토콜을 지원하여 다중화, 헤더 압축, 서버 푸시 등의 기능을 활용하여 네트워크 성능을 향상시킵니다. 연결 풀링: 연결 풀링을 통해 여러 요청을 효율적으로 처리하고, 연결 재사용을 통해 성능을 최적화합니다. 투명한 GZIP 압축: 응답 데이터를 자동으로 압축하여 네트워크 대역폭을 절약합니다. 응답 캐싱: 응답 데이터를 캐싱하여 동일한 요청을 반복할 때 네트워크 트래픽을 줄이고 응답 시간을 단축합니다. 요청 재시도: 네트워크 오류 발생 시 자동으로 요청을 재시도하여 안정성을 높입니다. Interceptor 지원: Interceptor를 사용하여 요청 및 응답을 가로채서 로깅, 헤더 추가, 인증 등 다양한 작업을 수행할 수 있습니다. WebSocket 지원: WebSocket 프로토콜을 지원하여 실시간 양방향 통신을 구현할 수 있습니다. OkHttp와 Retrofit의 관계:\nRetrofit은 OkHttp의 기능을 활용하면서, 더욱 간편하고 직관적인 API를 제공하여 REST API 통신을 쉽게 구현할 수 있도록 도와줍니다.\nOkHttp: 저수준 HTTP 클라이언트, 강력하고 유연하지만 사용하기 복잡\nRetrofit: OkHttp 기반 고수준 라이브러리, 간편하고 직관적인 API, 선언적 방식, 비동기 처리 지원\nOkHttp 사용 방법:\nOkHttpClient 생성: OkHttpClient 객체를 생성하고 필요에 따라 설정을 변경합니다.\n1 2 3 4 5 val client = OkHttpClient.Builder() .addInterceptor(HttpLoggingInterceptor().apply { level = HttpLoggingInterceptor.Level.BODY }) .build() Request 생성: Request.Builder를 사용하여 요청 객체를 생성하고 URL, 헤더, 요청 본문 등을 설정합니다.\n요청 실행: OkHttpClient 객체의 newCall() 메서드를 사용하여 요청을 실행하고 enqueue() 메서드를 통해 비동기적으로 응답을 처리합니다.\n1 2 3 4 5 6 7 8 9 client.newCall(request).enqueue(object : Callback { override fun onFailure(call: Call, e: IOException) { // 요청 실패 처리 } override fun onResponse(call: Call, response: Response) { // 응답 성공 처리 val body = response.body?.string() } }) OkHttp Interceptor 설명 OkHttp Interceptor는 네트워크 요청 및 응답을 가로채서 추가 작업을 수행하거나 수정할 수 있는 강력한 기능입니다.\n로깅, 인증, 캐싱, 헤더 수정, 요청/응답 데이터 변환 등 다양한 목적으로 활용될 수 있습니다.\n1. Application Interceptor:\n역할: 애플리케이션 레벨에서 요청 및 응답을 가로챕니다. 실제 네트워크 연결이 이루어지기 전후에 동작하며, 캐시된 응답에도 적용됩니다.\n주요 용도:\n로깅 (Logging): 요청 및 응답 정보를 로그로 출력하여 디버깅을 돕습니다. 헤더 추가 (Header Modification): 모든 요청에 공통적으로 추가해야 하는 헤더(예: 인증 토큰, API 키)를 설정합니다. 인증 (Authentication): 요청에 인증 정보를 추가하거나, 응답을 기반으로 인증 토큰을 갱신합니다. 요청/응답 수정 (Request/Response Rewriting): 요청 URL, 파라미터, 응답 데이터 등을 수정합니다. OkHttpClient.Builder의 addInterceptor() 메서드를 사용하여 추가합니다.\n2. Network Interceptor:\n역할: 네트워크 레벨에서 요청 및 응답을 가로챕니다. 실제 네트워크 연결이 이루어질 때만 동작하며, 캐시된 응답에는 적용되지 않습니다. 주요 용도: 캐싱 (Caching): 응답 데이터를 캐시에 저장하거나 캐시된 응답을 반환하여 네트워크 트래픽을 줄입니다. 압축 (Compression): 요청 및 응답 데이터를 압축하여 네트워크 대역폭을 절약합니다. 요청 재시도 (Retry): 네트워크 오류 발생 시 자동으로 요청을 재시도합니다. 네트워크 연결 변경 (Connection Modification): 특정 조건에 따라 다른 네트워크 연결을 사용하도록 변경합니다. OkHttpClient.Builder의 addNetworkInterceptor() 메서드를 사용하여 추가합니다. Interceptor 사용 예시:\n1 2 3 4 5 6 val client = OkHttpClient.Builder() .addInterceptor(HttpLoggingInterceptor().apply { level = HttpLoggingInterceptor.Level.BODY }) .addNetworkInterceptor(StethoInterceptor()) .build() HttpLoggingInterceptor: 요청 및 응답 정보를 로그로 출력하는 Interceptor입니다. 디버깅에 유용합니다. 커스텀 Interceptor 생성:\n1 2 3 4 5 6 7 8 9 class AuthInterceptor(private val token: String) : Interceptor { override fun intercept(chain: Interceptor.Chain): Response { val originalRequest = chain.request() val newRequest = originalRequest.newBuilder() .header(\u0026#34;Authorization\u0026#34;, \u0026#34;Bearer $token\u0026#34;) .build() return chain.proceed(newRequest) } } 위 예시는 요청 헤더에 인증 토큰을 추가하는 커스텀 Interceptor를 보여줍니다.\nInterceptor 활용 팁:\n여러 Interceptor를 사용할 때는 순서가 중요합니다. 요청(Request)은 추가된 순서대로 Interceptor를 거치고, 응답(Reply)은 역순으로 Interceptor를 거칩니다. Interceptor는 강력한 기능을 제공하지만, 과도하게 사용하면 성능 저하를 일으킬 수 있습니다. Interceptor를 사용하여 민감한 정보(예: API 키, 개인 정보)를 로깅하지 않도록 주의해야 합니다. ","permalink":"https://2taezeat.github.io/posts/android/android-network/","summary":"Android Retrofit 설명 Retrofit은 Square에서 개발한 안드로이드 및 JVM 환경에서 사용되는 타입-세이프(type-safe) HTTP 클라이언트 라이브러리입니다.\nREST API 기반의 네트워크 통신을 간편하고 효율적으로 처리할 수 있도록 도와줍니다.\nRetrofit의 주요 특징:\n타입 안정성: Retrofit은 인터페이스를 사용하여 API 엔드포인트를 정의하고, 어노테이션을 통해 HTTP 요청 메서드(GET, POST, PUT, DELETE 등)와 파라미터를 명시합니다. 이를 통해 컴파일 시점에 오류를 확인할 수 있어 안정적인 코드 작성이 가능합니다. 선언적인 API: Retrofit은 선언적인 방식으로 API 인터페이스를 정의하여 코드의 가독성을 높이고 유지보수를 용이하게 합니다.","title":"Android Network 기초"},{"content":"Android Hilt Hilt는 Android 앱 개발에서 의존성 주입(Dependency Injection, DI)을 쉽고 효율적으로 구현하기 위한 Jetpack 라이브러리입니다.\nDagger 기반으로 만들어졌으며, Android 환경에 최적화되어 있습니다.\n의존성 주입 (DI) 이란?\n객체 간의 의존 관계를 직접 생성하지 않고 외부에서 주입하는 방식입니다. 클래스 간의 결합도를 낮추고 유연성, 재사용성, 테스트 용이성을 높이는 데 도움을 줍니다. Hilt의 장점\nAndroid 환경에 최적화: Activity, Fragment, View, ViewModel 등 Android 컴포넌트의 생명주기를 고려하여 의존성을 관리합니다. 각 컴포넌트에 필요한 의존성을 자동으로 주입하여 보일러플레이트 코드를 줄여줍니다. Dagger 기반: Dagger의 강력한 기능을 활용하면서도 더욱 간편하게 사용할 수 있습니다. Hilt는 Dagger의 복잡한 설정을 대신 처리해주므로, 개발자는 핵심 로직에 집중할 수 있습니다. 표준화된 방법: Hilt는 Android 앱에서 DI를 구현하는 표준적인 방법을 제공합니다. 따라서 다른 개발자와의 협업이 용이하고, 코드의 일관성을 유지할 수 있습니다. Hilt 주요 구성 요소\n@HiltAndroidApp: 애플리케이션 클래스에 사용하여 Hilt를 활성화합니다.\n@AndroidEntryPoint: Activity, Fragment, View, Service, BroadcastReceiver 등 Android 컴포넌트에 사용하여 Hilt가 의존성을 주입하도록 합니다.\n@Inject: 의존성을 주입받을 필드 또는 생성자에 사용합니다.\n@Module: 의존성을 제공하는 클래스에 사용합니다.\n@Provides: @Module 클래스 내에서 의존성 객체를 생성하는 메서드에 사용합니다.\n@Binds: @Module 클래스 내에서 인터페이스 구현체를 바인딩하는 메서드에 사용합니다.\n@Singleton, @ActivityScoped, @FragmentScoped, @ViewScoped 등: 의존성 객체의 생명주기를 지정하는 어노테이션입니다.\nHilt 사용 방법\n의존성 추가: build.gradle 파일에 Hilt 의존성을 추가합니다. 애플리케이션 클래스에 @HiltAndroidApp 추가: 애플리케이션 클래스에 @HiltAndroidApp 어노테이션을 추가하여 Hilt를 활성화합니다. 컴포넌트에 @AndroidEntryPoint 추가: 의존성을 주입받을 Activity, Fragment 등의 컴포넌트에 @AndroidEntryPoint 어노테이션을 추가합니다. @Inject 어노테이션 사용: 의존성을 주입받을 필드 또는 생성자에 @Inject 어노테이션을 추가합니다. @Module 및 @Provides/@Binds 어노테이션 사용: 의존성을 제공하는 클래스에 @Module 어노테이션을 추가하고, @Provides 또는 @Binds 어노테이션을 사용하여 의존성 객체를 생성하거나 바인딩합니다. 의존성 주입 컴포넌트 Container(Component) 은 외부에서 클래스의 인스턴스를 생성하는 공간\nModule 는 클래스의 인스턴스들을 모아놓은 공간으로 Container에 의존성을 제공함\nContainer 안에 Module이 존재\n기존 IOC에는 Module이라는 개념이 없지만, Dagger에서는 특정 Container(Component)가 제공해야 하는 의존성이 Module 단위로 관리되어야 한다는 것이 편하다는 것을 고려하여 Module을 통해 클래스의 인스턴스들을 모듈 단위로 관리한다.\nProvider(Provides)\nProvider은 인스턴스를 제공(Provide) 하는 역할을 한다. 즉, 주입부의 인스턴스를 제공하는 것이 바로 Provider이다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 @Component(modules = [StringModule::class]) interface StringComponent{ fun injectString(student: Student) } @Module class StringModule { @Provides fun providesString() = \u0026#34;StringA\u0026#34; } class Student(){ @Inject lateinit var name: String } Dagger에서는 컴파일 타임에 Component Interface의 Annotation을 읽어 java(generated) 폴더에 다음과 같은 클래스들을 생성해준다.\n즉, 우리가 구현하는 Component는 Interface이며, Dagger에서 해당 인터페이스(interface StringComponent)를 구현하는 클래스를 자동 생성(class DaggerStringComponen)해주며\n해당 클래스를 통해 Provider에 의해 제공되는 변수를 Inject 할 수 있다. Hilt에서 @Provides와 @Binds의 차이 @Inject Annotation을 붙이는 방법말고,\nModule을 이용해서 Hilt에게 원하는 Dependency를 생성하는 방법을 알려줄 수 있습니다.\n특히, interface나 외부 라이브러리의 객체처럼, Hilt가 어떻게 객체를 생성해야할지 모르는 경우에는 꼭 필요한 방법입니다.\nProvides Annnotation과 Binds Annotation을 이용하는 것 입니다 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 @HiltAndroidApp class MyApplication : Application() { ... } @AndroidEntryPoint class MainActivity : AppCompatActivity() { @Inject lateinit var analyticsAdapter: AnalyticsAdapter // ... } @Module @InstallIn(SingletonComponent::class) object AnalyticsModule { @Provides @Singleton fun provideAnalyticsAdapter( // ... ): AnalyticsAdapter { // ... } } @Provides\n주입할 객체를 직접 생성하는 메서드에 사용됩니다.\n객체 생성 로직을 메서드 안에 구현하여 유연하게 의존성을 제공할 수 있습니다.\n생성자 주입이 어렵거나 불가능한 경우(예: 외부 라이브러리 클래스, 복잡한 생성 로직), 팩토리 메서드를 통해 객체를 생성해야 하는 경우에 유용합니다.\n@Binds\n인터페이스의 구현체를 Hilt에게 알려주는 메서드에 사용됩니다. 추상 메서드로 선언되어야 하며, 반환 타입은 인터페이스, 메서드 매개변수는 해당 인터페이스를 구현하는 클래스여야 합니다. 런타임 성능에 최적화되어 있으며, @Provides보다 더 간결하게 코드를 작성할 수 있습니다. 특징 @Provides @Binds 객체 생성 방식 메서드 내부에서 직접 생성 인터페이스 구현체를 Hilt에 알려줌 사용 시점 생성자 주입이 어렵거나 복잡한 객체 생성 시 인터페이스와 구현체 관계가 명확할 때 성능 @Binds에 비해 약간 느림 @Provides에 비해 빠름 코드 간결성 @Binds에 비해 코드가 길어질 수 있음 @Provides에 비해 간결함 ","permalink":"https://2taezeat.github.io/posts/android/android-hilt/","summary":"Android Hilt Hilt는 Android 앱 개발에서 의존성 주입(Dependency Injection, DI)을 쉽고 효율적으로 구현하기 위한 Jetpack 라이브러리입니다.\nDagger 기반으로 만들어졌으며, Android 환경에 최적화되어 있습니다.\n의존성 주입 (DI) 이란?\n객체 간의 의존 관계를 직접 생성하지 않고 외부에서 주입하는 방식입니다. 클래스 간의 결합도를 낮추고 유연성, 재사용성, 테스트 용이성을 높이는 데 도움을 줍니다. Hilt의 장점\nAndroid 환경에 최적화: Activity, Fragment, View, ViewModel 등 Android 컴포넌트의 생명주기를 고려하여 의존성을 관리합니다. 각 컴포넌트에 필요한 의존성을 자동으로 주입하여 보일러플레이트 코드를 줄여줍니다.","title":"Android Hilt 기초"},{"content":"Android 빌드 과정 Android 빌드 과정은 개발자가 작성한 소스 코드, 리소스 파일, 라이브러리 등을\n최종적으로 안드로이드 기기에서 실행 가능한 APK(Android Package Kit) 파일로 만드는 과정입니다.\n이 과정은 여러 단계를 거치며, 각 단계에서 다양한 도구와 기술이 사용됩니다.\n1. 빌드 준비:\nGradle 설정: build.gradle 파일에서 빌드 설정을 확인하고 필요한 플러그인, 의존성 라이브러리, 빌드 변수(Build Variant) 등을 설정합니다.\nManifest 병합: 애플리케이션의 AndroidManifest.xml 파일과 라이브러리의 매니페스트 파일을 병합하여 최종 매니페스트 파일을 생성합니다.\n리소스 병합: 애플리케이션의 리소스 파일과 라이브러리의 리소스 파일을 병합하고, 중복된 리소스를 처리합니다.\n2. 컴파일:\nJava/Kotlin 컴파일: Java 또는 Kotlin 소스 코드를 컴파일하여 .class 파일(Java 바이트코드)을 생성합니다.\nAIDL 컴파일: AIDL(Android Interface Definition Language) 파일을 컴파일하여 .java 인터페이스 파일을 생성합니다.\nR 클래스 생성: 리소스 파일을 컴파일하여 R 클래스를 생성합니다. R 클래스는 리소스 ID를 정수 값으로 매핑하여 코드에서 리소스에 접근할 수 있도록 합니다.\n3. DEX 변환:\nD8/R8 컴파일: .class 파일들을 DEX(Dalvik Executable) 형식으로 변환합니다. DEX는 Android 런타임에서 실행 가능한 바이트코드 형식입니다.\n코드 축소 (R8): 불필요한 코드를 제거하고 난독화하여 APK 파일 크기를 줄입니다.\n4. APK 패키징:\nAPK 생성: DEX 파일, 컴파일된 리소스, AndroidManifest.xml 파일, 서명 정보 등을 포함하는 APK 파일을 생성합니다.\n서명: APK 파일에 개발자의 서명을 추가하여 앱의 무결성과 출처를 보장합니다.\n정렬: APK 파일 내의 파일들을 정렬하여 앱 설치 및 로딩 속도를 향상시킵니다.\n5. 배포:\nGoogle Play Store: APK 파일을 Google Play Store에 업로드하여 사용자에게 배포합니다.\nAd-hoc 배포: APK 파일을 직접 사용자에게 전달하여 설치하도록 합니다.\n빌드 도구:\nGradle: Android 빌드 시스템으로, 빌드 과정을 자동화하고 관리하는 데 사용됩니다.\nAndroid Studio: Android 공식 IDE로, Gradle 기반 빌드 시스템을 내장하고 있으며, 편리한 빌드 및 배포 기능을 제공합니다.\n빌드 변형 (Build Variant):\n빌드 유형 (Build Type): debug, release 등 빌드 유형에 따라 다른 설정을 적용할 수 있습니다. 제품 특성 (Product Flavor): free, paid 등 제품 특성에 따라 다른 기능이나 리소스를 포함하는 APK를 생성할 수 있습니다. Android 멀티 모듈 구성 방법 안드로이드 앱을 멀티 모듈로 구성하면 코드의 재사용성, 유지보수성, 빌드 성능을 향상시킬 수 있습니다.\n멀티 모듈 구성은 앱을 여러 개의 작은 모듈로 분리하여 각 모듈이 특정 기능이나 레이어를 담당하도록 하는 것을 의미합니다.\n멀티 모듈 구성의 장점:\n재사용성 향상: 공통 기능을 모듈화하여 여러 프로젝트에서 재사용할 수 있습니다. 유지보수 용이: 모듈별로 코드를 분리하여 관리하므로 코드의 복잡성을 줄이고 유지보수를 쉽게 할 수 있습니다. 빌드 성능 향상: 변경된 모듈만 다시 빌드하여 빌드 시간을 단축할 수 있습니다. 협업 용이: 모듈별로 개발을 분담하여 팀 협업을 효율적으로 진행할 수 있습니다. 테스트 용이성: 모듈 단위로 테스트를 수행하여 테스트 커버리지를 높이고 오류를 조기에 발견할 수 있습니다. 멀티 모듈 구성 방법:\n모듈 분리 기준 설정: 기능별: 각 기능(로그인, 검색, 설정 등)을 담당하는 모듈로 분리합니다. 레이어별: UI, 데이터, 도메인 등 레이어별로 모듈을 분리합니다. 공통 모듈: 여러 모듈에서 공통으로 사용하는 기능(네트워크, 유틸리티 등)을 모듈화합니다. 모듈 생성: Android Studio에서 File -\u0026gt; New -\u0026gt; New Module을 선택합니다. Android Library 또는 Java/Kotlin Library를 선택하여 모듈을 생성합니다. 모듈 간 의존성 설정: build.gradle 파일에서 implementation 또는 api 키워드를 사용하여 모듈 간의 의존성을 설정합니다. api는 해당 모듈의 API를 외부에 공개할 때 사용하고, implementation은 외부에 공개하지 않을 때 사용합니다. 코드 및 리소스 이동: 각 모듈에 맞게 코드와 리소스를 이동하고, 필요한 경우 인터페이스를 정의하여 모듈 간 통신을 구현합니다. 멀티 모듈 구성 예시:\nMyApplication ├── app (Application Module) │ └── ... ├── core (Core Module) │ └── ... (네트워크, 유틸리티 등) ├── feature (Feature Modules) │ ├── login │ │ └── ... (로그인 관련 코드) │ ├── search │ │ └── ... (검색 관련 코드) │ └── settings │ └── ... (설정 관련 코드) └── data (Data Module) └── ... (데이터베이스, API 관련 코드) 주의 사항:\n순환 의존성 방지: 모듈 간에 순환(cycle) 의존성이 발생하지 않도록 주의해야 합니다, 단뱡향 지향 인터페이스 활용: 모듈 간의 결합도를 낮추기 위해 인터페이스를 적극적으로 활용합니다. 테스트 코드 작성: 각 모듈에 대한 테스트 코드를 작성하여 품질을 보장합니다. Gradle Plugin Gradle 플러그인은 재사용 가능한 빌드 로직을 패키지로 구성하여 다양한 프로젝트와 빌드에서 사용할 수 있습니다.\nGradle을 사용하면 자신만의 플러그인을 구현할 수 있으므로 빌드 로직을 재사용하고 다른 사람들과 공유할 수 있습니다.\nPlugin이란 빌드에 관련된 로직(task, dependency\u0026hellip;) 등을 모아서 재사용할 수 있게 도와주는 역할을 합니다.\norg.jetbrains.kotlin.android, com.android.application 등 안드로이드에서 사용하는 Plugin이며 내부적으로 Android 빌드에 필요한 코드로 구성되어 있습니다. buildScript 형식으로 프로젝트 내부에서 사용할 수 있으며, 독립 형태로 만들어서 배포하여 프로젝트 외부에서도 사용할 수 있습니다.\nGradle Plugin 구현 1. 프로젝트 단위 settings.gradle.kts에 Gradle Plugin 프로젝트를 추가합니다. 1 2 3 4 5 pluginManagement { repositories { includeBuild(\u0026#34;build-logic\u0026#34;) } } 2. 루트 프로젝트에 Gradle Plugin 프로젝트를 만들고 build.gradle.kts, settings.gradle.kts를 생성합니다. 프로젝트 구조\nProject - build-logic - build.gradle.kts - settings.gradle.kts build.gradle.kts\nPlugin 구현에 필요한 의존성을 추가할 수 있습니다. Hilt를 구현한다면 com.google.dagger:hilt-android-gradle-plugin 같이 필요한 의존성을 추가합니다. VersionCatalog를 사용할 수 있습니다. 1 2 3 4 5 6 7 8 9 10 11 12 plugins { `kotlin-dsl` } java { sourceCompatibility = JavaVersion.VERSION_17 targetCompatibility = JavaVersion.VERSION_17 } dependencies { } settings.gradle.kts\nVersionCatalog를 추가하여 사용할 수 있습니다. 1 2 3 4 5 6 7 8 9 10 11 12 13 dependencyResolutionManagement { repositories { google() mavenCentral() gradlePluginPortal() } versionCatalogs { create(\u0026#34;libs\u0026#34;) { from(files(\u0026#34;../gradle/libs.versions.toml\u0026#34;)) } } } 3. Plugin 구현 Plugin 인터페이스를 상속받고 공통된 로직을 구현합니다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 internal class HiltPlugin : Plugin\u0026lt;Project\u0026gt; { override fun apply(target: Project) { applyPlugin(target.pluginManager) applyDependency(target.dependencies, target.getVersionCatalog()) applyKapt(target.extensions.getByType()) } private fun applyPlugin(manager: PluginManager) = with(manager) { apply(\u0026#34;com.google.dagger.hilt.android\u0026#34;) apply(\u0026#34;org.jetbrains.kotlin.kapt\u0026#34;) } private fun applyDependency(handler: DependencyHandler, libs: VersionCatalog) = with(handler) { implementation(libs.findLibrary(\u0026#34;hilt-android\u0026#34;).get()) kapt(libs.findLibrary(\u0026#34;hilt-compiler\u0026#34;).get()) } private fun applyKapt(extension: KaptExtension) = with(extension) { correctErrorTypes = true } } ","permalink":"https://2taezeat.github.io/posts/android/android-build/","summary":"Android 빌드 과정 Android 빌드 과정은 개발자가 작성한 소스 코드, 리소스 파일, 라이브러리 등을\n최종적으로 안드로이드 기기에서 실행 가능한 APK(Android Package Kit) 파일로 만드는 과정입니다.\n이 과정은 여러 단계를 거치며, 각 단계에서 다양한 도구와 기술이 사용됩니다.\n1. 빌드 준비:\nGradle 설정: build.gradle 파일에서 빌드 설정을 확인하고 필요한 플러그인, 의존성 라이브러리, 빌드 변수(Build Variant) 등을 설정합니다.\nManifest 병합: 애플리케이션의 AndroidManifest.xml 파일과 라이브러리의 매니페스트 파일을 병합하여 최종 매니페스트 파일을 생성합니다.\n리소스 병합: 애플리케이션의 리소스 파일과 라이브러리의 리소스 파일을 병합하고, 중복된 리소스를 처리합니다.","title":"Android Build 기초"},{"content":"개요 Testing 프레임워크로 Kotest 에 대해 소개하고, 간단한 test 코드를 작성해본다. Mockk library를 통해 mocking 객체를 생성 할 수 있다. 특징 multi-platform\nJVM, Javascript and Native 을 지원한다. Gradle 4.6 이상에서, useJUnitPlatform()을 추가한 다음 Kotest junit5 depencency를 추가하기만 하면 된다. 코틀린 DSL 지원\n기존에 사용하던 Junit과 AssertJ, Mockito를 사용하면 Mocking이나 Assertion 과정에서 코틀린 DSL 을 활용할 수 있다. Kotest Mockk와 같은 도구들을 사용하면 아래처럼 코틀린 DSL과 Infix를 사용해 코틀린 스타일의 테스트 코드를 작성할 수 있다. 다양한, Kotest Testing Styles\nFun Spec : ScalaTest Describe Spec : Javascript frameworks and RSpec Should Spec : A Kotest original String Spec : A Kotest original Behavior Spec : BDD frameworks Free Spec : ScalaTest Word Spec : ScalaTest Feature Spec : Cucumber Expect Spec : A Kotest original Annotation Spec : JUnit Conditional tests with enabled flags\nKotest는 테스트에 구성 플래그를 설정하여 테스트를 비활성화할 수 있도록 지원한다. Spec ordering\n기본적으로 Spec 클래스의 순서는 정의되어 있지 않다. @Order( ) 로 순서를 지정할 수 있다. 1 2 3 4 @Order(1) class FooTest : FunSpec() { } @Order(0) class BarTest: FunSpec() {} Assertion Assertion 모듈은 상태를 테스트하는 함수의 모음이다. Kotest는 이러한 유형의 상태 Assertion 함수를 Matcher 라고 부른다. Core Matchers kotest-assertions-core module에서 제공한다.\nGeneral obj.shouldBe(other) General purpose assertion that the given obj and other are both equal expr.shouldBeTrue() Convenience assertion that the expression is true. Equivalent to expr.shouldBe(true) expr.shouldBeFalse() Convenience assertion that the expression is false. Equivalent to expr.shouldBe(false) shouldThrow\u0026lt;T\u0026gt; { block } General purpose construct that asserts that the block throws a T Throwable or a subtype of T shouldThrowExactly\u0026lt;T\u0026gt; { block } General purpose construct that asserts that the block throws exactly T shouldThrowAny { block } General purpose construct that asserts that the block throws a Throwable of any type shouldThrowMessage(message) { block } Verifies that a block of code throws any Throwable with given message Inspectors Inspectors를 사용하면 Collection 요소를 테스트할 수 있다.\nforAll : asserts every element passes the assertions forNone : asserts no element passes forOne : asserts only a single element passed forAtMostOne : asserts that either 0 or 1 elements pass forAtLeastOne : asserts that 1 or more elements passed forAtLeast(k) : is a generalization that k or more elements passed forAtMost(k) : is a generalization that k or fewer elements passed forAny : is an alias for forAtLeastOne forSome : asserts that between 1 and n-1 elements passed. Ie, if NONE pass or ALL pass then we consider that a failure. forExactly(k) : is a generalization that exactly k elements passed. This is the basis for the implementation of the other methods Setting libs.versions.toml\n1 2 3 4 5 6 7 kotest = \u0026#34;5.8.0\u0026#34; mockk = \u0026#34;1.13.8\u0026#34; kotest-runner = { group = \u0026#34;io.kotest\u0026#34;, name = \u0026#34;kotest-runner-junit5\u0026#34;, version.ref = \u0026#34;kotest\u0026#34; } kotest-property = { group = \u0026#34;io.kotest\u0026#34;, name = \u0026#34;kotest-property\u0026#34;, version.ref = \u0026#34;kotest\u0026#34; } kotest-extentions-junitxml = { group = \u0026#34;io.kotest\u0026#34;, name = \u0026#34;kotest-extensions-junitxml\u0026#34;, version.ref = \u0026#34;kotest\u0026#34; } mockk = { group = \u0026#34;io.mockk\u0026#34;, name = \u0026#34;mockk\u0026#34;, version.ref = \u0026#34;mockk\u0026#34; } testing을 수행하는 모듈의 build.gradle.kts\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 tasks.withType\u0026lt;Test\u0026gt;().configureEach { useJUnitPlatform() } tasks.getByName\u0026lt;Test\u0026gt;(\u0026#34;test\u0026#34;) { useJUnitPlatform() reports { junitXml.required.set(false) } systemProperty(\u0026#34;gradle.build.dir\u0026#34;, project.buildDir) } dependencies { api(libs.coroutines) implementation(libs.inject) testImplementation(libs.kotest.runner) testImplementation(libs.kotest.property) testImplementation(libs.kotest.extentions.junitxml) testImplementation(libs.mockk) } ~~test-result.xml 를 얻기 위한 코드\n참조 : https://kotest.io/docs/extensions/junit_xml.html 1 2 3 4 5 6 7 8 9 class KoTestConfig : AbstractProjectConfig() { override fun extensions(): List\u0026lt;Extension\u0026gt; = listOf( JunitXmlReporter( includeContainers = false, // don\u0026#39;t write out status for all tests useTestPathAsName = true, // use the full test path (ie, includes parent test names) outputDir = \u0026#34;../build/test-results\u0026#34; ) ) } 구현한 Test 코드 Coroutine Flow throttleFirst 확장 함수 Unit Test\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 class CoroutineUtilsKtTest : BehaviorSpec({ given(\u0026#34;throttleFirst 테스트하기 위해, delay(100)인 flow를 생성한다\u0026#34;) { val testFlow = flow { repeat(3) { num -\u0026gt; emit(num) delay(100) } } `when`(\u0026#34;windowDuration 을 400 만큼 주면\u0026#34;) { val result = mutableListOf\u0026lt;Int\u0026gt;() runTest { testFlow.throttleFirst(400) .onEach { result.add(it) } .launchIn(this) } then(\u0026#34;result는 [0]이 반환 된다.\u0026#34;) { result shouldBe listOf(0) } } `when`(\u0026#34;windowDuration 을 190 만큼 주면\u0026#34;) { val result = mutableListOf\u0026lt;Int\u0026gt;() runTest { testFlow.throttleFirst(190) .onEach { result.add(it) } .launchIn(this) } then(\u0026#34;result는 [0,2]이 반환 된다.\u0026#34;) { result shouldBe listOf(0, 2) } } `when`(\u0026#34;windowDuration 을 30 만큼 주면\u0026#34;) { val result = mutableListOf\u0026lt;Int\u0026gt;() runTest { testFlow.throttleFirst(30) .onEach { result.add(it) } .launchIn(this) } then(\u0026#34;result는 [0,1,2]이 반환 된다.\u0026#34;) { result shouldBe listOf(0, 1, 2) } } } }) GetPlaylistsUseCase Unit Test, Mocking 사용\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 const val RECENT_PLAYLIST_ID = 0 class GetPlaylistsUseCase @Inject constructor( private val playlistRepository: PlaylistRepository ) { operator fun invoke(): Flow\u0026lt;List\u0026lt;Playlist\u0026gt;\u0026gt; = combine( playlistRepository.getPlaylists(), playlistRepository.getRecentPlaylist() ) { playlists, recentPlaylist -\u0026gt; (playlists + Playlist( id = RECENT_PLAYLIST_ID, title = \u0026#34;최근 재생 목록\u0026#34;, thumbnailUrl = recentPlaylist.firstOrNull()?.imageUrl ?: \u0026#34;\u0026#34;, trackSize = recentPlaylist.size, )).sortedBy { it.id } } } class GetPlaylistsUseCaseTest : BehaviorSpec({ given(\u0026#34;GetPlaylistsUseCase 호출 하는 상황에서\u0026#34;) { val playlistRepository: PlaylistRepository = mockk() val getPlaylistsUseCase = GetPlaylistsUseCase(playlistRepository) val dummyRecentMusics = listOf( Music( id = \u0026#34;odio\u0026#34;, title = \u0026#34;dis\u0026#34;, artist = \u0026#34;epicurei\u0026#34;, imageUrl = \u0026#34;https://duckduckgo.com/?q=dolorum\u0026#34;, musicUrl = \u0026#34;https://search.yahoo.com/search?p=volutpat\u0026#34; ), Music( id = \u0026#34;quot\u0026#34;, title = \u0026#34;reque\u0026#34;, artist = \u0026#34;iuvaret\u0026#34;, imageUrl = \u0026#34;http://www.bing.com/search?q=efficitur\u0026#34;, musicUrl = \u0026#34;https://www.google.com/#q=maximus\u0026#34; ) ) val dummyPlaylists = listOf( Playlist( id = 7316, title = \u0026#34;maiorum\u0026#34;, thumbnailUrl = \u0026#34;http://www.bing.com/search?q=novum\u0026#34;, trackSize = 5275 ), Playlist( id = 7862, title = \u0026#34;dictum\u0026#34;, thumbnailUrl = \u0026#34;https://duckduckgo.com/?q=commune\u0026#34;, trackSize = 2537 ) ) `when`(\u0026#34;playlistId이 RECENT_PLAYLIST_ID 이라면\u0026#34;) { every { playlistRepository.getPlaylists() } returns flow { emit(dummyPlaylists) } every { playlistRepository.getRecentPlaylist() } returns flow { emit(dummyRecentMusics) } val result = getPlaylistsUseCase.invoke().first() val excepted = Playlist( id = RECENT_PLAYLIST_ID, title = \u0026#34;최근 재생 목록\u0026#34;, thumbnailUrl = \u0026#34;https://duckduckgo.com/?q=dolorum\u0026#34;, trackSize = 2, ) then(\u0026#34;recentMusics 들로 새로운 Playlist를 만들고 합치고, id로 정렬한 새로운 Playlist를 반환한다.\u0026#34;) { result.first() shouldBe excepted } } } }) Reference https://kotest.io/ https://techblog.woowahan.com/5825/ ","permalink":"https://2taezeat.github.io/posts/2023/kotest-%EB%8F%84%EC%9E%85%EA%B8%B0/","summary":"개요 Testing 프레임워크로 Kotest 에 대해 소개하고, 간단한 test 코드를 작성해본다. Mockk library를 통해 mocking 객체를 생성 할 수 있다. 특징 multi-platform\nJVM, Javascript and Native 을 지원한다. Gradle 4.6 이상에서, useJUnitPlatform()을 추가한 다음 Kotest junit5 depencency를 추가하기만 하면 된다. 코틀린 DSL 지원\n기존에 사용하던 Junit과 AssertJ, Mockito를 사용하면 Mocking이나 Assertion 과정에서 코틀린 DSL 을 활용할 수 있다. Kotest Mockk와 같은 도구들을 사용하면 아래처럼 코틀린 DSL과 Infix를 사용해 코틀린 스타일의 테스트 코드를 작성할 수 있다.","title":"Kotest 도입기"},{"content":"가정 멀티 모듈과 클린 아키텍처를 적용한 상태한 안드로이드 앱이다. 네트워크 라이브러리로, okHttp3와, Retrofit2를 사용하고 있다. 직렬화 라이브러리로 kotlinx.serialization을 사용하고 있다. 서버 개발자와 http response에 대한, request를 충분히 논의하고 합의할 수 있는 상태이다. 네트워크 예외 처리를 할 때, 참여하는 모든 안드로이드 개발자가 일관되고 가독성이 높게 개발하려면 어떻게 해야 할까?\n기준 예외 처리 코드의 Indent 가 깊지 않고, 읽기 쉽게 한다. data layer 와 domain layer의 예외(Exception) 가 Presentation layer 에서 catch 가능하게 한다. 이유: 유저에게 Error Event를 보여줘야 함으로 data layer의 예외는 data layer에서, throw 하게 한다. 예외 이벤트의 이유를 세분화하여, 명확히 그 이유를 사용자에게 보여준다. 중복 코드를 최대한 줄인다. 과정 서버 개발자와 협의 하여, success 한 상태가 아닌 상황에 대한 커스텀 예외와 Error 타입을 정의한다.\nOkHttp Interceptor를 활용해서, 발생 가능한, data layer의 네트워크 예외(IOException)를 throw 한다.\nviewModel에서, CoroutineExceptionHandler를 선언하고, 여기서 일관되게 Error에 대한 Event를 발생시킨다.\n유저에게 Event를 보여주는 것 외에, 다른 작업이 필요한 경우는 그에 맞게 다르게 처리해야 한다. Error Event 에 대해서, 유저에게 보여주는 방법은 일관되게 한다.\nFragment or Activity들 에서 Event 처리함수를 동일하게 사용하여, Error 이유를 유저에게 Toast or SnackBar로 보여준다. 예시 코드 ErrorResponse (data layer)\n1 2 3 4 5 6 @Serializable data class ErrorResponse( val message: String, val errorCode: Int = 0, val statusCode: Int = 0 ) SuccessResponse (data layer)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 @Serializable data class PlaylistResponse( val playlistId: Int, val playlistTitle: String, val trackSize: Int, val thumbnailUrl: String? ) { internal fun toDomain(): Playlist { return Playlist( id = playlistId, title = playlistTitle, thumbnailUrl = thumbnailUrl ?: \u0026#34;\u0026#34;, trackSize = trackSize ) } } Api or Service interface, (data layer)\n1 2 3 4 5 6 7 @GET(\u0026#34;playlists\u0026#34;) suspend fun getPlaylists(): List\u0026lt;PlaylistResponse\u0026gt; @POST(\u0026#34;playlists\u0026#34;) suspend fun postPlaylist( @Body title: PlaylistRequest ) RepositoryImpl (data layer)\n1 2 3 4 5 6 7 8 override fun getPlaylists(): Flow\u0026lt;List\u0026lt;Playlist\u0026gt;\u0026gt; = flow { val playlistResponse = playlistApi.getPlaylists() emit(playlistResponse.map { it.toDomain() }) } override suspend fun postPlaylist(title: String) { playlistApi.postPlaylist(PlaylistRequest(title = title)) } Repository (domain layer)\n1 2 3 4 5 interface PlaylistRepository { fun getPlaylists(): Flow\u0026lt;List\u0026lt;Playlist\u0026gt;\u0026gt; suspend fun postPlaylist(title: String) } ViewModel (presentation layer)\n1 2 3 4 5 6 7 8 9 10 11 fun fetchPlaylists() { // flow 를 사용한 경우 playlistRepository.getPlaylists().onEach { playlists -\u0026gt; _uiState.update { it.copy(playlists = playlists) } }.launchIn(viewModelScopeWithExceptionHandler) } fun createPlaylist(playlistTitle: String) { // suspend 함수를 사용한 경우 viewModelScopeWithExceptionHandler.launch { playlistRepository.postPlaylist(playlistTitle) } } Fragment or Activity (presentation layer)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 private fun observeEvents() { repeatOnStarted { viewModel.events.collect { event -\u0026gt; when (event) { is PlaylistsEvent.ShowMessage -\u0026gt; { showMessage(event.error.toMessageId()) } } } } } fun showMessage(@StringRes messageId: Int) { Snackbar.make(this.requireView(), messageId, Snackbar.LENGTH_LONG).show() } 참고 사항 BaseViewModel 를 추상 클래스로 선언하고, 추상 함수(onError) 을 상속 받은 viewModel 을 통해 중복된 코드를 줄일 수도 있다.\n네트워크 예외가 아닌, domain layer의 Usecase의 비지니스 로직에서 예외하는 것 까지 모두 일관되게 처리할 수 없다.\n이 경우는 viewModel의 exceptionHandler나 viewModel의 domain 호출 코드에서 예외처리를 그에 맞게 처리 해야 한다. Reference https://square.github.io/okhttp/features/interceptors/ https://square.github.io/okhttp/5.x/okhttp/okhttp3/-interceptor/index.html https://kotlinlang.org/docs/exception-handling.html#supervision-scope https://dongsik93.github.io/til/2022/07/05/til-kotlin-coroutine-exception-handling/ https://tourspace.tistory.com/154?category=797357 ","permalink":"https://2taezeat.github.io/posts/2023/android-%EA%B0%9C%EB%B0%9C%EC%97%90%EC%84%9C-%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC-%EC%98%88%EC%99%B8-%EC%B2%98%EB%A6%AC/","summary":"가정 멀티 모듈과 클린 아키텍처를 적용한 상태한 안드로이드 앱이다. 네트워크 라이브러리로, okHttp3와, Retrofit2를 사용하고 있다. 직렬화 라이브러리로 kotlinx.serialization을 사용하고 있다. 서버 개발자와 http response에 대한, request를 충분히 논의하고 합의할 수 있는 상태이다. 네트워크 예외 처리를 할 때, 참여하는 모든 안드로이드 개발자가 일관되고 가독성이 높게 개발하려면 어떻게 해야 할까?\n기준 예외 처리 코드의 Indent 가 깊지 않고, 읽기 쉽게 한다. data layer 와 domain layer의 예외(Exception) 가 Presentation layer 에서 catch 가능하게 한다.","title":"Android 개발에서, 네트워크 예외 처리"},{"content":"개요 Android 개발시 logging 에는 Logcat 을 기본으로 사용한다.\nhttps://developer.android.com/studio/debug/am-logcat?hl=ko println 으로도 logging 을 할 수 있지만, 단순 logcat 창에 출력 되는 기능만 가능하다.\nlogger 라는 library 도 있지만, 2018.03 월 release 이후, update가 되지 않고 있다.\nhttps://github.com/orhanobut/logger logger 는 더 pretty 하게 log 출력이 가능하지만, timber에 비해 좀 더 무겁다. timber 라는 libarary 를 사용하면, 커스텀도 가능하고, Logcat에 작성해야 하는 \u0026ldquo;TAG\u0026rdquo; 도 굳이 작성하지 않아도 자동으로 어느 파일에서 log가 남는지 알 수 있다.\nOkHttp의 HttpLoggingInterceptor 에도 timber를 적용과 Custom이 가능하다. 그 외에 logging 하는 방법은 기존 Logcat 과 동일하다. Log.d( , ) -\u0026gt; Timber.d() 세팅 gradle KTS 을 사용한다고 가정 Version Catalog 를 사용한다고 가정 libs.versions.toml\n1 2 3 4 5 [versions] timber = \u0026#34;5.0.1\u0026#34; #23.12.10 기준 최신 버전 [libraries] timber = { module = \u0026#34;com.jakewharton.timber:timber\u0026#34;, version.ref = \u0026#34;timber\u0026#34; } app 모듈의 build.gradle.kts\n1 2 3 4 dependencies { //... implementation(libs.timber) } Application()을 상속 받는 .kt 파일에 timber library을 initialize 한다.\n1 2 3 4 5 6 7 8 class MainApplication : Application() { override fun onCreate() { super.onCreate() if (BuildConfig.DEBUG) { Timber.plant(Timber.DebugTree()) } } } AndroidManifest 파일\n\u0026lt;application android:name=\u0026#34;.MainApplication\u0026#34; android:icon=\u0026#34;@mipmap/ic_launcher\u0026#34; //... Custom logging with timber createStackElementTag 함수를 override 해서, logging 되는 line, method, class를 logcat에 자동으로 표시할 수 있게 된다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class MainApplication : Application() { override fun onCreate() { super.onCreate() if (BuildConfig.DEBUG) { Timber.plant(object : Timber.DebugTree() { override fun createStackElementTag(element: StackTraceElement): String? { return String.format( \u0026#34;Class:%s: Line: %s, Method: %s\u0026#34;, super.createStackElementTag(element), element.lineNumber, element.methodName ) } }) } else { Timber.plant(ReleaseTree()) } } } ReleaseTree 를 따로 생성하여, release 모드 일때, error report 를 보낼 수 있게 할 수 있다.\n1 2 3 4 5 6 7 class ReleaseTree : @NotNull Timber.Tree() { override fun log(priority: Int, tag: String?, message: String, t: Throwable?) { if (priority == Log.ERROR || priority == Log.WARN) { //SEND ERROR REPORTS TO YOUR Crashlytics. } } } 장점 No need to write TAGs\nTimber가 자동으로 TAGs 를 생성한다. Customized behavior\nCustom Timber 트리를 사용하여 Logcat에 로깅하는 대신, Crashlytics service로 log를 전송할 수 있다. Customized Meta-Data\ncreateStackElementTag 함수를 통해 line, method, class를 logcat에 자동으로 표시할 수 있게 된다. Lightweight\n이미 존재하는 log utility 을 wrapper 한 library 여서 app 용량에 부담을 주지 않는다. 참고 : timber version 5.0.0 부터 timber 코드가 java 가 아닌 kotlin 으로 변경되었다. https://github.com/JakeWharton/timber/blob/trunk/CHANGELOG.md 주기적으로 업데이트 되는 open-source\n2021.08.13 에 5.0.1 버전이 release 되었다. 다른 logging 라이브러리(ex.logger)에 비해 비교적 최근 까지 업데이트 된다. 참고 사항 HttpLoggingInterceptor 사용시, log 함수를 override 하여, debug 모드 일때만, logging 하게 할 수 있다. Custom 하여, Json을 pretty 하게 출력할 수 도 있다. 1 2 3 4 5 6 7 @Singleton @Provides fun provideLoggingInterceptor(): HttpLoggingInterceptor { // Hilt로 DI를 하는 경우 val logger = HttpLoggingInterceptor.Logger { message -\u0026gt; Timber.tag(\u0026#34;okHttp\u0026#34;).d(message) } return HttpLoggingInterceptor(logger) .setLevel(HttpLoggingInterceptor.Level.BODY) } Timber.d(\u0026quot;\u0026quot;) 처럼 \u0026quot;\u0026quot;(empty string) 을 logging 하려면, Custom을 해야 한다. 1 2 3 4 5 6 7 override fun d(message: String?, vararg args: Any?) { if (message?.length == 0) { super.d(\u0026#34;EMPTY_STRING\u0026#34;, *args) } else { super.d(message, *args) } } Reference https://github.com/JakeWharton/timber https://medium.com/free-code-camp/how-to-log-more-efficiently-with-timber-a3f41b193940 관련 PR Url ","permalink":"https://2taezeat.github.io/posts/2023/android-%EA%B0%9C%EB%B0%9C%EC%8B%9C-timber%EC%9D%84-%EC%A0%81%EC%9A%A9%ED%95%9C-%EC%9D%B4%EC%9C%A0/","summary":"개요 Android 개발시 logging 에는 Logcat 을 기본으로 사용한다.\nhttps://developer.android.com/studio/debug/am-logcat?hl=ko println 으로도 logging 을 할 수 있지만, 단순 logcat 창에 출력 되는 기능만 가능하다.\nlogger 라는 library 도 있지만, 2018.03 월 release 이후, update가 되지 않고 있다.\nhttps://github.com/orhanobut/logger logger 는 더 pretty 하게 log 출력이 가능하지만, timber에 비해 좀 더 무겁다. timber 라는 libarary 를 사용하면, 커스텀도 가능하고, Logcat에 작성해야 하는 \u0026ldquo;TAG\u0026rdquo; 도 굳이 작성하지 않아도 자동으로 어느 파일에서 log가 남는지 알 수 있다.","title":"Android 개발시 Timber을 적용한 이유"},{"content":"개요 android application 에서는 주로 retrofit2 을 사용하여, json(JavaScript Object Notation) 을 주고 받으면서 서버와 통신한다.\njson 직렬화(Serialization) 란, 프로그래밍 언어에서 사용되는 데이터 구조를 json 형식으로 변환하는 과정\n역직렬화 : 직렬화된 데이터를 다시 객체의 형태로 만드는 것\nretrofit 를 이용하여 서버와 통신할 때, converter를 지정해주면 retrofit이 자동으로 역/직렬화 를 수행해준다.\n이때, 여러 converter, 역/직렬화 라이브러리 들이 있다.\n대표적으로 Gson, Moshi, kotlinx.serialization 이 존재한다. 3가지 라이브러리들을 비교 해보고 kotlinx.serialization를 선택한 이유와 특징을 살펴본다.\nGson vs Moshi Gson Google에서 개발한 Java 기반의 오픈 소스 json 데이터 처리 라이브러리 Gson은 현재 maintenance mode로 새로운 기능을 개발하는 것이 아닌 bug fix와 같은 유지보수성 업데이트만 진행되고 있다. Moshi retrofit을 만든, Square사에서 개발한 json 직렬화 라이브러리로, java와 kotlin에서 JSON 데이터를 처리하는 데 사용된다. Moshi 가 Gson 보다 더 좋은 점 높은 성능과 속도: Moshi는 경량화, 최적화된 구조를 통해 높은 성능을 지원한다.\nKotlin 호환성: Moshi는 Kotlin과의 높은 호환성을 가지고 있다. Kotlin의 Nullable 형식을 자동으로 처리하여, JSON 데이터를 다룰 수 있도록 지원한다.\n정적 타입 지원: Moshi는 코드 생성(codegen)을 통해 정적 타입 어노테이션을 지원합니다. 이를 활용하여 JSON 데이터의 파싱 과정에서 타입 안정성을 제공하고, 컴파일 시간에 발생할 수 있는 오류를 미리 방지할 수 있다.\n코드 자동 생성(codegen): Moshi는 어노테이션 기반 코드 생성을 지원하여 JSON 데이터 처리를 런타임이 아닌 컴파일 시점에 처리할 수 있게 해준다.\nkotlinx.serialization 의 대표적인 특징 kotlin 1.4 version 에서 나온 JetBrain이 개발한 역/직렬화 라이브러리\n다른 컨버터 라이브러리와 다르게 Reflection을 사용하지 않고 개발한 라이브러리 (성능 이점)\nKotlin-oriented kotlin의 default value 기능을 사용할 수 있다. KMM, kotlin/js, kotlin/native 에서도 사용가능하다. 1 2 3 4 5 @Serializable data class Project( val name: String, val language: String = \u0026#34;Kotlin\u0026#34; ) 이 문자열을 Gson 라이브러리로 파싱하면, name에는 정상적으로 값이 대입되지만 language 에는 null이 대입된다. 즉, non-null인 프로퍼티가 null 값을 가지게 될 뿐 아니라, language 프로퍼티의 기본값 조차 반영되지 않는 문제가 발생한다.\n1 2 3 4 5 println(Gson().fromJson(inputString, Project::class.java)) //Gson: Project(name=kotlinx.serialization, language=null) println(Json.decodeFromString\u0026lt;Project\u0026gt;(inputString)) //kotlinx.serialization: Project(name=kotlinx.serialization, language=Kotlin) compile-time safe 기본적으로 @Serializable 이 있는 클래스만 직렬화한다. 직렬화를 수행할 수 없는 경우 런타임 에러 대신 컴파일 에러가 발생하므로 버그를 사전에 방지가 가능하다. 1 2 3 4 5 6 7 8 9 @Serializable data class Project( val name: String, val owner: User, // 컴파일 에러 발생: Serializer for type User has not been found val language: String = \u0026#34;Kotlin\u0026#34; ) // @Serializable 어노테이션이 없으므로 직렬화를 지원하지 않습니다. data class User(val userName: String) 이 떄, 직렬화를 지원하지 않는 클래스인 User 클래스를 직렬화를 지원하는 Project 클래스의 프로퍼티로 넣으면 다음과 같이 컴파일 에러가 발생한다.\nPolymorphic serialization 상속 구조나 다형성을 파악해 직렬화를 해준다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 @Serializable sealed class Project { abstract val name: String var status = \u0026#34;open\u0026#34; } @Serializable @SerialName(\u0026#34;owned\u0026#34;) class OwnedProject(override val name: String, val owner: String) : Project() fun main() { val json = Json { encodeDefaults = true } // \u0026#34;status\u0026#34; will be skipped otherwise val data: Project = OwnedProject(\u0026#34;kotlinx.coroutines\u0026#34;, \u0026#34;kotlin\u0026#34;) println(json.encodeToString(data)) } // {\u0026#34;type\u0026#34;:\u0026#34;owned\u0026#34;,\u0026#34;status\u0026#34;:\u0026#34;open\u0026#34;,\u0026#34;name\u0026#34;:\u0026#34;kotlinx.coroutines\u0026#34;,\u0026#34;owner\u0026#34;:\u0026#34;kotlin\u0026#34;} 결론 Moshi이 Gson에 비해 장점도 있지만, 서술한 kotlinx.serialization 의 대표적인 특징 때문에, retrofit의 역/직렬화 converter 라이브러리는 kotlinx.serialization 으로 선택하였다.\nreference https://www.youtube.com/watch?v=Azi57n59ICM https://proandroiddev.com/goodbye-gson-hello-moshi-4e591116231e https://blog.imqa.io/json-moshi/ https://www.androidhuman.com/2020-11-08-kotlin_1_4_serialization https://github.com/Kotlin/kotlinx.serialization ","permalink":"https://2taezeat.github.io/posts/2023/android-%EA%B0%9C%EB%B0%9C%EC%97%90%EC%84%9C-%EC%93%B0%EC%9D%B4%EB%8A%94-%EC%A7%81%EB%A0%AC%ED%99%94-%EA%B8%B0%EC%88%A0-%EB%B9%84%EA%B5%90/","summary":"개요 android application 에서는 주로 retrofit2 을 사용하여, json(JavaScript Object Notation) 을 주고 받으면서 서버와 통신한다.\njson 직렬화(Serialization) 란, 프로그래밍 언어에서 사용되는 데이터 구조를 json 형식으로 변환하는 과정\n역직렬화 : 직렬화된 데이터를 다시 객체의 형태로 만드는 것\nretrofit 를 이용하여 서버와 통신할 때, converter를 지정해주면 retrofit이 자동으로 역/직렬화 를 수행해준다.\n이때, 여러 converter, 역/직렬화 라이브러리 들이 있다.\n대표적으로 Gson, Moshi, kotlinx.serialization 이 존재한다. 3가지 라이브러리들을 비교 해보고 kotlinx.serialization를 선택한 이유와 특징을 살펴본다.","title":"Android 개발에서 쓰이는, 직렬화 기술 비교"},{"content":" Library 기준\nandroidx.navigation:navigation-fragment-ktx:2.5.3\nandroidx.navigation:navigation-ui-ktx:2.5.3\nFragmentManager 를 통한 Transaction add: 호스트 Activity의 생명주기에 Fragment 생명주기 추가, add된 Fragment는 onAttach ~ onResume까지 호출 Add a fragment to the activity state. remove: onPause ~ onDetach까지 호출, Fragment가 메모리에서 제거됨. Remove an existing fragment. If it was added to a container, its view is also removed from that container. replace: replace() 함수 인자로 지정된 Fragment를 제외한 나머지 모든 프래그먼트가 remove (나머지 Fragment는 onDetach 까지 호출, 지정된 Fragment는 onAttach ~ onResume ) show / hide: 기본적으로 add된 Fragment를 대상으로 View를 보이게 하거나 감춤.(visibility 변경) attach: 대상 Fragment의 onCreateView ~ onResume 까지 호출 Detach the given fragment from the UI. This is the same state as when it is put on the back stack: the fragment is removed from the UI detach: 대상 Fragment의 onPause ~ onDestroyView 까지 호출 Re-attach a fragment after it had previously been detached from the UI with detach(android.app.Fragment). This causes its view hierarchy to be re-created, attached to the UI, and displayed. Jetpack Navigation 의 장점 Fragment의 관계를 resource.xml 파일로 한눈에 볼 수 있다. FragmentManager를 통한 Transaction 처리에 쓰이는 코드를 줄일 수 있다. Fragment 간에 data 전달을 safe-args를 통해 할 수 있다. deep link 처리 navigate 시 Fragment 생명주기 navController의 backQueue 변수로 backStack을 확인할 수 있다.\n1 2 3 4 5 6 7 8 // navController.kt 내부 코드 /** * Retrieve the current back stack. * @return The current back stack. */ @get:RestrictTo(RestrictTo.Scope.LIBRARY_GROUP) public open val backQueue: ArrayDeque\u0026lt;NavBackStackEntry\u0026gt; = ArrayDeque() navigate() 함수 호출시, FragmentTransaction의 replace()가 호출된다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 // FragmentNavigator.kt 내부 코드 @Navigator.Name(\u0026#34;fragment\u0026#34;) public open class FragmentNavigator( private val context: Context, private val fragmentManager: FragmentManager, private val containerId: Int ) : Navigator\u0026lt;Destination\u0026gt;() { // ... private fun createFragmentTransaction( entry: NavBackStackEntry, navOptions: NavOptions? ): FragmentTransaction { val destination = entry.destination as Destination //.. val frag = fragmentManager.fragmentFactory.instantiate(context.classLoader, className) frag.arguments = args val ft = fragmentManager.beginTransaction() //.. ft.replace(containerId, frag) //.. return ft } } 상황 설정 bottomMenu: GameFragment, SettingFragment 이고, action: SettingFragment -\u0026gt; WebViewFragment 인 상황 GameFragment -\u0026gt; SettingFragment -\u0026gt; WebViewFragment -\u0026gt;(뒤로가기 버튼) SettingFragment 의 경우 Logging 결과 backStack 에서 없어지면(pop되면), onDestoryView ~ onDetach 까지 호출 backStack 에 존재하면, onDestoryView 까지만 호출, 다시 backStack 최상단에 특정 Fragment가 존재하면, onCreateView 부터 호출 A -\u0026gt; B로 naviagte() 시, B가 Create 되고, A가 Destory 됨. (선 Create, 후 Destory) 13:43:37.780 GameFragment onCreate 13:43:37.802 GameFragment onCreateView 13:43:37.802 GameFragment [com.k031.fruitcardgame:id/game_nav_graph, com.k031.fruitcardgame:id/GameFragment] 13:43:39.586 SettingFragment onCreate 13:43:39.586 SettingFragment onCreateView 13:43:39.586 SettingFragment [com.k031.fruitcardgame:id/game_nav_graph, com.k031.fruitcardgame:id/GameFragment, com.k031.fruitcardgame:id/SettingFragment] 13:43:39.740 GameFragment onDestroyView 13:43:42.369 WebViewFragment onCreate 13:43:42.369 WebViewFragment onCreateView 13:43:42.369 WebViewFragment [com.k031.fruitcardgame:id/game_nav_graph, com.k031.fruitcardgame:id/GameFragment, com.k031.fruitcardgame:id/SettingFragment, com.k031.fruitcardgame:id/WebViewFragment] 13:43:42.560 SettingFragment onDestroyView 13:43:44.910 SettingFragment onCreateView 13:43:44.910 SettingFragment [com.k031.fruitcardgame:id/game_nav_graph, com.k031.fruitcardgame:id/GameFragment, com.k031.fruitcardgame:id/SettingFragment] 13:43:44.919 WebViewFragment onDestroyView 13:43:44.920 WebViewFragment onDestroy navigation popup a -\u0026gt; b -\u0026gt; c -\u0026gt; a 로 group 연결\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 \u0026lt;fragment android:id=\u0026#34;@+id/c\u0026#34; android:name=\u0026#34;com.example.myapplication.C\u0026#34; android:label=\u0026#34;fragment_c\u0026#34; tools:layout=\u0026#34;@layout/fragment_c\u0026#34;\u0026gt; \u0026lt;action android:id=\u0026#34;@+id/action_c_to_a\u0026#34; app:destination=\u0026#34;@id/a\u0026#34; app:popUpTo=\u0026#34;@+id/a\u0026#34; app:popUpToInclusive=\u0026#34;true\u0026#34;/\u0026gt; \u0026lt;/fragment\u0026gt; case 별 backStack 현황 ... -\u0026gt; a -\u0026gt; b -\u0026gt; c 까지, backStack 현황 = [..., a, b, c] app:popUpTo=\u0026quot;@+id/a\u0026quot; 가 없다면, a -\u0026gt; b -\u0026gt; c -\u0026gt; a 까지, backStack 현황 = [..., a, b, c, a] app:popUpTo=\u0026quot;@+id/a\u0026quot; 가 있다면, a -\u0026gt; b -\u0026gt; c -\u0026gt; a 까지, backStack 현황 = [..., a, a] app:popUpTo=\u0026quot;@+id/a\u0026quot; 있고, app:popUpToInclusive=\u0026ldquo;false\u0026rdquo; 이면, a -\u0026gt; b -\u0026gt; c -\u0026gt; a 까지, backStack 현황 = [..., a, a] app:popUpTo=\u0026quot;@+id/a\u0026quot; 있고, app:popUpToInclusive=\u0026ldquo;true\u0026rdquo; 이면, a -\u0026gt; b -\u0026gt; c -\u0026gt; a 까지, backStack 현황 = [..., a] 결론 popUpTo 속성으로 특정 Fragment를 지정하면, 그 사이의 NavBackStackEntry은 backStack에서 제거된다. popUpToInclusive 속성을 true로 설정해주면, backStack popUpTo로 지정된 NavBackStackEntry은 제거된다. popUpToInclusive 값을 지정하지 않으면, popUpToInclusive=false와 같다. Reference https://developer.android.com/reference/android/app/FragmentTransaction#attach(android.app.Fragment) . https://developer.android.com/guide/navigation/navigation-navigate?hl=ko#pop . https://velog.io/@dabin/%EC%95%88%EB%93%9C%EB%A1%9C%EC%9D%B4%EB%93%9CFragment-2%ED%8E%B8FragmentR#framgment-%EA%B5%90%EC%B2%B4replace%EC%9E%91%EC%97%85 . ","permalink":"https://2taezeat.github.io/posts/2023/navigation%EA%B3%BC-fragment-%EC%83%9D%EB%AA%85%EC%A3%BC%EA%B8%B0/","summary":"Library 기준\nandroidx.navigation:navigation-fragment-ktx:2.5.3\nandroidx.navigation:navigation-ui-ktx:2.5.3\nFragmentManager 를 통한 Transaction add: 호스트 Activity의 생명주기에 Fragment 생명주기 추가, add된 Fragment는 onAttach ~ onResume까지 호출 Add a fragment to the activity state. remove: onPause ~ onDetach까지 호출, Fragment가 메모리에서 제거됨. Remove an existing fragment. If it was added to a container, its view is also removed from that container. replace: replace() 함수 인자로 지정된 Fragment를 제외한 나머지 모든 프래그먼트가 remove (나머지 Fragment는 onDetach 까지 호출, 지정된 Fragment는 onAttach ~ onResume ) show / hide: 기본적으로 add된 Fragment를 대상으로 View를 보이게 하거나 감춤.","title":"Navigation과 Fragment 생명주기"},{"content":" Library 기준\nandroidx.fragment:fragment-ktx:1.5.7\nandroidx.recyclerview:recyclerview:1.3.0\nFragment Lifecycle Fragment.java 파일과 공식 문서 를 보면 알 수 있듯이, Fragment는 mLifecycleRegistry 와 mViewLifecycleOwner 두 개의 Lifecycle를 가지고 있다. Fragment 생명주기를 View lifecycle 과 Fragment 자체 lifecycle로 분리해서 바라보면, callback 함수명에서 알 수 있듯이, onDestoryView() 호출로 Fragment의 View는 사라지고, Fragment는 onDetach() 호출 전과 onDestoryView() 호출 후에 onDestory() 가 호출되어 사라진다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 //Fragment.java private void initLifecycle() { mLifecycleRegistry = new LifecycleRegistry (this); // ... } // ... @MainThread @NonNull public LifecycleOwner getViewLifecycleOwner() { // ... return mViewLifecycleOwner; } // ... @Override @NonNull public Lifecycle getLifecycle() { return mLifecycleRegistry; } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 void performStart () { // 예시 performStart() 함수, mLifecycleRegistry, mViewLifecycleOwner을 모두 이용하는 모습 mChildFragmentManager.noteStateNotSaved(); mChildFragmentManager.execPendingActions(true); mState = STARTED; mCalled = false; onStart(); if (!mCalled) { throw new SuperNotCalledException (\u0026#34;Fragment \u0026#34; + this + \u0026#34; did not call through to super.onStart()\u0026#34;); } mLifecycleRegistry.handleLifecycleEvent(Lifecycle.Event.ON_START); if (mView != null) { mViewLifecycleOwner.handleLifecycleEvent(Lifecycle.Event.ON_START); } mChildFragmentManager.dispatchStart(); } RecyclerView 내부 구조 RecyclerView.java 내부를 보면, Adapter는 mObservable을 가지고 있고, Observer들은 RecyclerView를 참조한다. 또한 RecyclerView는 Adapter를 참조하기에, Adatper와 RecyclerView는 양방향 참조, cycle이 생긴다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 // RecyclerView.java public class RecyclerView extends ViewGroup implements ScrollingView, NestedScrollingChild2, NestedScrollingChild3 { //... private final RecyclerViewDataObserver mObserver = new RecyclerViewDataObserver(); //... Adapter mAdapter; //... } private class RecyclerViewDataObserver extends AdapterDataObserver { // ... } public abstract static class Adapter\u0026lt;VH extends ViewHolder\u0026gt; { //... private final AdapterDataObservable mObservable = new AdapterDataObservable(); //... } static class AdapterDataObservable extends Observable\u0026lt;AdapterDataObserver\u0026gt; { public boolean hasObservers() { return !mObservers.isEmpty(); } //... } Memory Leak 발생 가능성 BottomNaviagtion을 사용하는 상황 BottomNavView 에 A,B,C 3개의 Fragment가 menu로 등록된 상태 현재 A_Fragment가 Resume인 상황에서, B_Fragment로 전환시에 A_Fragment는 onDestoryView()가 호출 RecyclerView가 사라질때, mOberver 참조로 인해 Memory Leak 발생 View or Data Binding 를 사용할때도 유사하게 Memory Leak 이 발생 할 수 있다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 class A_Fragment : Fragment() { private lateinit var mockAdapter: MockAdapter override fun onViewCreated(view: View, savedInstanceState: Bundle?) { super.onViewCreated(view, savedInstanceState) mockAdapter = MockAdapter() val recyclerView: RecyclerView = view.findViewById(R.id.recycler_view) recyclerView.layoutManager = LinearLayoutManager(this.context) recyclerView.adapter = mockAdapter } } LeakCanary 을 통해 확인한 Memory Leak 상태\n해결 방법 Adatper와 RecyclerView의 양방향 참조 를 onDestoryView()시에 해제\nmockAdapter 를 nullable 하게 설정 onDestoryView() 호출시 mockAdapter = null B_Fragment에서 다시 A_Fragment 로 전환시, Fragment는 onCreateView() 부터 생명주기 다시 시작 onCreateView() 호출시에 mockAdapter를 MockAdapeter() 로 초기화 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 class A_Fragment : Fragment() { private var mockAdapter: MockAdapter? = null override fun onCreateView( inflater: LayoutInflater, container: ViewGroup?, savedInstanceState: Bundle? ): View? { mockAdapter = MockAdapter() //... } override fun onViewCreated(view: View, savedInstanceState: Bundle?) { super.onViewCreated(view, savedInstanceState) val recyclerView: RecyclerView = view.findViewById(R.id.recycler_view) recyclerView.layoutManager = LinearLayoutManager(this.context) recyclerView.adapter = mockAdapter } override fun onDestroyView() { super.onDestroyView() mockAdapter = null } } Reference https://charlesmuchene.com/a-subtle-memory-leak-fragment-recyclerview-and-its-adapter. https://pluu.github.io/blog/android/2020/01/25/android-fragment-lifecycle/. ","permalink":"https://2taezeat.github.io/posts/2023/fragment%EC%97%90%EC%84%9C-memory-leak%EC%9D%B4-%EB%B0%9C%EC%83%9D%ED%95%A0-%EC%88%98-%EC%9E%88%EB%8A%94-%EA%B2%BD%EC%9A%B0/","summary":"Library 기준\nandroidx.fragment:fragment-ktx:1.5.7\nandroidx.recyclerview:recyclerview:1.3.0\nFragment Lifecycle Fragment.java 파일과 공식 문서 를 보면 알 수 있듯이, Fragment는 mLifecycleRegistry 와 mViewLifecycleOwner 두 개의 Lifecycle를 가지고 있다. Fragment 생명주기를 View lifecycle 과 Fragment 자체 lifecycle로 분리해서 바라보면, callback 함수명에서 알 수 있듯이, onDestoryView() 호출로 Fragment의 View는 사라지고, Fragment는 onDetach() 호출 전과 onDestoryView() 호출 후에 onDestory() 가 호출되어 사라진다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 //Fragment.","title":"Fragment에서 Memory Leak이 발생할 수 있는 경우"},{"content":"Intro Uniform Cost Search 알고리즘과 동일한 결과를 얻을 수 있도록, Iterative deepening 원리를 적용하여, space complexity가 O(bd)인 (b: branching factor, d: depth) Iterative Lengthening Search(ILS) 알고리즘을 작성하는 프로젝트를 설명합니다.\n기본적인 탐색 알고리즘 (BFS,DFS, Blind Search) 에 대한 이해가 ILS를 이해 하는데 도움이 됩니다. ILS 알고리즘 \u0026lsquo;그 자체\u0026rsquo;에 대한 자료가 많이 없기에, 제가 작성한 ILS 알고리즘이 100% 완벽한 효율을 내는 정답은 아닐 수 있습니다. 전체 수도코드 {: width=\u0026ldquo;800\u0026rdquo; height=\u0026ldquo;800\u0026rdquo;}\nITERATIVE-LENGTHENING-SEARCH 함수 설명 {: width=\u0026ldquo;800\u0026rdquo; height=\u0026ldquo;800\u0026rdquo;}\nMY_DLS 함수 설명 {: width=\u0026ldquo;800\u0026rdquo; height=\u0026ldquo;800\u0026rdquo;}\nLIMITCOST_CHECK 함수 설명 {: width=\u0026ldquo;800\u0026rdquo; height=\u0026ldquo;800\u0026rdquo;}\nReference Artificial Intelligence: A Modern Approach(인공지능 수업 교과서) [ 인공지능 강좌 ] 7. Uninformed Search(Blind Search) 설명 Iterative Deepening Search(IDS) or Iterative Deepening Depth First Search(IDDFS) ","permalink":"https://2taezeat.github.io/posts/2023/iterative-lengthening-searchils-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/","summary":"Intro Uniform Cost Search 알고리즘과 동일한 결과를 얻을 수 있도록, Iterative deepening 원리를 적용하여, space complexity가 O(bd)인 (b: branching factor, d: depth) Iterative Lengthening Search(ILS) 알고리즘을 작성하는 프로젝트를 설명합니다.\n기본적인 탐색 알고리즘 (BFS,DFS, Blind Search) 에 대한 이해가 ILS를 이해 하는데 도움이 됩니다. ILS 알고리즘 \u0026lsquo;그 자체\u0026rsquo;에 대한 자료가 많이 없기에, 제가 작성한 ILS 알고리즘이 100% 완벽한 효율을 내는 정답은 아닐 수 있습니다. 전체 수도코드 {: width=\u0026ldquo;800\u0026rdquo; height=\u0026ldquo;800\u0026rdquo;}\nITERATIVE-LENGTHENING-SEARCH 함수 설명 {: width=\u0026ldquo;800\u0026rdquo; height=\u0026ldquo;800\u0026rdquo;}","title":"Iterative Lengthening Search(ILS) 알고리즘"},{"content":"문제 출처 https://programmers.co.kr/learn/courses/30/lessons/67259\n풀이 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 dy = [1,-1,0,0] dx = [0,0,-1,1] fc = float(\u0026#39;inf\u0026#39;) def solution(board): N = len(board) cost = [[float(\u0026#39;inf\u0026#39;) for _ in range(N)] for _ in range(N)] dfs(0,0,board,0,0,cost) return (fc-5)*100 def dfs(y,x,board,pre_dire,g,cost): global fc N = len(board) if g \u0026gt; fc: return # 비용이 fc를 넘어가면 컷. if cost[y][x] \u0026lt; g: # 현재좌표의 비용이 g를 넘어가면 컷. 정답이 될 수 없기에. return elif cost[y][x] \u0026gt;= g: # 그게 아니면, 갱신. cost[y][x] = g if y == N-1 and x == N-1: fc = cost[-1][-1] # 목적지 도달하면, fc 갱신 return board[y][x] = 2 if 0\u0026lt;= y \u0026lt; N and 0\u0026lt;= x+1 \u0026lt; N and board[y][x+1] == 0 : if pre_dire != 1: dfs(y,x+1,board,1,g+6,cost) else: dfs(y,x+1,board,1,g+1,cost) if 0\u0026lt;= y+1 \u0026lt; N and 0\u0026lt;= x \u0026lt; N and board[y+1][x] == 0 : if pre_dire != 4: dfs(y+1,x,board,4,g+6,cost) else: dfs(y+1,x,board,4,g+1,cost) if 0\u0026lt;= y-1 \u0026lt; N and 0\u0026lt;= x \u0026lt; N and board[y-1][x] == 0 : if pre_dire != 3: dfs(y-1,x,board,3,g+6,cost) else: dfs(y-1,x,board,3,g+1,cost) if 0\u0026lt;= y \u0026lt; N and 0\u0026lt;= x-1 \u0026lt; N and board[y][x-1] == 0 : if pre_dire != 2: dfs(y,x-1,board,2,g+6,cost) else: dfs(y,x-1,board,2,g+1,cost) board[y][x] = 0 #print(solution([[0,0,0],[0,0,0],[0,0,0]])) #print (solution( [[0,0,0,0,0,0,0,1],[0,0,0,0,0,0,0,0],[0,0,0,0,0,1,0,0],[0,0,0,0,1,0,0,0],[0,0,0,1,0,0,0,1],[0,0,1,0,0,0,1,0],[0,1,0,0,0,1,0,0],[1,0,0,0,0,0,0,0]] ) ) #print( solution([[0,0,1,0],[0,0,0,0],[0,1,0,1],[1,0,0,0]])) #print( solution([[0,0,0,0,0,0],[0,1,1,1,1,0],[0,0,1,0,0,0],[1,0,0,1,0,1],[0,1,0,0,0,1],[0,0,0,0,0,0]])) Review DFS, BFS, DP등 여러가지 풀이가 있을 수 있지만, 저는 DFS로 해결하였습니다. DFS함수 에서 if문에서 방향을 아래, 오른쪽을 위, 왼쪽보다 먼저 수행하도록 해야 시간을 단축 시킬 수 있습니다. 2차원 배열 cost 을 선언해, cost 배열의 값을 갱신하였습니다. 재귀를 사용하는 DFS의 특성상, 어느상황에서 갱신과 컷을 할지가 중요합니다. ","permalink":"https://2taezeat.github.io/posts/2023/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4-programmers_2020-kakao-intern_%EA%B2%BD%EC%A3%BC%EB%A1%9C-%EA%B1%B4%EC%84%A4_%ED%8C%8C%EC%9D%B4%EC%8D%AC/","summary":"문제 출처 https://programmers.co.kr/learn/courses/30/lessons/67259\n풀이 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 dy = [1,-1,0,0] dx = [0,0,-1,1] fc = float(\u0026#39;inf\u0026#39;) def solution(board): N = len(board) cost = [[float(\u0026#39;inf\u0026#39;) for _ in range(N)] for _ in range(N)] dfs(0,0,board,0,0,cost) return (fc-5)*100 def dfs(y,x,board,pre_dire,g,cost): global fc N = len(board) if g \u0026gt; fc: return # 비용이 fc를 넘어가면 컷.","title":"[프로그래머스] 2020 Kakao Intern_경주로 건설_파이썬"},{"content":"","permalink":"https://2taezeat.github.io/posts/dev/asd/","summary":"","title":""}]